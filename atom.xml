<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Coding</title>
  
  <subtitle>Stay hungry, Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liujiacai.net/"/>
  <updated>2020-03-16T02:20:14.802Z</updated>
  <id>http://liujiacai.net/</id>
  
  <author>
    <name>刘家财</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go struct/interface 最佳实践</title>
    <link href="http://liujiacai.net/blog/2020/03/14/go-struct-interface/"/>
    <id>http://liujiacai.net/blog/2020/03/14/go-struct-interface/</id>
    <published>2020-03-14T14:52:26.000Z</published>
    <updated>2020-03-16T02:20:14.802Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Go 已经一年，深深沉浸在其简洁的设计中，就像其官网描述的：</p><blockquote><p>Go is expressive, concise, clean, and efficient. It’s a fast, statically typed, compiled language that feels like a dynamically typed, interpreted language. </p></blockquote><p>Rob Pike 在 <a href="https://talks.golang.org/2015/simplicity-is-complicated.slide" target="_blank" rel="noopener">Simplicity is Complicated</a> 中也提到 Go 的简洁是其流行的重要原因。简洁并不意味着简单，Go 有着诸多设计确保了把复杂性隐藏在背后。本文就结合笔者自身经验，来讨论 Go 中 struct/interface 的设计理念与最佳实践，帮助读者写出健壮、高效的 Go 程序。</p><h2 id="值类型的-struct"><a href="#值类型的-struct" class="headerlink" title="值类型的 struct"></a>值类型的 struct</h2><p>Go 的设计目标是取代 C/C++，所以 Go 里面的 struct 和 C 的类似，与 int/float 一样属于<strong>值类型</strong>，值类型最重要的特点是在进行赋值时，新变量会得到一份拷贝后的值，这和 Java 中以引用赋值的 Object 有着本质区别。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01Dgr4Ek1z69yFADCwq_!!581166664.png" alt="Go_struct_vs_Java_object"></p><p>这意味着，如果要改变 struct 的内部状态，需要将其定义为指针类型<code>*struct</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo := student&#123;name: <span class="string">"foo"</span>&#125;</span><br><span class="line">bar := foo</span><br><span class="line">bar.name = <span class="string">"bar"</span></span><br><span class="line">fmt.Println(foo.name)  <span class="comment">// 输出 foo</span></span><br><span class="line"></span><br><span class="line">bar2 := &amp;foo</span><br><span class="line">bar2.name = <span class="string">"bar"</span></span><br><span class="line">fmt.Println(foo.name)  <span class="comment">// 输出 bar</span></span><br></pre></td></tr></table></figure><p>与之类似的，使用<code>for range</code> 遍历 <code>[]struct</code> <code>map[xx]struct</code> 时，得到的也是一份拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]student&#123;</span><br><span class="line">    <span class="number">1</span>: &#123;name: <span class="string">"1"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">m[<span class="number">1</span>].name = <span class="string">"2"</span> <span class="comment">// 编译错误： cannot assign to struct field m[1].name in map</span></span><br></pre></td></tr></table></figure><p>可以看到，无法直接对 map 中的 struct 进行赋值，这是由于<code>m[1]</code>得到的是原有 struct 的拷贝，即使编译器允许这里的赋值，map 中的 struct 值也不会改变，所以编译器直接不允许这种情况。其次，<br>这里的赋值操作是个 <code>read-modify-write</code> 操作，无法保证原子性，更多讨论可参考 <a href="https://github.com/golang/go/issues/3117" target="_blank" rel="noopener">#3117</a>。解决方式有两种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用临时变量</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]student&#123;<span class="number">1</span>: &#123;name: <span class="string">"1"</span>&#125;&#125;</span><br><span class="line">tmp := m[<span class="number">0</span>]</span><br><span class="line">tmp.name = <span class="string">"2"</span></span><br><span class="line">m[<span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用指针类型 </span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]*student&#123;<span class="number">1</span>: &#123;name: <span class="string">"1"</span>&#125;&#125;</span><br><span class="line">m[<span class="number">1</span>].name = <span class="string">"2"</span></span><br></pre></td></tr></table></figure><p>笔者多次遇到这个“坑”，那是不是说把所有的 struct 都定义为指针就好了呢？这里需要了解下 Go 的逃逸分析才能回答这个问题。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析的主要作用是决定对象分配在内存中的位置，Go 会尽量分配在 stack 上，这样的好处显而易见：回收简单，减轻 GC 压力。可以通过 <code>go build -gcflags -m xx.go</code> 查看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnByValue</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> student&#123;name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnByPointer</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">./snippet.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">18</span>: &amp;student literal escapes to heap</span><br></pre></td></tr></table></figure><p>可以看到，<code>returnByPointer</code> 方法的返回值会逃逸，最终分配在 heap 上，关于变量分配在 stack / heap 上的性能差距，可参考：<a href="https://gist.github.com/jiacai2050/7354648a5cae59762640cd20e5022db4" target="_blank" rel="noopener">github gist</a>、<a href="https://gitee.com/liujiacai/codes/8jironvkfzay04ue31wmc36/widget" target="_blank" rel="noopener">gitee</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// snippet.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span> <span class="title">getNameByValue</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *student)</span> <span class="title">getNameByPointer</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randStr = <span class="string">"a very long string,a very long string,a very long string,a very long string"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnByValue</span><span class="params">()</span> <span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> student&#123;randStr&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnByPointer</span><span class="params">()</span> *<span class="title">student</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;student&#123;randStr&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bench_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blackholeStr = <span class="string">""</span></span><br><span class="line"><span class="keyword">var</span> blackholeValue student</span><br><span class="line"><span class="keyword">var</span> blackholePointer *student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPointerVSStruct</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    b.Run(<span class="string">"return pointer"</span>, <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        b.ReportAllocs()</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">            blackholePointer = returnByPointer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    b.Run(<span class="string">"return  value"</span>, <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        b.ReportAllocs()</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">            blackholeValue = returnByValue()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    b.Run(<span class="string">"value receiver"</span>, <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        b.ReportAllocs()</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">            r := student&#123;</span><br><span class="line">                name: randStr,</span><br><span class="line">            &#125;</span><br><span class="line">            blackholeStr = r.getNameByValue()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    b.Run(<span class="string">"pointer receiver"</span>, <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">        b.ReportAllocs()</span><br><span class="line">        b.ResetTimer()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">            r := &amp;student&#123;</span><br><span class="line">                name: randStr,</span><br><span class="line">            &#125;</span><br><span class="line">            blackholeStr = r.getNameByPointer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">go</span> <span class="string">test</span> <span class="string">-run</span> <span class="string">^NOTHING</span> <span class="string">-bench</span> <span class="string">Struct</span> <span class="string">bench_test.go</span>  <span class="string">snippet.go</span></span><br><span class="line"><span class="attr">goos:</span> <span class="string">darwin</span></span><br><span class="line"><span class="attr">goarch:</span> <span class="string">amd64</span></span><br><span class="line"><span class="string">BenchmarkPointerVSStruct/return_pointer-8</span>               <span class="number">34476903</span>                <span class="number">32.4</span> <span class="string">ns/op</span>            <span class="number">16</span> <span class="string">B/op</span>          <span class="number">1</span> <span class="string">allocs/op</span></span><br><span class="line"><span class="string">BenchmarkPointerVSStruct/return__value-8</span>                <span class="number">530538498</span>                <span class="number">2.27</span> <span class="string">ns/op</span>            <span class="number">0</span> <span class="string">B/op</span>          <span class="number">0</span> <span class="string">allocs/op</span></span><br><span class="line"><span class="string">BenchmarkPointerVSStruct/value_receiver-8</span>               <span class="number">415309486</span>                <span class="number">2.86</span> <span class="string">ns/op</span>            <span class="number">0</span> <span class="string">B/op</span>          <span class="number">0</span> <span class="string">allocs/op</span></span><br><span class="line"><span class="string">BenchmarkPointerVSStruct/pointer_receiver-8</span>             <span class="number">348904872</span>                <span class="number">3.23</span> <span class="string">ns/op</span>            <span class="number">0</span> <span class="string">B/op</span>          <span class="number">0</span> <span class="string">allocs/op</span></span><br><span class="line"><span class="string">PASS</span></span><br><span class="line"><span class="string">ok</span>      <span class="string">command-line-arguments</span>  <span class="number">5.</span><span class="string">699s</span></span><br></pre></td></tr></table></figure></p><p>可以看到，方法返回 pointer 时，会有一次 heap 分配，占 16 个字节，这正好是 name 字段（string 类型）的大小，8 个字节表示指向数据的指针，8 个字节表示长度（笔者为 64 位系统），类似下面的结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">uintptr</span></span><br><span class="line">    Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回 value 时，则没有 heap 分配，说明所有变量都分配在 stack 上。<br>对于 receiver 为 pointer 或 value 性能则无差别，这是因为 s 在两种情况下均无逃逸，所以都分配在了 stack 上，这也说明变量分配在那里与是否为指针无关。</p><h3 id="value-vs-pointer"><a href="#value-vs-pointer" class="headerlink" title="value vs pointer"></a>value vs pointer</h3><p>结合上面的实验，可以按照下述流程确定选用 value/pointer：</p><ol><li>如果 struct 需要改变状态（比如包含 waitgroup/sync.Poll/sync.Mutex 等），则需要 pointer</li><li>如果 <code>unsafe.Sizeof(struct)</code> 大于一定阈值时，拷贝 value 的时间大于在 heap 上分配的时间，考虑用 pointer</li><li>除此之外，struct 即可</li></ol><p>为了确定出 2 中的阈值，可以在 struct 中添加一数组元素，之后再来跑上述测试即可，在笔者机器中，这个阈值大概为 72K，很少有 struct 会达到这个量级，这是由于 Go 中常用的 slice/map/string 均为复合类型（可认为由 header+data 两部分组成），在 struct 的结构中，只保存 header 部分，所以大小是固定的，而 array 有的地方也不是很多，所以读者可认为只要 struct 状态不需要改变，value 则是最佳选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    dummy  [<span class="number">9000</span>]<span class="keyword">int64</span>  <span class="comment">// 添加一数组元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BenchmarkPointerVSStruct/return_pointer<span class="number">-8</span>                 <span class="number">150147</span>              <span class="number">8147</span> ns/op           <span class="number">73728</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">BenchmarkPointerVSStruct/return__value<span class="number">-8</span>                  <span class="number">138591</span>              <span class="number">8146</span> ns/op               <span class="number">0</span> B/op          <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure><table><thead><tr><th>简单类型</th><th>复合类型</th></tr></thead><tbody><tr><td>bool</td><td>slice</td></tr><tr><td>numeric</td><td>map</td></tr><tr><td>(unsafe)pointer</td><td>channel</td></tr><tr><td>struct</td><td>function</td></tr><tr><td>array</td><td>interface</td></tr><tr><td></td><td>string</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">uint64</span>&#123;</span><br><span class="line"><span class="string">"ptr"</span>:       <span class="keyword">uint64</span>(unsafe.Sizeof(&amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)),</span><br><span class="line"><span class="string">"map"</span>:       <span class="keyword">uint64</span>(unsafe.Sizeof(<span class="keyword">map</span>[<span class="keyword">bool</span>]<span class="keyword">bool</span>&#123;&#125;)),</span><br><span class="line"><span class="string">"slice"</span>:     <span class="keyword">uint64</span>(unsafe.Sizeof([]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)),</span><br><span class="line"><span class="string">"chan"</span>:      <span class="keyword">uint64</span>(unsafe.Sizeof(<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;))),</span><br><span class="line"><span class="string">"func"</span>:      <span class="keyword">uint64</span>(unsafe.Sizeof(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;)),</span><br><span class="line"><span class="string">"interface"</span>: <span class="keyword">uint64</span>(unsafe.Sizeof(<span class="keyword">interface</span>&#123;&#125;(<span class="number">0</span>))),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">chan</span>:<span class="number">8</span> <span class="function"><span class="keyword">func</span>:8 <span class="title">interface</span>:16 <span class="title">map</span>:8 <span class="title">ptr</span>:8 <span class="title">slice</span>:24]</span></span><br></pre></td></tr></table></figure><p>可以看到，</p><ul><li>chan/func/map/ptr 均为 8 个字节，即一个指向具体数据的指针</li><li>interface 为 16，两个指针，一个指向具体类型，一个指向具体数据。细节可参考 Russ Cox 的 <a href="https://research.swtch.com/interfaces" target="_blank" rel="noopener">Go Data Structures: Interfaces </a></li><li>slice 为 24，包括一个指向底层 array 的指针，两个整型，分布表示 cap、len</li></ul><p>上文中提到无法直接修改 map 中的 struct，那么下面的程序是否合法？为什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>&#123;<span class="number">1</span>: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>struct 中的字段会按照机器字长进行对齐，所以在性能要求比较高的地方，可以尽量把相同类型的字段放一起。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(</span><br><span class="line">    unsafe.Sizeof(<span class="keyword">struct</span> &#123;</span><br><span class="line">        a <span class="keyword">bool</span></span><br><span class="line">        b <span class="keyword">string</span></span><br><span class="line">        c <span class="keyword">bool</span>            </span><br><span class="line">    &#125;&#123;&#125;),</span><br><span class="line">    unsafe.Sizeof(<span class="keyword">struct</span> &#123;</span><br><span class="line">        a <span class="keyword">bool</span></span><br><span class="line">        c <span class="keyword">bool</span></span><br><span class="line">        b <span class="keyword">string</span>            </span><br><span class="line">    &#125;&#123;&#125;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上述代码会依次输出 <code>32 24</code>，下面的图示清晰的展示了两个顺序的 struct 在内存中的布局：（<a href="https://stackoverflow.com/a/38034334/2163429" target="_blank" rel="noopener">图片来源</a>）<br><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN018aBsFK1z69yFIcVSO_!!581166664.png" alt="field_align"></p><p>最后，读者可以思考下面代码的运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(</span><br><span class="line">    unsafe.Sizeof(<span class="keyword">interface</span>&#123;&#125;(<span class="number">0</span>)),</span><br><span class="line">    unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="基于组合的-interface"><a href="#基于组合的-interface" class="headerlink" title="基于组合的 interface"></a>基于组合的 interface</h2><p>如果说 struct 是对状态的封装，那么 interface 就是对行为的封装，是 Go 中构造抽象的基础。由于 Go 中没有 oop 的概念，主要是通过组合，而非继承来实现不同组件的整合，比如 io 包下的 Reader/Writer。<br>但就组合来说，并没有什么优势，Java 中也可以实现，但 Go 中的隐式“继承” 让组合变得十分灵活。</p><h3 id="Embedded-struct"><a href="#Embedded-struct" class="headerlink" title="Embedded struct"></a>Embedded struct</h3><p>下面通过一示例进行说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RecordWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    code <span class="keyword">int</span></span><br><span class="line">    http.ResponseWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RecordWriter)</span> <span class="title">WriteHeader</span><span class="params">(statusCode <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    rw.code = statusCode</span><br><span class="line">    rw.ResponseWriter.WriteHeader(statusCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">URLStat</span><span class="params">(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)</span></span> &#123;</span><br><span class="line">    <span class="comment">// if w.WriteHeader isn't called inside handlerFunc, 200 is the default code.</span></span><br><span class="line">    rw := &amp;RecordWriter&#123;ResponseWriter: w, code: <span class="number">200</span>&#125;</span><br><span class="line">    next(rw, r)</span><br><span class="line">    metrics.HTTPReqs.WithLabelValues(r.URL.Path, r.Method, strconv.FormatInt(<span class="keyword">int64</span>(rw.code), <span class="number">10</span>)).Inc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片段为 <a href="https://github.com/urfave/negroni" target="_blank" rel="noopener">negroni</a> 中的一个 middleware，用来记录 http code。自定义 Writer 通过嵌入 ResponseWriter，实现了 ResponseWriter 接口，然后通过重写 WriteHeader 的方式来实现业务需求，由于需要改变状态，所以采用指针类型 <code>*RecordWriter</code> 来作为 receiver，整个实现非常简洁扼要。</p><h3 id="New-func-type"><a href="#New-func-type" class="headerlink" title="New func type"></a>New func type</h3><p>第二个示例是关于如何通过自定义 type，来达到简化 err 处理的目的。在 net/http 中，handlerFunc 没有返回值，这就导致在每个异常处理的后面加上一个空的 return 来中止逻辑处理，这样不仅繁琐，还容易遗漏，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">"Record"</span>, r.FormValue(<span class="string">"id"</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时便可通过自定义新类型来解决这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error   error</span><br><span class="line">    Message <span class="keyword">string</span></span><br><span class="line">    Code    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span> <span class="title">appError</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e := fn(w, r); e != <span class="literal">nil</span> &#123; <span class="comment">// e is *appError, not os.Error.</span></span><br><span class="line">        c := appengine.NewContext(r)</span><br><span class="line">        c.Errorf(<span class="string">"%v"</span>, e.Error)</span><br><span class="line">        http.Error(w, e.Message, e.Code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span> <span class="title">appError</span></span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">"Record"</span>, r.FormValue(<span class="string">"id"</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appError&#123;err, <span class="string">"Record not found"</span>, <span class="number">404</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appError&#123;err, <span class="string">"Can't display record"</span>, <span class="number">500</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> appError&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mux.HandleFunc(<span class="string">"/view"</span>, appHandler(viewRecord))</span><br></pre></td></tr></table></figure><p>可以看到，上述示例通过定义 appHandler 新函数类型，并隐式“继承” <a href="https://golang.org/pkg/net/http/#Handler" target="_blank" rel="noopener">http.Handler</a> 接口来达到了统一集中处理 err 的需求。<br>该实现漂亮的地方为函数增加新类型，且函数签名与 ServeHTTP 一致，这样就可以直接复用参数。对于初学者来说，可能没想到也可以给 func 类型来定义方法，但是在 Go 中，可以给任何类型增加方法。</p><p>之前在网上看到一些框架，采用 <a href="https://github.com/gogf/gf/blob/506552c3a93a9094c96699bdf62c533b5b4f42c6/net/ghttp/ghttp_request.go#L84" target="_blank" rel="noopener">panic</a> 的方式来简化 err 处理，感觉这属于对 panic 的滥用，先不说对性能是否有损耗，更主要的是破坏了 <code>if err != nil</code> 的处理方式。希望读者在后续处理繁琐的逻辑时，多去考虑如何抽象新类型来解决。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go 的精妙设计保证了其简洁的特性，而且这些特性可能和传统的 oop 不同，这对于从这些语言转过来的读者来说会采用旧思维去思考问题，这无可厚非，但作为优秀的 Go 程序员，更多的需要从 Go 自身特点来考虑问题，这样就不至于产生“为什么 XX 特性在 Go 中没有”的疑惑，要知道 Go 的作者可是 Rob Pike, Ken Thompson :-)<br>如果读者阅读/实现过基于 interface 的精巧设计，欢迎留言分享。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://go101.org/article/value-part.html" target="_blank" rel="noopener">https://go101.org/article/value-part.html</a></li><li><a href="https://github.com/tyranron/golang-sizeof.tips/blob/master/internal/parser/types.go" target="_blank" rel="noopener">https://github.com/tyranron/golang-sizeof.tips/blob/master/internal/parser/types.go</a></li><li><a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">https://blog.golang.org/error-handling-and-go</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 Go 已经一年，深深沉浸在其简洁的设计中，就像其官网描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Go is expressive, concise, clean, and efficient. It’s a fast, statically typed, com
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Go" scheme="http://liujiacai.net/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>2019 年终总结</title>
    <link href="http://liujiacai.net/blog/2020/02/02/review-2019/"/>
    <id>http://liujiacai.net/blog/2020/02/02/review-2019/</id>
    <published>2020-02-02T03:42:59.000Z</published>
    <updated>2020-02-02T11:25:50.553Z</updated>
    
    <content type="html"><![CDATA[<p>因起源于武汉的<a href="https://baike.baidu.com/medicine/disease/%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92%E6%84%9F%E6%9F%93%E7%9A%84%E8%82%BA%E7%82%8E/24282048?tab=%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">新型冠状病毒</a>（2019 novel Coronavirus，2019-nCoV），让 2020 开年之初就与众不同，全国人民纷纷戴上了口罩，这也是我记事以来第一次在大年初一没去村里长辈家拜年。是时候回顾下 19 年了，其实 18 年的总结也迟迟没能写出来，这里一并总结下。</p><h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>18 年与我个人而言最重要的就是认识了现在的女朋友，生活、心态上变化了不少，把重心从工作转移到生活上，周末有空都会坐动车去苏州找她聚聚，苏州大大小小的景点都转遍了。昆山的工作没有现在所谓的 996，每天下班有空都能去健身房打打乒乓球，周末也能去周边的南京、黄山，度过了着实悠闲的一段时间。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN01LlMsPx1z69xoy9ZXk_!!581166664.jpg" alt="健身一角.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN011EsFek1z69xysMBCE_!!581166664.jpg" alt="有轨电车.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN01m8Cp9b1z69xzfRv5B_!!581166664.jpg" alt="遇见你.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN01zMqMGm1z69xyger1k_!!581166664.jpg" alt="昆山南站.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN01pVmO9P1z69xub8NkJ_!!581166664.jpg" alt="夜泊秦淮.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01MGmwWg1z69xxCCho0_!!581166664.jpg" alt="朱元璋.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN01XQF9ZM1z69y0rC2uL_!!581166664.jpg" alt="黄山脚下.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01A3YHPB1z69xwrPmUi_!!581166664.jpg" alt="迎客松.jpg"></p><p>在 18 年底就有些厌烦这样“无所事事”的状态，考虑再回杭州去发展。于是乎在 19 年春节前后开始复习基础知识，并在 19 年四月入职了现在公司。<br>在 LeanCloud “服役”两年左右，从之前的数据开发转到了后台开发，并且过了一把 Clojure 的瘾，除了工作中重度使用外，还录制了一套<a href="https://github.com/jiacai2050/learn_clojure.mp4" target="_blank" rel="noopener">教学视频</a>。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01iPSaRY1z69xtdlGfp_!!581166664.png" alt="2018_github.png"></p><p>由于工作中使用 Github 似有仓库，所以上面的<a href="https://github.com/jiacai2050?tab=overview&amp;from=2018-01-01&amp;to=2018-12-31" target="_blank" rel="noopener">提交记录</a>比较多。去掉 Private contributions 后的提交记录如下：</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN01X4Y7gk1z69xygxvD7_!!581166664.png" alt="2018_github_public.png"></p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN01aYIYG81z69xwNdnHC_!!581166664.png" alt="2018_blog.png"><br>18 年共写了 6 篇文章，GC 相关占 4 篇，这是个大坑，后面还需要继续添。<a href="/blog/2018/12/29/how-java-synchronizer-work/">《Java 线程同步原理探析》</a> 着重从操作系统层面讲述同步原理。</p><h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><h3 id="Bye-LeanCloud-Hello-Alibaba"><a href="#Bye-LeanCloud-Hello-Alibaba" class="headerlink" title="Bye LeanCloud, Hello Alibaba"></a>Bye LeanCloud, Hello Alibaba</h3><p>在 19 年 3 月底正式离开 LeanCloud，4 月 1 入职杭州蚂蚁金服。凑巧的是工作地点还是在黄龙万科中心，离有赞很近。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN018mF0mj1z69xzltdZa_!!581166664.jpg" alt="leancloud_cup.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01gfBFmL1z69y1OIt97_!!581166664.jpg" alt="LeanCloud_nearby.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN01RCZz2D1z69xp4LiKy_!!581166664.jpg" alt="科技广场.jpg"></p><p>杭州的工作强度相比昆山不是一个量级，竞争也更激烈。阿里有“一年香三年醇五年陈”的说法，我目前还不到一年，还不敢说对这家公司有多深的认识，只能说好的坏的都有，没有完美的公司。杭州这个城市也是，之前想的是来杭州后打听打听房价，看看能否尽快“安居乐业”，没想到政府要求“外地户口须缴满近两年社保才有购房资格”，我 2 年前在有赞缴的不算，先不说买不买得起，这下连资格都没有了。</p><h3 id="天天向上"><a href="#天天向上" class="headerlink" title="天天向上"></a>天天向上</h3><p>新的工作接触了 Golang/Rust，方向是时序数据库，产品是 CeresDB，整体架构和 <a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener">tidb</a> 类型，底层的存储层用 Rust，上层的交互层用 Golang。这大半年我主要负责 Golang 这部分，把 prometheus 协议加了进来。对于监控，从使用者变为了开发者，考虑的东西自然多了，比如 push/pull 收集方式的区别；不同机器的同一指标在聚合时，如何对齐；如何展示收集的 metrics。</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>这里列举 18/19 两年内看完的书，一些还在看的这里就先不列出来了。</p><ul><li><a href="https://book.douban.com/subject/6039359/" target="_blank" rel="noopener">Programming Concurrency on the JVM</a>，介绍了 JVM 语言中并发的模式与利弊，这对开拓眼界是非常有用的，书中给出的算文件夹大小的例子也不错，由浅入深，逐步完善。</li><li><a href="https://book.douban.com/subject/21866396/" target="_blank" rel="noopener">High Performance Browser Networking</a>，网络开发必备书籍，让我进一步清楚 <a href="https://book.douban.com/review/9653382/" target="_blank" rel="noopener">tcp/udp 的区别</a></li><li><a href="https://book.douban.com/subject/4163938/" target="_blank" rel="noopener">软件随想录</a>，Joel on Software 的文集，涉及软件开发的方方面面，包括不限于如何管理项目周期、如何与程序员相处、如何写出好代码。<a href="https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/" target="_blank" rel="noopener">Making Wrong Code Look Wrong</a>，让我意识到之前一直<a href="https://www.zhihu.com/question/34526639/answer/59135532" target="_blank" rel="noopener">误解了匈牙利命名法</a>。</li><li><a href="https://book.douban.com/subject/25854634/" target="_blank" rel="noopener">公共问题经济学</a>，大略看了下，只能说很多问题没有表面上那么简单，可能会有意想不到的连锁反应。</li><li><a href="https://book.douban.com/subject/26197294/" target="_blank" rel="noopener">Designing Data-Intensive Applications</a>，涵盖后端开发的方方面面，了解现有基础软件的优劣势，不同数据库的一致性实现，分布式公式算法的来龙去脉。兼具实用性与学术性，不可多得的一本好书。</li></ul><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01EsIWdY1z69xtjtuyq_!!581166664.png" alt="2019_blog.png"></p><p>19 年产出也比较少，博客一共写了 4 篇。现在来看，是非常失败的，不管工作多么繁重，抽出时间来总结还是有必要的，2020 年要多去总结。</p><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01WaQSHM1z69xwU2QJA_!!581166664.png" alt="2019_github.png"></p><p><a href="https://github.com/jiacai2050?tab=overview&amp;from=2019-01-01&amp;to=2019-12-31" target="_blank" rel="noopener">提交记录</a> 更少了，证明周末时间都出去玩了 :-)</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>仿佛每换一个地方，我的身材都会发福一次，囧，到现在体重又回到锻炼之前的基数了！果断办了个卡开始练起来。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01jNE8av1z69xymp35m_!!581166664.jpg" alt="健身房.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN01UyMgCB1z69xtjmGRB_!!581166664.jpg" alt="浙大乒乓球.jpg"></p><p>身边的朋友有 2 个出国工作，到了年底也开始考虑自己是否有必要出去看看，这可能也是每个在大城市奋斗的同学都会面临的问题，与其在国内 996 的环境下生活，为何不选择 Work Life Balance 的国外？！当然每个人都会有不同的羁绊，出去不一定好，还要慎重考虑。</p><h4 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h4><p>3 月底在换工作之际，去<a href="https://www.jianshu.com/p/d078714d358b" target="_blank" rel="noopener">泰国玩了一圈</a>，算是领略了一番异国风光，中秋节去千岛湖溜了一圈，其他时间就都在杭州市内溜达了。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01fLMIs91z69xv28ql9_!!581166664.jpg" alt="西湖一角.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01ceQUTB1z69xxK6rSJ_!!581166664.jpg" alt="千岛湖.jpg"></p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN01FyLI8z1z69xymsbem_!!581166664.jpg" alt="IMG_1652.jpg"></p><h4 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h4><p>这两年有听了不少好播客，这里给大家推荐一下：</p><ul><li><a href="https://talk.swift.gg/" target="_blank" rel="noopener">ggtalk</a>，程序员的闲聊节目，还挺喜欢主播梁杰的采访风格，出国那几期听了收获颇多；<a href="https://talk.swift.gg/22" target="_blank" rel="noopener">《23. 区块链到底能干嘛？》</a> 这一期让我了解到区块链的本质</li><li><a href="https://www.ximalaya.com/zhubo/46905980/" target="_blank" rel="noopener">软件那些事儿</a>，喜欢栋哥的八卦能力</li><li><a href="https://podcasts.apple.com/cn/podcast/%E6%96%B0%E9%97%BB%E9%85%B8%E8%8F%9C%E9%A6%86/id473501583" target="_blank" rel="noopener">新闻酸菜馆</a>，生活中已经不能没有王掌柜和叮叮，已经听了 2 年多，2020 年是不是要买会员了呢？新听众可参考知乎<a href="https://www.zhihu.com/question/22412028/answer/435223672" target="_blank" rel="noopener">如何评价《新闻酸菜馆》？</a></li><li><a href="https://www.ximalaya.com/toutiao/5218657/" target="_blank" rel="noopener">俊玮谈新-新加坡</a>，作者移居新加坡十多年，每一期内容都干货满满，对于了解新加坡非常有帮助</li><li><a href="https://www.ximalaya.com/youshengshu/19606439/" target="_blank" rel="noopener">藏海花</a> 盗墓笔记五年之后，吴邪在雪山寻找张起灵的印记。主播九月声音细腻，不同于周建龙，但也是我喜欢但风格。找一个阳光明媚的中午，闭目收听盗墓或鬼吹灯，惬意的很。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的总结，感觉这两年过的还是有些自我了，技术的积累也不够深，如果后面两个人生活在一起了，自己的时间必定更少，所以后面还是要“集中精力”，不要过多分散精力，首先做好本职工作，再有找一两个可以长久从事的方向、项目。</p><p>最近也一直在思考，编程到底难在哪里？对于如今的开发，各种组件都已经很齐全了，对于有界面的前端，有 Vue/React；对于后端技术，更是层出不穷，各式各样的数据库、消息队列、RPC 框架，仿佛如今的开发者需要的技能是组装，而非创造。是否能有一种系统/框架，来统一掉这些组件呢？serverless 要解决的问题正是组装（主要包括：分配 cpu/memory 资源，调度 http/rpc 流量），所以 k8s 会是软件开发的终极嘛？</p><p>春节期间宅在家中，开始刷 leetcode/hackerrank，一方面锻炼自己的编程能力，另一方面为今后可能的出国做好准备。算法也是很多同学的痛，基本原理（空间/时间互补）都了解，但是遇到一个题目就是无法想到最优解，有种高三疯狂做试卷的感觉，基本定理都知道，但是题目就是解不出来。刘未鹏的<a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/" target="_blank" rel="noopener">《知其所以然（以算法学习为例）》</a>阐述了其原因，就编程来说，知道算法的流程是远远不够的，因为编程相比其他技能，更注重细节，一个循环的中止条件到底是 <code>i&lt;n</code> 还是 <code>i&lt;n-1</code>，其差别是非常大的，而人的记忆是不可能记住这么细微的差别的，所以必须具备推导能力。今年希望能在这方面多写些总结。</p><p>病毒还在蔓延，希望大家都能平稳度过。2020，加油。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因起源于武汉的&lt;a href=&quot;https://baike.baidu.com/medicine/disease/%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92%E6%84%9F%E6%9F%93%E7%9A%8
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>何处安放我们的 Go 代码</title>
    <link href="http://liujiacai.net/blog/2019/10/24/go-modules/"/>
    <id>http://liujiacai.net/blog/2019/10/24/go-modules/</id>
    <published>2019-10-24T13:30:55.000Z</published>
    <updated>2019-12-24T10:59:14.615Z</updated>
    
    <content type="html"><![CDATA[<p>用了近半年的 Go，真是有种相见恨晚的感觉。简洁的语法、完善并强大的开发工具链，省去新手不少折腾的时间，可以专注写代码。<br>这期间也掌握了不少技巧与惯用法（idioms），比如 <a href="https://github.com/jiacai2050/prosumer" target="_blank" rel="noopener">prosumer</a>，就是一个踩了 chan/timer 一些坑后实现生产者/消费者模式框架。但今天不去谈 chan 的使用方式，而是来谈一个最基本的问题，Go 代码应该放在哪里，其实也就是 Go 的包管理机制，有时也称为版本化，其实是一个意思。这看似简单，却让不少 Gopher <a href="https://stackoverflow.com/questions/tagged/go-modules" target="_blank" rel="noopener">吃了不少苦头</a>。</p><p>本文大致顺序：包管理的历史；新的包管理方式 module；最后加上一个问题排查，彻底解决如何放置 Go 代码的问题。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01CCdfct1z69wzuInE9_!!581166664.png" alt="Go package manager"></p><h2 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h2><p>在 go mod 出现之前，所有的 Go 项目都需要放在同一个工作空间：<code>$GOPATH/src</code> 内，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">    outyet/</span><br><span class="line">        main.go                <span class="comment"># command source</span></span><br><span class="line">        main_test.go           <span class="comment"># test source</span></span><br><span class="line">    stringutil/</span><br><span class="line">        reverse.go             <span class="comment"># package source</span></span><br><span class="line">        reverse_test.go        <span class="comment"># test source</span></span><br></pre></td></tr></table></figure></p><p>相比其他语言，这个限制有些无法理解。其实，这和 Go 的一设计理念紧密相关：</p><blockquote><p>包管理应该是去中心化的</p></blockquote><p>所以 Go 里面没有 maven/npm 之类的包管理工具，只有一个 <code>go get</code>，支持从公共的代码托管平台（Bitbucket/GitHub..）下载依赖，当然也支持自己托管，具体可参考官方文档：<a href="https://tip.golang.org/cmd/go/#hdr-Remote_import_paths" target="_blank" rel="noopener">Remote import paths</a>。</p><p>由于没有中央仓库，所以 Go 项目位置决定了其 import path，同时为了与 go get 保持一致，所以一般来说我们的项目名称都是 <code>github.com/user/repo</code> 的形式。<br>当然也可以不是这种形式，只是不方便别人引用而已，后面会讲到如何在 go mod 中实现这种效果。</p><h2 id="百花齐放"><a href="#百花齐放" class="headerlink" title="百花齐放"></a>百花齐放</h2><p>使用 <code>go get</code> 下载依赖的方式简单暴力，伴随了 Go 七年之久，直到 1.6（2016/02/17）才正式支持了 <a href="https://golang.org/doc/go1.6#go_command" target="_blank" rel="noopener">vendor</a>，可以把所有依赖下载到当前项目中，解决可重复构建（reproducible builds）的问题，但是无法管理依赖版本。社区出现了各式各样的<a href="https://github.com/golang/go/wiki/PackageManagementTools#dep-tool" target="_blank" rel="noopener">包管理工具</a>，来方便开发者固化依赖版本，由于不同管理工具采用不同的元信息格式（比如：godep 的 Godeps.json、Glide 的 glide.yaml），不利于社区发展，所以 Go 官方推出了 <a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a>。</p><p>dep 的定位是实验、探索如何管理版本，并不会直接集成到 Go 工具链，Go 核心团队会吸取 dep 使用经验与社区反馈，开发下一代包管理工具 <a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">modules</a>，并于 2019/09/03 发布的 <a href="https://golang.org/doc/go1.13" target="_blank" rel="noopener">1.13</a> 正式支持，并随之发布 <a href="https://blog.golang.org/module-mirror-launch" target="_blank" rel="noopener">Module Mirror, Index, Checksum</a>，用于解决软件分发、中间人攻击等问题。下图截取自 Go <a href="https://blog.golang.org/modules2019" target="_blank" rel="noopener">官方博客</a></p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01NxbOES1z69wxSzgy2_!!581166664.png_620x10000.jpg" alt="Module Big Picture"></p><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Module 是多个 package 的集合，版本管理的基本单元，使用 go.mod 文件记录依赖的 module。</p><p>go.mod 位于项目的根目录，支持 4 条命令：module、require、replace、exclude。示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module github.com/my/repo</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/some/dependency v1<span class="number">.2</span><span class="number">.3</span></span><br><span class="line">    github.com/another/dependency/v4 v4<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>module 声明 module path，一个 module 内所有 package 的 import path 都以它为前缀</li></ul><p>假如一个 module 有如下目录结构，go.mod 采用上面的示例<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repo</span><br><span class="line">|<span class="comment">-- bar</span></span><br><span class="line">|   `<span class="comment">-- bar.go</span></span><br><span class="line">|<span class="comment">-- foo</span></span><br><span class="line">|   `<span class="comment">-- foo.go</span></span><br><span class="line">`<span class="comment">-- go.mod</span></span><br></pre></td></tr></table></figure></p><p>那么 bar 包的 import path 即为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/my/repo/bar"</span></span><br></pre></td></tr></table></figure></p><ul><li>require 声明所依赖的 module，版本信息使用形如 <code>v(major).(minor).(patch)</code> 的语义化版本 <a href="https://semver.org/" target="_blank" rel="noopener">semver</a>，比如：v0.1.0</li><li>replace/exclude 用于替换、排查指定 module path</li></ul><p>下面重点介绍 modules 中最实用的两个方面：semantic version 与 replace 指令。</p><h3 id="Semantic-Version"><a href="#Semantic-Version" class="headerlink" title="Semantic Version"></a>Semantic Version</h3><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01bk1zqT1z69wz301hZ_!!581166664.png_620x10000.jpg" alt="语义化版本"></p><p>语义化版本要求 v1 及以上的版本保证向后兼容，v2 及以上的版本需要体现在 module path 中，比如</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module github.<span class="keyword">com</span>/my/<span class="keyword">mod</span>/v2</span><br><span class="line"></span><br><span class="line">require github.<span class="keyword">com</span>/my/<span class="keyword">mod</span>/v2 v2.<span class="number">0.1</span></span><br><span class="line">import <span class="string">"github.com/my/mod/v2/mypkg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/my/<span class="keyword">mod</span>/v2@v2.<span class="number">0.1</span></span><br></pre></td></tr></table></figure><p>之所以要求把版本号放在 module path，是为了解决不同大版本之间的 breaking changes。举一个场景：</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01ZyOLHg1z69wz3Le3i_!!581166664.png_310x310.jpg" alt="dependency hell"></p><p>从上图可以看的，A 通过直接或间接依赖 D 的三个不同版本，如果不把版本号放在 module path 中，如何去加载正确的版本的？当然，这里有个前提，同一个大版本内必须保证向后兼容！</p><p>下面截取 prometheus 的部分 <a href="https://github.com/prometheus/prometheus/blob/master/go.mod" target="_blank" rel="noopener">go.mod</a>，来进一步探索 go.mod 的用法</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module github.<span class="keyword">com</span>/prometheus/prometheus</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    # indirect 表示间接依赖</span><br><span class="line">    cloud.google.<span class="keyword">com</span>/<span class="keyword">go</span> v0.<span class="number">44.1</span> // indirect</span><br><span class="line">    k8s.io/klog v0.<span class="number">4.0</span></span><br><span class="line">    # 这里采用 pseudo_versions 表示没有采用 <span class="keyword">go</span> module，且没有打版本 <span class="keyword">tag</span></span><br><span class="line">    github.<span class="keyword">com</span>/alecthomas/units v0.<span class="number">0.0</span>-<span class="number">20190717042225</span>-c3de453c63f4</span><br><span class="line">    # incompatible 表示 <span class="keyword">go</span>-autorest 没有采用 <span class="keyword">go</span> module，而且版本大于 v2</span><br><span class="line">    github.<span class="keyword">com</span>/Azure/<span class="keyword">go</span>-autorest v11.<span class="number">2.8</span>+incompatible</span><br><span class="line">    github.<span class="keyword">com</span>/aws/aws-sdk-<span class="keyword">go</span> v1.<span class="number">23.12</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace (</span><br><span class="line">    # 表示从 github.<span class="keyword">com</span> 下载 klog，而不是 k8s.io</span><br><span class="line">    k8s.io/klog =&gt; github.<span class="keyword">com</span>/simonpasquier/klog-gokit v0.<span class="number">1.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里重点说一下伪版本 <a href="https://golang.org/cmd/go/#hdr-Pseudo_versions" target="_blank" rel="noopener">pseudo_versions</a>，主要用于兼容未采用 module 的依赖。一般形式：</p><ul><li><code>v0.0.0-yyyymmddhhmmss-abcdefabcdef</code></li></ul><p>中间的时间采用 UTC 表示，用于对比两个伪版本的新旧；最后的部分为 commit id 前 12 个字符。</p><h3 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h3><p>go.mod 的 replace 主要用于替换 module path，这对于引用本地依赖非常有帮助。比如有一个库 <code>github.com/user/lib</code> 有 bug，你需要 fork 到本地去修复，这时在自己的项目中需要引用本地 fork 的分支，那么就可以这么用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">replace</span> github.com/<span class="keyword">user</span>/lib =&gt; /<span class="keyword">some</span>/<span class="keyword">path</span>/<span class="keyword">on</span>/your/disk</span><br></pre></td></tr></table></figure><p>代码里面的 import path 不用变。</p><p>类似的原理，项目的 module 名字，也不必加上托管平台前缀了。我创建了一个示例项目 <a href="https://github.com/jiacai2050/strutil" target="_blank" rel="noopener">strutil</a>，其 go.mod 如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">strutil</span></span></span><br><span class="line"></span><br><span class="line">go <span class="number">1.12</span></span><br></pre></td></tr></table></figure><p>如果要引用这个项目，只需要这么做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go.mod</span></span><br><span class="line">replace strutil =&gt; github.com/jiacai2050/strutil v0<span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// str_test.go</span></span><br><span class="line"><span class="keyword">import</span> strutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestModule</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    s := strutil.Reverse(<span class="string">"hello"</span>)</span><br><span class="line">    assert.Equal(t, <span class="string">"olleh"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>对于使用 module 开发的项目，使用 <code>go mod init {moduleName}</code> 初始化后，直接在源文件中 import 所需包名，go test/build 之类的命令会自动分析，将其加到 go.mod 中的 require 里面，不需要自己去修改。开发测试完成后，需要打 tag 才能让其它用户使用。<br>项目的版本号一般从 v0.1.0 开始，表示开始第一个 feature，当有 bugfix 时，变更第三个版本号，如 v0.1.1；当有新 feature 时，变更中间版本号，如 v0.2.0；有 breaking changes 时，变更第一个版本号，比如 v1.0.0。</p><p>除此之外，一般还需配置如下相关变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.13 默认开启</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="comment"># 1.13 之后才支持多个地址，之前版本只支持一个</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn,https://mirrors.aliyun.com/goproxy,direct</span><br><span class="line"><span class="comment"># 1.13 开始支持，配置私有 module，不去校验 checksum</span></span><br><span class="line"><span class="built_in">export</span> GOPRIVATE=*.corp.example.com,rsc.io/private</span><br></pre></td></tr></table></figure><p>关于 module 校验的更多内容，可参考：</p><ul><li><a href="https://golang.org/cmd/go/#hdr-Module_configuration_for_non_public_modules" target="_blank" rel="noopener">https://golang.org/cmd/go/#hdr-Module_configuration_for_non_public_modules</a></li></ul><p>其它常用命令有：</p><ul><li><p><code>go mod download -json</code> 查看 module 详细信息</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Module struct &#123;</span><br><span class="line">    Path    <span class="built_in"> string</span> // <span class="keyword">module</span><span class="built_in"> path</span></span><br><span class="line">    Version <span class="built_in"> string</span> // <span class="keyword">module</span> version</span><br><span class="line">    Error   <span class="built_in"> string</span> //<span class="built_in"> error</span> loading <span class="keyword">module</span></span><br><span class="line">    Info    <span class="built_in"> string</span> // absolute<span class="built_in"> path</span> <span class="keyword">to</span> cached .info file</span><br><span class="line">    GoMod   <span class="built_in"> string</span> // absolute<span class="built_in"> path</span> <span class="keyword">to</span> cached .mod file</span><br><span class="line">    Zip     <span class="built_in"> string</span> // absolute<span class="built_in"> path</span> <span class="keyword">to</span> cached .zip file</span><br><span class="line">    Dir     <span class="built_in"> string</span> // absolute<span class="built_in"> path</span> <span class="keyword">to</span> cached source<span class="built_in"> root</span> directory</span><br><span class="line">    Sum     <span class="built_in"> string</span> // checksum <span class="keyword">for</span><span class="built_in"> path</span>, version (<span class="keyword">as</span> <span class="keyword">in</span> go<span class="built_in">.sum</span>)</span><br><span class="line">    GoModSum<span class="built_in"> string</span> // checksum <span class="keyword">for</span> go.mod (<span class="keyword">as</span> <span class="keyword">in</span> go<span class="built_in">.sum</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>go list -m all</code> 查看当前项目最终所使用的 module 版本</p></li><li><code>go list -u -m all</code> 查看依赖的新版本</li><li><code>go get -u ./...</code> 更新所有依赖到最新版</li><li><code>go get -u=patch ./...</code> 更新所有依赖到最新的 patch 版本</li><li><code>go mod tidy</code> 清理 go.mod/go.sum 中不在需要的 module</li><li><code>go mod vendor</code> 创建 vendor 依赖目录，这时为了与之前做兼容，后面在执行 go test/build 之类的命令时，可以加上 <code>-mod=vendor</code> 这个 build flag 声明使用 vendor 里面的依赖，这样 go mod 就不会再去 <code>$GOPATH/pkg/mod</code> 里面去找。</li></ul><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>在使用 go mod 中我遇到过一个问题，之前很是困扰，后来才发现是没清楚 go 命令参数的含义。下面首先看下项目目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/code/ceresdb-go-sdk</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── ceresdb</span><br><span class="line">│   ├── client.go</span><br><span class="line">│   ├── client_test.go</span><br><span class="line">├── examples</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   └── quickstart.go</span><br><span class="line">├── go.mod</span><br><span class="line">└── go.sum</span><br><span class="line"></span><br><span class="line">$ cat go.mod</span><br><span class="line">module github.com/user/ceresdb-go-sdk</span><br><span class="line">require ( ... )</span><br></pre></td></tr></table></figure><p>可以看到，项目根目录 ceresdb-go-sdk 内没有 go 源码，而是放在了 ceresdb 子目录中，这么设计的目的是保证 import path 与目录名一致</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/user/ceresdb-go-sdk/ceresdb"</span></span><br><span class="line">c := ceresdb.NewClient(...)</span><br></pre></td></tr></table></figure><p>当然也可以去掉 ceresdb 目录，将源码放在项目根目录下，这样 import 就变为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/user/ceresdb-go-sdk"</span></span><br><span class="line">c := ceresdb.NewClient(...)</span><br></pre></td></tr></table></figure></p><p>感觉不是很友好，有些 IDE 比较智能，会自动填充 alias<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这也说明包名可以不和目录一致！但是一般都要保证一致，否则会很具备迷惑性</span></span><br><span class="line"><span class="keyword">import</span> ceresdb <span class="string">"github.com/user/ceresdb-go-sdk"</span></span><br></pre></td></tr></table></figure></p><p>但现在还是假设采用子目录的方式，执行 <code>go test ./...</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">time go test -v -x  ./...</span><br><span class="line">can't <span class="keyword">load</span> <span class="keyword">package</span>: <span class="keyword">package</span> github.com/<span class="keyword">user</span>/ceresdb-<span class="keyword">go</span>-sdk: <span class="literal">unknown</span> <span class="keyword">import</span> <span class="keyword">path</span> <span class="string">"github.com/user/ceresdb-go-sdk"</span>: cannot find <span class="keyword">module</span> providing <span class="keyword">package</span> github.com/<span class="keyword">user</span>/ceresdb-<span class="keyword">go</span>-sdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意花的时间，这期间没有任何输出，即使加了 -x flag</span></span><br><span class="line"><span class="built_in">real</span><span class="number">1</span>m2<span class="number">.472</span>s</span><br><span class="line"><span class="keyword">user</span><span class="number">0</span>m0<span class="number">.111</span>s</span><br><span class="line"><span class="keyword">sys</span><span class="number">0</span>m0<span class="number">.082</span>s</span><br></pre></td></tr></table></figure><p>对于这个错误有些懵，我这个项目不就是  github.com/user/ceresdb-go-sdk 嘛，怎么会报找不到呢？为了解释原因，需要了解下 go 命令的一般形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">go</span> <span class="selector-tag">command</span> <span class="selector-attr">[command_args]</span> <span class="selector-attr">[build flags]</span> <span class="selector-attr">[packages]</span></span><br></pre></td></tr></table></figure><ul><li>command 是指 test/build/mod/list 之类命令</li><li>command_args 是指特定命令相关的参数</li><li>build flags 是大部分命令都支持的参数，比较常用的有：<ul><li><code>-race</code> 开启 race 检测</li><li><code>-v</code> 输出正在编译的包名</li><li><code>-x</code> 输出详细执行的命令，在 go get 卡住时可以打开定位问题</li><li><code>-mod</code> 指定 module 依赖下载模式，目前只有两个值：readonly 或者 vendor</li><li><code>-tags</code> 逗号分隔编译 tags，主要用于区别 build 环境，比如<a href="https://stackoverflow.com/a/28007631/2163429" target="_blank" rel="noopener">集成测试</a></li></ul></li><li>packages 指定当前命令作用的包</li></ul><p>上面的错误就出错在最后一个参数上，我们知道包的 import path 需要加上 module path，上面的错误也证明了这一点。<br>特殊的，对于 <code>./xxx</code> 会去找对应目录下面的包，不用写 module path 了，<code>./...</code> 则意味着递归地找当前目录下的所有包，且包括当前目录。<br>问题就在于项目根目录下没有任何 go 源文件，所以就找不到当前目录下的包了！解决方法也很简单：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test  ./ceresdb</span><br><span class="line"># <span class="keyword">go</span> test github.<span class="keyword">com</span>/user/ceresdb-<span class="keyword">go</span>-sdk/ceresdb 当然也可以</span><br><span class="line">...</span><br><span class="line">PASS</span><br><span class="line">ok  github.<span class="keyword">com</span>/user/ceresdb-<span class="keyword">go</span>-sdk/ceresdb<span class="number">0.017</span>s</span><br></pre></td></tr></table></figure><p>或者，在根目录下加一个 go 文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 包名可以和 import path 不一致，所以这里 <span class="keyword">abc</span> 也是可以的</span><br><span class="line">$ <span class="keyword">echo</span> <span class="string">'package abc'</span> &gt; <span class="keyword">abc</span>.<span class="keyword">go</span></span><br><span class="line">$ <span class="keyword">go</span> test .</span><br><span class="line">?   github.<span class="keyword">com</span>/user/ceresdb-<span class="keyword">go</span>-sdk[<span class="keyword">no</span> test <span class="keyword">files</span>]</span><br></pre></td></tr></table></figure><p>这样也不会报错了。</p><h2 id="vgo"><a href="#vgo" class="headerlink" title="vgo"></a>vgo</h2><p><a href="https://github.com/golang/vgo" target="_blank" rel="noopener">vgo</a> 是 Go 的核心开发者 <a href="https://swtch.com/~rsc/" target="_blank" rel="noopener">Russ Cox</a> 尝试给 Go 增加包管理的原型，是个单独的命令，相当于自动加上 <code>GO111MODULE=on</code> 的 go 命令，在把包管理功能集成到 go 命令时，才叫 modules。</p><blockquote><p>The reference implementation was named vgo, but support for modules is being integrated into the go command itself. The feature within the go command is called “versioned Go modules” (or “modules” for short), not “vgo”.</p></blockquote><p>关于 Go 的包管理，Russ Cox 有一系列 <a href="https://github.com/golang/go/wiki/vgo" target="_blank" rel="noopener">vgo</a> 的文章介绍<a href="https://research.swtch.com/vgo" target="_blank" rel="noopener">来龙去脉</a>，感兴趣的读者可以去看看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，希望让大家更清楚了解 modules 的设计初衷以及如何排查问题，做到语义化版本，大版本向后兼容。如果你的项目比较复杂，项目的结构可以参考：</p><ul><li><a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout</a></li></ul><p>Clojure 作者 Rich Hickey 有个有名的演讲 <a href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md" target="_blank" rel="noopener">Simple Made Easy</a>，主要讲述了可以通过简单的工具来降低软件开发的复杂度，Go 作者 Rob Pike 在 2015 年的一个 talk <a href="https://talks.golang.org/2015/simplicity-is-complicated.slide#1" target="_blank" rel="noopener">Simplicity is Complicated</a> 中也指出，Go 成功的一大原因源自其简单易用的特性。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN012w8eQ11z69x0Nk2xz_!!581166664.jpg" alt="Simplicity"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">https://golang.org/doc/code.html</a></li><li><a href="https://blog.golang.org/modules2019" target="_blank" rel="noopener">https://blog.golang.org/modules2019</a></li><li><a href="https://research.swtch.com/vgo-intro" target="_blank" rel="noopener">https://research.swtch.com/vgo-intro</a></li><li><a href="https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527" target="_blank" rel="noopener">https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用了近半年的 Go，真是有种相见恨晚的感觉。简洁的语法、完善并强大的开发工具链，省去新手不少折腾的时间，可以专注写代码。&lt;br&gt;这期间也掌握了不少技巧与惯用法（idioms），比如 &lt;a href=&quot;https://github.com/jiacai2050/prosume
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Go" scheme="http://liujiacai.net/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>写给新手的 Go 开发指南</title>
    <link href="http://liujiacai.net/blog/2019/07/17/hello-golang/"/>
    <id>http://liujiacai.net/blog/2019/07/17/hello-golang/</id>
    <published>2019-07-17T13:52:33.000Z</published>
    <updated>2020-03-15T08:02:49.159Z</updated>
    
    <content type="html"><![CDATA[<p>转眼加入蚂蚁已经三个多月，这期间主要维护一 Go 写的服务器。虽然用的时间不算长，但还是积累了一些心得体会，这里总结归纳一下，供想尝试 Go 的同学参考。<br>本文会依次介绍 Go 的设计理念、开发环境、语言特性。本文在谈及语言特性的时也会讨论一些 Go 的不足之处，旨在给读者提供一个全面的视角。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一般来说，编程语言都会有一个 slogan 来表示它们的特点。比如提到 Clojure，一般会想到这么几个词汇：lisp on JVM、immutable、persistent；Java 的话我能想到的是企业级开发、中规中矩。对于 Go ，官网介绍到：</p><blockquote><p>Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</p></blockquote><p>提取几个关键词：open（开放）、simple（简洁）、reliable（可靠）、efficient（高效）。这也可以说是它的设计目标。除了上面这些口号外，初学者还需要知道 Go 是一门命令式的静态语言（是指在编译时检查变量类型是否匹配），与 Java 属于同一类别。</p><table><thead><tr><th></th><th>Imperative</th><th>Functional</th></tr></thead><tbody><tr><td>Dynamic</td><td>Python/Ruby/Javascript</td><td>Lisp/Scheme/Clojure</td></tr><tr><td>Static</td><td>Java/C++/Rust/Go</td><td>OCaml/Scala/Haskell</td></tr></tbody></table><p>由于 <a href="https://play.golang.org/" target="_blank" rel="noopener">Hello World</a> 太简洁，不具备展示 Go 的特点，所以下面展示一段访问 httpbin，打印 response 的完整代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// http://httpbin.org/#/Anything/get_anything</span></span><br><span class="line">    r, err := http.Get(<span class="string">"http://httpbin.org/anything?hello=world"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"></span><br><span class="line">    bs, err := ioutil.ReadAll(r.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"body = %s\n"</span>, bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码片段包括了 Go 的主要组成：包的声明与引用、函数定义、错误处理、流程控制、<a href="https://tour.golang.org/flowcontrol/12" target="_blank" rel="noopener">defer</a>。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>通过上面的代码片段，可以看出 Go 语言 simple（简洁）的特点，所以找一个最熟悉的文本编辑器，一般通过配置插件，都可以达到快速开发的目的。很久之前我就已经把所有文本编辑放到 Emacs 上，这里介绍下我的配置。</p><p>除了 <a href="https://github.com/dominikh/go-mode.el" target="_blank" rel="noopener">go-mode</a> 这个 major mode，为了配置像 源码跳转、API 自动补全、查看函数文档等现代 IDE 必备功能，需要安装以下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">go get -u github.com/rogpeppe/godef</span><br><span class="line">go get -u github.com/stamblerre/gocode <span class="comment"># for go-eldoc/company-go</span></span><br><span class="line">go get -u golang.org/x/tools/cmd/goimports</span><br><span class="line">go get -u github.com/kisielk/errcheck</span><br><span class="line">go get -u github.com/lukehoban/go-outline <span class="comment"># for go-imenu</span></span><br></pre></td></tr></table></figure></p><p>然后再按照 <a href="https://github.com/jiacai2050/dotfiles/blob/master/.emacs.d/customizations/setup-go.el" target="_blank" rel="noopener">setup-go.el</a> 里的配置，就拥有了一个功能完备的开发环境。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01TBr6Xm1z69vZesJfk_!!581166664.png" alt="Emacs Go 开发环境"></p><p>不像 Java 语言需要运行时，Go 支持直接将整个项目 build 成一个二进制文件，方便部署，而支持<a href="https://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5" target="_blank" rel="noopener">交叉编译</a>，不过在开发时，直接 <code>go run XXX.go</code> 更为便利，截止到 Go 1.12，还不支持 <a href="https://stackoverflow.com/questions/8513609/does-go-provide-repl" target="_blank" rel="noopener">REPL</a>，官方有提供在线版的 <a href="https://play.golang.org/" target="_blank" rel="noopener">Playground</a> 供分享、调试代码。</p><p>我个人的习惯是建一个 go-app 项目，每个要测试的逻辑放到一个 test 里面去，这样就可以使用 <code>go test -v -run XXX</code> 来运行。之所以不选用 <code>go run</code>，是因为一个目录下只允许有一个 main 的 package，多个 IDE 会提示错误。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>一般编程语言，<a href="https://go101.org/article/type-system-overview.html" target="_blank" rel="noopener">数据类型</a>分为基本的与复杂的两类。<br>基本的一般比较简单，表示一个值，Go 里面就有 string, bool, int8, int32(rune), int64, float32, float64, byte(uint8) 等基本类型<br>复杂类型一般表示多个值或具有某些高级用法，Go 里面有：</p><ul><li>pointer Go 里只支持取地址 <code>&amp;</code> 与间接访问 <code>*</code> 操作符，不支持对指针进行算术操作</li><li>struct 类似于 C 语言里面的 struct，Java 里面的对象</li><li>function 函数在 Go 里是一等成员</li><li>array 大小固定的数组</li><li>slice 动态的数组</li><li>map 哈希表</li><li>chan 用于在多个 goroutine 内通信</li><li>interface 类似于 Java 里面的接口，一组方法的封装</li></ul><p>下面将重点介绍 Go 里特有或用途最广的数据类型。</p><h3 id="struct-interface"><a href="#struct-interface" class="headerlink" title="struct/interface"></a>struct/interface</h3><p>Go 里面的 struct 类似于 Java 里面的 Object，但是并没有继承，仅仅是对数据的一层包装（抽象）。相对于其他复杂类型，struct 是<strong>值类型</strong>，也就是说作为函数参数或返回值时，会拷贝一份值。<br>一般来说，值类型分配在 stack 上，与之相对的引用类型，分配在 heap 上。<br>初学者一般会有这样的误区，认为传值比传引用要慢，实则不然，具体涉及到 Go <a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html" target="_blank" rel="noopener">如何管理内存</a>，这里暂不详述，感兴趣到可以阅读：</p><ul><li><a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65" target="_blank" rel="noopener">The Top 10 Most Common Mistakes I’ve Seen in Go Projects</a></li><li><a href="https://gist.github.com/teivah/a32a8e9039314a48f03538f3f9535537" target="_blank" rel="noopener">pointer_test.go</a> 这个测试在笔者机器上运行结果：<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkByPointer<span class="number">-8</span>    <span class="number">20000000</span>                <span class="number">86.7</span> ns/op</span><br><span class="line">BenchmarkByValue<span class="number">-8</span>      <span class="number">50000000</span>                <span class="number">31.9</span> ns/op</span><br></pre></td></tr></table></figure></li></ul><p>所以一般情况下推荐直接使用值类型的 struct，如果需要改变状态，再考虑改为指针类型（&amp;struct）</p><p>如果说 struct 是对状态的封装，那么 interface 就是对行为的封装，相当于对外的契约（contract）。而且 Go 里面有这么一条<a href="https://www.reddit.com/r/golang/comments/cf1lda/having_trouble_understanding_how_to_properly_use/eu7r4f3" target="_blank" rel="noopener">最佳实践</a></p><blockquote><p>Accept interfaces, return concrete structs. （函数的参数尽量为 interface，返回值为 struct）</p></blockquote><p>这样的好处也很明显，作为类库的设计者，对其要求的参数尽量宽松，方便使用，返回具体值方便后续的操作处理。一个极端的情况，可以用 <code>interface{}</code> 表示任意类型的参数，因为这个接口里面没有任何行为，所以所有类型都是符合的。又由于 Go 里面不支持<a href="https://dev.to/deanveloper/go-2-draft-generics-3333" target="_blank" rel="noopener">范型</a>，所以<code>interface{}</code>是唯一的解决手段。</p><p>相比较 Java 这类面向对象的语言，接口需要显式（explicit）继承（使用 implements 关键字），而在 Go 里面是<a href="https://golang.org/doc/faq#implements_interface" target="_blank" rel="noopener">隐式的（implicit）</a>，新手往往需要一段时间来体会这一做法的巧妙，这里举一例子来说明：</p><p>Go 的 IO 操作涉及到两个基础类型：Writer/Reader ，其定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">        Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类型如果实现了这两个方法，那么就实现了这两个接口，下面的 Example 就是这么一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Example)</span> <span class="title">Write</span><span class="params">(p <span class="keyword">byte</span>[])</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Example)</span> <span class="title">Read</span><span class="params">(p <span class="keyword">byte</span>[])</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于隐式继承过于灵活，在 Go 里面可能会看到<a href="https://stackoverflow.com/questions/17994519/golang-interface-compliance-compile-type-check" target="_blank" rel="noopener">如下代码</a>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ blob.Fetcher = (*CachingFetcher)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p><p>这是通过将 nil 强转为 <code>*CachingFetcher</code>，然后在赋值时，指定 <code>blob.Fetcher</code> 类型，保证 <code>*CachingFetcher</code> 实现了 <code>blob.Fetcher</code> 接口。<br>作为接口的设计者，如果想实现者显式继承一个接口，可以在接口中<a href="https://golang.org/doc/faq#guarantee_satisfies_interface" target="_blank" rel="noopener">额外加一个方法</a>。比如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fooer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Foo()</span><br><span class="line">    ImplementsFooer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，实现者必须实现 <code>ImplementsFooer</code> 方法才能说是继承了 <code>Fooer</code> 接口。所以说隐式继承有利有弊，需要开发者自己去把握。</p><h3 id="map-slice"><a href="#map-slice" class="headerlink" title="map/slice"></a>map/slice</h3><p>Map/Slice 是 Go 里面最常用的两类数据结构，属于引用类型。在语言 runtime 层面实现，仅有的两个支持范型的结构。<br>Slice 是长度不固定的数组，类似于 Java 里面的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 通过 make 进行初始化</span></span><br><span class="line"><span class="comment">// 如果提前知道 m 大小，建议通过 make 的第二个参数指定，避免后期的数据移动、复制</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">m[<span class="string">"zhangsan"</span>] = <span class="string">"teacher"</span></span><br><span class="line"><span class="comment">// 读取指定值，如不存在，返回其类型的默认值</span></span><br><span class="line">v := m[<span class="string">"zhangsan"</span>]</span><br><span class="line"><span class="comment">// 判断指定 key 知否在 map 内</span></span><br><span class="line">v, ok := m[<span class="string">"zhangsan"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 通过 make 进行初始化</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 增加元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 make 第二个参数指定大小</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line">    s[i] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以使用三个参数的 make 初始化 slice</span></span><br><span class="line"><span class="comment">// 第二个参数为初始化大小，第三个为最大容量</span></span><br><span class="line"><span class="comment">// 需要通过 append 增加元素</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span> ,<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="chan-goroutine"><a href="#chan-goroutine" class="headerlink" title="chan/goroutine"></a>chan/goroutine</h3><p>作为一门新语言，Goroutine 是 Go <a href="https://golang.org/doc/faq#csp" target="_blank" rel="noopener">借鉴 CSP 模型</a>提供的并发解决方案，相比传统 OS 级别的线程，它有以下<a href="https://stackoverflow.com/a/27794268/2163429" target="_blank" rel="noopener">特点</a>：</p><ol><li>轻量，完全在用户态调度（不涉及OS状态直接的转化）</li><li>资源占用少，启动快</li><li>目前，Goroutine 调度器不保证公平（fairness），抢占（pre-emption）也支持的非常有限，一个空的 <code>for{}</code> 可能会一直不被调度出去。</li></ol><p>一般可以使用 chan/select 来进行 Goroutine 之间的调度。chan 类似于 Java 里面的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html" target="_blank" rel="noopener">BlockingQueue</a>，且能保证 Goroutine-safe，也就是说多个 Goroutine 并发进行读写是安全的。</p><p>chan 里面的元素默认为1个，也可以在创建时指定缓冲区大小，读写支持堵塞、非堵塞两种模式，关闭一个 chan 后，再写数据时会 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chan 与 slice/map 一样，使用 make 初始化</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// blocking read</span></span><br><span class="line">v := &lt;-ch</span><br><span class="line"><span class="comment">// nonblocking read, 需要注意 default 分支不能省略，否则会堵塞住</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v:=&lt;-ch:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// blocking write</span></span><br><span class="line">ch &lt;- v</span><br><span class="line"><span class="comment">// nonblocking write</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch&lt;-v:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chan 作为 Go 内一重要数据类型，看似简单，实则暗藏玄妙，用时需要多加留意，这里不再展开叙述，后面打算专门写一篇文章去介绍，感兴趣的可以阅读下面的文章：</p><ul><li><a href="https://dave.cheney.net/2013/04/30/curious-channels" target="_blank" rel="noopener">Curious Channels</a></li><li><a href="https://github.com/jiacai2050/prosumer" target="_blank" rel="noopener">Prosumer</a> 基于 buffered chan 实现的生产者消费者，核心点在于关闭 chan 只意味着生产者不能再发送数据，消费者无法获知 chan 是否已经关闭，需要用其他方式去通信。</li></ul><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>Go 相比 Java 来说，语言特性真的是少太多。推荐 <a href="https://learnxinyminutes.com/docs/go/" target="_blank" rel="noopener">Learn X in Y minutes</a> 这个网站，快速浏览一遍即可掌握 Go 的语法。Go 的简洁程度觉得和 JavaScript 差不多，但却是一门静态语言，具有强类型，这两点又让它区别于一般的脚本语言。</p><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><p>Go 遵循约定大于配置（convention over configuratio）的设计理念，比如在构建一个项目时，直接 <code>go build</code> 一个命令就搞定了，不需要什么 Makefile、pom.xml 等配置文件。下面介绍几个常用的约定：</p><ul><li>一个包内函数、变量的可见性是通过首字母大小写确定的。大写表示可见。</li><li>一般 <code>{</code> 放在行末，否则 Go 编辑器会<a href="https://golang.org/doc/effective_go.html#semicolons" target="_blank" rel="noopener">自动插入一个逗号</a>，导致编译错误</li><li>一个文件夹内，只能定义一个包</li><li>变量、函数命名<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_identifier_length" target="_blank" rel="noopener">尽量简短</a>，标准库里面经常可以看到一个字母的变量</li></ul><p>由于以上种种约定，在看别人代码时很舒服，有种 Python 的感觉。另外建议在编辑器中配置 <a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a> 来自动化格式代码。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Go 内没有 try catch 机制，而且已经明确拒绝了这个 <a href="https://github.com/golang/go/issues/32437" target="_blank" rel="noopener">Proposal</a>，而是通过返回值的方式来处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> …, err  <span class="comment">// zero values for other results, if any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 的函数一般通过返回多值的方式来传递 error（且一般是第二个位置），实际项目中一般使用 <a href="https://github.com/pkg/errors" target="_blank" rel="noopener">pkg/errors</a> 去处理、包装 err。</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>Go 的依赖管理，相比其他语言较弱。<br>在 Go 1.11 正式引入的 <a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">modules</a> 之前，项目必须放在 $GOPATH/src/xxx.com/username/project 内，这样 Go 才能去正确解析项目依赖，而且 Go 社区没有统一的包托管平台，不像 Java 中 maven 一样有中央仓库的概念，而是直接引用 Git 的库地址，所以在 Go 里，一般会使用 <code>github.com/username/package</code> 的方式来表示。<br><code>go get</code> 是下载依赖的命令，但一个个去 get 库不仅仅繁碎，而且无法固化依赖版本信息，所以 <a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a> 应运而生，添加新依赖后，直接运行 <code>dep ensure</code> 就可以全部下下来，而且会把当前依赖的 commit id 记录到 Gopkg.lock 里面，这就能解决版本不固定的问题。</p><p>但 modules 才是正路，且在 1.13 版本会默认开启，所以这里只介绍它的用法。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先导出环境变量</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="comment"># 在一个空文件夹执行 init，创建一个名为 hello 的项目</span></span><br><span class="line">go mod init hello</span><br><span class="line"><span class="comment"># 这时会在当前文件夹内创建 go.mod ，内容为</span></span><br><span class="line"></span><br><span class="line">module hello</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"><span class="comment"># 之后就可以编写 Go 文件，添加依赖后，执行 go run/test/build...</span></span><br><span class="line"><span class="comment"># 依赖会自动下载，并记录在 go.mod 内，版本信息记录在 go.sum</span></span><br></pre></td></tr></table></figure><p>更多用法可以参考官方示例，这里只是想说明 <a href="https://github.com/golang/tools" target="_blank" rel="noopener">go tools</a> 大部分已经支持，但是 <a href="https://github.com/golang/go/issues/26827" target="_blank" rel="noopener">godoc 还不支持</a>，更多可参考 <a href="https://github.com/golang/go/issues/24661" target="_blank" rel="noopener">#24661</a>。</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>Go 也是具有<a href="https://blog.golang.org/ismmkeynote" target="_blank" rel="noopener">垃圾回收</a>的语言，但相比于 JVM，Go GC 可能显得及其简单，从 Go 1.10 开始，Go GC 采用 Concurrent Mark &amp; Sweep (CMS) 算法，且不具有分代、compact 特性。读者如果对相关名词不熟悉，可以阅读：</p><ul><li><a href="https://engineering.linecorp.com/en/blog/go-gc/" target="_blank" rel="noopener">https://engineering.linecorp.com/en/blog/go-gc/</a></li></ul><p>而且 Go 里面调整 GC 的参数只有一个 <code>GOGC</code>，表示下面的比率</p><blockquote><p>新分配对象 / 上次 GC 后剩余对象</p></blockquote><p>默认 100，表示新分配对象达到上次 GC 后剩余对象的两倍时，进行 GC。</p><ul><li>调大 GOGC，可以减少 GC 的总体耗时</li><li>减小 GOGC，意味着用更多的 GC 来换取更少的内存使用</li></ul><p><code>GOGC=off</code> 可以关闭 GC，<a href="https://golang.org/pkg/runtime/debug/#SetGCPercent" target="_blank" rel="noopener">SetGCPercent</a> 可以动态修改这个比率。</p><p>在启动一个 Go 程序时，可以设置 <code>GODEBUG=gctrace=1</code> 来打印 GC 日志，日志具体含义可参考 <a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables" target="_blank" rel="noopener">pkg/runtime</a>，这里不再赘述。对调试感兴趣的可以阅读：</p><ul><li><a href="https://new.blog.cloudflare.com/go-dont-collect-my-garbage/" target="_blank" rel="noopener">https://new.blog.cloudflare.com/go-dont-collect-my-garbage/</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go 最初由 Google 在 2007 为解决软件复杂度、提升开发效率的一试验品，到如今不过十二年，但无疑已经<a href="https://hackernoon.com/major-programming-trends-to-prepare-for-in-2019-169987cc75f4" target="_blank" rel="noopener">家喻户晓</a>，成为<a href="https://thenewstack.io/go-the-programming-language-of-the-cloud/" target="_blank" rel="noopener">云时代的首选</a>。其面向接口的特有编程方式，也非常灵活，兼具动态语言的简洁与静态语言的高效，推荐大家尝试一下。Go Go Go!</p><p><img src="https://golang.org/lib/godoc/images/go-logo-blue.svg" alt="Go"></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://github.com/overnote/golang/blob/master/01-Go初识/03-包与依赖管理.md" target="_blank" rel="noopener">03-包与依赖管理.md</a></li><li><a href="http://dtrace.org/blogs/ahl/2016/08/02/i-love-go-i-hate-go/" target="_blank" rel="noopener">I Love Go; I Hate Go</a></li><li><a href="https://golang.org/ref/spec#Receive_operator" target="_blank" rel="noopener">The Go Programming Language Specification#Receive operator</a></li><li><a href="http://www.yinwang.org/blog-cn/2014/04/18/golang" target="_blank" rel="noopener">王垠：对 Go 语言的综合评价</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></li><li><a href="https://golang.org/doc/faq" target="_blank" rel="noopener">https://golang.org/doc/faq</a></li><li><a href="https://blog.golang.org/go15gc" target="_blank" rel="noopener">https://blog.golang.org/go15gc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转眼加入蚂蚁已经三个多月，这期间主要维护一 Go 写的服务器。虽然用的时间不算长，但还是积累了一些心得体会，这里总结归纳一下，供想尝试 Go 的同学参考。&lt;br&gt;本文会依次介绍 Go 的设计理念、开发环境、语言特性。本文在谈及语言特性的时也会讨论一些 Go 的不足之处，旨在
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Go" scheme="http://liujiacai.net/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Clojure 开发经验总结</title>
    <link href="http://liujiacai.net/blog/2019/04/21/experience-in-clojure/"/>
    <id>http://liujiacai.net/blog/2019/04/21/experience-in-clojure/</id>
    <published>2019-04-21T05:10:52.000Z</published>
    <updated>2019-12-24T10:59:14.614Z</updated>
    
    <content type="html"><![CDATA[<p>大概在两年半前，我开始陆陆续续写了<a href="/tags/Clojure/">一系列文章</a>，来介绍如何上手、深入 Clojure，后来有幸加入 LeanCloud 写了两年的 Clojure，期间制作了一套<a href="https://github.com/jiacai2050/learn_clojure.mp4" target="_blank" rel="noopener">七集的教学视频</a>，算是对这门语言有了较为全面的认识。<br>鉴于国内 Clojure 普及程度很低，我觉得有必要把这些年的经验整理出来，可能会有些片面，但贵在真实，希望我的这些实战经验能帮助到后面 Clojure 的学习者。</p><p>工欲善其事，必先利其器。首先，会介绍如何打造高效实用的集成开发环境（IDE）；接着会介绍 Clojure 语言特性隐藏的一些坑；之后就如何长期维护 Clojure 项目提供一些思路；然后会介绍 Clojure 社区中一些重量级的人物，通过阅读他们的代码可以极大增强自己的内功；最后想谈下对国内 Clojure 找工作的个人见解。</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>在 <a href="/blog/2016/12/31/dev-in-clojure">Clojure 开发那些事</a> 中，介绍了开发 Clojure 的两种组合，即 IDEA+Cursive 与 Emacs+Cider。我一直用的是 Emacs 这一组合，在编写与 Java 交互比较多的情况下，会去采用 IDEA 方案。</p><p>关于编辑器之争，这里没必要讨论，适合自己的才是最好的，都是工具而已，写出优雅的代码才是目的。这里仅仅分享个人使用 Emacs 的一些小心得。</p><h3 id="Emacs"><a href="#Emacs" class="headerlink" title="Emacs"></a>Emacs</h3><p>Emacs 是起源最早的编辑器之一。有人说它是伪装成编辑器的操作系统，我当初怀揣着试试看的心理，反反复复用了几次，但基本上都无疾而终，相比于 VSCode 之类开箱即用的编辑器， Emacs 确实很不友好。后来才知道，入门 Emacs，最好的方式是先用前辈们的配置文件，然后逐渐去适应、学习。<br>这个过程比较痛苦，我大概持续了一周左右，即使到了今天，也还是有可能陶醉在配置文件的修改中，一改就是3、4个小时，因为它的配置文件就是 Elisp 代码，随着使用程度的增加，这些代码会变得比较复杂，所以隔一段时间，我就会重新整理一下，寻找最佳的管理方式。</p><ul><li><a href="https://github.com/flyingmachine/emacs-for-clojure" target="_blank" rel="noopener">https://github.com/flyingmachine/emacs-for-clojure</a> 这是我最初参考的配置</li><li><a href="https://github.com/jiacai2050/dotfiles/tree/master/.emacs.d" target="_blank" rel="noopener">https://github.com/jiacai2050/dotfiles/tree/master/.emacs.d</a> 这是我目前的配置</li></ul><p>建议感兴趣的同学专门拿出两天来学习 Emacs 一些基本操作，然后强迫自己在日常工作中使用它，这样应该能很快上手，一旦习惯了，基本上就离不开了，我目前除了 Java 用 IDEA 开发外，其余的 go/python/js/rust 等都用 Emacs 搞定。喜欢折腾的同学不要错过！<br>下面介绍两个 Emacs 中杀手锏：</p><ul><li><a href="https://magit.vc/" target="_blank" rel="noopener">Magit, A Git Porcelain inside Emacs</a> 深度与 Emacs 整合的 git 客户端，非常好用</li><li><a href="https://orgmode.org/" target="_blank" rel="noopener">Org mode</a> 一个强大的标记语言，完虐 markdown</li></ul><p>最后，国内的 Emacs 社区也是非常推荐，经常会有精彩的讨论，各种使用问题都可以在上面找到答案</p><ul><li><a href="https://emacs-china.org/" target="_blank" rel="noopener">https://emacs-china.org/</a></li></ul><h3 id="Cider-Lein"><a href="#Cider-Lein" class="headerlink" title="Cider + Lein"></a>Cider + Lein</h3><p>Cider 全称是 The Clojure Interactive Development Environment that Rocks for Emacs</p><p>参考 flyingmachine 的配置，能把 cider+lein 跑起来，在使用过程中，我逐渐总结出一套“最佳实践”，供大家参考：</p><ol><li>慎重升级。每次升级 cider，我都会<a href="https://github.com/clojure-emacs/cider/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+commenter%3Ajiacai2050+" target="_blank" rel="noopener">或多或少遇到些问题</a>，这很烦人，尤其是你要开始干活的时候，IDE 突然坏了，于是乎你不得不停下手中的活，来修复它。虽然社区反应还算快，但还是挺影响效率的。</li><li><p><a href="https://github.com/technomancy/leiningen" target="_blank" rel="noopener">lein</a> 作为 Clojure 默认的项目管理工具，已够用，不需要再去折腾 <a href="https://github.com/boot-clj/boot" target="_blank" rel="noopener">boot-clj</a></p><ul><li><a href="https://github.com/technomancy/leiningen/blob/master/doc/TUTORIAL.md#checkout-dependencies" target="_blank" rel="noopener">Checkout Dependencies</a> 多项目开发时必备的技巧。项目目录大概是这样子的：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|<span class="comment">-- project.clj</span></span><br><span class="line">|<span class="comment">-- README.md</span></span><br><span class="line">|<span class="comment">-- checkouts</span></span><br><span class="line">|   `<span class="comment">-- suchwow [link to ~/code/oss/suchwow]</span></span><br><span class="line">|   `<span class="comment">-- commons [link to ~/code/company/commons]</span></span><br><span class="line">|<span class="comment">-- src</span></span><br><span class="line">|   `<span class="comment">-- my_stuff</span></span><br><span class="line">|       `<span class="comment">-- core.clj</span></span><br><span class="line">`<span class="comment">-- test</span></span><br><span class="line">    `<span class="comment">-- my_stuff</span></span><br><span class="line">        `<span class="comment">-- core_test.clj</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Clojure REPL 启动很慢，所以正确的姿势是启动一个 REPL 后，不去关闭它，一直在里面去调试代码，有下面几个 plugin 使用的推荐：</p><ul><li><a href="https://github.com/palletops/lein-shorthand" target="_blank" rel="noopener">lein-shorthand</a> + <a href="https://github.com/pallet/alembic" target="_blank" rel="noopener">alembic</a> 可以在已启动的 REPL 中动态添加新依赖，不需要重启，必备！</li><li><a href="https://github.com/vvvvalvalval/scope-capture" target="_blank" rel="noopener">scope-capture</a> 让 REPL 开发、测试流程如丝般柔滑！</li><li><a href="https://github.com/jiacai2050/dotfiles/blob/master/.lein/profiles.clj" target="_blank" rel="noopener">profiles.clj</a> 是我目前的配置，供参考</li><li>REPL 启动久了，难免变得比较“脏”，对于改动较多的情况，在正式 push 到 remote 前，建议重启 REPL 测试</li></ul></li></ol><h2 id="Clojure-踩雷区"><a href="#Clojure-踩雷区" class="headerlink" title="Clojure 踩雷区"></a>Clojure 踩雷区</h2><p>每门语言都会过度宣扬自己的长处，而刻意回避自己不擅长的地方，这无可厚非。这一小节就会介绍下 Clojure 中容易出问题的几个地方：</p><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="Lazy"></a>Lazy</h3><p><a href="https://clojure.org/reference/lazy" target="_blank" rel="noopener">惰性</a>是 Clojure 语言的一重要特性，按需求值，看起来很美好，但是用起来坑缺很多。<br>首先就是官方文档里介绍的 <a href="https://clojure.org/reference/lazy#_dont_hang_onto_your_head" target="_blank" rel="noopener">Don’t hang (onto) your head</a>，类似的变种还有 <a href="https://stuartsierra.com/2015/04/26/clojure-donts-concat" target="_blank" rel="noopener">lazy-seq + concat</a> 的组合，非常容易写出看似优雅、实则暗藏 bug 的代码，到现在我都必须非常小心的使用它们，并且不能完全保证没有错误。</p><p>另一个是与动态变量结合时，比如</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> *some-predict* <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> do-somework [exercises]</span><br><span class="line">  (<span class="name">binding</span> [*some-predict* <span class="literal">false</span>]</span><br><span class="line">    (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">fn</span></span> [x] (<span class="name">do-with</span> x))</span><br><span class="line">         exercises)))</span><br></pre></td></tr></table></figure><p>由于 map 是惰性求值的，导致 do-somework 在返回后还没有真正求值（realize），导致没有用到函数内 binding 的值。</p><h3 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h3><p>动态变量解决的问题就是在不改变函数签名（主要是参数）的情况下，改变函数的行为。但用好它并不容易，除了上面提及的与 lazy 整合的问题，还要注意，其 binding 的值是不能跨线程的，为了解决这个问题，Clojure 1.3 版本提出了 <a href="https://github.com/clojure/clojure/blob/master/changes.md#234-binding-conveyance" target="_blank" rel="noopener">binding conveyance</a>，但仅仅对 Clojure 自身的线程池有效，然后又增加了 <a href="https://clojuredocs.org/clojure.core/bound-fn" target="_blank" rel="noopener">bound-fn</a> 来解决这个问题。可以参考下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(def ^:dynamic *num* <span class="number">1</span>)</span><br><span class="line">(binding [*num* <span class="number">2</span>] </span><br><span class="line">  (future (println *num*)))</span><br><span class="line">;; 因为 binding conveyance，这里打印 <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line">(let [^<span class="function">ExecutorService <span class="title">executor</span> <span class="params">(Executors/newFixedThreadPool <span class="number">1</span>)</span>]</span></span><br><span class="line"><span class="function">  <span class="params">(binding [*num* <span class="number">2</span>]</span></span></span><br><span class="line"><span class="function"><span class="params">    (.submit executor ^Callable (fn [] (println *num*)</span>))</span></span><br><span class="line"><span class="function">    <span class="params">(.shutdown executor)</span>))</span></span><br><span class="line"><span class="function"></span>;; 对于自定义线程池，这里打印 <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">(let [^<span class="function">ExecutorService <span class="title">executor</span> <span class="params">(Executors/newFixedThreadPool <span class="number">1</span>)</span>]</span></span><br><span class="line"><span class="function">  <span class="params">(binding [*num* <span class="number">2</span>]</span></span></span><br><span class="line"><span class="function"><span class="params">    (.submit executor ^Callable (bound-fn [] (println *num*)</span>))</span></span><br><span class="line"><span class="function">    <span class="params">(.shutdown executor)</span>))</span></span><br><span class="line"><span class="function"></span>;; 对于 bound-fn ，这里打印 <span class="string">"2"</span></span><br></pre></td></tr></table></figure><p>更多可参考：</p><ul><li><a href="https://stuartsierra.com/2013/03/29/perils-of-dynamic-scope" target="_blank" rel="noopener">https://stuartsierra.com/2013/03/29/perils-of-dynamic-scope</a></li></ul><h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>nil 表示无，在不同场景下有不同含义，而且 Clojure 想尽量屏蔽掉这种差异性，比如：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user&gt; (str nil "abc")</span><br><span class="line"><span class="string">"abc"</span></span><br><span class="line">user&gt; (conj nil "abc")</span><br><span class="line">(<span class="string">"abc"</span>)</span><br><span class="line">user&gt; (assoc nil :a 1)</span><br><span class="line">&#123;<span class="symbol">:a</span> <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>但时不时 nil 就会出来咬你一口。记得之前有这么一个需求，需要对消息的格式做了升级，之前可能是 map/string，升级后只能是 string 并且用 v2 标示，处理的代码需要找出这两类消息，分别处理，代码大致如下</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [&#123;v1-msgs <span class="literal">false</span> v2-msgs <span class="literal">true</span>&#125;</span><br><span class="line">      (<span class="name">group-by</span> #(<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">string?</span></span> %)</span><br><span class="line">                   (<span class="name">.startsWith</span> <span class="comment">^String</span> % <span class="string">"v2:"</span>)) msgs)])</span><br></pre></td></tr></table></figure><p>可以看到，代码很简单，就是判断 msg 是不是字符串，如果是，再看看版本是不是 v2，由于 nil 与 false 是不同的值，导致会丢失一部分数据，正确的写法是这样的：<br><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [&#123;v1-msgs <span class="literal">false</span> v2-msgs <span class="literal">true</span>&#125;</span><br><span class="line">      (<span class="name">group-by</span> #(<span class="name"><span class="builtin-name">boolean</span></span> (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">string?</span></span> %)</span><br><span class="line">                   (<span class="name">.startsWith</span> <span class="comment">^String</span> % <span class="string">"v2:"</span>))) msgs)])</span><br></pre></td></tr></table></figure></p><p>所以这里的一个提醒就是尽量不要让自己的函数返回 nil，而是返回空值，比如空数组、空链表、空字符串等。</p><h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p>future 可以很方便的起一个新线程来工作，但其运行的线程池是无限制的，如果无节制的使用会导致线上服务 oom，这里推荐一个并发的库 <a href="https://github.com/TheClimateCorporation/claypoole" target="_blank" rel="noopener">com.climate/claypoole</a> 可以完美替换 <code>pmap/future/run!</code> 等！</p><h2 id="长期维护-Clojure-项目"><a href="#长期维护-Clojure-项目" class="headerlink" title="长期维护 Clojure 项目"></a>长期维护 Clojure 项目</h2><p>Clojure 作为一门动态语言，同样有“编写爽，维护难”痛点，解决方式也是统一的：完备的测试，外加 lint（代码质量检测）。</p><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>测试这个问题很尴尬，是每个开发者都知道很重要但很少落实到位的一项技能，除了基本的单元测试，还要有覆盖整条链路的黑盒测试，不仅仅测正常的输入，更多的是异常情况。<br>下面说下 Clojure 单元测试开发中会用到的一些技巧：</p><ol><li><a href="https://clojure.github.io/clojure/clojure.test-api.html" target="_blank" rel="noopener">clojure.test</a> 提供了最基本的断言，<a href="https://clojuredocs.org/clojure.test/use-fixtures" target="_blank" rel="noopener">use-fixtures</a> 可以进行一些 setup 与 teardown</li><li><a href="https://clojuredocs.org/clojure.core/with-redefs" target="_blank" rel="noopener">with-redefs</a> 可以去 mock 一些外部依赖的返回</li><li><a href="https://github.com/venantius/ultra/wiki/Tests" target="_blank" rel="noopener">ultra</a> 更直观的测试结果展示</li></ol><h3 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h3><p>Clojure 作为一 Lisp 方言，有非常强的表现力，几行代码就可以干很多事情，为了保证整个团队有统一的编程风格，应该在项目起始阶段，就加上质量检测。<br>Clojure 社区里面，<a href="https://github.com/jonase/eastwood" target="_blank" rel="noopener">eastwood</a> 是一个非常全面的 lint 工具，它帮助我发现了很多程序中肉眼难以识别的错误，成熟 Clojure 程序员必备。</p><h3 id="跟进社区"><a href="#跟进社区" class="headerlink" title="跟进社区"></a>跟进社区</h3><ul><li>Clojure 1.9 引入 <a href="https://clojure.org/news/2017/12/08/clojure19" target="_blank" rel="noopener">spec</a>，尝试来解决一直被初学者诟病的错误信息看不懂的问题</li><li>Clojure 1.10 更进一步，<a href="https://clojure.org/news/2018/12/17/clojure110" target="_blank" rel="noopener">对错误信息进行了分类</a>，适配 Java 9 带来的 module</li></ul><p>除了 Clojure 语言本身外，Lein/JVM 等周边生态链也在不断推进，我们需要及时去了解这些新技术，现在我比较头疼的是下面这两个：</p><ol><li>Lein 在 3.0 大版本中会<a href="https://github.com/technomancy/leiningen/blob/master/doc/PLUGINS.md#hooks" target="_blank" rel="noopener">移除对 hook 的支持</a>，这将会导致很多有用的插件不可用，包括上面推荐的 lein-shorthand</li><li>Java 9 为了支持 module，<a href="https://stackoverflow.com/questions/46494112/classloaders-hierarchy-in-java-9" target="_blank" rel="noopener">改变了 classloader 的行为</a>，导致<a href="https://github.com/clojure-emacs/clj-refactor.el/issues/410" target="_blank" rel="noopener">无法使用 alembic 提供的动态加载依赖</a>的功能，所以目前只能锁定在 Java 8 上</li></ol><h2 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h2><p>Clojure 社区虽小，但不乏高手，通过阅读高手的代码，是熟悉一门语言 idioms 最有效的方式。下面介绍社区内，对我影响最大的三位：</p><h3 id="Nathan-Marz"><a href="#Nathan-Marz" class="headerlink" title="Nathan Marz"></a><a href="http://nathanmarz.com/" target="_blank" rel="noopener">Nathan Marz</a></h3><p>一个非常务实的 coder，文章见解独特、观点新颖。明星项目：</p><ul><li><a href="https://github.com/nathanmarz/storm" target="_blank" rel="noopener">Storm</a> 流式数据框架</li><li><a href="https://github.com/nathanmarz/specter" target="_blank" rel="noopener">Specter</a> 号称 Clojure(Script)’s missing piece，操作复杂数据结构的利器！</li><li><a href="https://www.manning.com/books/big-data" target="_blank" rel="noopener">Big Data: Principles and best practices of scalable realtime data systems</a>，在本书中提出有名的 <a href="https://en.wikipedia.org/wiki/Lambda_architecture" target="_blank" rel="noopener">Lambda 架构</a></li><li><a href="https://github.com/nathanmarz/cascalog" target="_blank" rel="noopener">Cascalog</a> 这是我 2014 年首次接触 Clojure 时用的项目，主要是分析日志。语法借鉴自声明式逻辑语言 <a href="https://en.wikipedia.org/wiki/Datalog" target="_blank" rel="noopener">Datalog</a></li></ul><h3 id="Kyle-Kingsbury-a-k-a-“Aphyr”"><a href="#Kyle-Kingsbury-a-k-a-“Aphyr”" class="headerlink" title="Kyle Kingsbury a.k.a “Aphyr”"></a><a href="https://aphyr.com" target="_blank" rel="noopener">Kyle Kingsbury</a> a.k.a “Aphyr”</h3><p>神人一个，高产 coder。明星项目：</p><ul><li><a href="http://riemann.io/" target="_blank" rel="noopener">Riemann</a> 一个强大的监控系统，具备丰富的<a href="http://riemann.io/api/riemann.streams.html" target="_blank" rel="noopener">数据流操作</a></li><li><a href="https://jepsen.io/" target="_blank" rel="noopener">Jepsen</a> 著名的分布式系统测试框架</li><li><a href="https://aphyr.com/tags/Clojure-from-the-ground-up" target="_blank" rel="noopener">Clojure from the Ground Up</a> 介绍 Clojure 的一系列文章</li><li><a href="https://github.com/aphyr" target="_blank" rel="noopener">https://github.com/aphyr</a> </li></ul><h3 id="Zach-Tellman"><a href="#Zach-Tellman" class="headerlink" title="Zach Tellman"></a><a href="https://ideolalia.com/" target="_blank" rel="noopener">Zach Tellman</a></h3><p>神人另一个，高产 coder，貌似与 Aphyr 共事过</p><ul><li><a href="https://elementsofclojure.com/" target="_blank" rel="noopener">Elements of Clojure</a> This book tries to put words to what most experienced programmers already know</li><li><a href="https://github.com/ztellman" target="_blank" rel="noopener">https://github.com/ztellman</a><br>我目前还没直接使用过 Zach 写的库，这是由于他的库很多都是基本性质的，所以很有极有可能间接引用了他的库，比如 specter 就用了他的 riddley。下面一张图摘自他的博客：<br><img src="https://ideolalia.com/images/libraries.png" alt="Zach&#39;s libraries"></li></ul><p>混 Clojure 社区，应该还会经常看到 Congnitect 公司内的 <a href="https://github.com/richhickey" target="_blank" rel="noopener">Rich</a>/<a href="https://github.com/stuarthalloway" target="_blank" rel="noopener">Stuart Halloway</a>/<a href="https://github.com/puredanger" target="_blank" rel="noopener">Alex Miller</a>/<a href="http://blog.fogus.me/" target="_blank" rel="noopener">Michael Fogus</a>…</p><h2 id="Clojure-工作机会"><a href="#Clojure-工作机会" class="headerlink" title="Clojure 工作机会"></a>Clojure 工作机会</h2><p>首先明确一点，语言只是工具，而只会工具是找不到工作的，很多初学 Clojure 的同学都有这个误区。打个比方：一个厨师的刀工非常好，但是不知道如何去做菜（领域知识），有什么用呢？</p><p>比如，做 Web 开发，那对 HTTP 了解多少？ TCP/UDP 区别是什么？Mysql 锁有几种？这些都是必须的。再进一步，JVM 上的 gc 懂吗？多线程用过没？linux 上如何排除进程相关信息？</p><p>有了以上基础，我们也不得不承认，使用 Clojure 作为主力开发语言的公司确实少，但也不是没有，比如：北京的 LeanCloud/BearyChat、深圳的 <a href="https://www.bagevent.com/event/1760284" target="_blank" rel="noopener">风林火山</a> 。<br>即使工作中无法使用，了解这门优雅、富有表现力的语言来扩展自己的眼界，也是不错的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从 14 年实习期间接触 Clojure，到现在 19 年差不多 5 年了，学到了太多太多东西，一方面是编程语言的设计，另一方面是后端开发的整个体系。坊间甚至一度传闻 <a href="https://news.ycombinator.com/item?id=14418013" target="_blank" rel="noopener">Clojure is dead</a>。<br>Clojure 不是银弹，肯定是有一些瑕疵，但这并不妨碍它是一门优秀的语言，虽然我现在工作中用不到它了，但是业余时间肯定还是会去研究它，社区有太多有意思的项目了。<br>希望新入门的同学可以坚持下去，早日体味到 Clojure 的乐趣。加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大概在两年半前，我开始陆陆续续写了&lt;a href=&quot;/tags/Clojure/&quot;&gt;一系列文章&lt;/a&gt;，来介绍如何上手、深入 Clojure，后来有幸加入 LeanCloud 写了两年的 Clojure，期间制作了一套&lt;a href=&quot;https://github.com/
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Java 垃圾回收权威指北</title>
    <link href="http://liujiacai.net/blog/2019/01/09/java-gc-definitive-guide/"/>
    <id>http://liujiacai.net/blog/2019/01/09/java-gc-definitive-guide/</id>
    <published>2019-01-09T12:14:54.000Z</published>
    <updated>2019-12-24T10:59:14.614Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，GC（垃圾回收） 已经是现代编程语言标配，为了研究这个方向之前曾经写过四篇<a href="/blog/2018/06/15/garbage-collection-intro/">《深入浅出垃圾回收》</a>博文来介绍其理论，之后也看了不少网络上关于 JDK GC 原理、优化的文章，质量参差不齐，其中理解有误的文字以讹传讹，遍布各地，更是把初学者弄的晕头转向。<br>不仅仅是个人开发者的文章，一些<a href="https://engineering.linkedin.com/garbage-collection/garbage-collection-optimization-high-throughput-and-low-latency-java-applications" target="_blank" rel="noopener">大厂的官博</a>也有错误。<br>本文在实验+阅读 openjdk 源码的基础上，整理出一份相对来说比较靠谱的资料，供大家参考。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>为方便理解 GC 算法时，需要先介绍一些常见的名词</p><ul><li>mutator，应用程序的线程</li><li>collector，用于进行垃圾回收的线程</li><li>concurrent（并发），指 collector 与 mutator 可以并发执行</li><li>parallel（并行），指 collector 是多线程的，可以利用多核 CPU 工作</li><li>young/old(也称Tenured) 代，根据大多数对象“朝生夕死”的特点，现代 GC 都是分代</li></ul><p>一个 gc 算法可以同时具有 concurrent/parallel 的特性，或者只具有一个。</p><h3 id="JDK-版本"><a href="#JDK-版本" class="headerlink" title="JDK 版本"></a>JDK 版本</h3><ul><li>HotSpot 1.8.0_172</li><li><a href="https://openjdk.java.net/projects/jdk8u/" target="_blank" rel="noopener">openjdk8u</a>（changeset: 2298:1c0d5a15ab4c）</li></ul><p>为了方便查看当前版本 JVM 支持的选项，建议配置下面这个 alias</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> jflags=<span class="string">'java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version'</span></span><br></pre></td></tr></table></figure><p>然后就可以用 <code>jflags | grep XXX</code> 的方式来定位选项与其默认值了。</p><h3 id="打印-GC-信息"><a href="#打印-GC-信息" class="headerlink" title="打印 GC 信息"></a>打印 GC 信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-Xloggc:/data/logs/gc-%t.log</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCCause</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:NumberOfGCLogFiles=10</span><br><span class="line">-XX:GCLogFileSize=50M</span><br><span class="line">-XX:+PrintPromotionFailure</span><br></pre></td></tr></table></figure><h2 id="JDK-中支持的-GC"><a href="#JDK-中支持的-GC" class="headerlink" title="JDK 中支持的 GC"></a>JDK 中支持的 GC</h2><p>Java 8 中默认集成了哪些 GC 实现呢？ jflags 可以告诉我们</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jflags |  grep <span class="string">"Use.*GC"</span></span><br><span class="line">     bool UseAdaptiveGCBoundary                     = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizeDecayMajorGCCost           = <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizePolicyWithSystemGC         = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseAutoGCSelectPolicy                     = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseConcMarkSweepGC                        = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseDynamicNumberOfGCThreads               = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseG1GC                                   = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseGCLogFileRotation                      = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseGCOverheadLimit                        = <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     bool UseGCTaskAffinity                         = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseMaximumCompactionOnSystemGC            = <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     bool UseParNewGC                               = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseParallelGC                             = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseParallelOldGC                          = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseSerialGC                               = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">java version <span class="string">"1.8.0_172"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_172-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.172-b11, mixed mode)</span><br></pre></td></tr></table></figure><p>肉眼筛选下，就知道有如下几个相关配置：</p><ul><li>UseSerialGC</li><li>UseParNewGC，</li><li>UseParallelGC</li><li>UseParallelOldGC</li><li>UseConcMarkSweepGC</li><li>UseG1GC</li></ul><p>每个配置项都会对应两个 collector ，表示对 young/old 的不同收集方式。而且由于 JVM 不断的演化，不同 collector 的组合方式其实很复杂。而且在 Java 7u4 后，UseParallelGC 与 UseParallelOldGC 其实是等价的，openjdk 中有如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/runtime/arguments.cpp#set_gc_specific_flags</span></span><br><span class="line"><span class="comment">// Set per-collector flags</span></span><br><span class="line"><span class="keyword">if</span> (UseParallelGC || UseParallelOldGC) &#123;</span><br><span class="line">  set_parallel_gc_flags();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (UseConcMarkSweepGC) &#123; <span class="comment">// Should be done before ParNew check below</span></span><br><span class="line">  set_cms_and_parnew_gc_flags();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (UseParNewGC) &#123;  <span class="comment">// Skipped if CMS is set above</span></span><br><span class="line">  set_parnew_gc_flags();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (UseG1GC) &#123;</span><br><span class="line">  set_g1_gc_flags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用<a href="https://stackoverflow.com/a/19837515/2163429" target="_blank" rel="noopener">下面的代码</a>测试使用不同配置时，young/old 代默认所使用的 collector：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gc;</span><br><span class="line"><span class="comment">// 省略 import 语句</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhichGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;GarbageCollectorMXBean&gt; gcMxBeans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line">            <span class="keyword">for</span> (GarbageCollectorMXBean gcMxBean : gcMxBeans) &#123;</span><br><span class="line">                System.out.println(gcMxBean.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            System.err.println(exp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ java gc.WhichGC  <span class="comment"># 两个输出分别表示 young/old 代的 collector</span></span><br><span class="line">PS Scavenge</span><br><span class="line">PS MarkSweep</span><br><span class="line"></span><br><span class="line">$ java -XX:+UseSerialGC gc.WhichGC</span><br><span class="line">Copy</span><br><span class="line">MarkSweepCompact</span><br><span class="line"></span><br><span class="line">$ java -XX:+UseParNewGC gc.WhichGC <span class="comment"># 注意提示</span></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed <span class="keyword">in</span> a future release</span><br><span class="line">ParNew</span><br><span class="line">MarkSweepCompact</span><br><span class="line"></span><br><span class="line">$ java -XX:+UseParallelGC gc.WhichGC</span><br><span class="line">PS Scavenge</span><br><span class="line">PS MarkSweep <span class="comment"># 虽然名为 MarkSweep，但其实现是 mark-sweep-compact</span></span><br><span class="line"></span><br><span class="line">$ java -XX:+UseParallelOldGC gc.WhichGC <span class="comment"># 与上面输出一致，不加 flag 时这样同样的输出</span></span><br><span class="line">PS Scavenge</span><br><span class="line">PS MarkSweep</span><br><span class="line"></span><br><span class="line">$ java -XX:+UseConcMarkSweepGC gc.WhichGC <span class="comment"># ParNew 中 Par 表示 parallel，表明采用并行方式收集 young 代</span></span><br><span class="line">ParNew</span><br><span class="line">ConcurrentMarkSweep  <span class="comment"># 注意这里没有 compact 过程，也就是说 CMS 的 old 可能会产生碎片</span></span><br><span class="line"></span><br><span class="line">$ java -XX:+UseG1GC gc.WhichGC</span><br><span class="line">G1 Young Generation</span><br><span class="line">G1 Old Generation</span><br></pre></td></tr></table></figure><p>PS 开头的系列 collector 是 Java5u6 开始引入的。按照 <a href="https://hllvm-group.iteye.com/group/topic/27629" target="_blank" rel="noopener">R 大的说法</a>，这之前的 collector 都是在一个框架内开发的，所以 young/old 代的 collector 可以任意搭配，但 PS 系列与后来的 G1 不是在这个框架内的，所以只能单独使用。</p><p>使用 UseSerialGC 时 young 代的 collector 是 Copy，这是单线程的，PS Scavenge 与 ParNew 分别对其并行化，至于这两个并行 young 代 collector 的区别呢？这里再引用 <a href="https://hllvm-group.iteye.com/group/topic/37095#post-242695" target="_blank" rel="noopener">R 大的回复</a>：</p><ol><li>PS以前是广度优先顺序来遍历对象图的，JDK6的时候改为默认用深度优先顺序遍历，并留有一个UseDepthFirstScavengeOrder参数来选择是用深度还是广度优先。在JDK6u18之后这个参数被去掉，PS变为只用深度优先遍历。ParNew则是一直都只用广度优先顺序来遍历 </li><li>PS完整实现了adaptive size policy，而ParNew及“分代式GC框架”内的其它GC都没有实现完（倒不是不能实现，就是麻烦+没人力资源去做）。所以千万千万别在用ParNew+CMS的组合下用UseAdaptiveSizePolicy，请只在使用UseParallelGC或UseParallelOldGC的时候用它。 </li><li>由于在“分代式GC框架”内，ParNew可以跟CMS搭配使用，而ParallelScavenge不能。当时ParNew GC被从Exact VM移植到HotSpot VM的最大原因就是为了跟CMS搭配使用。 </li><li>在PS成为主要的throughput GC之后，它还实现了针对NUMA的优化；而ParNew一直没有得到NUMA优化的实现。 </li></ol><p>如果你对上面所说的 mark/sweep/compact 这些名词不了解，建议参考下面这篇文章：</p><ul><li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations" target="_blank" rel="noopener">https://plumbr.io/handbook/garbage-collection-algorithms-implementations</a></li></ul><p>其实原理很简单，和我们整理抽屉差不多，找出没用的垃圾，丢出去，然后把剩下的堆一边去。但是别忘了</p><blockquote><p>The evil always comes from details!</p></blockquote><p>怎么定义「没用」？丢垃圾时还允不允许同时向抽屉里放新东西？如果允许放，怎么区别出来，以防止被误丢？抽屉小时，一个人整理还算快，如果抽屉很大，多个人怎么协作？</p><h2 id="核心流程指北"><a href="#核心流程指北" class="headerlink" title="核心流程指北"></a>核心流程指北</h2><h3 id="ParallelGC"><a href="#ParallelGC" class="headerlink" title="ParallelGC"></a>ParallelGC</h3><p>SerialGC 采用的收集方式十分简单，没有并行、并发，一般用在资源有限的设备中。由于其简单，对其也没什么好说的，毕竟也没怎么用过 :-)<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html" target="_blank" rel="noopener">ParallelGC</a> 相比之下，使用多线程来回收，这就有些意思了，比如</p><ul><li>多个GC线程如何实现同步，需要注意一点，ParallelGC 运行时会 STW，因此不存在与 mutator 同步问题</li><li>回收时，并行度如何选择（也就是 GC 对应用本身的 overhead）</li></ul><p>凭借仅有的 cpp 知识，大略扫一下 <code>parNewGeneration.cpp</code> 这个文件，大概是这样实现多个 GC 线程同步的：</p><blockquote><p>每个 GC 线程对应一个 queue（叫 ObjToScanQueue），然后还支持不同 GC 线程间 steal，保证充分利用 cpu</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParNewGeneration 构造方法</span></span><br><span class="line"><span class="keyword">for</span> (uint i1 = <span class="number">0</span>; i1 &lt; ParallelGCThreads; i1++) &#123;</span><br><span class="line">  ObjToScanQueue *q = <span class="keyword">new</span> ObjToScanQueue();</span><br><span class="line">  guarantee(q != <span class="literal">NULL</span>, <span class="string">"work_queue Allocation failure."</span>);</span><br><span class="line">  _task_queues-&gt;register_queue(i1, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do_void 方法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// We have no local work, attempt to steal from other threads.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// attempt to steal work from promoted.</span></span><br><span class="line">  <span class="keyword">if</span> (task_queues()-&gt;steal(par_scan_state()-&gt;thread_num(),</span><br><span class="line">                           par_scan_state()-&gt;hash_seed(),</span><br><span class="line">                           obj_to_scan)) &#123;</span><br><span class="line">    <span class="keyword">bool</span> res = work_q-&gt;push(obj_to_scan);</span><br><span class="line">    assert(res, <span class="string">"Empty queue should have room for a push."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   if successful, goto Start.</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try global overflow list.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (par_gen()-&gt;take_from_overflow_list(par_scan_state())) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面还是重点说一下我们开发者能控制的选项，</p><ul><li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code> 应用停顿（STW）的的最大时间</li><li><code>-XX:GCTimeRatio=&lt;N&gt;</code>  GC 时间占整个应用的占比，默认 99。需要注意的是，它是这么用的 <code>1/(1+N)</code>，即默认 GC 占应用时间 1%。这么说来这个选项的意思貌似正好反了！<br>其实不仅仅是这个，类似的还有 <code>NewRatio</code> <code>SurvivorRatio</code>，喜欢八卦的可以看看<a href="http://yoroto.io/wo-ke-neng-zai-pao-yi-ge-jia-gc/" target="_blank" rel="noopener">《我可能在跑一个假GC》</a></li></ul><p>当然，上面两个指标是软限制，GC 会采用后面提到的自适应策略（Ergonomics）来调整 young/old 代大小来满足。</p><h4 id="Ergonomics"><a href="#Ergonomics" class="headerlink" title="Ergonomics"></a>Ergonomics</h4><p>每次 gc 后，会记录一些统计信息，比如 pause time，然后根据这些信息来决定</p><ol><li>目标是否满足</li><li>是否需要调整代大小</li></ol><p>可以通过 <code>-XX:AdaptiveSizePolicyOutputInterval=N</code> 来打印出每次的调整，N 表示每隔 N 次 GC 打印。<br>默认情况下，一个代增长或缩小是按照固定百分比，这样有助于达到指定大小。默认增加以 20% 的速率，缩小以 5%。也可以自己设定<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:YoungGenerationSizeIncrement=&lt;Y&gt;</span><br><span class="line">-XX:TenuredGenerationSizeIncrement=&lt;T&gt;</span><br><span class="line">-XX:AdaptiveSizeDecrementScaleFactor=&lt;D&gt;</span><br><span class="line"><span class="comment"># 如果增长的增量是 X，那么减少的减量则为 X/D</span></span><br></pre></td></tr></table></figure></p><p>当然，一般情况下是不需要自己设置这三个值的，除非你有明确理由。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>ParallelGC 另一个名字就表明了它的用途：吞吐量 collector。主要用在对延迟要求低，更看重吞吐量的应用上。<br>我们公司的数据导入导出、跑报表的定时任务，用的就是这个 GC。（能提供数据导入导出的都是良心公司呀！）<br>一般利用自适应策略就能满足需求。线上的日志大概这样子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">2018-12-27T22:14:19.006+0800: 5433.841: [GC (Allocation Failure) [PSYoungGen: 606785K-&gt;3041K(656896K)] 746943K-&gt;143356K(2055168K), 0.0157837 secs] [Times: user=0.03 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.02         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:21:36.581+0800: 5871.417: [GC (Allocation Failure) [PSYoungGen: 615905K-&gt;3089K(654848K)] 756220K-&gt;143504K(2053120K), 0.0157796 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:28:51.669+0800: 6306.505: [GC (Allocation Failure) [PSYoungGen: 615953K-&gt;3089K(660992K)] 756368K-&gt;143664K(2059264K), 0.0178418 secs] [Times: user=0.03 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:36:17.738+0800: 6752.573: [GC (Allocation Failure) [PSYoungGen: 624145K-&gt;2896K(658944K)] 764720K-&gt;143576K(2057216K), 0.0144179 secs] [Times: user=0.02 sys=0.01, real=0.01 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:43:40.208+0800: 7195.043: [GC (Allocation Failure) [PSYoungGen: 623952K-&gt;2976K(665088K)] 764632K-&gt;143720K(2063360K), 0.0135656 secs] [Times: user=0.03 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:48:59.110+0800: 7513.945: [GC (Allocation Failure) [PSYoungGen: 632224K-&gt;5393K(663040K)] 772968K-&gt;146241K(2061312K), 0.0230613 secs] [Times: user=0.05 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:54:05.871+0800: 7820.706: [GC (Allocation Failure) [PSYoungGen: 634641K-&gt;4785K(669696K)] 775489K-&gt;147601K(2067968K), 0.0173448 secs] [Times: user=0.04 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br></pre></td></tr></table></figure><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS 相比于 ParallelGC，支持并发式的回收，虽然个别环节还是需要 STW，但相比之前已经小了很多；另一点不同是 old 代在 sweep 后，没有 compact 过程，而是通过 freelist 来将空闲地址串起来。CMS 具体流程还是参考下面的文章：</p><ul><li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep" target="_blank" rel="noopener">https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep</a></li></ul><p>上述文章会针对 gc 日志里面的每行含义做解释，务必弄清楚每一个数字含义，这是今后调试优化的基础。网站找了个<a href="http://fengfu.io/2016/06/21/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8CMS%E4%B9%8B%E5%90%84%E9%98%B6%E6%AE%B5%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">比较详细的图</a>供大家参考：</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01eiAx891z69sKEdsdy_!!581166664.jpg" alt="CMS 工作流程示意图"></p><p>之前在有赞的同事阿杜写过一篇<a href="https://www.jianshu.com/p/78017c8b8e0f" target="_blank" rel="noopener">《不可错过的CMS学习笔记》</a> 推荐大家看看，主要是文章的思路比较欣赏，带着问题去探索。这里重申下 CMS 的特点：</p><ul><li>CMS 作用于 old 区，与 mutator 并发执行（因为是多线程的，所以也是并行的）；默认与 young 代 ParNew 算法一起工作</li></ul><p>下面重点介绍以下三点：</p><ul><li>误传最广的 CMF</li><li>影响最为严重的内存碎片问题</li><li>最被忽视的 Abortable Preclean</li></ul><h4 id="Concurrent-mode-failure"><a href="#Concurrent-mode-failure" class="headerlink" title="Concurrent mode failure"></a>Concurrent mode failure</h4><p>在每次 young gc 开始前，collector 都需要确保 old 代有足够的空间来容纳新晋级的对象（通过之前GC的统计估计），如果判断不足，或者当前判断足够，但是真正晋级对象时空间不够了（即发生 Promotion failure），那么就会发生 Concurrent mode failure（后面简写 CMF），CMF 发生时，不一定会进行 Full GC，而是这样的：</p><blockquote><p>如果这时 CMS 会正在运行，则会被中断，然后根据 UseCMSCompactAtFullCollection、CMSFullGCsBeforeCompaction 和当前收集状态去决定后面的行为</p></blockquote><p>有两种选择：</p><ol><li>使用跟Serial Old GC一样的LISP2算法的mark-compact来做 Full GC，或</li><li>用CMS自己的mark-sweep来做不并发的（串行的）old generation GC （这种串行的模式在 openjdk 中称为 foreground collector，与此对应，并发模型的 CMS 称为 background collector）</li></ol><p>UseCMSCompactAtFullCollection默认为true，CMSFullGCsBeforeCompaction默认是0，这样的组合保证CMS默认不使用foreground collector，而是用Serial Old GC的方式来进行 Full GC，而且在 JDK9 中，彻底去掉了这两个参数以及 foreground GC 模式，具体见：<a href="https://bugs.openjdk.java.net/browse/JDK-8010202" target="_blank" rel="noopener">JDK-8010202: Remove CMS foreground collection</a>，所以这两个参数就不需要再去用了。</p><p>这里还需要注意，上述两个备选策略的异同，它们所采用的算法与作用范围均不同：</p><ol><li>Serial Old GC的算法是mark-compact（也可以叫做mark-sweep-compact，但要注意它不是“mark-sweep”）。具体算法名是LISP2。它收集的范围是整个GC堆，包括Java heap的young generation和old generation，以及non-Java heap的permanent generation。因而其名 Full GC</li><li>CMS的foreground collector的算法就是普通的mark-sweep。它收集的范围只是CMS的old generation，而不包括其它generation。因而它在HotSpot VM里不叫做Full GC</li></ol><p>这里大家可能会有疑问，既然能够用多线程方式去进行 Full GC（比如 ParallelGC），那么 CMS 在降级时却采用了 Serial 的方式呢？从 <a href="https://bugs.openjdk.java.net/browse/JDK-8130200" target="_blank" rel="noopener">JDK-8130200</a> 里可以略知端倪，大概是这样的：</p><blockquote><p>Google 的开发人员实现了多线程版本的 Full GC，然后在 2015 年给 openjdk 提了个 PR，但是这个 PR 一直没人理，根据<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-dev/2015-June/thread.html#13649" target="_blank" rel="noopener">邮件列表</a>来看，主要是 CMS 没有 leader maintainer 了，其他 maintainer 又怕这个改动太大，带来今后巨大的维护成本，就一直没合这个 PR，再后来 G1 出来了，这个 PR 就更不受人待见了</p></blockquote><p>解决 CMF 的方式，一般是尽早执行 CMS，可以通过下面两个参数设置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=60</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br></pre></td></tr></table></figure><p>上述两个参数缺一不可，第一个表示 old 区占用量超过 60% 时开始执行 CMS，第二个参数禁用掉 JVM 的自适应策略，如果不设置这个 JVM 可能会忽略第一个参数。</p><p>此外，除了 CMF 能触发 Full GC 外，<code>System.gc()</code> 的方式也能触发，不过 CMS 有个选项，可以将这个单线程的 Full GC 转化为 CMS 并发收集过程，一般建议打开：<code>-XX:+ExplicitGCInvokesConcurrent</code>。</p><p>上述关于 CMF 解释主要参考</p><ul><li><a href="https://hllvm-group.iteye.com/group/topic/42365" target="_blank" rel="noopener">R 大的这个帖子</a></li><li><a href="http://blog.ragozin.info/2011/10/java-cg-hotspots-cms-and-heap.html" target="_blank" rel="noopener">http://blog.ragozin.info/2011/10/java-cg-hotspots-cms-and-heap.html</a></li><li>自己的消化吸收，如果有误肯定是我的（请留言指出），与 <a href="https://www.zhihu.com/question/48973999" target="_blank" rel="noopener">R 大</a>无关</li></ul><h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>Promotion failure 一般是由于 heap 内存碎片过多导致检测空间足够，但是真正晋级时却没有足够连续的空间，监控 old 代碎片可以用下面的选项</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintPromotionFailure</span><br><span class="line">-XX:PrintFLSStatistics=1</span><br></pre></td></tr></table></figure><p>这时的 gc 日志大致是这样的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">592.079: [ParNew (0: promotion failure size = 2698)  (promotion failed): 135865K-&gt;134943K(138240K), 0.1433555 secs]</span><br><span class="line">Statistics <span class="keyword">for</span> BinaryTreeDictionary:</span><br><span class="line">------------------------------------</span><br><span class="line">Total Free Space: 40115394</span><br><span class="line">Max   Chunk Size: 38808526</span><br><span class="line">Number of Blocks: 1360</span><br><span class="line">Av.  Block  Size: 29496</span><br><span class="line">Tree      Height: 22</span><br></pre></td></tr></table></figure><p>重点是 Max Chunk Size 这个参数，如果这个值一直在减少，那么说明碎片问题再加剧。解决碎片问题可以按照下面步骤：</p><ol><li>尽可能提供较大的 old 空间，但是最好不要超过 32G，<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html#compressed_oops" target="_blank" rel="noopener">超过了就没法用压缩指针了</a>。</li><li>尽早执行 CMS，即修改  initiating occupancy 参数</li><li>减少 PLAB，我具体还没试过，可参考 <a href="http://blog.ragozin.info/2011/11/java-gc-hotspots-cms-promotion-buffers.html" target="_blank" rel="noopener">Java GC, HotSpot’s CMS promotion buffers</a> 这篇文章</li><li>应用尽量不要去分配巨型对象</li></ol><h4 id="Abortable-Preclean"><a href="#Abortable-Preclean" class="headerlink" title="Abortable Preclean"></a>Abortable Preclean</h4><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01iVE4uz1z69sCiXptB_!!581166664.png" alt="ParallelGC vs CMS 工作流程"><br>根据上图重新回顾下 CMS 工作流程。Openjdk 内部通过 <code>_collectorState</code> 这个变量实现不同状态的转变（采用状态机设计模式），在 <code>collect_in_background</code> 方法内有个大 switch 进行转化，对应的 case 顺序即为状态机转化顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrentMarkSweepGeneration.cpp#collect_in_background</span></span><br><span class="line"><span class="keyword">while</span> (_collectorState != Idling) &#123;</span><br><span class="line">   ....</span><br><span class="line">  <span class="keyword">switch</span> (_collectorState) &#123;</span><br><span class="line">    <span class="keyword">case</span> InitialMarking:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">ReleaseForegroundGC <span class="title">x</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        stats().record_cms_begin();</span><br><span class="line">        <span class="function">VM_CMS_Initial_Mark <span class="title">initial_mark_op</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        VMThread::execute(&amp;initial_mark_op);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The collector state may be any legal state at this point</span></span><br><span class="line">      <span class="comment">// since the background collector may have yielded to the</span></span><br><span class="line">      <span class="comment">// foreground collector.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Marking:</span><br><span class="line">      <span class="comment">// initial marking in checkpointRootsInitialWork has been completed</span></span><br><span class="line">      <span class="keyword">if</span> (markFromRoots(<span class="literal">true</span>)) &#123; <span class="comment">// we were successful</span></span><br><span class="line">        assert(_collectorState == Precleaning, <span class="string">"Collector state should "</span></span><br><span class="line">          <span class="string">"have changed"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(_foregroundGCIsActive, <span class="string">"Internal state inconsistency"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Precleaning:</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_precleaning_begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// marking from roots in markFromRoots has been completed</span></span><br><span class="line">      preclean();</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_precleaning_end();</span><br><span class="line">      &#125;</span><br><span class="line">      assert(_collectorState == AbortablePreclean ||</span><br><span class="line">             _collectorState == FinalMarking,</span><br><span class="line">             <span class="string">"Collector state should have changed"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AbortablePreclean:</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">      size_policy()-&gt;concurrent_phases_resume();</span><br><span class="line">      &#125;</span><br><span class="line">      abortable_preclean();</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_precleaning_end();</span><br><span class="line">      &#125;</span><br><span class="line">      assert(_collectorState == FinalMarking, <span class="string">"Collector state should "</span></span><br><span class="line">        <span class="string">"have changed"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FinalMarking:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">ReleaseForegroundGC <span class="title">x</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">VM_CMS_Final_Remark <span class="title">final_remark_op</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        VMThread::execute(&amp;final_remark_op);</span><br><span class="line">      &#125;</span><br><span class="line">      assert(_foregroundGCShouldWait, <span class="string">"block post-condition"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Sweeping:</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_sweeping_begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// final marking in checkpointRootsFinal has been completed</span></span><br><span class="line">      sweep(<span class="literal">true</span>);</span><br><span class="line">      assert(_collectorState == Resizing, <span class="string">"Collector state change "</span></span><br><span class="line">        <span class="string">"to Resizing must be done under the free_list_lock"</span>);</span><br><span class="line">      _full_gcs_since_conc_gc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Stop the timers for adaptive size policy for the concurrent phases</span></span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_sweeping_end();</span><br><span class="line">        size_policy()-&gt;concurrent_phases_end(gch-&gt;gc_cause(),</span><br><span class="line">                                           gch-&gt;prev_gen(_cmsGen)-&gt;capacity(),</span><br><span class="line">                                           _cmsGen-&gt;<span class="built_in">free</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Resizing: &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Resetting:</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Idling:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      ShouldNotReachHere();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面有 Precleaning 与 AbortablePreclean 两个状态，他们底层都是调用 <code>preclean_work</code> 进行具体工作，区别只是 </p><ul><li>precleaning 阶段只执行一次，而 AbortablePreclean 是个迭代执行的过程，直到某个条件不成立。先看看 AbortablePreclean 阶段受哪些条件限制，再来介绍 preclean_work 里面做的具体事情。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrentMarkSweepGeneration.cpp#abortable_preclean()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get_eden_used() &gt; CMSScheduleRemarkEdenSizeThreshold) &#123;</span><br><span class="line">  <span class="keyword">size_t</span> loops = <span class="number">0</span>, workdone = <span class="number">0</span>, cumworkdone = <span class="number">0</span>, waited = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!(should_abort_preclean() ||</span><br><span class="line">           ConcurrentMarkSweepThread::should_terminate())) &#123;</span><br><span class="line">    workdone = preclean_work(CMSPrecleanRefLists2, CMSPrecleanSurvivors2);</span><br><span class="line">    cumworkdone += workdone;</span><br><span class="line">    loops++;</span><br><span class="line">    <span class="comment">// Voluntarily terminate abortable preclean phase if we have</span></span><br><span class="line">    <span class="comment">// been at it for too long.</span></span><br><span class="line">    <span class="keyword">if</span> ((CMSMaxAbortablePrecleanLoops != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        loops &gt;= CMSMaxAbortablePrecleanLoops) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PrintGCDetails) &#123;</span><br><span class="line">        gclog_or_tty-&gt;print(<span class="string">" CMS: abort preclean due to loops "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pa.wallclock_millis() &gt; CMSMaxAbortablePrecleanTime) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PrintGCDetails) &#123;</span><br><span class="line">        gclog_or_tty-&gt;print(<span class="string">" CMS: abort preclean due to time "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we are doing little work each iteration, we should</span></span><br><span class="line">    <span class="comment">// take a short break.</span></span><br><span class="line">    <span class="keyword">if</span> (workdone &lt; CMSAbortablePrecleanMinWorkPerIteration) &#123;</span><br><span class="line">      <span class="comment">// Sleep for some time, waiting for work to accumulate</span></span><br><span class="line">      stopTimer();</span><br><span class="line">      cmsThread()-&gt;wait_on_cms_lock(CMSAbortablePrecleanWaitMillis);</span><br><span class="line">      startTimer();</span><br><span class="line">      waited++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (PrintCMSStatistics &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    gclog_or_tty-&gt;print(<span class="string">" [%d iterations, %d waits, %d cards)] "</span>,</span><br><span class="line">                        loops, waited, cumworkdone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件包括下面几个：</p><ol><li>首先要 eden 大于 CMSScheduleRemarkEdenSizeThreshold（默认 2M）时才继续</li><li>下面的 while 里面条件主要是为了与 foregroundGC 做同步用的，这里可以先忽略</li><li>while 后面的第一个 if 表示这个阶段执行的次数小于 CMSMaxAbortablePrecleanLoops 时才继续，由于这个值默认为 0，所以默认不会进入这个分支</li><li>紧接着的那个 if 表示这个阶段的运行时间不能大于 CMSMaxAbortablePrecleanTime，默认是 5s</li></ol><p>好了，上面就是 abortable preclean 迭代执行的条件，任意一个不满足即会转到下一个状态。<br>下面介绍 <code>preclean_work</code> 里做的事情，主要包含两个：</p><ol><li>根据 card marking 状态，重新 mark 在 concurrent mark 阶段，mutator 又有访问的对象<br><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN012DBLER1z69sHf5zR6_!!581166664.png" alt="preclean 执行前 card mark 以及对象 live mark 状态"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01Rdi6pg1z69sIciHq8_!!581166664.png" alt="preclean 执行后 card mark 以及对象 live mark 状态"></li><li>对 eden 进行抽样（sample），把 eden 划分成大小相近的 chunk ，且每个 chunk 的起始地址都是对象的起始地址。</li></ol><p>把 eden 划分成不同 chunk 主要是为了方便后面的 remark 阶段并发执行。试想一下，如果 remark 阶段以多线程的方式重新 mark 被 mutator 访问的对象，势必要将 eden 划分为不同区域，然后不同区域由不同的线程去 mark，这里的区域就是 chunk。这个抽样过程主要是保证不同 chunk 大小一致，这样不同线程的工作量就均匀了。根据<a href="http://hiroshiyamauchi.blogspot.com/2013/08/parallel-initial-mark-and-more-parallel.html" target="_blank" rel="noopener">这个功能作者测试</a>，这个抽样使得 remark 阶段的 STW 由 500ms 减到 100ms</p><p>不过这个抽样阶段，也可能发生在 ParNew 过程中，是由 CMSEdenChunksRecordAlways 这个选项控制的，而且默认是 true，表示 preclean 阶段不对 eden 进行抽样，而是在 ParNew 运行时抽样，相关代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrentMarkSweepGeneration.cpp </span></span><br><span class="line"><span class="comment">// preclean_work 会调用 sample_eden，但是这里的 !CMSEdenChunksRecordAlways 默认为 false</span></span><br><span class="line"><span class="comment">// 所以这里不会进行抽样</span></span><br><span class="line"><span class="keyword">void</span> CMSCollector::sample_eden() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_eden_chunk_array != <span class="literal">NULL</span> &amp;&amp; !CMSEdenChunksRecordAlways) &#123;</span><br><span class="line">    ...... <span class="keyword">do</span> sample</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defNewGeneration.cpp#allocate() </span></span><br><span class="line">  HeapWord* result = eden()-&gt;par_allocate(word_size);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (CMSEdenChunksRecordAlways &amp;&amp; _next_gen != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里会调用 concurrentMarkSweepGeneration 里的 sample_eden_chunk</span></span><br><span class="line">      _next_gen-&gt;sample_eden_chunk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// concurrentMarkSweepGeneration.cpp </span></span><br><span class="line"><span class="keyword">void</span> CMSCollector::sample_eden_chunk() &#123;</span><br><span class="line">  <span class="comment">// 默认会在这里进行抽样</span></span><br><span class="line">  <span class="keyword">if</span> (CMSEdenChunksRecordAlways &amp;&amp; _eden_chunk_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ..... <span class="keyword">do</span> sample</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>说到优化，让很多人望而却步，一方便有人不断在说“不要过早优化”，另一方面在真正有问题时，不知道如何入手。这里介绍我自己的一些经验供大家参考。</p><p>既然提到 GC 优化，首先要明确衡量 GC 的几个指标，LinkedIn 在这方面值得借鉴，在 <a href="https://engineering.linkedin.com/26/tuning-java-garbage-collection-web-services" target="_blank" rel="noopener">Tuning Java Garbage Collection for Web Services</a> 提出了从 gc 日志中可以获知的 5 个指标：</p><ol><li>Allocation Rate: the size of the young generation divided by the time between young generation collections</li><li>Promotion Rate: the change in usage of the old gen over time (excluding collections)</li><li>Survivor Death Ratio: when looking at a log, the size of survivors in age N divided by the size of survivors in age N-1 in the previous collection</li><li>Old Gen collection times: the total time between a CMS-initial-mark and the next CMS-concurrent-reset. You’ll want both your ‘normal’ and the maximum observed</li><li>Young Gen collection times: both normal and maximum. These are just the “total collection time” entries in the logs Old Gen Buffer: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the promotion rate*the maximum Old Gen collection time*(1 + a little bit)</span><br></pre></td></tr></table></figure></li></ol><p>直接从纯文本的 gc 日志中得出这 5 项指标比较困难，还好有个比较好用的开源工具 <a href="https://github.com/dmart28/gcplot" target="_blank" rel="noopener">gcplot</a>，借助 docker，一行命令即可启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 gcplot/gcplot</span><br></pre></td></tr></table></figure><p>如果发现 gcplot 里面的指标不符合你的预期，那就可以根据所使用 GC 算法的特点进行优化了。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>利用 gcplot，我对公司内部 API 服务（使用 CMS）进行了一次优化，效果较为明显：</p><p>优化前的配置：Xmx/Xms 均为 4G，CMSInitiatingOccupancyFraction=60，下面是使用 gcplot 得到的一些数据</p><table><thead><tr><th>Percentiles</th><th>STW Pause (ms)</th></tr></thead><tbody><tr><td>50%</td><td>22.203</td></tr><tr><td>90%</td><td>32.872</td></tr><tr><td>95%</td><td>40.255</td></tr><tr><td>99%</td><td>76.724</td></tr><tr><td>99.9%</td><td>317.584</td></tr></tbody></table><ul><li>STW Pause per Minute: 3.396 secs</li><li>STW Events per Minute: 133</li></ul><table><thead><tr><th>Promoted Total</th><th>17.313 GB</th></tr></thead><tbody><tr><td>Promotion Rate (MB/Sec)</td><td>5.99</td></tr><tr><td>Allocated Total</td><td>5.053 TB</td></tr><tr><td>Allocation Rate (MB/Sec)</td><td>1273.73</td></tr></tbody></table><p>优化后的配置：Xmx/Xms 均为 4G, NewRatio 为 1， CMSInitiatingOccupancyFraction=80。<br>这么修改主要是增加 young 区空间，因为对于 Web 服务来说，除了一些 cache 外，没什么常驻内存的对象；通过把 OccupancyFraction 调大，延迟 CMS 发生频率，还是基于前面的推论，大多数对象不会晋级到 old 代，所以发生碎片的概率也不会怎么大。下面是优化后的相关参数，也证明了上面的猜想</p><table><thead><tr><th>percentiles</th><th>STW pause(ms)</th></tr></thead><tbody><tr><td>50%</td><td>19.75</td></tr><tr><td>90%</td><td>30.334</td></tr><tr><td>95%</td><td>35.441</td></tr></tbody></table><p> 99%         | 53.5          |<br>| 99.9%       | 120.008       |</p><ul><li>STW Pause per Minute: 826.607 ms</li><li>STW Events per Minute: 38</li></ul><table><thead><tr><th>Promoted Total</th><th>6.182 GB</th></tr></thead><tbody><tr><td>Promotion Rate (MB/Sec)</td><td>0.29</td></tr><tr><td>Allocated Total</td><td>28.254 TB</td></tr><tr><td>Allocation Rate (MB/Sec)</td><td>1121.29</td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>虽然本文一开始指出 LinkedIn 文章中存在理解误差，但是那篇文章的思路还是值得解决，下面再次给出链接</p><ul><li><a href="https://engineering.linkedin.com/garbage-collection/garbage-collection-optimization-high-throughput-and-low-latency-java-applications" target="_blank" rel="noopener">https://engineering.linkedin.com/garbage-collection/garbage-collection-optimization-high-throughput-and-low-latency-java-applications</a></li><li>段子手王四哥对上面文章的指正：<a href="http://yoroto.io/nan-dao-ta-men-shuo-de-du-shi-zhen-de/" target="_blank" rel="noopener">难道他们说的都是真的？</a></li><li>江南白衣的 <a href="http://calvin1978.blogcn.com/articles/jvmoption-7.html" target="_blank" rel="noopener">关键业务系统的JVM参数推荐</a>，说到这里就不得不提 <a href="https://github.com/vipshop/vjtools/" target="_blank" rel="noopener">vjtools</a> 了，我目前主要用了 vjtop。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面基本把 ParallelGC 与 CMS 核心点过了一遍，然后顺带介绍了下优化，主要还是熟悉 GC 日志中的每个指标含义，理解透后再去决定是否需要优化。关于 G1 本文没有过多介绍，主要是用的确实不多，后面会尝试把服务升级到 G1 后再来写写它。</p><p>本文一开始就说网络上关于 GC 的误解很多，本文可能也是这样的，虽然我已经尽可能保证“正确”，但还是需要大家带着辩证的眼光来看。元芳,你怎么看？</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All" target="_blank" rel="noopener">https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html</a></li><li><a href="https://blogs.oracle.com/jonthecollector/did-you-know" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/did-you-know</a></li><li><a href="https://dzone.com/articles/how-tame-java-gc-pauses" target="_blank" rel="noopener">https://dzone.com/articles/how-tame-java-gc-pauses</a></li><li><a href="https://mechanical-sympathy.blogspot.com/2013/07/java-garbage-collection-distilled.html" target="_blank" rel="noopener">https://mechanical-sympathy.blogspot.com/2013/07/java-garbage-collection-distilled.html</a></li><li><a href="https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;毫无疑问，GC（垃圾回收） 已经是现代编程语言标配，为了研究这个方向之前曾经写过四篇&lt;a href=&quot;/blog/2018/06/15/garbage-collection-intro/&quot;&gt;《深入浅出垃圾回收》&lt;/a&gt;博文来介绍其理论，之后也看了不少网络上关于 JDK GC
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
      <category term="GC" scheme="http://liujiacai.net/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程同步原理探析</title>
    <link href="http://liujiacai.net/blog/2018/12/29/how-java-synchronizer-work/"/>
    <id>http://liujiacai.net/blog/2018/12/29/how-java-synchronizer-work/</id>
    <published>2018-12-29T14:40:42.000Z</published>
    <updated>2019-12-24T10:59:14.613Z</updated>
    
    <content type="html"><![CDATA[<p>现如今，服务器性能日益增长，并发（concurrency）编程已经“深入人心”，但由于冯诺依式计算机“指令存储，顺序执行”的特性，使得编写跨越时间维度的并发程序异常困难，所以现代编程语言都对并发编程提供了一定程度的支持，像 Golang 里面的 <a href="https://tour.golang.org/concurrency/1" target="_blank" rel="noopener">Goroutines</a>、Clojure 里面的 <a href="https://clojure.org/reference/refs" target="_blank" rel="noopener">STM（Software Transactional Memory）</a>、Erlang 里面的 <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank" rel="noopener">Actor</a>。</p><p>Java 对于并发编程的解决方案是多线程（Multi-threaded programming），而且 Java 中的线程 与 native 线程一一对应，多线程也是早期操作系统支持并发的方案之一（其他方案：多进程、IO多路复用）。</p><p>本文着重介绍 Java 中线程同步的原理、实现机制，更侧重操作系统层面，部分原理参考 <a href="http://hg.openjdk.java.net/jdk/jdk/file/cfceb4df2499" target="_blank" rel="noopener">openjdk 源码</a>。阅读本文需要对 CyclicBarrier、CountDownLatch 有基本的使用经验。</p><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>在 Java 1.5 版本中，引入 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html" target="_blank" rel="noopener">JUC</a> 并发编程辅助包，很大程度上降低了并发编程的门槛，JUC 里面主要包括：</p><ul><li>线程调度的 Executors</li><li>缓冲任务的 Queues</li><li>超时相关的 TimeUnit</li><li>并发集合（如 ConcurrentHashMap）</li><li>线程同步类（Synchronizers，如 CountDownLatch ）</li></ul><p>个人认为其中最重要也是最核心的是线程同步这一块，因为并发编程的难点就在于如何保证「共享区域（专业术语：临界区，Critical Section）的访问时序问题」。</p><h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><p>JUC 提供的同步类主要有如下几种：</p><ul><li><code>Semaphore</code> is a classic concurrency tool.</li><li><code>CountDownLatch</code> is a very simple yet very common utility for blocking until a given number of signals, events, or conditions hold.</li><li>A <code>CyclicBarrier</code> is a resettable multiway synchronization point useful in some styles of parallel programming.</li><li>A <code>Phaser</code> provides a more flexible form of barrier that may be used to control phased computation among multiple threads.</li><li>An <code>Exchanger</code> allows two threads to exchange objects at a rendezvous(约会) point, and is useful in several pipeline designs.</li></ul><p>通过阅读其源码可以发现，其实现都基于 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer</a> 这个抽象类（一般简写 AQS），正如其 javadoc 开头所说：</p><blockquote><p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state.</p></blockquote><p>也就是说，AQS 通过维护内部的 FIFO 队列和具备原子更新的整型 state 这两个属性来实现各种锁机制，包括：是否公平，是否可重入，是否共享，是否可中断（interrupt），并在这基础上，提供了更方便实用的同步类，也就是一开始提及的 Latch、Barrier 等。</p><p>这里暂时不去介绍 AQS 实现细节与如何基于 AQS 实现各种同步类（挖个坑），感兴趣的可以移步美团的一篇文章<a href="https://tech.meituan.com/Java_Lock.html" target="_blank" rel="noopener">《不可不说的Java“锁”事》</a> 第六部分“独享锁 VS 共享锁”。</p><p>在学习 Java 线程同步这一块时，对我来说困扰最大的是「线程唤醒」，试想一个已经 wait/sleep/block 的线程，是如何响应 interrupt 的呢？当调用 Object.wait() 或 lock.lock() 时，JVM 究竟做了什么事情能够在调用 Object.notify 或 lock.unlock 时重新激活相应线程？</p><p>带着上面的问题，我们从源码中寻找答案。</p><h2 id="Java-如何实现堵塞、通知"><a href="#Java-如何实现堵塞、通知" class="headerlink" title="Java 如何实现堵塞、通知"></a>Java 如何实现堵塞、通知</h2><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在 JDK 源码中，上述两个方法均用 native 实现（即 cpp 代码），追踪相关代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.base/share/native/libjava/Object.c</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"hashCode"</span>,    <span class="string">"()I"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;<span class="string">"wait"</span>,        <span class="string">"(J)V"</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;<span class="string">"notify"</span>,      <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;<span class="string">"notifyAll"</span>,   <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;<span class="string">"clone"</span>,       <span class="string">"()Ljava/lang/Object;"</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面的 cpp 代码，我们大概能猜出 JVM 是使用 monitor 来实现的 wait/notify 机制，至于这里的 monitor 是何种机制，这里暂时跳过，接着看 lock 相关实现</p><h3 id="lock-unlock"><a href="#lock-unlock" class="headerlink" title="lock/unlock"></a>lock/unlock</h3><p>LockSupport 是用来实现堵塞语义模型的基础辅助类，主要有两个方法：park 与 unpark。（在英文中，park 除了“公园”含义外，还有“停车”的意思）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LockSupport.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unblocks the given thread blocked on &#123;<span class="doctag">@code</span> park&#125;, or, if it is</span></span><br><span class="line"><span class="comment">     * not blocked, causes the subsequent call to &#123;<span class="doctag">@code</span> park&#125; not to</span></span><br><span class="line"><span class="comment">     * block.  Note: this operation is "unsafe" solely because the</span></span><br><span class="line"><span class="comment">     * caller must somehow ensure that the thread has not been</span></span><br><span class="line"><span class="comment">     * destroyed. Nothing special is usually required to ensure this</span></span><br><span class="line"><span class="comment">     * when called from Java (in which there will ordinarily be a live</span></span><br><span class="line"><span class="comment">     * reference to the thread) but this is not nearly-automatically</span></span><br><span class="line"><span class="comment">     * so when calling from native code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thread the thread to unpark.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Blocks current thread, returning when a balancing</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> unpark&#125; occurs, or a balancing &#123;<span class="doctag">@code</span> unpark&#125; has</span></span><br><span class="line"><span class="comment">     * already occurred, or the thread is interrupted, or, if not</span></span><br><span class="line"><span class="comment">     * absolute and time is not zero, the given time nanoseconds have</span></span><br><span class="line"><span class="comment">     * elapsed, or if absolute, the given deadline in milliseconds</span></span><br><span class="line"><span class="comment">     * since Epoch has passed, or spuriously (i.e., returning for no</span></span><br><span class="line"><span class="comment">     * "reason"). Note: This operation is in the Unsafe class only</span></span><br><span class="line"><span class="comment">     * because &#123;<span class="doctag">@code</span> unpark&#125; is, so it would be strange to place it</span></span><br><span class="line"><span class="comment">     * elsewhere.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hotspot/share/prims/unsafe.cpp</span></span><br><span class="line">UNSAFE_ENTRY(<span class="keyword">void</span>, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time)) &#123;</span><br><span class="line">  HOTSPOT_THREAD_PARK_BEGIN((uintptr_t) thread-&gt;parker(), (<span class="keyword">int</span>) isAbsolute, time);</span><br><span class="line">  EventThreadPark event;</span><br><span class="line"></span><br><span class="line">  <span class="function">JavaThreadParkedState <span class="title">jtps</span><span class="params">(thread, time != <span class="number">0</span>)</span></span>;</span><br><span class="line">  thread-&gt;parker()-&gt;park(isAbsolute != <span class="number">0</span>, time);</span><br><span class="line">  <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">    post_thread_park_event(&amp;event, thread-&gt;current_park_blocker(), time);</span><br><span class="line">  &#125;</span><br><span class="line">  HOTSPOT_THREAD_PARK_END((uintptr_t) thread-&gt;parker());</span><br><span class="line">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure><p>通过上述 unsafe.cpp 可以看到每个 thread 都会有一个 Parker 对象，所以我们需要查看 parker 对象的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotspot/share/runtime/park.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parker</span> :</span> <span class="keyword">public</span> os::PlatformParker</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// For simplicity of interface with Java, all forms of park (indefinite,</span></span><br><span class="line">  <span class="comment">// relative, and absolute) are multiplexed into one call.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">bool</span> isAbsolute, jlong time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hotspot/os/posix/os_posix.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformParker</span> :</span> <span class="keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    REL_INDEX = <span class="number">0</span>,</span><br><span class="line">    ABS_INDEX = <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">int</span> _cur_index;  <span class="comment">// which cond is in use: -1, 0, 1</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> _mutex[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">pthread_cond_t</span>  _cond[<span class="number">2</span>]; <span class="comment">// one for relative times and one for absolute</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到这里大概就能知道 park 是使用 <code>pthread_mutex_t</code> 与 <code>pthread_cond_t</code> 实现。好了，到目前为止，就引出了 Java 中与堵塞相关的实现，不难想象，都是依赖底层操作系统的功能。</p><h2 id="OS-支持的同步原语"><a href="#OS-支持的同步原语" class="headerlink" title="OS 支持的同步原语"></a>OS 支持的同步原语</h2><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>并发编程领域的先锋人物 <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger Dijkstra</a>（也是最短路径算法的作者）在 1965 年首次提出了信号量（ Semaphores） 这一概念来解决线程同步的问题。信号量是一种特殊的变量类型，为非负整数，只有两个特殊操作PV：</p><ul><li>P(s) 如果 s!=0，将 s-1；否则将当前线程挂起，直到 s 变为非零</li><li>V(s) 将 s+1，如果有线程堵塞在 P 操作等待 s 变成非零，那么 V 操作会重启这些线程中的任意一个</li></ul><p>注：Dijkstra 为荷兰人，名字 P 和 V 来源于荷兰单词 Proberen（测试）和Verhogen（增加），为方便理解，后文会用 Wait 与 Signal 来表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     thread_list waiting;  <span class="comment">// List of threads waiting for semaphore</span></span><br><span class="line">&#125;</span><br><span class="line">wait(semaphore Sem):    <span class="comment">// Wait until &gt; 0 then decrement</span></span><br><span class="line">  <span class="comment">// 这里用的是 while 而不是 if</span></span><br><span class="line">  <span class="comment">// 这是因为在 wait 过程中，其他线程还可能继续调用 wait</span></span><br><span class="line">  <span class="keyword">while</span> (Sem.val &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    add <span class="keyword">this</span> thread to Sem.waiting;</span><br><span class="line">    block(<span class="keyword">this</span> thread);</span><br><span class="line">  &#125;</span><br><span class="line">  Sem.val = Sem.val - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">signal(semaphore Sem):<span class="comment">// Increment value and wake up next thread</span></span><br><span class="line">     Sem.val = Sem.val + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (Sem.waiting is nonempty) &#123;</span><br><span class="line">         remove a thread T from Sem.waiting;</span><br><span class="line">         wakeup(T);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>有两点注意事项：</p><ol><li>wait 中的「测试和减 1 操作」，signal 中的「加 1 操作」需要保证原子性。一般来说是使用硬件支持的 <a href="https://en.wikipedia.org/wiki/Read-modify-write" target="_blank" rel="noopener">read-modify-write 原语</a>，比如 test-and-set/fetch-and-add/compare-and-swap，除了硬件支持外，还可以用 <a href="https://en.wikipedia.org/wiki/Mutual_exclusion#Software_solutions" target="_blank" rel="noopener">busy wait</a> 的软件方式来模拟。</li><li>signal 中没有定义重新启动的线程顺序，也即多个线程在等待同一信号量时，无法预测重启哪一个线程</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>信号量为控制并发程序的执行提供了强有力工具，这里列举两个场景：</p><h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>信号量提供了了一种很方便的方法来保证对共享变量的互斥访问，基本思想是</p><blockquote><p>将每个共享变量（或一组相关的共享变量）与一个信号量 s （初始化为1）联系起来，然后用 wait/signal 操作将相应的临界区包围起来。</p></blockquote><p>二元信号量也被称为互斥锁（mutex，mutual exclusve, 也称为 binary semaphore），wait 操作相当于加锁，signal 相当于解锁。<br>一个被用作一组可用资源的计数器的信号量称为计数信号量（counting semaphore）</p><h5 id="调度共享资源"><a href="#调度共享资源" class="headerlink" title="调度共享资源"></a>调度共享资源</h5><p>除了互斥外，信号量的另一个重要作用是调度对共享资源的访问，比较经典的案例是生产者消费者，伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">emptySem = N</span><br><span class="line">fullSem = <span class="number">0</span></span><br><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">while</span>(whatever) &#123;</span><br><span class="line">    locally generate item</span><br><span class="line">    wait(emptySem)</span><br><span class="line">    fill empty buffer with item</span><br><span class="line">    signal(fullSem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">while</span>(whatever) &#123;</span><br><span class="line">    wait(fullSem)</span><br><span class="line">    get item from full buffer</span><br><span class="line">    signal(emptySem)</span><br><span class="line">    use item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="POSIX-实现"><a href="#POSIX-实现" class="headerlink" title="POSIX 实现"></a>POSIX 实现</h4><p>POSIX 标准中有定义信号量相关的逻辑，在 <a href="http://pubs.opengroup.org/onlinepubs/007904875/basedefs/semaphore.h.html" target="_blank" rel="noopener">semaphore.h</a> 中，为 sem_t 类型，相关 API：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intialize: </span></span><br><span class="line">sem_init(&amp;theSem, <span class="number">0</span>, initialVal);</span><br><span class="line"><span class="comment">// Wait: </span></span><br><span class="line">sem_wait(&amp;theSem);</span><br><span class="line"><span class="comment">// Signal: </span></span><br><span class="line">sem_post(&amp;theSem);</span><br><span class="line"><span class="comment">// Get the current value of the semaphore:       </span></span><br><span class="line">sem_getvalue(&amp;theSem, &amp;result);</span><br></pre></td></tr></table></figure><p>信号量主要有两个缺点：</p><ul><li>Lack of structure，在设计大型系统时，很难保证 wait/signal 能以正确的顺序成对出现，顺序与成对缺一不可，否则就会出现死锁！</li><li>Global visiblity，一旦程序出现死锁，整个程序都需要去检查</li></ul><p>解决上述两个缺点的新方案是<a href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29" target="_blank" rel="noopener">监控器（monitor）</a>。</p><h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><p><a href="https://en.wikipedia.org/wiki/C._A._R._Hoare" target="_blank" rel="noopener">C. A. R. Hoare</a>（也是 Quicksort 的作者） 在 1974 年的论文 <a href="https://dl.acm.org/citation.cfm?doid=355620.361161" target="_blank" rel="noopener">Monitors: an operating system structuring concept</a> 首次提出了「监控器」概念，它提供了对信号量互斥和调度能力的更高级别的抽象，使用起来更加方便，一般形式如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">monitor1</span> . . . monitorM</span><br><span class="line">process1 . . . processN</span><br></pre></td></tr></table></figure></p><p>我们可以认为监控器是这么一个对象：</p><ul><li>所有访问同一监控器的线程通过条件变量（condition variables）间接通信</li><li>某一个时刻，只能有一个线程访问监控器</li></ul><h4 id="Condition-variables"><a href="#Condition-variables" class="headerlink" title="Condition variables"></a>Condition variables</h4><p>上面提到监控器通过条件变量（简写 cv）来协调线程间的通信，那么条件变量是什么呢？它其实是一个 FIFO 的队列，用来保存那些因等待某些条件成立而被堵塞的线程，对于一个条件变量 c 来说，会关联一个断言（assertion） P。线程在等待 P 成立的过程中，该线程不会锁住该监控器，这样其他线程就能够进入监控器，修改监控器状态；在 P 成立时，其他线程会通知堵塞的线程，因此条件变量上主要有三个操作：</p><ol><li><code>wait(cv, m)</code> 等待 cv 成立，m 表示与监控器关联的一 mutex 锁</li><li><code>signal(cv)</code> 也称为 <code>notify(cv)</code> 用来通知 cv 成立，这时会唤醒等待的线程中的一个执行。根据唤醒策略，监控器分为两类：Hoare vs. Mesa，后面会介绍</li><li><code>broadcast(cv)</code> 也称为 <code>notifyAll(cv)</code> 唤醒所有等待 cv 成立的线程</li></ol><h5 id="POSIX-实现-1"><a href="#POSIX-实现-1" class="headerlink" title="POSIX 实现"></a>POSIX 实现</h5><p>在 pthreads 中，条件变量的类型是 <code>pthread_cond_t</code>，主要有如下几个方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize</span></span><br><span class="line">pthread_cond_init() </span><br><span class="line">pthread_cond_wait(&amp;theCV, &amp;someLock);</span><br><span class="line">pthread_cond_signal(&amp;theCV);</span><br><span class="line">pthread_cond_broadcast(&amp;theCV);</span><br></pre></td></tr></table></figure><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>在 pthreads 中，所有使用条件变量的地方都必须用一个 mutex 锁起来，这是为什么呢？看下面一个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> myLock;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> myCV;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread A</span></span><br><span class="line">pthread_mutex_lock(&amp;myLock);</span><br><span class="line"><span class="keyword">while</span>(count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;myCV, &amp;myLock);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;myLock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread B</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;myLock);</span><br><span class="line">count ++;</span><br><span class="line"><span class="keyword">while</span>(count == <span class="number">10</span>) &#123;</span><br><span class="line">    pthread_cond_signal(&amp;myCV);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;myLock);</span><br></pre></td></tr></table></figure></p><p>如果没有锁，那么</p><ul><li>线程 A 可能会在其他线程将 count 赋值为10后继续等待</li><li>线程 B 无法保证加一操作与测试 count 是否为零 的原子性</li></ul><p>这里的关键点是，在进行条件变量的 wait 时，会释放该锁，以保证其他线程能够将之唤醒。不过需要注意的是，在线程 B 通知（signal） myCV 时，线程 A 无法立刻恢复执行，这是因为 myLock 这个锁还被线程 B 持有，只有在线程 B <code>unlock(&amp;myLock)</code> 后，线程 A 才可恢复。总结一下：</p><ol><li>wait 时会释放锁</li><li>signal 会唤醒等待同一 cv 的线程</li><li>被唤醒的线程需要重新获取锁，然后才能从 wait 中返回</li></ol><h4 id="Hoare-vs-Mesa-监控器语义"><a href="#Hoare-vs-Mesa-监控器语义" class="headerlink" title="Hoare vs. Mesa 监控器语义"></a>Hoare vs. Mesa 监控器语义</h4><p>在上面条件变量中，我们提到 signal 在调用时，会去唤醒等待同一 cv 的线程，根据唤醒策略的不同，监控器也分为两类：</p><ul><li>Hoare 监控器（1974），最早的监控器实现，在调用 signal 后，会立刻运行等待的线程，这时调用 signal 的线程会被堵塞（因为锁被等待线程占有了）</li><li>Mesa 监控器（Xerox PARC, 1980），signal 会把等待的线程重新放回到监控的 ready 队列中，同时调用 signal 的线程继续执行。这种方式是现如今 pthreads/Java/C# 采用的</li></ul><p>这两类监控器的关键区别在于等待线程被唤醒时，需要重新检查 P 是否成立。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01opA7ut1z69s6EhwrR_!!581166664.png" alt="监控器工作示意图"></p><p>上图表示蓝色的线程在调用监控器的 get 方式时，数据为空，因此开始等待 emptyFull 条件；紧接着，红色线程调用监控器的 set 方法改变 emptyFull 条件，这时</p><ul><li>按照 Hoare 思路，蓝色线程会立刻执行，并且红色线程堵塞</li><li>按照 Mesa 思路，红色线程会继续执行，蓝色线程会重新与绿色线程竞争与监控器关联的锁</li></ul><h4 id="Java-中的监控器"><a href="#Java-中的监控器" class="headerlink" title="Java 中的监控器"></a>Java 中的监控器</h4><p>在 Java 中，每个对象都是一个监控器（因此具备一个 lock 与 cv），调用对象 o 的 synchronized 方法 m 时，会首先去获取 o 的锁，除此之外，还可以调用 o 的 wait/notify/notify 方法进行并发控制</p><h3 id="Big-Picture"><a href="#Big-Picture" class="headerlink" title="Big Picture"></a>Big Picture</h3><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01RZViZw1z69s99tJfI_!!581166664.png" alt="操作系统并发相关 API 概括图"><br>来源：<a href="https://www.cs.princeton.edu/courses/archive/fall11/cos318/lectures/L8_SemaphoreMonitor_v2.pdf" target="_blank" rel="noopener">https://www.cs.princeton.edu/courses/archive/fall11/cos318/lectures/L8_SemaphoreMonitor_v2.pdf</a></p><h2 id="Interruptible"><a href="#Interruptible" class="headerlink" title="Interruptible"></a>Interruptible</h2><p>通过介绍操作系统支持的同步原语，我们知道了 park/unpark、wait/notify 其实就是利用信号量（ <code>pthread_mutex_t</code>）、条件变量（ <code>pthread_cond_t</code>）实现的，其实监控器也可以用信号量来实现。在查看 AQS 中，发现有这么一个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment"> * rather than to use timed park. A rough estimate suffices</span></span><br><span class="line"><span class="comment"> * to improve responsiveness with very short timeouts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure></p><p>也就是说，在小于 1000 纳秒时，await 条件变量 P 时，会使用一个循环来代替条件变量的堵塞与唤醒，这是由于堵塞与唤醒本身的操作开销可能就远大于 await 的 timeout。相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS 的 doAcquireNanos 方法节选</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">    <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">        nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">        LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JUC 提供的高级同步类中，acquire 对应 park，release 对应 unpark，interrupt 其实就是个布尔的 flag 位，在 unpark 被唤醒时，检查该 flag ，如果为 true，则会抛出我们熟悉的 InterruptedException。</p><p><code>Selector.select()</code> 响应中断异常的逻辑有些特别，因为对于这类堵塞 IO 操作来说，没有条件变量的堵塞唤醒机制，我们可以再看下 Thread.interrupt 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenJDK 使用了这么一个技巧来实现堵塞 IO 的中断唤醒：在一个线程被堵塞时，会关联一个 Interruptible 对象。<br>对于 Selector 来说，在开始时，会关联这么一个<a href="http://hg.openjdk.java.net/jdk/jdk/file/cfceb4df2499/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java#l154" target="_blank" rel="noopener">Interruptible 对象</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread target)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (closed)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        closed = <span class="keyword">true</span>;</span><br><span class="line">                        interrupted = target;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            AbstractInterruptibleChannel.<span class="keyword">this</span>.implCloseChannel();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    blockedOn(interruptor);</span><br><span class="line">    Thread me = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">        interruptor.interrupt(me);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 interrupt 方式时，会关闭该 channel，这样就会关闭掉这个堵塞线程，可见为了实现这个功能，代价也是比较大的。LockSupport.park 中采用了类似技巧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也许基于多线程的并发编程不是最好的（可能是最复杂的，Clojure 大法好 :-），但却是最悠久的。<br>即便我们自己不去写往往也需要阅读别人的多线程代码，而且能够写出“正确”（who knows?）的多线程程序往往也是区分 senior 与 junior 程序员的标志，希望这篇文章能帮助大家理解 Java 是如何实现线程控制，有疑问欢迎留言指出，谢谢！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://carlmastrangelo.com/blog/javas-mysterious-interrupt" target="_blank" rel="noopener">https://carlmastrangelo.com/blog/javas-mysterious-interrupt</a></li><li><a href="https://blog.csdn.net/hengyunabc/article/details/28126139" target="_blank" rel="noopener">Java的LockSupport.park()实现分析</a></li><li>课件 <a href="http://www.cse.unsw.edu.au/~cs3151/17s2/lec/PDF/lecture06a.pdf" target="_blank" rel="noopener">COMP3151/9151 Foundations of Concurrency Lecture 6 - Semaphores, Monitors, POSIX Threads, Java</a></li><li>课件 <a href="http://crystal.uta.edu/~ylei/cse6324/data/semaphore.pdf" target="_blank" rel="noopener">http://crystal.uta.edu/~ylei/cse6324/data/semaphore.pdf</a></li><li>课件 <a href="https://cs61.seas.harvard.edu/wiki/images/1/12/Lec19-Semaphores.pdf" target="_blank" rel="noopener">https://cs61.seas.harvard.edu/wiki/images/1/12/Lec19-Semaphores.pdf</a></li><li><a href="https://barrgroup.com/Embedded-Systems/How-To/RTOS-Mutex-Semaphore" target="_blank" rel="noopener">Mutexes and Semaphores Demystified</a></li><li><a href="https://book.douban.com/subject/1888733/" target="_blank" rel="noopener">https://book.douban.com/subject/1888733/</a></li><li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mutual_exclusion</a></li><li><a href="https://stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore" target="_blank" rel="noopener">https://stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore</a></li><li><a href="https://stackoverflow.com/questions/2332765/lock-mutex-semaphore-whats-the-difference" target="_blank" rel="noopener">https://stackoverflow.com/questions/2332765/lock-mutex-semaphore-whats-the-difference</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现如今，服务器性能日益增长，并发（concurrency）编程已经“深入人心”，但由于冯诺依式计算机“指令存储，顺序执行”的特性，使得编写跨越时间维度的并发程序异常困难，所以现代编程语言都对并发编程提供了一定程度的支持，像 Golang 里面的 &lt;a href=&quot;https
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>形单影只的 Socket</title>
    <link href="http://liujiacai.net/blog/2018/11/10/damn-single-socket/"/>
    <id>http://liujiacai.net/blog/2018/11/10/damn-single-socket/</id>
    <published>2018-11-10T14:15:18.000Z</published>
    <updated>2019-12-24T10:59:14.613Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作上遇到过几次因 http client 没有配置超时相关参数，导致线程数占满或应用卡住的情况，出问题时线程的堆栈大致是这样的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"qtp325266363-35729"</span> <span class="comment">#35729 prio=5 os_prio=0 tid=0x00007f5154033000 nid=0x1cf8f runnable [0x00007f4f7f511000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">        at sun.security.ssl.InputRecord.readFully(InputRecord.java:465)</span><br><span class="line">        at sun.security.ssl.InputRecord.read(InputRecord.java:503)</span><br><span class="line">        at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:983)</span><br><span class="line">        - locked &lt;0x00000006e1494d68&gt; (a java.lang.Object)</span><br><span class="line">        at sun.security.ssl.SSLSocketImpl.readDataRecord(SSLSocketImpl.java:940)</span><br><span class="line">        at sun.security.ssl.AppInputStream.read(AppInputStream.java:105)</span><br><span class="line">        - locked &lt;0x00000006e1496d88&gt; (a sun.security.ssl.AppInputStream)</span><br><span class="line">        at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)</span><br><span class="line">        at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)</span><br><span class="line">        at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)</span><br><span class="line">        at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:282)</span><br><span class="line">        at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)</span><br><span class="line">        at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)</span><br><span class="line">        at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)</span><br><span class="line">        at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)</span><br></pre></td></tr></table></figure><p>程序卡在了 <code>socketRead0</code> 上，我们线上版本用的是 <a href="https://hc.apache.org/httpcomponents-client-ga/" target="_blank" rel="noopener">httpclient 4.4.5</a>，配置下面参数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timeout = <span class="number">5</span>;</span><br><span class="line">RequestConfig config = RequestConfig.custom()</span><br><span class="line">  .setConnectTimeout(timeout * <span class="number">1000</span>)</span><br><span class="line">  .setConnectionRequestTimeout(timeout * <span class="number">1000</span>)</span><br><span class="line">  .setSocketTimeout(timeout * <span class="number">1000</span>).build();</span><br><span class="line">CloseableHttpClient client = </span><br><span class="line">  HttpClientBuilder.create().setDefaultRequestConfig(config).build();</span><br></pre></td></tr></table></figure><p>上面设置了三个超时时间，含义分别是</p><ul><li>Connection Timeout，表示与远端服务期建立连接的超时</li><li>Socket Timeout，表示连接上两个 packet 之间的超时，当空闲时间超过这个后该连接就会自动断开</li><li>Connection Manager Timeout，表示从连接池申请连接时的超时</li></ul><p>好了，其实这不是这篇文章的重点，重点是在 debug 这个问题时，发现的一个有趣现象，为了阐述该现象，需要先回顾下 <a href="/blog/2016/10/31/socket-programming/">socket 编程</a>的基本知识。</p><h2 id="Socket-定义"><a href="#Socket-定义" class="headerlink" title="Socket 定义"></a>Socket 定义</h2><p>计算机领域里的 socket ，表示可以进行通讯的两个程序，一般称为 endpoint，如果是同一台机器上，则对应 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix domain socket</a>，如果是不同机器，则为 <a href="https://en.wikipedia.org/wiki/Network_socket" target="_blank" rel="noopener">network socket</a>，一方称为 client，另一方称为 server。</p><p>对于 TCP socket 来说，使用流程如下：</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2egBSbOKO.eBjSZPhXXXqcpXa_!!581166664.png_620x10000.jpg" alt="TCP socket API"></p><p>连接建立后，可以通过 <a href="https://linux.die.net/man/8/ss" target="_blank" rel="noopener">ss 命令</a>查看到</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3000 端口为一 Java 写的 HTTP Server，35050 为 curl 访问时随机选择的本地端口</span></span><br><span class="line">$ ss -np | grep 3000</span><br><span class="line">Netid  State      Recv-Q Send-Q     Local Address:Port       Peer Address:Port</span><br><span class="line">tcp    ESTAB      0      0              127.0.0.1:35050         127.0.0.1:3000   users:((<span class="string">"curl"</span>,12436,3))</span><br><span class="line">tcp    ESTAB      0      0              127.0.0.1:3000          127.0.0.1:35050  users:((<span class="string">"java"</span>,12279,82))</span><br></pre></td></tr></table></figure><p>由于 socket 涉及两端，每一端用 ip + port 去标示，再加上通讯协议，所以需要用五个字段来标示，一般表述为 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># protocol 一般为 tcp/udp</span></span><br><span class="line">(protocol, src_ip:src_port, dst_ip:dst_port)</span><br></pre></td></tr></table></figure><h2 id="形单影只的-socket"><a href="#形单影只的-socket" class="headerlink" title="形单影只的 socket"></a>形单影只的 socket</h2><p>经过上面的介绍，往往会以为 TCP socket 都是成对出现的，毕竟有两方参与。这也符合 99.99% 的场景，但是 TCP 协议在定义时，并没有严格要通讯双方必须为不同的程序，也就是说只要符合 TCP 状态机的模型，就可以做到自己与自己通讯（即 ESTABLISHED 状态）。通过下面一示例可以证明：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> nc -v localhost 11111; <span class="keyword">done</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">nc: connect to localhost port 11111 (tcp) failed: Connection refused</span><br><span class="line">nc: connect to localhost port 11111 (tcp) failed: Connection refused</span><br><span class="line">nc: connect to localhost port 11111 (tcp) failed: Connection refused</span><br><span class="line">nc: connect to localhost port 11111 (tcp) failed: Connection refused</span><br><span class="line">Connection to localhost 11111 port [tcp/*] succeeded!</span><br></pre></td></tr></table></figure><p>上面示例在开始运行时一直失败，说明 11111 端口没有被 LISTEN，所以连接一直失败，但是在某一时刻突然就连上了！还是请出我们的老朋友 ss 看看怎么回事</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ss -np  | grep 11111</span><br><span class="line">tcp    ESTAB      0      0              127.0.0.1:11111         127.0.0.1:11111  users:((<span class="string">"nc"</span>,8419,3))</span><br></pre></td></tr></table></figure><p>额，竟然只有一个 socket！这时的 nc 命令同时兼具了 server 与 client 两个角色，这时其实是个 echo server，输入什么，就会输出什么。</p><p>这看上去有些不可思议，为了弄清问题，可以通过 tcpdump 来分析连接是怎么建立的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump -i any port 11111 -Snw /tmp/debug.pcap -vvv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开另一个窗口，输入</span></span><br><span class="line">$ nc -vp 11111 localhost 11111</span><br><span class="line">Connection to localhost 11111 port [tcp/*] succeeded!</span><br><span class="line"><span class="comment"># 这里通过 -p 选项制定了 client 的端口号，方便快速浮现问题</span></span><br></pre></td></tr></table></figure><p>然后通过 Wireshark 打开得到的 pcap 文件，发现了著名的「三次握手」</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01cgFBcS1z69rFquQhR_!!581166664.png" alt="三次握手"></p><p>虽然第二个 packet 显示为 out of order，但是并没有影响该 socket TCP 状态的转移！</p><p>这里需要再复习下 TCP 状态转移过程：</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2Us0HbNeK.eBjSZFlXXaywXXa_!!581166664.gif" alt="tcp_state transition"></p><p>当处于 close 状态的 socket 发出 <code>SYN</code> 包后，会处于 <code>SYN_SENT</code> 状态，这时如果收到 <code>SYN,ACK</code> 并回复 <code>ACK</code> 包后，就会处于 <code>ESTABLISHED</code>。<br>可以看到，一个 socket 竟然就可以完成上述步骤。</p><p>那么能不能复现「四次挥手」呢？直接 <code>Ctrl+C</code> 结束上面的 nc 进程，然后再通过 tcpdump+wireshark 可以得到下面的结果：</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN011z69rDS08WSZzlD_!!581166664.png" alt="“二次挥手”"></p><p>通过 ss 命令也没找到处于 TIME-WAIT 状态的 11111，说明进行的是「被动关闭」（状态转移图右下角）流程。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>看完本文的一点“实用”干货可能是解释为什么不要去 LISTEN 比较高的端口，但是更希望大家能多去动手，发现隐藏在表象下的根源，这其实和脱单是一个道理 -:)</p><p>最后，留个“动手”问题给大家思考：</p><blockquote><p>如何找出一个已经 ESTABLISHED 的 TCP 连接建立时间与最后一次通讯（即有数据传输）的时间？</p></blockquote><p><a href="https://github.com/jiacai2050/jiacai2050.github.io/issues/3" target="_blank" rel="noopener">在这里</a> 提供一种解决思路。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.baeldung.com/httpclient-timeout" target="_blank" rel="noopener">https://www.baeldung.com/httpclient-timeout</a></li><li><a href="https://blog.cloudflare.com/this-is-strictly-a-violation-of-the-tcp-specification/" target="_blank" rel="noopener">https://blog.cloudflare.com/this-is-strictly-a-violation-of-the-tcp-specification/</a></li><li><a href="https://linux.die.net/man/8/ss" target="_blank" rel="noopener">https://linux.die.net/man/8/ss</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近工作上遇到过几次因 http client 没有配置超时相关参数，导致线程数占满或应用卡住的情况，出问题时线程的堆栈大致是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="Linux" scheme="http://liujiacai.net/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出垃圾回收（四）分代式 GC</title>
    <link href="http://liujiacai.net/blog/2018/08/18/generational-gc/"/>
    <id>http://liujiacai.net/blog/2018/08/18/generational-gc/</id>
    <published>2018-08-18T04:12:30.000Z</published>
    <updated>2019-12-24T10:59:14.612Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/blog/2018/08/04/incremental-gc">上文</a>介绍的增量式 GC 是对 mark 阶段的一大优化，可以极大避免 STW 的影响。本文将要介绍的分代式 GC 根据对象生命周期（后面称为 age）的特点来优化 GC，降低其性能消耗。</p><p>阅读本文需要熟悉<a href="/blog/2018/07/08/mark-sweep/#术语">之前提及的术语</a>。</p><h1 id="分代的必要性"><a href="#分代的必要性" class="headerlink" title="分代的必要性"></a>分代的必要性</h1><p>虽然对象的生命周期因应用而异，但对于大多数应用来说，80% 的对象在创建不久即会成为垃圾<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。因此，针对不同 age 的对象「划分不同区域，采用不同的回收策略」也就不难理解了。</p><p>对于 Copying GC 来说，需要在两个 semispace 间移动对象，如果移动对象较大，就会对程序造成较大影响，而分代就能解决这个问题。简单情况下可以分为两个代：younger、older。</p><blockquote><p>younger 用于分配新对象，在这里的对象经过几轮 GC 后会移动到 older。younger 与 older 相比空间要小，且 GC 发生更频繁。</p></blockquote><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2xIAtpY3nBKNjSZFMXXaUSFXa_!!581166664.jpg" alt="分代式 GC 示意图"><br>即便采用的是 non-copying GC，也可以通过分代，减少 GC 作用范围，缩小耗时。</p><h1 id="分代的问题"><a href="#分代的问题" class="headerlink" title="分代的问题"></a>分代的问题</h1><p>天下没有免费的午餐，GC 采用分代算法，一个首要的问题是「如何在不回收 older 的同时安全的回收 younger 里面的对象」。由于引用关系图是全局的属性，older 里面的对象也必须考虑的。比如 younger 里面的一对象只被 older 里面的对象引用了，如何保证 GC 不会错误的回收这个对象呢？<br>避免上述问题的一个方法是采用写屏障（write barrier），在 mutator 进行指针存储时，进行一些额外的操作（bookkeeping）。写屏障的主要目的是保证所有由 <code>older--&gt;younger</code> 的指针在进行 younger 内的 GC 时被考虑在内，并且作为 root set 进行 copy 遍历。需要注意的是，这里的写屏障与增量式 GC 同样具有一定的保守性。这是由于所有由 <code>older--&gt;younger</code> 的指针都会被当作 root set，但在 older 内对象的 liveness 在进行下一次 older GC 前是不可知的，这也就造成了一些 floating garbage，不过这在实现中问题不是很大。</p><p>为了独立回收 older，通过记录所有由 <code>younger--&gt;older</code> 的指针也是可行的，不过这会比较消耗性能。这是因为：</p><blockquote><p>在大多数情况下，由 <code>younger--&gt;older</code> 的指针数目要远大于 <code>older--&gt;younger</code> 的，这是符合程序运行规律的——创建一个新对象，将至指向一个老对象。</p></blockquote><p>即便不记录 <code>younger--&gt;older</code> 的指针，也可以在不回收 younger 的前提下回收 older，只不过这时会把 younger 里面的所有对象作为 root set。尽管这样遍历的时间会与 younger 里面的对象数目成正比，但考虑到 younger 内对象数量一般都要小于 older 的，而且遍历操作的消耗要远小于 copying，所以这也是一种可以接受的方式。</p><p>除了上面交叉引用的问题，对于一个分代的 GC 来说，还需要考虑下面几个方面：</p><ol><li>提升策略（advancement policy）。在一个代内的对象经过多少次 GC 会晋级到下一个代</li><li>堆组织（heap organization）。在代与代之间或者一个代内，heap 空间如何组织可以保证高的 locality 与 缓存命中率</li><li>代之间的交叉引用（intergenerational references）。采用哪种方式来记录这些指针最好？dirty bit or indirect table</li></ol><p>下面就针对这三点分别进行阐述。</p><h2 id="提升策略"><a href="#提升策略" class="headerlink" title="提升策略"></a>提升策略</h2><p>最简单的提升策略是在每次 GC 遍历时，把 live 的对象移动到下一代去。这样的优势有：</p><ol><li>实现简单，不需要去区分一个代内不同对象的 age。对于 copying GC 来说，只需要用一块连续的区域表示即可，不需要 semispace，也不需要额外的 header 来保存 age 信息</li><li>可以尽快的把大对象提升的 GC 频率小的下一代中去</li></ol><p>当然，这样做的问题也比较明显，可能会把一些 age 较小的对象移动到下一代中去，导致下一代被更快的填满，所以一般会让 younger 里面的对象停留一次，即第二次 GC 时才去提升，当然这时就需要记录对象的 age 了。</p><p>至于是不是需要停留两次，这个就不好说了，这个和应用也比较相关。一般来说，如果代分的少，比如2个，那么会倾向多停留几次，减慢 older 被填满的速度；如果代的数目大于2，那么就倾向于快速提升，因为这些对象很有可能在中间的某个代就会死亡，不会到达最终的 older。</p><h2 id="堆组织"><a href="#堆组织" class="headerlink" title="堆组织"></a>堆组织</h2><p>分代式 GC 需要对不同 age 的对象采取不同的处理方式，所以在 GC 遍历时，必须能够判断当前对象属于哪个代，写屏障也需要这个信息来识别 <code>older--&gt;younger</code> 指针。</p><ul><li>对于 copying GC 来说，一般是把不同 age 的对象放在不同的连续区域内，这样一个对象的代就能够从内存地址推断出来了。也有一些系统不采用连续地址，而是采用由 <code>page number of object--&gt;generation</code> 的表来辅助判断。</li><li>对于 non-copying GC，一般是存放在 header 内</li></ul><h3 id="Subareas-in-Copying"><a href="#Subareas-in-Copying" class="headerlink" title="Subareas in Copying"></a>Subareas in Copying</h3><p>分代式 copying GC 一般会把 generation 分为几个子区域，比如 semispace，通过来回的移动对象让它们一直处于当前代中。如果一个代内只有一个区域，那么每次 GC 时都需要把对象提升到下一代（没有可移动的地方）。<br>但是 semispace 的 locality 比较差，一个代的内存只有一半可以使用，且来回需要移动。</p><h4 id="Ungar’s-Generation-Scavenging"><a href="#Ungar’s-Generation-Scavenging" class="headerlink" title="Ungar’s Generation Scavenging"></a>Ungar’s Generation Scavenging</h4><p><a href="https://en.wikipedia.org/wiki/David_Ungar" target="_blank" rel="noopener">Ungar</a> 在其论文<a href="https://people.cs.umass.edu/~emery/classes/cmpsci691s-fall2004/papers/p157-ungar.pdf" target="_blank" rel="noopener">《Generation Scavenging》</a> 中提出一个解决方法：</p><blockquote><p>一个代内除了两个 semispace 外，还有第三个区域，这里称为Third。在 Third 内分配新对象，在 GC 时，Third 内 live 对象与 semispace 中的一个对象会复制到 semispace 中的另一个去，GC 结束时 Third 会被清空，用于再次分配对象。这样就能够与只有一个区域的代类似的 locality 了。</p></blockquote><p>乍一看，增加的 Third 区域会增加内存使用，但实际情况要好很多。Third 区域会被充分利用，semispace 用来保存每次 GC 后的存活对象（survivors）。一般来说，新创建的对象只有少部分能“活过”一次 GC，所以每个 semispace 中只有一小部分会使用，因此总的来说内存使用较小。</p><p>最后一个代（oldest generation，后面称为 oldest）在一些系统中有特殊处理。比如，在 Lisp Machine 中，每次 GC 后，大多数代都会被清空，并将其内对象拷贝到下一代去，但是 oldest 后面没有可用代了，因此 oldest 内会被分为 semispace。另一个优化是分配一个特殊的区域，称为 static space，用来分配 system data &amp; compiled code 等这些基本不会变的数据，这个区域基本不会有 GC。</p><p>在一些基于 Ungar 的 Generation Scavenging 的系统中，把 oldest 分为一个区域，在这个区域使用 mark-compact 算法。使用一个区域可以提高内存利用率，MC 虽然比 copying 算法成本更高，但对于 oldest 来说减少<a href="https://en.wikipedia.org/wiki/Page_fault" target="_blank" rel="noopener">换页（page fault）</a>也是有价值的。（copying GC 由于 semispace 的原因，所以内存使用率只有一半，所以更容易导致发生换页的问题<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>）。关于<a href="https://en.wikipedia.org/wiki/Paging" target="_blank" rel="noopener">虚拟内存的分页</a>对 GC 影响的研究不是很多，感兴趣可以参考下面的链接：</p><ul><li><a href="https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/virtual-memory-paging-and-swapping/" target="_blank" rel="noopener">Virtual Memory, Paging, and Swapping</a></li><li><a href="https://cs.stackexchange.com/questions/22649/are-there-any-garbage-collectors-that-take-into-account-paging" target="_blank" rel="noopener">Are there any garbage collectors that take into account paging?</a></li><li><a href="https://stackoverflow.com/questions/21810059/relation-between-garbage-collection-and-swapping-paging" target="_blank" rel="noopener">Relation between garbage collection and swapping,paging</a></li></ul><h3 id="Generations-in-Non-copying"><a href="#Generations-in-Non-copying" class="headerlink" title="Generations in Non-copying"></a>Generations in Non-copying</h3><p>上面的讨论主要围绕 copying GC 来说，其实那些技巧也可以用在 non-copying GC 之上，只不过它们更容易发生碎片问题。在增量式 GC 那里使用<a href="/blog/2018/08/04/incremental-gc/#三色标记">三色标记</a>来抽象，分代算法可以用不同 age 的对象集合来抽象。在 GC 遍历时，通过检查 header 里面的 age 来决定是否需要提升。</p><h3 id="其他讨论"><a href="#其他讨论" class="headerlink" title="其他讨论"></a>其他讨论</h3><ul><li>对于 copying GC 来说，大对象会被特殊的分配在一特殊区域「large object area」来避免拷贝。</li><li>对于明确指定不含有指针的对象，最好也能与其他对象分开，来降低检查交叉引用的成本。</li><li>一般情况下，对 younger 代采用 stop-and-copy 方式的 GC；对 older 采用 incremental-and-sweep GC</li></ul><h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>上面已经介绍的，<code>older--&gt;younger</code> 的交叉引用是由写屏障来保障的。对于某些系统（如 Lisp，指针存储指令占全部指令的1%<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>），这个写屏障的成本对分代式 GC 来说非常严重，因此写屏障的策略就十分重要了。下面介绍几种常见的策略</p><h3 id="Indirect-tables"><a href="#Indirect-tables" class="headerlink" title="Indirect tables"></a>Indirect tables</h3><p>重定向表（indirect tables）的思路是这样的：</p><p>所有 <code>older--&gt;younger</code> 的指针经由一个称为「<a href="http://www.memorymanagement.org/glossary/e.html" target="_blank" rel="noopener">entry table</a>」的表进行中转，每个代都有其对应的 entry table 来记录后一个代指向当前代的指针。这样在回收一个代时，只需要把 entry table 里面的引用考虑在内就可以了。<br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB208pDqcUrBKNjSZPxXXX00pXa_!!581166664.png" alt="indirect table 示意图"></p><p>但这种重定向表在普通机器（stock hardware）上不够快或高效，因此最近的分代式 GC 都避免使用这种方式，而是采用记录的方式（pointer recording schemes）来保存这些交叉引用。</p><h3 id="Ungar’s-Remembered-Sets"><a href="#Ungar’s-Remembered-Sets" class="headerlink" title="Ungar’s Remembered Sets"></a>Ungar’s Remembered Sets</h3><p>Ungar 的 generation scavenging 采用一个称为 Remembered Sets（后面简写 RS） 的结构来记录交叉引用。在每一次指针存储时，写屏障通过检查</p><ol><li>将要保存的对象是否为指针</li><li>指针是否指向 younger</li><li>是否被保存到 older 内</li></ol><p>这三个条件，判断是否会创建交叉引用，如果上述三个条件都满足，就会把 older 的对象添加到 RS 中。每个对象的 header 都有一位表示其是否存在于 RS 中，所以可以保证 RS 的内元素的唯一性，这样可以缩短扫描 RS 的时间。</p><p>这种方式的主要弊端是 RS 里面的所有对象在 GC 时，需要全部扫描一边，这对于下面两种情况来说成本是比较高的：</p><ol><li>younger 里面的一对象可能被多个 older 里的对象引用，这会导致不必要的重复检查</li><li>RS 里面的对象在回收 older 时需要再被扫描一边，这里面有一些大对象时情况会更严重</li></ol><h3 id="Page-Marking"><a href="#Page-Marking" class="headerlink" title="Page Marking"></a>Page Marking</h3><p><a href="https://en.wikipedia.org/wiki/David_A._Moon" target="_blank" rel="noopener">Moon</a> 在为 Symbolics Lisp machine 开发的 <a href="https://news.ycombinator.com/item?id=13225876" target="_blank" rel="noopener">Ephemeral GC</a> 中采用了另一种 pointer-recording 方式。这种方式不去记录哪些对象中含有交叉引用，而是记录哪些「虚拟内存页（virtual memory pages）」里保存了交叉引用。采用页为记录单位避免了扫描特大对象的问题。虽然整个页还需要扫描，但成本对 <a href="https://en.wikipedia.org/wiki/Symbolics" target="_blank" rel="noopener">Symbolics</a> 公司生产的机器来说不是很大，这是因为：</p><ol><li>有特殊的 tag 支持，可以让检查代的操作非常快的完成</li><li>page 相对来说比较小</li></ol><p>但这种方式对于普通机器来说就要慢很多了，除了普通机器的 page 较大（一般4K）以及没有特殊的 tag 支持外，还需要能够「从头扫描任意页」，这也是比较困难的，Symbolics 机器是因为每个 machine word 都有一额外标志位，所有这个扫描才比较快。</p><h3 id="Word-Marking"><a href="#Word-Marking" class="headerlink" title="Word Marking"></a>Word Marking</h3><p><a href="https://www.linkedin.com/in/psobalvarro/" target="_blank" rel="noopener">Sobalvarro</a> 通过为普通机器适配 Moon 的 Page marking 算法，采用 word marking 策略，使用一个 bitmap 来记录哪些 machine word 有交叉引用，这就避免了扫描任意页的问题。<br>但这种方式最大的问题时对于大 heap 来说，bitmap 会比较大，需要占整个内存空间的1/3，bitmap 如果是一维线性数组的话会比较耗时。</p><h3 id="Card-Marking"><a href="#Card-Marking" class="headerlink" title="Card Marking"></a>Card Marking</h3><p>为了解决页太大、字太小的问题，Sobalvarro <a href="https://dspace.mit.edu/bitstream/handle/1721.1/6795/AITR-1417.pdf?sequence=2" target="_blank" rel="noopener">又提出</a>了一个中等大小的新单位，也就是 card。card 避免了 </p><ul><li>page 太大，造成需要额外遍历多余对象</li><li>word 大小，造成遍历 bitmap 过长</li></ul><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2PyJEqDmWBKNjSZFBXXXxUFXa_!!581166664.png" alt="card marking 示意图"><br>card marking 的一个问题是，即使 card 的开端不是一个对象的开端，也需要去扫描。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分代式 GC 由于其普适性，已经被多数语言所采纳，比如：</p><ul><li>JavaScript：<a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection" target="_blank" rel="noopener">V8</a>、<a href="https://hacks.mozilla.org/2014/09/generational-garbage-collection-in-firefox/" target="_blank" rel="noopener">SpiderMonkey</a></li><li><a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby" target="_blank" rel="noopener">Generational GC in Python and Ruby</a>，这里面有介绍 Python 如何使用分代来解决「循环引用」</li><li><a href="https://www.mono-project.com/docs/advanced/garbage-collector/sgen/" target="_blank" rel="noopener">Mono Generational GC</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html" target="_blank" rel="noopener">JVM Generations</a></li></ul><p>截止到这篇文章，<a href="/tags/gc/">GC 的理论知识</a>就告一段落，主要参考了 Wilson 的论文 <a href="https://www.cs.cmu.edu/~fp/courses/15411-f08/misc/wilson94-gc.pdf" target="_blank" rel="noopener">Uniprocessor Garbage Collection Techniques</a>。有很多细节点都没有涉及到，比如</p><ol><li>locality 在不同策略下的影响</li><li>一个对象包含数据部分与指针部分，如何识别出指针</li></ol><p>可能是 C 语言已经离我比较久远，需要重新拾起来才能更好理解不同 GC实现上的取舍，谁让现如今大多数编译器、运行时都是由 C/C++ 编写的呢？<br>不过我觉得最重要的一点就是意识到 GC 的技术是通过一代又一代大师的努力不断进化的，像 Cheney、Baker、Guy Steele。即便站在巨人肩膀上的我们，GC 这个话题也还有很多问题需要解决。<br>后面的文章会主要集中在 JVM 的 GC，包括原理、调优、实现细节，做到理论与实践相结合。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://wiki.c2.com/?GenerationalGarbageCollection" target="_blank" rel="noopener">http://wiki.c2.com/?GenerationalGarbageCollection</a></li><li><a href="https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html" target="_blank" rel="noopener">http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="http://www.hboehm.info/gc/complexity.html" target="_blank" rel="noopener">http://www.hboehm.info/gc/complexity.html</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://dl.acm.org/citation.cfm?id=36183" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=36183</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/blog/2018/08/04/incremental-gc&quot;&gt;上文&lt;/a&gt;介绍的增量式 GC 是对 mark 阶段的一大优化，可以极大避免 STW 的影响。本文将要介绍的分代式 GC 根据对象生命周期（后面称为 age）的特点来优化 GC，降低其性能消
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="GC" scheme="http://liujiacai.net/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出垃圾回收（三）增量式 GC</title>
    <link href="http://liujiacai.net/blog/2018/08/04/incremental-gc/"/>
    <id>http://liujiacai.net/blog/2018/08/04/incremental-gc/</id>
    <published>2018-08-04T14:00:34.000Z</published>
    <updated>2019-12-24T10:59:14.612Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/blog/2018/07/08/mark-sweep/">上一篇文章</a>中介绍的 MS 优化策略都是围绕 sweep 阶段展开，但 mark 阶段会导致应用程序挂起，也就是常说的：stop-the-world（STW），这严重影响了 Tracing GC 的应用场景。本文即将介绍的增量式 GC 可以大大缓解 STW 问题。</p><p>阅读本文需要读者熟悉<a href="/blog/2018/07/08/mark-sweep/#术语">前文提及的术语</a>。</p><h2 id="增量式-GC-思路"><a href="#增量式-GC-思路" class="headerlink" title="增量式 GC 思路"></a>增量式 GC 思路</h2><p>增量式（incremental）GC 顾名思义，允许 collector 分多个小批次执行，每次造成的 mutator 停顿都很小，达到近似实时的效果。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2QgDSJASWBuNjSszdXXbeSpXa_!!581166664.png" alt="STW vs 增量式"></p><p>引用计数类 GC 本身就具有增量式特性，但由于其算法自身的<a href="/blog/2018/06/15/garbage-collection-intro/#引用计数（Reference-counting）">缺陷与效率问题</a>，一般不会采用。而追踪类 GC 实现增量式的难点在于：</p><blockquote><p>在 collector 遍历引用关系图，mutator 可能会改变对象间的引用关系</p></blockquote><p>这其实是一个并发问题，collector 线程与 mutator 线程同时去读/写一些共享的数据结构（引用关系图），这就要求把它保护起来，使 collecotr 与 mutator 能够感知其改变，并作出相应调整。<br>在 GC 期间，对 mutator 改变「引用关系图」的保守度（conservatism）是增量式 GC 一大特性。如果 mutator 在 collector 遍历某对象后将其释放（floating garbage），那么这个对象在本次 GC 不会被回收，但在下一轮 GC 开始时会被回收。<br>这种弱一致性（relaxed consistency）是允许的，因为它不会对程序逻辑造成影响，只是延迟了垃圾对象的回收，而且一致性越弱，遍历算法的实现就可以更灵活。</p><h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><p><a href="http://www.memorymanagement.org/glossary/t.html#term-tri-color-marking" target="_blank" rel="noopener">三色标记（tricolor marking）</a>抽象屏蔽了 GC 实现的算法（MS/Copying）、遍历策略（宽度优先/深度优先）等细节，对于理解增量式 GC 十分有帮助。具体来说是在 GC 遍历引用关系图时，对象会被标为三种颜色：</p><ol><li>黑色black，表明对象被 collector 访问过，属于可到达对象</li><li>灰色gray，也表明对象被访问过，但是它的子节点还没有被 scan 到</li><li>白色white，表明没有被访问到，如果在本轮遍历结束时还是白色，那么就会被收回</li></ol><p>对于 MS 来说，设置标记位就是着色的过程：有 mark-bit 的即为黑色。对 Copying GC 来说，把对象从 fromspace 移动到 tospace 就是着色过程：在 fromspace 中不可到达的对象为白色，被移动到 tospace 的对象为黑色。<br>对于增量时 GC 来说，需要在黑白之间有个中间状态来记录「那些之前被 collector 标记黑色，后来又被 mutator 改变的对象」，这就是灰色的作用。<br>对于 MS 来说，灰色对象是用于协助遍历 queue 里面的对象，即<a href="/blog/2018/07/08/mark-sweep/#MS-基本流程">上文中描述的 worklist 里面</a>的对象。对于 Copying GC 来说，灰色对象就是那些在 topspace 中还没被 scan 的对象，如果采用 <a href="/blog/2018/07/08/mark-sweep/#Cheney-算法">Cheney 的宽度优先遍历算法</a> ，那么就是 scan 与 free 指针之间的对象。</p><p>增加的中间状态灰色要求 mutator 不会把黑色对象直接指向白色对象（这称为三色不变性 tri-color invariant），collector 就能够认为黑色对象不需要在 scan，只需要遍历灰色对象即可。</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB24SYJIVuWBuNjSszbXXcS7FXa_!!581166664.png" alt="违法三色不变性的一个例子"></p><p>上图描述了一个违法着色不变性的情况。假设 A 已经被完全地 scan，它本身被标为黑色，字节点被标为灰色，现在假设 mutator 交换了 A–&gt;C 与 B–&gt;D 的指针，现在指向 D 的指针只有 A，而 A 已经被完全地 scan 了，如果继续 scan 过程的话，B 会被置为黑色，C 会被重新访问，而 D 则不会被访问到，在本轮遍历后，D 由于是白色，会被错误的认为是垃圾并被回收掉。</p><h2 id="增量策略"><a href="#增量策略" class="headerlink" title="增量策略"></a>增量策略</h2><p>为了解决上面的问题，一般有两类方式来协调 mutator 与 collector 的行为：</p><ol><li>读屏障（read barrier），它会禁止 mutator 访问白色对象，当检测到 mutator 即将要访问白色对象时，collector 会立刻访问该对象并将之标为灰色。由于 mutator 不能访问指向白色对象的指针，也就无法使黑色对象指向它们了</li><li>写屏障（write barrier），它会记录下 mutator 新增的由黑色–&gt;白色对象的指针，并把该对象标为灰色，这样 collector 就又能访问有问题的对象了</li></ol><p>读/写屏障本质是一些同步操作——在 mutator 进行某些操作前，它必须激活 collector 进行一些操作。<br>在实际应用中，调用 collector 只需要一些简单的操作，compiler 可以在输出 mutator 机器码（machine code）的同时，额外输出一些指令（instructions），在进行读/写指针时，会额外执行这些指令。根据读/写屏障复杂度，整个屏障操作可以内联（inline），也可以是个额外的过程调用（out of line procedure call）。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>如果要使 collector 错误地回收可到达对象，mutator 必须做到以下两点（缺一不可）：</p><ol><li>把指向白色对象的指针存储在一黑色对象中。称为条件1</li><li>在 collector 访问该白色对象之前，破坏指向它的原有指针。称为条件2</li></ol><p>写屏障也从这两个方面入手，下面分别阐述。</p><h4 id="Incremental-Update"><a href="#Incremental-Update" class="headerlink" title="Incremental Update"></a>Incremental Update</h4><p>Incremental Update 算法（后面简写IU）避免条件1的发生。IU 最常用的实现是由 Dijkstra 提出<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，该算法核心思想阐述如下：</p><blockquote><p>它会启发式（或者说是保守式）保留在 GC 遍历结束时 live 的对象。在遍历期死亡的对象（该对象还没被遍历到），不会再被访问、标记。</p></blockquote><p>为了避免指向白色对象的指针被隐藏在黑色对象中，这些指针在存储到黑色对象中时会被捕捉到，这时会把白色对象重新置为灰色，这个过程会一直迭代下去，直到没有灰色对象为止。</p><p>新创建的对象在 Dijkstra 算法中会被乐观的认为是白色，这是该算法的一大优势，因为大多数对象的生命周期都比较短。如果在 GC 遍历到它们之前就已经不可到达，这就意味着它们永远不用访问了。</p><p><a href="https://www.cs.utexas.edu/users/mckinley/395Tmm/talks/Mar-23-CMS.pdf" target="_blank" rel="noopener">Guy Steele 提出的算法</a>中建议采用一种启发性方式，部分新对象是白色，部分是黑色，来保证短生命周期的对象尽快被回收的同时，避免遍历长生命周期的对象。但这种方式是否更有效不能很好证明。</p><p>在 Steele 算法中，如果指向白色对象的指针被储存在了黑色对象内，会把黑色对象变为灰色。Dijkstra 采用的方式与这种方式相比，显得更保守些，因为那些白色对象很有可能会在再次变为白色。这里举一实际例子进行说明：</p><blockquote><p>假设程序使用一由双向链表实现的 stack 来存储数据，GC 遍历到栈顶元素，并将其标为黑色，这时程序进行一些 push/pop 操作，按照 Dijkstra 算法，pop 出来的所有元素会依次被标为灰色，那么就意味着在本次 GC 时不会被回收；而按照 Steele 算法，则有可能回收掉大部分 pop 出来的元素。</p></blockquote><h4 id="Snapshot-at-beginning"><a href="#Snapshot-at-beginning" class="headerlink" title="Snapshot at beginning"></a>Snapshot at beginning</h4><p>Snapshot at beginning（后面简写 SAB）算法避免条件2的发生。该算法在开始 GC 之前，会使用 copy-on-write 的方式复制一份当时的引用关系图。也就是说，在 GC 开始时引用关系图是固定的。<br>该算法最为人所知的实现由 Yuasa 提出，在该实现中，如果改变某个指针的地址，那么之前的地址会被加入一 marking stack，便于后面再次检查，这样就可以保证在 GC 时，所有的对象都会被遍历到，即使指向它们的指针发生了改变。拿上面三色标记举例来说，B–&gt;D 的指针会被保存在一个 stack 中。</p><h3 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h3><p>目前来说，最有名的实时性 GC 是 Baker 提出的增量式复制（incremental copying）GC。</p><h4 id="Incremental-Copying"><a href="#Incremental-Copying" class="headerlink" title="Incremental Copying"></a>Incremental Copying</h4><p>Baker’s GC 大部分逻辑与 <a href="/blog/2018/07/08/mark-sweep/#Copying-GC">Copying GC</a> 相似，使用 Cheney 的宽度优先算法遍历引用关系图，把所有引用的对象拷贝到 topspace 的 scan 指针处。但这个过程是与mutator并行的，而且 mutator 为了保证引用关系图的一致性，也可能会触发拷贝操作。下面具体阐述该算法工作流程：</p><ol><li>GC 开始时会有一个原子性的 flip 过程，会把由 root set 可直接到达的对象由 fromspace 拷贝到 tospace</li><li>mutator 恢复执行，与 collector 交替执行</li><li>当 mutator 访问到 fromspace 中的对象时，立刻将之拷贝到 topspace 中。这个 copy-on-demand 使用 read-barrier 来保证</li></ol><p>Barker 算法一个重要特点是：在增量回收时，新分配的对象直接分配在 tospace，当作已遍历对象，也就是三色标记中的黑色。为保证 GC 能在内存耗尽前发现所有可到达对象并复制到 tospace，复制的速率与分配对象的速率息息相关。</p><h4 id="Non-copying—Treadmill"><a href="#Non-copying—Treadmill" class="headerlink" title="Non-copying—Treadmill"></a>Non-copying—Treadmill</h4><p>Baker 在1991年对其增量式算法提出了 <a href="http://home.pipeline.com/~hbaker1/NoMotionGC.html" target="_blank" rel="noopener">non-copying 版本</a>，称为 Treadmill。Treadmill 使用双向链表来区别不同颜色的对象集合，这样就可以通过修改指针来避免移动对象与更新指针的操作。不同集合首尾相连形成环结构，便于对象的转化。如下图：</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB26SaYnXkoBKNjSZFEXXbrEVXa_!!581166664.png" alt="Treadmill 示意图"></p><p>该环结构分为四个区域：</p><ol><li>new 区。在 GC 期间的对象分配在这里，默认为黑色。在 GC 开始时，该区为空</li><li>from 区。对应 fromspace，GC 开始前对象分配区域</li><li>to 区。对应 tospace。在 GC 开始时，该区为空</li><li>free 区。与 new、from 区相连，别于分配新对象</li></ol><p>GC 工作过程与之前方式相似，再将 from 区对象连接到 to 区后，遍历 to 区里面的灰色对象，直到全部为黑色时GC结束。然后，new 与 to 合并后形成新 to 区，from 与 free 合并形成新的 free 区。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>如果没有特殊的硬件支持，写屏障一般来说效率要高于读屏障，主要原因是：</p><blockquote><p>heap 指针的读操作要多于写操作</p></blockquote><p>其中比较特别的是 Lisp Machine 有特殊的硬件支持重定向指针（forwording pointer），可以在不进行 forward 检测的前提下，交替使用新旧两个地址。<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p><p>关于两类屏障在实现细节上的更多差异这里暂且跳过，感兴趣的读者可以重点参考下面这篇论文</p><ul><li><a href="http://www.cs.colorado.edu/department/publications/reports/docs/CU-CS-494-90.pdf" target="_blank" rel="noopener">《Barrier Methods for Garbage Collection》 Benjamin Zorn 1990</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截止到这里，追逐类 GC 的优化基本都涉及到了，可以参考下面这张 GC 衍化图进行回顾反思：</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB28nozJXGWBuNjy0FbXXb4sXXa_!!581166664.png" alt="GC 衍化图"></p><p>可以看到，在右下角还剩下一个 Generational 没有涉及，这也是现代 GC 的必备优化，不过这是下一篇文章的内容了。Stay Tuned！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.heroku.com/incremental-gc" target="_blank" rel="noopener">https://blog.heroku.com/incremental-gc</a></li><li><a href="http://xiao-feng.blogspot.com/2007/04/incremental-update-tracing-vs-snapshot.html" target="_blank" rel="noopener">http://xiao-feng.blogspot.com/2007/04/incremental-update-tracing-vs-snapshot.html</a></li><li><a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cheney%27s_algorithm</a></li><li><a href="http://www.memorymanagement.org/glossary/f.html#glossary-f" target="_blank" rel="noopener">http://www.memorymanagement.org/glossary/f.html#glossary-f</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html" target="_blank" rel="noopener">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.iecc.com/gclist/GC-algorithms.html" target="_blank" rel="noopener">https://www.iecc.com/gclist/GC-algorithms.html</a> forwarding-pointer 词条</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;/blog/2018/07/08/mark-sweep/&quot;&gt;上一篇文章&lt;/a&gt;中介绍的 MS 优化策略都是围绕 sweep 阶段展开，但 mark 阶段会导致应用程序挂起，也就是常说的：stop-the-world（STW），这严重影响了 Tracing
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="GC" scheme="http://liujiacai.net/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</title>
    <link href="http://liujiacai.net/blog/2018/07/08/mark-sweep/"/>
    <id>http://liujiacai.net/blog/2018/07/08/mark-sweep/</id>
    <published>2018-07-08T04:26:31.000Z</published>
    <updated>2019-12-24T10:59:14.612Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文中介绍的追踪类（tracing）GC 较引用计数（Reference Counting）<a href="/blog/2018/06/15/garbage-collection-intro/#引用计数（Reference-counting）">性能更高</a>，但原生的追踪类 GC 也有其自身缺点，需要对其进行改造才能真正的名副其实。这篇文章就来介绍与之相关的内容。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>为了后面叙述方便，首先明确以下几个名词的含义：</p><ul><li>Collector，用于进行垃圾回收的线程</li><li>Mutators，应用程序的线程，可以修改 heap</li><li>MS，mark-sweep 算法的简写</li><li>MC，mark-compact 算法的简写</li><li>RC，reference-counting 的简写</li><li>liveness，一个对象的可到达性</li><li>引用关系图，由可到达对象引用形成的图结构</li><li>locality，现代CPU在访问内存时，有多级缓存。缓存以 cache line （一般64字节）为最小操作单位，所以当访问内存中连续的数据时会比较高校，这称为 locality</li></ul><h2 id="MS-基本流程"><a href="#MS-基本流程" class="headerlink" title="MS 基本流程"></a>MS 基本流程</h2><p>首先来回顾下追踪类 GC 最基本的 <a href="/blog/2018/06/15/garbage-collection-intro/#基本算法-mark-and-sweep">mark-and-sweep 算法</a> ：先扫描整个 heap，标出可到达对象，然后执行 sweep 操作回收不可到达对象。这个算法本身比较简单，下面给出其实现伪代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutator 通过 new 函数来申请内存</span></span><br><span class="line"><span class="keyword">new</span>():</span><br><span class="line">    <span class="keyword">ref</span> = allocate()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">ref</span> == <span class="literal">null</span></span><br><span class="line">        collect()</span><br><span class="line">        <span class="keyword">ref</span> = allocate()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">ref</span> == <span class="literal">null</span></span><br><span class="line">            error <span class="string">"Out of memory"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ref</span></span><br><span class="line"></span><br><span class="line"><span class="function">atomic <span class="title">collect</span>(<span class="params"></span>):  <span class="comment">// 这里 atomic 表明 gc 是原子性的，mutator 需要暂停</span></span></span><br><span class="line"><span class="function">    <span class="title">markFromRoots</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    <span class="title">sweep</span>(<span class="params">heapStart, heapEnd</span>)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="title">markFromRoots</span>(<span class="params"></span>):</span></span><br><span class="line"><span class="function">    <span class="title">initialize</span>(<span class="params">worklist</span>)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> each reference <span class="keyword">in</span> Roots  <span class="comment">// Roots 表示所有根对象，比如全局对象，stack 中的对象</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="keyword">ref</span> !</span>= <span class="literal">null</span> &amp;&amp; !isMarked(reference)</span><br><span class="line">            setMarked(reference)</span><br><span class="line">            <span class="keyword">add</span>(worklist, reference)</span><br><span class="line">            mark()          <span class="comment">// mark 也可以放在循环外面</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">initialize():</span><br><span class="line">    <span class="comment">// 对于单线程的collector 来说，可以用队列实现 worklist</span></span><br><span class="line">    worklist = emptyQueue()</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 worklist 是队列，那么 mark 采用的是 BFS（广度优先搜索）方式来遍历引用树                </span></span><br><span class="line">mark():</span><br><span class="line">    <span class="keyword">while</span> !isEmpty(worklist):</span><br><span class="line">        <span class="keyword">ref</span> = <span class="keyword">remove</span>(worklist)  <span class="comment">// 从 worklist 中取出第一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">for</span> each field <span class="keyword">in</span> <span class="title">Pointers</span>(<span class="params"><span class="keyword">ref</span></span>)  <span class="comment">// Pointers(obj) 返回一个object的所有属性，可能是数据，对象，指向其他对象的指针</span></span></span><br><span class="line"><span class="function">            child</span> = *field</span><br><span class="line">            <span class="keyword">if</span> child != <span class="literal">null</span> &amp;&amp; !isMarked(child)</span><br><span class="line">                setMarked(child)</span><br><span class="line">                <span class="keyword">add</span>(worklist, child)</span><br><span class="line">                </span><br><span class="line">sweep(start, end):</span><br><span class="line">    scan = start</span><br><span class="line">    <span class="keyword">while</span> scan &lt; end</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">isMarked</span>(<span class="params">scan</span>)</span></span><br><span class="line"><span class="function">            <span class="title">unsetMarked</span>(<span class="params">scan</span>)</span></span><br><span class="line"><span class="function">        else</span></span><br><span class="line"><span class="function">            <span class="title">free</span>(<span class="params">scan</span>)</span></span><br><span class="line"><span class="function">        scan</span> = nextObject(scan)</span><br></pre></td></tr></table></figure><p>通过上面伪代码描述，不难得出 MS 有以下问题：</p><ol><li>heap 容易出现碎片</li><li>破坏引用本地性（由于对象不会被移动，存活的对象与空闲空间交错在一起）</li><li>GC 时间与 heap 空间大小成正比</li><li>在进行 GC 期间，整个系统会被挂起，即stop-the-world</li></ol><p>需要说明一点，RC 类 GC 同样有前两个问题，但是对于 RC 来说，并没有好的优化措施来缓解。下面我们就来看追踪类 GC 是如何解决上述问题。</p><h2 id="优化MS"><a href="#优化MS" class="headerlink" title="优化MS"></a>优化MS</h2><h3 id="Bitmap-marking"><a href="#Bitmap-marking" class="headerlink" title="Bitmap marking"></a>Bitmap marking</h3><p>在 mark 过程中，需要去标记（mark-bits）对象的 liveness，有两种方式来实现：</p><ol><li>在每个对象的header部分（in-object mark-bit）</li><li>使用一个单独的 bitmap，每一位 bit 对应一个对象</li></ol><p>两种方式各有利弊，需要结合具体场景进行分析。In-object mark-bit 是最直接的方式，对于 JVM/.NET 运行时来说，每个 object 都会有 header，使用这种方式也就理所应当了；<br>对于 bitmap 来说，需要在 bit 位与 object 之间进行映射，这就要求 object 进行对齐，比如：heap 大小为 65536 字节，所有的对象以 16 字节对齐，那么堆内就有 4096 个地址可以作为对象的起始地址，与之对应需要 4096 个 bit 即 512 个字节。除此之外，bitmap 还有下面两个优势：</p><ol><li>sweep 操作更高效，这是由于 bitmap 结构紧凑，可以一次性加载到内存中；通过整型的 ALU 操作与<a href="https://en.wikipedia.org/wiki/Branch_%28computer_science%29" target="_blank" rel="noopener">条件分支（conditional branch）</a> 一次性可进行 32 位的检测</li><li>在类 Unix 系统中，bitmap 有利于 fork() 出来的进程与主进程进行 copy-on-write 数据共享，<a href="http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0#" target="_blank" rel="noopener">Ruby 2.0 就因此获得较大性能提升</a>。</li></ol><p>下面给出 bitmap 方式的伪代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mark():</span><br><span class="line">    cur = nextInBitmap()</span><br><span class="line">    <span class="keyword">while</span> cur &lt; heapEnd</span><br><span class="line">        <span class="keyword">add</span>(worklist, cur)</span><br><span class="line">        markStep(cur)</span><br><span class="line">        cur = nextInBitmap()</span><br><span class="line">        </span><br><span class="line">markStep(start):</span><br><span class="line">    <span class="keyword">while</span> !isEmpty():</span><br><span class="line">        <span class="keyword">ref</span> = <span class="keyword">remove</span>(worklist)</span><br><span class="line">        <span class="function"><span class="keyword">for</span> each field <span class="keyword">in</span> <span class="title">Pointers</span>(<span class="params"><span class="keyword">ref</span></span>):</span></span><br><span class="line"><span class="function">            child</span> = *field</span><br><span class="line">            <span class="keyword">if</span> child != <span class="literal">null</span> &amp;&amp; !isMarked(child)</span><br><span class="line">                setMarked(child)</span><br><span class="line">                <span class="keyword">if</span> child &gt; start         <span class="comment">//这里与之前不同，只需要把高于当前地址的子节点加入到 worklist 即可</span></span><br><span class="line">                    <span class="keyword">add</span>(worklist, child)</span><br></pre></td></tr></table></figure></p><h3 id="Lazy-sweeping"><a href="#Lazy-sweeping" class="headerlink" title="Lazy sweeping"></a>Lazy sweeping</h3><p>MS 算法有以下几个特点：</p><ol><li>某对象一旦被标为garbage，它永远都会是 garbage，不会被 mutator 再访问</li><li>mutator 不能修改 mark-bit</li></ol><p>基于以上几点，sweep 操作完全可以与 mutator 同时运行（parallel）的。<br>Lazy sweep 指的是把较为耗时（相对 mark 来说）的 sweep 操作放在 allocate 过程中，并且只在有足够的空间时才去真正进行回收。<a href="https://www.infoq.com/news/2011/08/ruby193-gc" target="_blank" rel="noopener">Ruby 1.9.3 引入 lazy sweep 获得较大性能提升</a>。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">atomic collect():</span><br><span class="line">    markFromRoots()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">block</span> <span class="keyword">in</span> Blocks  <span class="comment">// 这里以 block 为单位管理更高效</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isMarked(<span class="keyword">block</span>)</span><br><span class="line">            <span class="keyword">add</span>(blockAllocator, <span class="keyword">block</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">add</span>(reclaimList, <span class="keyword">block</span>)    <span class="comment">// 把待回收的 block 放入队列中延迟回收</span></span><br><span class="line">            </span><br><span class="line">atomic allocate(sz):</span><br><span class="line">    <span class="keyword">result</span> = <span class="keyword">remove</span>(sz)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">result</span> = null</span><br><span class="line">        lazySweep(sz)</span><br><span class="line">        <span class="keyword">result</span> = <span class="keyword">remove</span>(sz)</span><br><span class="line">    return <span class="keyword">result</span></span><br><span class="line">    </span><br><span class="line">lazySweep(sz):</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">block</span> = nextBlock(reclaimList, sz)  <span class="comment">// 这里需要分配一个 sz 大小的 block，可见 block 需要按大小 group 起来管理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">block</span> != null</span><br><span class="line">            sweep(start(<span class="keyword">block</span>), <span class="keyword">end</span>(<span class="keyword">block</span>))</span><br><span class="line">            <span class="keyword">if</span> spaceFound(<span class="keyword">block</span>)</span><br><span class="line">                return</span><br><span class="line">    <span class="keyword">until</span> <span class="keyword">block</span> == null</span><br><span class="line">    allocSlow(sz)</span><br><span class="line">    </span><br><span class="line">allocSlow(sz):</span><br><span class="line">    <span class="keyword">block</span> = allocateBlock(sz)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">block</span> != null</span><br><span class="line">        init(<span class="keyword">block</span>)</span><br></pre></td></tr></table></figure><p>Lazy Sweep 除了降低 sweep 阶段 mutator 的暂停时间外，还有以下优点：</p><ul><li>更好的 locality。这是因为被回收的 block 会尽快地重新使用</li><li>GC 复杂度只于<strong>可到达对象</strong>成正比</li><li>在大部分 heap 空间为空时效率最好</li></ul><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><p>除了上面介绍的两类优化，比较新的优化手段还有如下几个：</p><ul><li>FIFO prefetch buffer [Cher et al, 2004]</li><li>Edge marking [Garner et al, 2007]</li></ul><p>鉴于篇幅原因，这里不再讲述，感兴趣的读者可自行搜索。</p><h2 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h2><p>上面优化的措施虽然能提高 MS 性能，但都无法解决 heap 碎片问题，这就需要新的算法去解决。</p><h3 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h3><p>MC 算法与 MS 类似，先是一个 mark 过程标记可到达对象，这里取代 sweep 的是一个 compact，工作流程如下：</p><ol><li>重新安排（relocate）可到达对象</li><li>更新指向可到达对象的指针</li></ol><p>关于第一步中的安排策略，一般有如下三种选择：</p><ol><li>任意（Arbitrary）。特点是快，但是空间的 locality 较差</li><li>线性（Linearising）。重新分配到附近有关系的（siblings/pointer/reference…）对象周边</li><li>滑动（Sliding）。所有活对象被滑动到 heap 的一端，保证原有顺序，这有利于改善 locality 的情况。这是现在采用较多的方案</li></ol><p>对于采用 MC 的系统，allocate 过程就变得较为简单，只需要bump pointer 即可。<br>但是这类算法需要多次遍历对象，第一次遍历算出对象将要移动到的新位置，接下来的遍历来真正移动对象，并更新指针，所以MC相对MS要更耗时，这在 heap 较大时更为明显。<br>这里比较有名的是 Edward 的 Two-pointer 压缩算法。大致过程如下：</p><ol><li>在 heap 两端各准备一指针，由外向内 scan 寻找可压缩的对象</li><li>自顶向下的指针寻找可到达对象，自底向上的指针寻找 heap 中的“洞”来存放可到达对象</li></ol><p>关于这个算法还有很多变种，这里不在讲述，感兴趣可以自行搜索：</p><ul><li>Threaded compaction [Jonkers, 1979]</li><li>One pass algorithms [Abuaiadh et al, 2004,Kermany and Petrank, 2006]</li></ul><h3 id="Copying-GC"><a href="#Copying-GC" class="headerlink" title="Copying GC"></a>Copying GC</h3><p>MC 算法虽然能解决内存碎片问题，但是需要多次遍历heap空间，这会导致较大性能损耗，Copying GC 采用空间换时间的方式来提升性能。<br>这类 GC 并不会真正去“回收”不可到达对象，而是会把所有可到达对象移动到一个区域，heap 中剩余的空间就是可用的了（因为这里面都是垃圾）。这里并没有进行 sweep/compact，而是用 scavenging（净化） 来描述回收这一过程。</p><h4 id="Semispace-collector"><a href="#Semispace-collector" class="headerlink" title="Semispace collector"></a>Semispace collector</h4><p>Copying GC 典型的代表半空间回收器（semispace collector）。其工作过程是这样的：</p><ol><li>heap 被分成2份相邻的空间（semispace）：fromspace 与 tospace</li><li>在程序运行时，只有 fromspace 会被使用（分配新对象）</li><li>在 fromspace 没有足够空间容纳新对象时，程序会被挂起，然后把 fromspace 的可到达对象拷贝到 tospace</li><li>在拷贝完成时，之前的2个空间交换身份，tospace 成了新一轮的 fromspace</li></ol><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2XvQXuS8YBeNkSnb4XXaevFXa_!!581166664.png" alt="semispace 示意图"></p><h4 id="Cheney-算法"><a href="#Cheney-算法" class="headerlink" title="Cheney 算法"></a>Cheney 算法</h4><p><a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm" target="_blank" rel="noopener">Cheney 算法</a>是用来解决如何遍历引用关系图，将之移动到 tospace 的算法，其步骤如下：</p><ol><li>所有可直接到达的对象组成一队列，作为宽度优先遍历的起点，同时有两个辅助指针：scan 指针指向起始位置，free 指针指向末尾</li><li>通过移动 scan 来依次遍历队列，当 scan 的对象存在指向 fromspace 中对象的指针时，把被指向的对象添加到队列末端，同时更新指针，使之指向新对象；</li><li>更新 free 使之始终指向队列末尾，重复步骤2</li><li>当 scan 移动到队列末尾时，算法结束</li></ol><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2hTZWC1ySBuNjy1zdXXXPxFXa_!!581166664.png" alt="Cheney 宽度优先遍历复制示意图"></p><p>如果按照上述算法操作，会把被指向多次的对象复制多次，所以在拷贝对象到 tospace 时，会在原始版本的对象上记录一个重定向指针（forwarding pointer），来标明这个对象已经被复制过了，并且告知新对象的位置；后面 scan 对象时，如果发现具有重定向指针的对象时就会跳过复制操作，直接更新指针就可以了。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">initialize():</span><br><span class="line">    <span class="attr">tospace</span> = N/<span class="number">2</span></span><br><span class="line">    <span class="attr">fromspace</span> = <span class="number">0</span></span><br><span class="line">    <span class="attr">allocPtr</span> = fromspace</span><br><span class="line">    <span class="attr">scanPtr</span> = whatever // 只在 collect 阶段使用</span><br><span class="line">    </span><br><span class="line">allocate(n):</span><br><span class="line">    <span class="keyword">if</span> allocPtr + n &gt; fromspace + N/<span class="number">2</span></span><br><span class="line">        collect()</span><br><span class="line">    <span class="keyword">if</span> allocPtr + n &gt; fromspace + N/<span class="number">2</span></span><br><span class="line">        fail <span class="string">"Insufficient memory"</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">o</span> = allocPtr</span><br><span class="line">    <span class="attr">allocPtr</span> = allocPtr + n</span><br><span class="line">    return o</span><br><span class="line">    </span><br><span class="line">atomic collect():</span><br><span class="line">    swap(fromspace, tospace)</span><br><span class="line">    <span class="attr">allocPtr</span> = fromspace</span><br><span class="line">    <span class="attr">scanPtr</span> = fromspace</span><br><span class="line">    </span><br><span class="line">    for each field <span class="keyword">in</span> Roots</span><br><span class="line">        copy(field)</span><br><span class="line">        </span><br><span class="line">    while scanPtr &lt; allocPtr:</span><br><span class="line">        for each reference <span class="keyword">in</span> o // scanPtr 指向 o</span><br><span class="line">            copy(reference)</span><br><span class="line">        <span class="attr">scanPtr</span> = scanPtr + o.size()</span><br><span class="line"></span><br><span class="line">copy(o):</span><br><span class="line">    <span class="keyword">if</span> hasForwardingAddress(o)</span><br><span class="line">        return forwardAddress(o)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        o' = allocPtr</span><br><span class="line">        <span class="attr">allocPtr</span> = allocPtr + o.size()</span><br><span class="line">        copy the contents of o to o'</span><br><span class="line">        forwardAddress(o) = o'</span><br></pre></td></tr></table></figure><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>通过上述描述，不难发现Copying GC 一最大缺点在于所需空间翻倍，不过现如今内存已经普遍较大，这个问题不是很严重。<br>其次，复制的效率于可到达对象成正比，如果每次 GC 时可到达对象相近，那么降低 GC 频率就会减少 GC 对程序的影响。如果降低 GC 频率呢？答案就是加大 semispace 空间，这样程序就需要更多的时间来填满它。</p><p>如果程序中有一些大对象体积（比如：大数组），且存活时间较长，那么这个复制操作对程序影响就会会比较严重，基于此，Baker 提出了一种衍化方案：Non-Copying Implicit GC</p><h4 id="Non-Copying-Implicit-GC"><a href="#Non-Copying-Implicit-GC" class="headerlink" title="Non-Copying Implicit GC"></a>Non-Copying Implicit GC</h4><p>这类 GC 从 Copying GC 衍化而来，巧妙之处在于，semispace 不必是物理上分割的空间，可以用两个用双向链表来表示，一般称为 ：from-set 与 to-set。为了实现这种策略，需要在每个对象上多加以下两个信息：</p><ul><li>两个指针，用来形成链表</li><li>一个flag，标明属于哪个集合</li></ul><p>当 from-set 耗尽时，只需遍历 from-set，把其中的可到达对象插入到 to-set，然后改变flag即可，复制操作变成了链表指针操作。这类 GC 的优势除了不用进行真正的拷贝外，还有下面两处优点：</p><ol><li>语言级别的指针不需要改变了（因为对象没动），这对编译器的要求更小了</li><li>如果一个对象不含有指针，那么就没必要 scan 了</li></ol><p>缺点当然也比较明显：</p><ul><li>每个对象需要而外的空间</li><li>碎片问题依旧</li></ul><p>所以这类 GC 虽然是 Copying GC 的优化，但也只适用于某些特定的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的介绍，觉得最重要的就是要分清一个算法的优势与劣势，软件工程里面没有「银弹」，都是有取舍的。<br>上面对 MS 算法的优化，基本都是在 sweep 阶段，mark 阶段没怎么改进。鉴于文章篇幅，将在下一篇中介绍 Incremental GC，来说明如何优化 mark 阶段；而且通过不断研究，前辈们总结出「大部分对象的生命周期较短」的特性，所以就延伸出了 Generational GC，这也将在下文中介绍。Stay Tuned！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.cs.tau.ac.il/~maon/teaching/2014-2015/seminar/seminar1415a-lec2-mark-sweep-mark-compact.pdf" target="_blank" rel="noopener">http://www.cs.tau.ac.il/~maon/teaching/2014-2015/seminar/seminar1415a-lec2-mark-sweep-mark-compact.pdf</a></li><li><a href="https://the.gregor.institute/t/5n/842/slides/6.pdf" target="_blank" rel="noopener">https://the.gregor.institute/t/5n/842/slides/6.pdf</a></li><li><a href="https://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec26-gc/lec26.html" target="_blank" rel="noopener">https://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec26-gc/lec26.html</a></li><li><a href="https://stackoverflow.com/questions/23057531/what-are-the-advantages-and-disadvantages-of-having-mark-bits-together-and-separ" target="_blank" rel="noopener">https://stackoverflow.com/questions/23057531/what-are-the-advantages-and-disadvantages-of-having-mark-bits-together-and-separ</a></li><li><a href="http://xiao-feng.blogspot.com/2007/11/better-bitmap-design-for-mark-sweep-gc.html" target="_blank" rel="noopener">http://xiao-feng.blogspot.com/2007/11/better-bitmap-design-for-mark-sweep-gc.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文中介绍的追踪类（tracing）GC 较引用计数（Reference Counting）&lt;a href=&quot;/blog/2018/06/15/garbage-collection-intro/#引用计数（Reference-counting）&quot;&gt;性能更高&lt;/a&gt;，但
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="GC" scheme="http://liujiacai.net/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出垃圾回收（一）简介篇</title>
    <link href="http://liujiacai.net/blog/2018/06/15/garbage-collection-intro/"/>
    <id>http://liujiacai.net/blog/2018/06/15/garbage-collection-intro/</id>
    <published>2018-06-15T13:28:41.000Z</published>
    <updated>2019-12-24T10:59:14.611Z</updated>
    
    <content type="html"><![CDATA[<p>GC 算法作为计算机科学领域非常热的研究话题之一，最早可追溯到 1959 年<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，由 John McCarthy 在 Lisp 中实现来简化内存管理。早期的 Lisp 之所以被大众诟病慢，主要原因就是当时的 GC 实现相对简单，对程序的影响（overhead）比较严重。经过几十年的发展，GC 算法已经很成熟了，可以完全摆脱「速度慢」这个让人望而却步的标签。</p><p>单就 JVM 这个平台来说，GC 算法一直在优化、演变，从最初的串行到高吞吐量的并行，为了解决高延迟又演化出了 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank" rel="noopener">CMS（Concurrent Mark Sweep）</a>，为了解决碎片问题，又开发了 <a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">G1</a>，Oracle 内部还在不断尝试新算法，比如 <a href="http://openjdk.java.net/projects/zgc/" target="_blank" rel="noopener">ZGC</a>。</p><p>对于这么一个庞大但有趣的话题，我决定写一系列文章来介绍，首先会介绍 GC 的必要性、常见回收策略，这些是语言无关的；然后会重点介绍 JVM 上的 GC 实现；再之后会对现较为流行的脚本语言（js/python/ruby）所用的 GC 算法做一些探索。每个语言在实现 GC 算法时都有其独特之处，所以最后希望能深入到源代码级别，做到真正的深入浅出（inside out）。我所参考的资料主要来自 wikipedia 以及一些前辈的总结（Google 检索），当然对于能实践的部分我会给上相关测试代码。</p><p>所以如果读者发现文中有错误，麻烦指出，我会及时更新，保证不对后面学习者产生误导。好了，进入正题。</p><h2 id="为什么需要-GC"><a href="#为什么需要-GC" class="headerlink" title="为什么需要 GC"></a>为什么需要 GC</h2><p>在计算机诞生初期，在程序运行过程中没有栈帧（stack frame）需要去维护，所以内存采取的是静态分配策略，这虽然比动态分配要快，但是其一明显的缺点是程序所需的数据结构大小必须在编译期确定，而且不具备运行时分配的能力，这在现在来看是不可思议的。在 1958 年，Algol-58 语言首次提出了<a href="https://en.wikipedia.org/wiki/Block_%28programming%29" target="_blank" rel="noopener">块结构（block-structured）</a>，块结构语言通过在内存中申请栈帧来实现按需分配的动态策略。在过程被调用时，帧（frame）会被压到栈的最上面，调用结束时弹出。栈分配策略赋予程序员极大的自由度，局部变量在不同的调用过程中具有不同的值，这为递归提供了基础。但是后进先出（Last-In-First-Out, LIFO）的栈限制了栈帧的生命周期不能超过其调用者，而且由于每个栈帧是固定大小，所以一个过程的返回值也必须在编译期确定。所以诞生了新的内存管理策略——堆（heap）管理。</p><p>堆分配运行程序员按任意顺序分配/释放程序所需的数据结构——动态分配的数据结构可以脱离其调用者生命周期的限制，这种便利性带来的问题是垃圾对象的回收管理。C/C++/Pascal 把这个任务交给了程序员，但事实证明这非常容易出错，野指针（wild pointer）、悬挂指针（dangling pointer）是比较典型的错误。在另一些场景中，动态分配的对象传入了其他过程中，这时程序员或编译器就无法预测这个对象什么时刻不再需要，现如今的面向对象语言，这种场景更是频繁，这也就间接促进了自动内存管理技术的发展。而且即便是 C/C++ ，也有类似 <a href="http://www.hboehm.info/gc/" target="_blank" rel="noopener">Boehm GC</a> 这样的第三方库来实现内存的自动管理。可以毫不夸张的说，GC 已经是现代语言的标配了。</p><h3 id="图灵机模型"><a href="#图灵机模型" class="headerlink" title="图灵机模型"></a>图灵机模型</h3><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2FiZbALuSBuNkHFqDXXXfhVXa_!!581166664.png" alt="假象中的图灵机"><br>现在的计算机相较图灵机，最本质的不同在于<strong>资源有限性</strong>，所以在使用完各种资源（memory/socket/file handler等）后，需要将其释放（release）。<br>GC 并不适应于 socket/file handler 等资源的回收，究其原因是 GC 的不确定性<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。比如，A 应用占用了 TCP 8080 端口，当其使用完后，GC 并不会立刻对其进行回收，这时如果 A 应用其它部分再使用这个 socket 时，程序就会报错。<br>也许有些 GC 系统在清理这些资源的引用时，回去将其释放（这称为finalization），但这同样具有不确定性，所以我们并不能依赖这些机制，需要显式对其回收（一般调用 close/destroy 方法）。内存适合于 GC 回收还有一重要原因：独占性。也就是说操作系统给每个运行的程序分配的内存是相互独立的，所以可以完全由 GC 来决定什么时刻去对其进行释放，只需保证在报 OutOfMemory 异常之前就可以了。</p><p>我们选择 GC 而不是手动释放资源的原因很简单：靠人来约束很容易出问题。当然对于实时性较高（炒股）、资源相对紧张（比如嵌入式设备）的程序，手工释放资源还是首选。</p><h2 id="GC-的定义"><a href="#GC-的定义" class="headerlink" title="GC 的定义"></a>GC 的定义</h2><p>上面一小节介绍了 GC 的对象是内存，但内存在一运行的程序中通常会划分为多个区域，其中最常见的是栈（stack） 与堆（heap）。栈的空间一般较小，在一个函数调用时用以分配其内部变量，在函数调用结束时自动回收，这里并不涉及到 GC；而堆的空间一般较大，可以在多个函数间共享数据，程序可根据需要进行<strong>动态申请</strong>，GC 主要是工作在这个区域。所以我们可以这么定义 GC：</p><blockquote><p>GC 是一种自动管理内存的技术，用来回收（释放） heap 中不再使用的对象。</p></blockquote><p>GC 过程中涉及到两个阶段：</p><ol><li>区分活对象（live object）与垃圾对象（garbage）</li><li>回收垃圾对象的内存，使得程序可以重复使用这些内存</li></ol><h2 id="GC-常用策略"><a href="#GC-常用策略" class="headerlink" title="GC 常用策略"></a>GC 常用策略</h2><h3 id="追踪（Tracing）"><a href="#追踪（Tracing）" class="headerlink" title="追踪（Tracing）"></a>追踪（Tracing）</h3><p>这是目前使用范围最广的技术，一般我们提到 GC 都是指这类，实现这种机制的系统有：JVM/.NET/OCaml。<br>这类 GC 从某些被称为 root 的对象开始，不断追踪可以被引用到的对象，这些对象被称为<strong>可到达的</strong>（reachable），其他剩余的对象就被称为 garbage，并且会被释放。</p><h4 id="对象的可到达行"><a href="#对象的可到达行" class="headerlink" title="对象的可到达行"></a>对象的可到达行</h4><p>一般来说，可到达的对象主要包含下面两类情况：</p><ol><li>root 对象，这包括全局对象、调用栈（call stack）上的对象（包括内部变量与参数）</li><li>从 root 对象开始，间接引用的对象</li></ol><p>采用可到达行来区分一个对象是否为 garbage 有一定的局限性，因为程序中真正使用一个对象时距其创建可能需要很久。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object x = <span class="keyword">new</span> Foo();</span><br><span class="line">Object y = <span class="keyword">new</span> Bar();</span><br><span class="line">x = <span class="keyword">new</span> Quux();</span><br><span class="line"><span class="comment">/* 这这里，x 之前为赋值的 Foo 对象以及不可到达，可以被 GC 回收</span></span><br><span class="line"><span class="comment"> * 这种情况称为： syntactic garbage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x.check_something()) &#123;</span><br><span class="line"> x.do_something(y);</span><br><span class="line">&#125;</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 在这里，y 是否能回收取决于 if 条件里面的函数执行结果，而这个函数可能会发生死循环或者返回false</span></span><br><span class="line"><span class="comment"> * 这种情况被称为： semantic garbage</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>要确定 semantic garbage 是否能被回收，需要去分析代码，这和<a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" rel="noopener">停机问题</a>类似，没有固定的算法；而对于 syntactic garbage，只需要分析引用链就可以了。</p><h4 id="强引用与弱引用"><a href="#强引用与弱引用" class="headerlink" title="强引用与弱引用"></a>强引用与弱引用</h4><p>追踪类 GC 使用引用来决定一个对象的可到达性，但是在程序中有时会希望能以弱引用的方式指向一个对象，弱引用不会保护该对象被 GC 回收。如果该对象被回收了，那么这个弱引用会被赋予一个安全值（一般为NULL）。使用弱引用可以解决很多问题，比如：</p><ul><li><a href="https://en.wikipedia.org/wiki/Reference_cycle" target="_blank" rel="noopener">循环引用</a></li><li>在 Map 中，如果允许 key 为弱引用，那么 GC 就可以回收用不到对象，而不会因为 Map 中的引用让其一直留在内存中，适用于做缓存</li></ul><p>在一些实现中，弱引用被分成了几个类别。比如在 JVM 中，提供了三类，soft、phantom、常规的弱引用，其区别可参考我之前的文章<a href="/blog/2015/09/27/java-weakhashmap/#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">Java WeakHashMap 源码解析</a>。</p><h4 id="基本算法-mark-and-sweep"><a href="#基本算法-mark-and-sweep" class="headerlink" title="基本算法 mark-and-sweep"></a>基本算法 mark-and-sweep</h4><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2mWTqqm8YBeNkSnb4XXaevFXa_!!581166664.gif" alt="Mark-and-Sweep 过程图示"></p><p>该算法主要包括两步，</p><ol><li>mark，从 root 开始进行树遍历，每个访问的对象标注为「使用中」</li><li>sweep，扫描整个内存区域，对于标注为「使用中」的对象去掉该标志，对于没有该标注的对象直接回收掉</li></ol><p>该算法的缺点有：</p><ol><li>在进行 GC 期间，整个系统会被挂起（暂停，Stop-the-world），所以在一些实现中，会采用各种措施来减少这个暂停时间</li><li>heap 容易出现碎片。实现中一般会进行 move 或 compact。（需要说明一点，所有 heap 回收机制都会这个问题）</li><li>在 GC 工作一段时间后，heap 中连续地址上存在 age 不同的对象，这非常不利于引用的本地化（locality of reference）</li><li>回收时间与 heap 大小成正比</li></ol><p>原始版的 mark-sweep 问题虽然比较多，但是有一系列的优化措施来解决（mark-compact/copying/non-copying..），后面会涉及到。</p><h3 id="引用计数（Reference-counting）"><a href="#引用计数（Reference-counting）" class="headerlink" title="引用计数（Reference counting）"></a>引用计数（Reference counting）</h3><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2arI8yv1TBuNjy0FjXXajyXXa_!!581166664.png" alt="Reference counting 过程图示"></p><p>引用计数类 GC 会记录每个对象的引用次数，当引用次数为0时，就会被回收，这类 GC 实现起来较为简单。采用这类 GC 的主流语言有：Python/PHP/<a href="https://stackoverflow.com/questions/2972021/garbage-collection-in-perl" target="_blank" rel="noopener">Perl</a>/TCL/Objective-C。<br>与追踪类 GC 相比，有以下两处优势：</p><ol><li>可以保证对象引用为0时立马得到清理，无不确定行</li><li>大多数操作具有增量特性（incremental），GC 可与应用交替运行，不需要暂停应用即可完成回收功能</li><li>可以用来优化运行时性能。比如函数式编程中所推崇的「<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可变数据结构</a>」的更新就能收益：运行时知道某个对象的引用为1，这时对这个对象进行修改，类似 <code>str &lt;- str+&quot;a&quot;</code>，那么这个修改就可以在本地进行，而不必进行额外的 copy</li></ol><p>除了上面介绍的优势，引用计数具有以下几处劣势：</p><ol><li>无法解决循环引用。CPython 使用独特的环检测算法规避<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>，后面文章再分析该算法；此外也可以用弱引用的方式解决</li><li>实现一个高效率的引用计数 GC 比较困难。主要包括下面两方面<ul><li>space overhead，每个对象需要额外的空间来存储其引用次数，在追踪类 GC 中，用以标注对象是否在使用中的flag 位一般放在引用变量里面</li><li>speed overhead，在增加/减少对象的引用时，需要修改引用次数。这对于栈上的赋值（on-stack assignment，比如函数调用是的参数、函数内部变量等）影响是非常大的，因为之前只需要简单修改寄存器里面的值，现在需要一个原子操作（这涉及到加锁，会浪费几百个 CPU cycles）<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></li></ul></li><li>减少一个对象的引用计数时，会级联减少其引用对象的计数，这就可能造成同时删除过多的对象。在实现中一般会把要回收的对象放入一队列，当程序申请大小为 N 的内存时，从这个队列取出总体积不小于 N 的一个或多个对象将其回收。</li></ol><p>由于以上缺陷，对性能要求较高的系统在实现 GC 时一般不会选择引用计数，而会转向追踪类（追踪类 GC 虽然有 stop-the-world 的问题，但是可以通过各种措施优化，后面会介绍到）。<br>但由于引用计数实现较为简单，除了用在 GC 领域，还广泛用在管理系统资源上。比如：大多数文件系统会维持特定文件/block的引用数（inode里面的link count），这些引用被称为 hard links。当引用数为0时，这个文件就可以被安全的删除了。</p><h3 id="逃逸分析（Escape-analysis）"><a href="#逃逸分析（Escape-analysis）" class="headerlink" title="逃逸分析（Escape_analysis）"></a>逃逸分析（Escape_analysis）</h3><p>这里主要是指通过逃逸分析，来将在 heap 中分配的对象分配到 stack 中。如果一个对象的使用只出现在某一函数内（即没有 escape），那么这个对象就完全可以分配在该函数的 stack 中，减少 GC 的工作量。</p><p>JVM 中有相关实现，后面文章也会涉及到，感兴趣的朋友可以先参考：</p><ul><li><a href="https://en.wikipedia.org/wiki/Java_performance#Escape_analysis_and_lock_coarsening" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Java_performance#Escape_analysis_and_lock_coarsening</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>「追踪」与「引用计数」这两类 GC 各有千秋，真正的工业级实现一般是这两者的结合，不同的语言有所偏重而已。可以参考下面几处提问：</p><ul><li><a href="https://www.quora.com/Why-doesnt-Apple-Swift-adopt-the-memory-management-method-of-garbage-collection-like-Java-uses" target="_blank" rel="noopener">Why doesn’t Apple Swift adopt the memory management method of garbage collection like Java uses?</a></li><li><a href="https://softwareengineering.stackexchange.com/questions/285333/how-does-garbage-collection-compare-to-reference-counting" target="_blank" rel="noopener">How does garbage collection compare to reference counting?</a></li><li><a href="https://www.quora.com/Why-doesnt-Java-use-reference-counting-based-GC" target="_blank" rel="noopener">Why doesn’t Java use reference counting based GC?</a></li></ul><p>总体来说，追踪类 GC 是效率最高的算法<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>，其变种也比较多，后面的文章也会重点讲述此类 GC，这里面有趣的内容非常多，比如：semispace（用以提高 sweep 的速度与减少内存碎片）、<a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm" target="_blank" rel="noopener">Cheney’s algorithm</a> / <a href="https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm" target="_blank" rel="noopener">Baker’s Algorithm</a>（这两算法都是对 semispace 的优化）、generational GC（减少 GC 作用范围）、incremental/concurrent GC（减少 stop-the-world 时间）。<br>Stay Tuned!</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29</a></li><li><a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reference_counting</a></li><li><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a></li><li><a href="http://www.goodmath.org/blog/2017/12/22/a-beginners-guide-to-garbage-collection/" target="_blank" rel="noopener">http://www.goodmath.org/blog/2017/12/22/a-beginners-guide-to-garbage-collection/</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://www.informit.com/articles/article.aspx?p=1671639" target="_blank" rel="noopener">http://www.informit.com/articles/article.aspx?p=1671639</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://cs.stackexchange.com/questions/52735/why-does-garbage-collection-extend-only-to-memory-and-not-other-resource-types" target="_blank" rel="noopener">https://cs.stackexchange.com/questions/52735/why-does-garbage-collection-extend-only-to-memory-and-not-other-resource-types</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://docs.python.org/release/2.5.2/ext/refcounts.html" target="_blank" rel="noopener">https://docs.python.org/release/2.5.2/ext/refcounts.html</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="http://www.informit.com/articles/article.aspx?p=1745749&amp;seqNum=2" target="_blank" rel="noopener">http://www.informit.com/articles/article.aspx?p=1745749&amp;seqNum=2</a></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;"><a href="http://flyingfrogblog.blogspot.com/2011/01/boosts-sharedptr-up-to-10-slower-than.html" target="_blank" rel="noopener">http://flyingfrogblog.blogspot.com/2011/01/boosts-sharedptr-up-to-10-slower-than.html</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GC 算法作为计算机科学领域非常热的研究话题之一，最早可追溯到 1959 年&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，由 John McCarthy 在 Lisp 中实现来简化内存管理。早期的 
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="GC" scheme="http://liujiacai.net/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>2017 年终总结</title>
    <link href="http://liujiacai.net/blog/2018/01/21/review-2017/"/>
    <id>http://liujiacai.net/blog/2018/01/21/review-2017/</id>
    <published>2018-01-21T04:18:00.000Z</published>
    <updated>2020-02-02T04:17:01.087Z</updated>
    
    <content type="html"><![CDATA[<p>2018 年不知不觉已经过了 20 天，从元旦开始就一直在重写之前的 <a href="https://github.com/jiacai2050/history-master" target="_blank" rel="noopener">History Master</a>，其实这个插件一开始就是为了写年终总结，但功能相对较简单，经过这十几天的不断开发，算是脱胎换骨了，现在也可以好好写年终总结了。<br>一个词来形容 2017 的话，应该会是：变化。由于换了工作， 那就从工作开始谈起吧。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><h3 id="再见，有赞"><a href="#再见，有赞" class="headerlink" title="再见，有赞"></a>再见，有赞</h3><p>大概是在 17 年 4 月份从有赞毕业的，当时就想写一下在有赞两年的收获，但觉得时机不是很对，就一直到了现在。因为有赞，我来到了杭州，第一年可能去的地方比较少，第二年基本上把西湖周边的山爬遍了，不得不说杭州是我呆过最宜居的城市，互联网氛围也好，我走的时候几个北漂的同学都来杭州买房了。</p><p>在有赞一直做的是数据开发，属于后后端的岗位，真正做过数据开发的就会知道，这里的事情会比较杂，从最基础的手动报表，到数据仓库，从日志 ETL 到 mysql 数据同步，最后由于跑的任务比较多了一般还需要个调度平台，为了让其他组使用整理好的数据，还需要提供一个开发平台。用到的技术架构网上也很容易找到，类似下图：<a href="https://tech.youzan.com/you-zan-big-data-practice/" target="_blank" rel="noopener">图片来源</a></p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2pD.6nRDH8KJjSspnXXbNAVXa_!!581166664.png" alt="大数据架构"></p><p>现在回想来看，那两年工作的成果差强人意，浑浑噩噩，虽然学到了很多，但你就是感觉不对，于是从其他方面找满足感，这包括写一些科普型文章，刷 SICP，健身，这两天看到 <a href="http://lucida.me/blog/2018-being-honest/" target="_blank" rel="noopener">《2018，从对自己诚实开始》</a> 这位 exGoogler 的总结，深有感触。</p><p>很幸运我从大学开始就接触了 SICP，在有赞期间完完整整的把它看完了，一直想找一份与 Lisp 相关的工作，碰巧现在的公司在招聘，我就想试试看吧，然后就来到了 LeanCloud。我至今也还记得我初入职场时一前辈对我说过：</p><blockquote><p>不要轻易换工作，不管什么事情，真正坚持的人不多，但是你坚持下来就是赢家。</p></blockquote><p>其实从实习开始一直做的是 Hadoop 相关工作，差不多 3 年。换后端开发，是个挑战，很大的挑战。之所以这次还是这么坚定的换了，一方面是之前的工作有些疲劳了，另一方面确实是想体验真正的后端开发，而且能用 Clojure！我觉得这会是我下一个爆发点！</p><p>不过对于离开杭州，我真是非常不舍。离开的前一天，我骑着 ofo 沿着平时上班的路线去西湖转了一圈。对于杭州的小伙伴，我只能说有缘再见 :-)</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2UrQsnJzJ8KJjSspkXXbF7VXa_!!581166664.jpg" alt="有赞 18 楼前台"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2uAZQnJrJ8KJjSspaXXXuKpXa_!!581166664.jpg" alt="公司附近健身房"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2UiIsnTTI8KJjSsphXXcFppXa_!!581166664.jpg" alt="数据组聚餐胜地"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2JFk2nIjI8KJjSsppXXXbyVXa_!!581166664.jpg" alt="文一路物美超市"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2av8Nn22H8KJjy1zkXXXr7pXa_!!581166664.jpg" alt="西湖风光1"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2LzFnnZbI8KJjy1zdXXbe1VXa_!!581166664.jpg" alt="西湖风光2"></p><h3 id="Hello-LeanCloud"><a href="#Hello-LeanCloud" class="headerlink" title="Hello LeanCloud"></a>Hello LeanCloud</h3><p>我之前看 <a href="http://blog.fnil.net/" target="_blank" rel="noopener">dennis</a> 博客时就对 <a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a> 就有所耳闻，是一家重度使用 Clojure 的公司，光这一点我就觉得就足够酷了。对我来说这一切充满挑战，我十分期待这一段新的历程。</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/O1CN01UYKgNF1z69y0poBMj_!!581166664.jpg" alt="leancloud-logo.jpg"></p><h2 id="天天向上"><a href="#天天向上" class="headerlink" title="天天向上"></a>天天向上</h2><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>17 年制定的<a href="/blog/2017/01/08/review-2016/#%E8%AF%BB%E4%B9%A6">读书计划</a>只完成不到了 50%，从客观上说是 LeanCloud 的工作更充实，以至于没有之前刷 SICP 那么多时间，更重要的是技术栈的改变，当初凭借兴趣想读的书都没进行，当然自己的惰性也是很大一原因。究其原因，应该是反馈不够及时，任何事情都是这样。一个事情一味的去做，没有反馈，大家一般就不想做了，比较典型的例子就是减肥与看书。指定 18 年计划时一定要避免这点。</p><ul><li><a href="http://book.douban.com/subject/25854634/" target="_blank" rel="noopener">公共问题经济学</a>，计划内完成。这本书比较精悍，里面讲到了很多案例都很具启发性。一些关键词：边际效益；供需关系是影响市场的第一准则，政府的干预只会让市场变糟；没有绝对的安全，安全是需要付出代价的。</li><li><a href="http://book.douban.com/subject/1888733/" target="_blank" rel="noopener">Java Concurrency in Practice</a>，计划内完成。</li><li><a href="http://book.douban.com/subject/1230413/" target="_blank" rel="noopener">Computer Systems: A Programmer’s Perspective</a>，计划内，但是只完成前3章。这本书非常符合我说的反馈不够及时导致没法继续。首先这本书非常基础，基础到它会告诉你计算浮点数的误差范围的数学公式，另一方面是工作中没有直接应用的场景，所以导致这本经典书一直在我书桌上吃灰。18年要想办法把它啃完，顺带复习 C 语言。</li><li><a href="https://book.douban.com/subject/1432683/" target="_blank" rel="noopener">On Lisp</a>、<a href="http://book.douban.com/subject/1726083/" target="_blank" rel="noopener">The Seasoned Schemer</a> 这两本计划内的书基本没进行，18 年是否要重新读还要看情况，由于工作上技术栈的改变，加上还要运动，可能没精力去看。暂定。</li></ul><p>计划外读的书有：</p><ul><li><a href="https://book.douban.com/subject/11554138/" target="_blank" rel="noopener">HBase in Action</a>，挑有兴趣的章节看完了。</li><li><a href="https://book.douban.com/subject/24700704/" target="_blank" rel="noopener">Netty in Action</a>，工作需要，粗略浏览一遍。</li><li><a href="https://book.douban.com/subject/26665230/" target="_blank" rel="noopener">硅谷之谜</a>，主要讲述硅谷的成因。关键词：信息论、指控论、系统论是信息时代的三大路标。</li><li><a href="https://book.douban.com/subject/5988772/" target="_blank" rel="noopener">刘心武续红楼梦</a>，今年听了不少播客，红楼梦听了几个版本，包括 刘心武 老师百家讲堂的红楼梦，觉得“草蛇灰线，伏延千里”分析方法比较另辟蹊径，于是找来这本书。</li><li><a href="https://book.douban.com/subject/26248211/" target="_blank" rel="noopener">编程人生（上卷）</a>，编程大家的采访，目前看到第六章。</li></ul><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>由于 LeanCloud 使用 GitHub 做代码管理，所以 commit 数较去年有了较大变化，但是其实并没有什么较大的贡献，只是把之前的两个插件用 cljs 改写了。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2t6ZHnJfJ8KJjy0FeXXXKEXXa_!!581166664.png" alt="Github commit"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2qUkZnIrI8KJjy0FhXXbfnpXa_!!581166664.png" alt="Github profile"></p><p>followers 从 147 增加到 224，star 数从 224 增加到 367，repo 数从 42 增加到 59。</p><p>再重写插件期间，深入了解使用了 clojurescript，像是发现了“新大陆”一样惊喜。借助于 React，终于可以让我写出实用且不适美感的页面，React 可以让我们用纯函数的方式来写；reframe 又进一步抽象出一般 SPA 的模式，使用起来非常顺畅。</p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2GPvln0bJ8KJjy1zjXXaqapXa_!!581166664.png" alt="17 年博客总览"></p><p>17 年博客发了 9 篇文章，其中 <a href="/blog/2017/03/22/ace-technical-interview/">“玩转” 技术面试——链表的函数表示法</a> 是翻译的，<a href="/blog/2017/05/11/review-of-secret-of-silicon-valley/">《硅谷之谜》读后感</a> 是读后感，其他都是介绍 Clojure 的，最满意的应该是介绍 Clojure 宏写法的那两篇，然后是运行原理那两篇，以及最近的 <a href="/blog/2017/11/22/create-firefox-chrome-extensions-in-clojurescript/">使用 ClojureScript 开发浏览器插件的过程与收获</a>，这里面详细介绍了 ClojureScript 的使用经历。</p><p>博客这一块我还是比较满意的，18 年我想更多的写一些经验性的文章，一方面更加深入思考工作中遇到的问题，另一方面锻炼自己架构的能力，对于一些科普性质的文章最好也要附带上一两个实际案例。<br>为了积累工作中一些繁琐的事情，特地开了 <a href="http://wiki.liujiacai.net/" target="_blank" rel="noopener">个人 wiki</a>，这里主要会记录一些环境的配置，可以 copy paste 的代码段。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB27ZEPnL2H8KJjy0FcXXaDlFXa_!!581166664.png" alt="百度统计 2017 年博客访问情况"></p><h3 id="学洋文"><a href="#学洋文" class="headerlink" title="学洋文"></a>学洋文</h3><p>17 年在扇贝<a href="https://www.shanbay.com/web/annual-plan/award/74548" target="_blank" rel="noopener">打卡 299 天</a>，差一天就完成了 300 天的计划😭，而且其中有些天打的比较水，文章没怎么看就标为已读了。不管怎么说，这个习惯算是养成了，而且扇贝上的新闻也很及时，更新比较快，可以很方便的了解时事。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2KOlan22H8KJjy0FcXXaDlFXa_!!581166664.png" alt><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB23SBhn8HH8KJjy0FbXXcqlpXa_!!581166664.png" alt><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2wlOkn_vI8KJjSspjXXcgjXXa_!!581166664.png" alt><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2mNXYn6nD8KJjSspbXXbbEXXa_!!581166664.jpg" alt="扇贝新年计划徽章--Feel the change"></p><h3 id="视频课程"><a href="#视频课程" class="headerlink" title="视频课程"></a>视频课程</h3><p>17 年还录制了一套 <a href="https://github.com/jiacai2050/learn_clojure.mp4" target="_blank" rel="noopener">Clojure 学习视频</a>，一共7讲，算是一个意外的收获。希望能为国内 Clojure 初学者提供另一个选择。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2phveekfb_uJkHFqDXXXVIVXa_!!581166664.png" alt="Learn Clojure 视频课程"></p><p>通过制作这一套视频，我结识了一些志同道合的朋友，我觉得这比单纯获取知识更有意义。互联网就是这么神奇，让素未见面的一群人因共同的爱好聚集起来，感谢你们的支持，希望你们新的一年一切顺利。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>由于换了工作，所以生活也发生了较大改变。首先惭愧的说一点，之前花了将近一年的时间去减肥，最近 8 个月全部还了回来，而且有过之无不及。面对镜子里面的自己，真是觉得羞愧至极。</p><p>首先，新办公室人员较少，没有一起去健身的，这是一个很重要的客观因素，而且昆山本身比较安逸，安逸到你怎么样都行的状态。虽然也办了公司附近的健身卡，但是我告诉自己新工作需要去多熟悉代码，也就逐渐减低了去的频率，这应该是 17 年最大的败笔。</p><p>不过，我的心态还比较好，科学减肥的方式我非常清楚，只是在实施上了问题，18 年一定会再锻炼起来，重新“做人”。和读书计划一样，这里一定要做到即使反馈，每天做好记录，健身房的每滴汗水都不能白流。</p><h3 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h3><p>17 年听了不少播客，一方面写程序时解闷，另一方面开了不少眼界。主要有下面几个（按收听时间）：</p><ul><li><a href="https://itunes.apple.com/cn/podcast/%E6%9E%81%E5%AE%A2%E7%94%B5%E5%8F%B0/id914427651?mt=2" target="_blank" rel="noopener">极客电台</a> by <a href="https://geek.wasai.org/" target="_blank" rel="noopener">王掌柜</a>。到目前大概 190 多期，基本全听完了，其中比较有价值的是 「170期-比特币投资教会我的三件事」，「189期 点评 iOS11 和比特币交易所关闭事件」，他让我放心的知道，我不必去了解这些“时髦”的东西，下车容易上车难。而且教会了我一些生活的技巧。</li><li><a href="http://www.ximalaya.com/9316189/album/5609461/" target="_blank" rel="noopener">猫哥详说红楼梦</a>，是猫哥陪女儿读书时录制的，有自己的理解。</li><li><a href="http://www.ximalaya.com/32674504/album/3836293/" target="_blank" rel="noopener">《白话红楼梦-完》韦岽著</a>，播主精致女王读的韦岽的书，如其名曰，白话讲解。</li><li><a href="http://www.ximalaya.com/32674504/album/11064027/" target="_blank" rel="noopener">《红楼梦》女王读原著</a>，播主同精致女王，对原著的阅读。</li><li><a href="https://fm.qq.com/album/rd004IyeGv3gH42A" target="_blank" rel="noopener">三毛全集</a>，三毛的想念汇成了撒哈拉。见证了一对佳人的离合悲欢。</li><li><a href="http://blog.cognitect.com/cognicast/" target="_blank" rel="noopener">Cognicast</a>，cognitect 官方的播客，主要谈使用 Clojure 以及软件开发的经验，练习听力。</li></ul><p>听了各种版本的红楼梦，发现确实是一本奇书，而且由于后四十回遗失，高鹗续写的不尽人意，更是让后人“浮想联翩”，增加了探索书中原型的乐趣。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在 6 月最后一天终于拿到了驾照，真是一段<a href="https://www.jianshu.com/p/469f63ffd263" target="_blank" rel="noopener">痛快的回忆</a>；离开了有赞，乒乓球打的也少了；同学介绍了几个朋友，也无疾而终，今年回去估计要相亲了 😴</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>17年是毕业后工作的第三个年头，可能有些同学已经深耕在某一领域，但是我却选择了重新开辟一条人迹罕至的道路，我不知道这是对还是错，也许并没有对错之说，有得必有失，尽我所能就好。</p><p>希望 18 年能有所突破，遇见不一样的自己。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018 年不知不觉已经过了 20 天，从元旦开始就一直在重写之前的 &lt;a href=&quot;https://github.com/jiacai2050/history-master&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;History Master&lt;/
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 ClojureScript 开发浏览器插件的过程与收获</title>
    <link href="http://liujiacai.net/blog/2017/11/22/create-firefox-chrome-extensions-in-clojurescript/"/>
    <id>http://liujiacai.net/blog/2017/11/22/create-firefox-chrome-extensions-in-clojurescript/</id>
    <published>2017-11-22T08:23:34.000Z</published>
    <updated>2019-12-24T10:59:14.610Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Firefox 57 的到来，之前维护的一个浏览器插件 <a href="https://github.com/jiacai2050/gooreplacer" target="_blank" rel="noopener">gooreplacer</a> 必须升级到 WebExtensions 才能继续使用，看了下之前写的 JS 代码，毫无修改的冲动，怕改了这个地方，那个地方突然就 broken 了。因此，这次选择了 cljs，整体下来流程很顺利，除了迁移之前的功能，又加了更多功能，希望能成为最简单易用的重定向插件 :-)</p><p>闲话少说，下面的内容依次会介绍 cljs 的工作机制、开发环境，如何让 cljs 适配浏览器插件规范，以及重写 gooreplacer 时的一些经验。<br>本文的读者需要对 Clojure 语言、浏览器插件开发一般流程有基本了解，并且完成 ClojureScript 的 <a href="https://clojurescript.org/guides/quick-start" target="_blank" rel="noopener">Quick Start</a>。对于 Clojure，我目前在 sf 上有<a href="https://github.com/jiacai2050/learn_clojure.mp4" target="_blank" rel="noopener">一套视频课程</a>，供参考。</p><p>为了方便大家使用 cljs 开发插件，我整理了<a href="https://github.com/jiacai2050/browser-extenstion.cljs" target="_blank" rel="noopener">一份模板</a>，供大家参考。gooreplacer 完整代码在<a href="https://github.com/jiacai2050/gooreplacer" target="_blank" rel="noopener">这里</a>，技术栈为  cljs + reagent + antd。我的另一个项目 <a href="https://github.com/jiacai2050/history-master" target="_blank" rel="noopener">History Master</a> 在最近也用 cljs 重写了，技术栈相比 gooreplacer 增加了 <a href="https://github.com/Day8/re-frame" target="_blank" rel="noopener">re-frame</a>。</p><h2 id="ClojureScript-工作机制"><a href="#ClojureScript-工作机制" class="headerlink" title="ClojureScript 工作机制"></a>ClojureScript 工作机制</h2><p>ClojureScript 是使用 Clojure 编写，最终编译生成 JS 代码的一个<a href="http://blog.fogus.me/2012/04/25/the-clojurescript-compilation-pipeline/" target="_blank" rel="noopener">编译器</a>，在编译过程中使用 <a href="https://github.com/google/closure-compiler" target="_blank" rel="noopener">Google Closure Compiler</a> 来优化 JS 代码、解决<a href="https://github.com/google/closure-compiler/wiki/Managing-Dependencies" target="_blank" rel="noopener">模块化引用</a>的问题。整体工作流程如下：</p><p><img src="/images/clojure/cljs_compile.png" alt="cljs 编译流程"></p><p>Cljs 还提供 <a href="http://cljs.info/cheatsheet/" target="_blank" rel="noopener">与原生 JS 的交互</a>、<a href="https://clojurescript.org/reference/javascript-module-support" target="_blank" rel="noopener">集成</a><a href="https://clojurescript.org/news/2017-07-12-clojurescript-is-not-an-island-integrating-node-modules" target="_blank" rel="noopener">第三方类库</a>的支持，所以，只要能用 JS 的地方，都能用 cljs。</p><h3 id="Closure-compiler"><a href="#Closure-compiler" class="headerlink" title="Closure compiler"></a>Closure compiler</h3><p>这里需要着重介绍一下 Google 的这个项目，可以在不运行代码的前提下分析代码逻辑，去掉没有使用到的代码，这对于 cljs 是非常重要的。一个项目中不可能使用到 cljs 中所有的函数，如果不进行代码“减肥”，最终编译出来 JS 文件就会超大，根本没法在浏览器中使用。<br>奇怪的是功能这么强大的项目却鲜为人知，不得不说 Google 在“推销”这方面还需要向 Facebook 学习。有一个在线地址，供大家体验 Closure 的强大：</p><ul><li><a href="https://closure-compiler.appspot.com" target="_blank" rel="noopener">https://closure-compiler.appspot.com</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hello, '</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">hello(<span class="string">'New user'</span>);</span><br></pre></td></tr></table></figure><p>在优化策略为 advanced 时最终生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"Hello, New user"</span>);</span><br></pre></td></tr></table></figure><h2 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h2><p>开发 cljs 的环境首选 <a href="https://github.com/technomancy/leiningen#installation" target="_blank" rel="noopener">lein</a> + <a href="https://github.com/bhauman/lein-figwheel" target="_blank" rel="noopener">figwheel</a>，figwheel 相比 <a href="https://github.com/emezeske/lein-cljsbuild" target="_blank" rel="noopener">lein-cljsbuild</a> 提供了热加载的功能，这一点对于开发 UI 很重要！</p><p>对于一般的 cljs 应用，基本都是用一个 script 标签去引用编译后的 js 文件，然后这个 js 文件再去加载其他依赖。比如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>js/main.js 是 project.clj 里面指定的输出文件，它会去加载其他所需文件，其内容大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CLOSURE_UNCOMPILED_DEFINES = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> CLOSURE_NO_DEPS = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> goog == <span class="string">"undefined"</span>) <span class="built_in">document</span>.write(<span class="string">'&lt;script src="js/out/goog/base.js"&gt;&lt;/script&gt;'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script src="js/out/goog/deps.js"&gt;&lt;/script&gt;'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script src="js/out/cljs_deps.js"&gt;&lt;/script&gt;'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script&gt;if (typeof goog == "undefined") console.warn("ClojureScript could not load :main, did you forget to specify :asset-path?");&lt;/script&gt;'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script&gt;goog.require("process.env");&lt;/script&gt;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;script&gt;if (typeof goog != \"undefined\") &#123; goog.require(\"figwheel.connect.build_dev\"); &#125;&lt;/script&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script&gt;goog.require("hello_world.core");&lt;/script&gt;'</span>);</span><br></pre></td></tr></table></figure><h3 id="消除-inline"><a href="#消除-inline" class="headerlink" title="消除 inline"></a>消除 inline</h3><h4 id="background-script"><a href="#background-script" class="headerlink" title="background script"></a>background script</h4><p>对于一般的 Web 项目，只引用这一个 js 文件就够了，但是对于浏览器插件来说，有一些问题，浏览器插件出于安全因素考虑，是<a href="https://developer.chrome.com/extensions/contentSecurityPolicy#relaxing-inline-script" target="_blank" rel="noopener">不让执行 incline script</a>，会报如下错误</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2xXZVeJnJ8KJjSszdXXaxuFXa_!!581166664.png" alt="inline script error"></p><p>为了去掉这些错误，手动加载 js/main.js 里面动态引入的文件，require 所需命名空间即可，修改后的 html 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/out/goog/base.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/out/cljs_deps.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/init.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 init.js 内容为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// figwheel 用于热加载，这里的 build_dev 其实是 build_&#123;build_id&#125;，默认是 dev</span></span><br><span class="line">goog.require(<span class="string">"figwheel.connect.build_dev"</span>);</span><br><span class="line"><span class="comment">// 加载为 main 的命名空间</span></span><br><span class="line">goog.require(<span class="string">"hello_world.core"</span>);</span><br></pre></td></tr></table></figure><p>这样就可以正常在浏览器插件环境中运行了。可以在 DevTools 中观察到所有引用的 js 文件</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2buKhe3vD8KJjSsplXXaIEFXa_!!581166664.png" alt="动态加载的 JS 文件"> </p><p>在左下角可以看到，总共有 92 个文件。</p><h4 id="option-popup"><a href="#option-popup" class="headerlink" title="option/popup"></a>option/popup</h4><p>上述方案对于没有 UI 的 background script 时合适的，但是对于 option 与 popup 页面来说，需要做一点小修改：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/out/goog/base.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/out/cljs_deps.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CLJS demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"init.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>由于我们采用 React 开发，所以一般需要在 html 页面中放一个 id 为 app 的 div，之后的逻辑都围绕这个 div 进行，所以只需要把 init.js 放在这个 div 之后就可以了。</p><h4 id="content-script"><a href="#content-script" class="headerlink" title="content script"></a>content script</h4><p>最后比较复杂的是 content script，他与上述两类脚本不一样，没法指定 js 脚本加载顺序，可以想到的一种方式是：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"content_scripts"</span>: [&#123;</span><br><span class="line">  <span class="string">"matches"</span>: [<span class="string">"http://*/*"</span>, <span class="string">"https://*/*"</span>],</span><br><span class="line">  <span class="string">"run_at"</span>: <span class="string">"document_end"</span>,</span><br><span class="line">  <span class="string">"js"</span>: [<span class="string">"content/js/out/goog/base.js"</span>, <span class="string">"content/js/out/cljs_deps.js"</span>, <span class="string">"content/init.js"</span>]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>这里的 content 的目录与 manifest.json 在同一级目录。采用这种方式会报如下的错误</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2vEaHbBLN8KJjSZPhXXc.spXa_!!581166664.png" alt="content script 报错"></p><p>根据错误提示，可以看出是 base.js 再去动态引用其他 js 文件时，是以访问网站为相对路径开始的，因此也就找不到正确的 JS 文件了。</p><p>解决方法是设置 cljsbuild 的 <code>optimizations</code> 为 <code>:whitespace</code>，把所有文件打包到一个文件，然后引用这一个就可以了，<a href="https://github.com/binaryage/chromex-sample/issues/2" target="_blank" rel="noopener">这个方法不是很完美</a>，采用 whitespace 一方面使编译时间更长，在我机器上需要12s；另一方面是无法使用 figwheel，会报 A Figwheel build must have :compiler &gt; :optimizations default to nil or set to :none 的错误，因此也就无法使用代码热加载的功能。</p><p>gooreplacer 里面只使用了 background page 与 option page，所以这个问题也就避免了。</p><h3 id="区分-dev-与-release-模式"><a href="#区分-dev-与-release-模式" class="headerlink" title="区分 dev 与 release 模式"></a>区分 dev 与 release 模式</h3><p>这里的 dev 是指正常的开发流程，release 是指开发完成，准备打包上传到应用商店的过程。</p><p>在 dev 过程中，推荐设置 cljsbuild 的 <code>optimizations</code> 为 none，以便得到最快的编译速度；<br>在 release 过程中，可以将其设置为 <code>advanced</code>，来压缩、优化 js 文件，以便最终的体积最小。</p><p>为了在两种模式中复用使用的图片、css 等资源，可采用了软链的来实现，resources 目录结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── css</span><br><span class="line">│   └── option.css</span><br><span class="line">├── dev</span><br><span class="line">│   ├── <span class="attribute">background</span></span><br><span class="line">│   │   ├── index.html</span><br><span class="line">│   │   └── init.js</span><br><span class="line">│   ├── <span class="attribute">content</span></span><br><span class="line">│   ├── manifest<span class="selector-class">.json</span> -&gt; ../manifest.json</span><br><span class="line">│   └── option</span><br><span class="line">│       ├── css -&gt; ../../css/</span><br><span class="line">│       ├── images -&gt; ../../images/</span><br><span class="line">│       ├── index.html</span><br><span class="line">│       └── init.js</span><br><span class="line">├── images</span><br><span class="line">│   ├── cljs.png</span><br><span class="line">│   ├── cljs_16.png</span><br><span class="line">│   ├── cljs_32.png</span><br><span class="line">│   └── cljs_48.png</span><br><span class="line">├── manifest.json</span><br><span class="line">└── release</span><br><span class="line">    ├── <span class="attribute">background</span></span><br><span class="line">    │   ├── index.html</span><br><span class="line">    │   └── js</span><br><span class="line">    │       └── main.js</span><br><span class="line">    ├── <span class="attribute">content</span></span><br><span class="line">    │   └── js</span><br><span class="line">    │       └── main.js</span><br><span class="line">    ├── manifest<span class="selector-class">.json</span> -&gt; ../manifest.json</span><br><span class="line">    └── option</span><br><span class="line">        ├── css -&gt; ../../css/</span><br><span class="line">        ├── images -&gt; ../../images/</span><br><span class="line">        ├── index.html</span><br><span class="line">        └── js</span><br><span class="line">            └── main.js</span><br></pre></td></tr></table></figure><p>其次，为了方便开启多个 figwheel 实例来分别编译 background、option 里面的 js，定义了多个 lein 的 profiles，来指定不同环境下的配置，具体可参考 <a href="https://github.com/jiacai2050/browser-extenstion.cljs/blob/master/project.clj#L13" target="_blank" rel="noopener">模板的 project.clj</a> 文件。</p><h3 id="externs"><a href="#externs" class="headerlink" title="externs"></a>externs</h3><p>在 optimizations 为 advanced 时，cljs 会充分借用 Google Closure Compiler 来压缩、混淆代码，会把变量名重命名为 a b c 之类的简写，为了不使 chrome/firefox 插件 API 里面的函数混淆，需要加载它们对应的 externs 文件，一般只需要这两个 <a href="https://github.com/google/closure-compiler/blob/master/contrib/externs/chrome_extensions.js" target="_blank" rel="noopener">chrome_extensions.js</a>、<a href="https://github.com/google/closure-compiler/blob/master/contrib/externs/chrome.js" target="_blank" rel="noopener">chrome.js</a>，如果项目中用到了其他的库，extern 文件的生成方式可以参考<a href="https://github.com/google/closure-compiler/wiki/Externs-For-Common-Libraries" target="_blank" rel="noopener">Externs For Common Libraries</a>。</p><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>cljs 自带的 test 功能比较搓，比较好用的是 <a href="https://github.com/bensu/doo" target="_blank" rel="noopener">doo</a>，为了使用它，需要先提前安装 <a href="http://phantomjs.org/" target="_blank" rel="noopener">phantom</a> 来提供 headless 环境，写好测试就可以执行了：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">lein doo phantom </span><span class="template-variable">&#123;build-id&#125;</span><span class="xml"> </span><span class="template-variable">&#123;watch-mode&#125;</span></span><br></pre></td></tr></table></figure><p>非常棒的一点是它也能支持热加载，所以在开发过程中我一直开着它。</p><h3 id="re-agent"><a href="#re-agent" class="headerlink" title="re-agent"></a>re-agent</h3><p><a href="http://reagent-project.github.io/" target="_blank" rel="noopener">re-agent</a> 是对 React 的一个封装，使之符合 cljs 开发习惯。毫无夸张的说，对于非专业前端程序员来说，要想使用 React，cljs 比 jsx 是个更好的选择，<a href="https://github.com/weavejester/hiccup" target="_blank" rel="noopener">Hiccup-like</a> 的语法比 jsx 更紧凑，不用再去理睬 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>，<a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a> 等等层出不穷的 js 工具，更重要的一点是 immutable 在 cljs 中无处不在，re-agent 里面有自己维护状态的机制 atom，不在需要严格区分 React 里面的 props 与 state。</p><p>了解 re-agent 的最好方式就是从它<a href="http://reagent-project.github.io/" target="_blank" rel="noopener">官网给出的示例</a>开始，然后阅读 re-frame wiki 里面的 <a href="https://github.com/Day8/re-frame/wiki/Creating-Reagent-Components" target="_blank" rel="noopener">Creating Reagent Components</a>，了解三种不同的 form 的区别，98% gooreplacer 都在使用 form-2。如果对原理感兴趣，建议也把其他 wiki 看完。</p><p>re-agent 还有一点比较实用，提供了对 React 原生组件的转化函数：<a href="http://nicolovaligi.com/boostrap-components-reagent-clojurescript.html" target="_blank" rel="noopener">adapt-react-class</a>，使用非常简单：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> Button (<span class="name">reagent/adapt-react-class</span> (<span class="name">.-Button</span> js/ReactBootstrap)))</span><br><span class="line"></span><br><span class="line">[<span class="symbol">:div</span></span><br><span class="line">  [<span class="symbol">:h2</span> <span class="string">"A sample title"</span>]</span><br><span class="line">  [Button <span class="string">"with a button"</span>]]</span><br></pre></td></tr></table></figure><p>此外对于原生的 JS 库比如 <a href="http://echarts.baidu.com/" target="_blank" rel="noopener">echarts</a>，也可以采用 <a href="http://timothypratley.blogspot.hk/2017/01/reagent-deep-dive-part-2-lifecycle-of.html" target="_blank" rel="noopener">form3 的方式使用</a>。可以看看 <a href="https://github.com/jiacai2050/history-master/blob/6ed01d28d68ed1d6b7a95cc3229e2cbcb9748d6a/cljs-src/src/option/history_master/stat.cljs#L12-L49" target="_blank" rel="noopener">History Master 是如何使用</a>的，这里有一些有<a href="https://www.reddit.com/r/Clojure/comments/7oz1ak/reagent_deep_dive_part_2_the_lifecycle_of_a/" target="_blank" rel="noopener">价值的讨论</a>供参考。</p><p>说到 re-agent，就不能不提到 <a href="https://github.com/omcljs/om/wiki/Quick-Start-%28om.next%29" target="_blank" rel="noopener">om.next</a>，这两个在 cljs 社区里面应该是最有名的 React wrapper，om.next 理念与使用难度均远高于 re-agent，初学者一般不推荐直接用 om.next。感兴趣的可以看看这两者之间的比较：</p><ul><li><a href="https://purelyfunctional.tv/article/why-re-frame-instead-of-om-next/" target="_blank" rel="noopener">Why Re-frame instead of Om Next</a>，以及 <a href="https://www.reddit.com/r/Clojure/comments/6q0jhn/why_reframe_instead_of_om_next/" target="_blank" rel="noopener">Reddit 上的讨论</a></li><li><a href="https://www.reddit.com/r/Clojure/comments/3vk58p/a_rant_on_om_next/" target="_blank" rel="noopener">A rant on Om Next</a></li></ul><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a><a href="https://clojurescript.org/about/differences#_macros" target="_blank" rel="noopener">宏</a></h3><p>cljs 里面加载宏的机制有别于 Clojure，一般需要单独把宏定义在一个文件里面，然后在 cljs 里面用<code>(:require-macros [my.macros :as my])</code> 这样的方式去引用，而且宏定义的文件名后缀必须是 clj 或 cljc，不能是 cljs，这一点坑了我好久。。。</p><p>由于宏编译与 cljs 编程在不同的时期，所以如果宏写错了，就需要把 repl 杀掉重启来把新的宏 feed 给 cljs，这点也比较痛苦，因为 repl 的启动速度实在是有些慢。这一点在 Clojure 里面虽然也存在，但是 Clojure 里面一般 repl 开了就不关了，直到电脑重启。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2iGyXbvjM8KJjSZFyXXXdzVXa_!!581166664.png" alt="我机器上启动的 repl 列表"></p><h3 id="JS-interop"><a href="#JS-interop" class="headerlink" title="JS interop"></a>JS interop</h3><p>与 Clojure 类似， cljs 提供了很便利的方式与 JS 交互，但是社区内有一点误用，就是访问、设置一个 JS 对象的属性，网上<a href="http://clojurescriptmadeeasy.com/blog/js-interop-property-access.html" target="_blank" rel="noopener">很多地方</a>推荐使用 aset aget，但是这是一个误用，这两个方法中的 a 表示的是 array，只是用来访问数组的，由于这个误用非常广泛，cljs 官网还专为其<a href="https://clojurescript.org/news/2017-07-14-checked-array-access" target="_blank" rel="noopener">发了一篇博客</a>。正确的方式是用 goog.object 或者 <a href="https://github.com/binaryage/cljs-oops" target="_blank" rel="noopener">cljs-oops</a>。示例代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;instead of aget</span></span><br><span class="line">(<span class="name">require</span> 'goog.object)</span><br><span class="line">(<span class="name">def</span> obj #js &#123;<span class="symbol">:foo</span> #js &#123;<span class="symbol">:bar</span> <span class="number">2</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line">(<span class="name">goog</span>.object/get obj <span class="string">"foo"</span>)</span><br><span class="line"><span class="comment">;;=&gt; #js &#123;:bar 2&#125; </span></span><br><span class="line"></span><br><span class="line">(<span class="name">goog</span>.object/getValueByKeys obj <span class="string">"foo"</span> <span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">;;=&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;instead of aset</span></span><br><span class="line">(<span class="name">def</span> obj #js &#123;<span class="symbol">:foo</span> <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">(<span class="name">goog</span>.object/set obj <span class="string">"foo"</span> <span class="string">"bar"</span>)</span><br><span class="line">obj</span><br><span class="line"><span class="comment">;;=&gt; #js &#123;:foo "bar"&#125;</span></span><br></pre></td></tr></table></figure><p>其实我们需要的大部分 dom 操作都可以在 <a href="https://github.com/google/closure-library" target="_blank" rel="noopener">Google closure library</a> 找到，而且其代码质量也比较高，所以熟练掌握其 <a href="https://google.github.io/closure-library/api/" target="_blank" rel="noopener">API</a> 也是很有必要的。</p><p>写到这里，还有一点我想强调的是，cljs 一些项目是对 JS 的 wrapper，比如我用到的 reagent 就是 React 的一个 wrapper，这就很有可能你需要的功能没在它的说明文档里面，虽然 JS 库里面有，但是你却不知道如何在 cljs 去调用，另一个比较类似的问题是根据文档去操作，遇到了很奇怪的问题，比如应该输出 A，却输出了 B，这时就需要去社区寻求帮助，一般来说都可以在一两天内得到解决，但是也不排除没有解决的情况，我自己就遇到一两个这样的例子，这时就只能去看源代码，这点其实与 Clojure 比较像，比较 Lisp 是个小众语言，所以不建议初学者把一些重要的项目用 cljs 重写，不过对于一些自己个人项目，我鼓励用 cljs 改写，可以学到很多东西，我再使用 reframe 时，了解到了 React <a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">组件生命周期</a>的过程，Reagent 何时会<a href="https://github.com/Day8/re-frame/wiki/When-do-components-update%3F" target="_blank" rel="noopener">触发 component 的更新</a>，这都是很宝贵的经验。</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>Clojure 里面采用 Emacs + Cider 的开发环境非常完美，但是到了 cljs 里面，开发流程没有那么平滑，总是有些磕磕绊绊，也给 cider <a href="https://github.com/clojure-emacs/cider/issues/2099" target="_blank" rel="noopener">提了个 issue</a>，貌似一直没人理，支持确实不好，不过有了 figwheel，在一定程度上能弥补这个缺陷。在 Emacs 里面配置 repl 可参考：</p><ul><li><a href="https://cider.readthedocs.io/en/latest/up_and_running/#clojurescript-usage" target="_blank" rel="noopener">https://cider.readthedocs.io/en/latest/up_and_running/#clojurescript-usage</a></li></ul><p>Cider 默认会使用 rhino 作为 repl 求值环境，这个在开发浏览器插件时功能很有限，但是对于查看函数定义还是可以的，不过对于真正的项目，还是建议配置成 figwheel repl，可参考：</p><ul><li><a href="https://github.com/bhauman/lein-figwheel/wiki/Using-the-Figwheel-REPL-within-NRepl" target="_blank" rel="noopener">Using-the-Figwheel-REPL-within-NRepl</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到了 2018 年，如果让我列举 Clojure 里面的一个<a href="https://www.reddit.com/r/Clojure/comments/75apb2/does_clojure_have_a_killer_app/" target="_blank" rel="noopener">杀手级</a><a href="https://groups.google.com/forum/#!topic/clojure/YCnG3rmOp5w" target="_blank" rel="noopener">应用</a>，我觉得会是 ClojureScript。<br>ClojureScript 项目的 leader swannodette 在<a href="https://swannodette.github.io" target="_blank" rel="noopener">其博客</a>里描述了自 cljs 诞生一来的开发历程，通过阅读里面的大部分文章，我感受到 cljs 社区的强大，不断有让人眼前一亮的项目，从 <a href="https://github.com/bhauman/lein-figwheel" target="_blank" rel="noopener">figwheel</a> 到 <a href="https://github.com/bhauman/devcards" target="_blank" rel="noopener">devcards</a>，从 <a href="https://github.com/reagent-project/reagent" target="_blank" rel="noopener">re-agent</a> 到 <a href="https://github.com/Day8/re-frame" target="_blank" rel="noopener">re-frame</a>，从<a href="https://swannodette.github.io/2015/07/29/clojurescript-17" target="_blank" rel="noopener">自编译的 cljs</a> 到 <a href="https://github.com/mfikes/Planck" target="_blank" rel="noopener">Planck</a> 与 <a href="https://github.com/mfikes/replete" target="_blank" rel="noopener">Replete</a>，当然还有 <a href="https://shaunlebron.github.io/parinfer/" target="_blank" rel="noopener">parinfer</a>，他给初学者提供了一种全新的方式学习 Lisp。</p><p>当我看到 swannodette 也是在<a href="https://swannodette.github.io/2015/07/29/clojurescript-17" target="_blank" rel="noopener">受 SICP 的影响</a>后开始了其 Lisp 道路后，我深深感到自己内功的不足，需要更加努力，Keep Coding.</p><p>JS 社区里面层出不穷的框架每次都让跃跃欲试的我望而却步，有了 cljs，算是把 Lisp 延伸到了更宽广的“领土”。最近看到这么一句话，与大家分享：</p><blockquote><p>也许 Lisp 不是解决所有问题最合适的语言，但是它鼓励你设计一种最合适的语言来解决这个难题。</p></blockquote><p>出处忘记了，大体是这么个意思。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.fogus.me/2012/04/25/the-clojurescript-compilation-pipeline/" target="_blank" rel="noopener">The ClojureScript Compilation Pipeline</a></li><li><a href="https://nvbn.github.io/2014/12/07/chrome-extension-clojurescript/" target="_blank" rel="noopener">Chrome extension in ClojureScript</a></li><li><a href="https://github.com/binaryage/chromex-sample" target="_blank" rel="noopener">https://github.com/binaryage/chromex-sample</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着 Firefox 57 的到来，之前维护的一个浏览器插件 &lt;a href=&quot;https://github.com/jiacai2050/gooreplacer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gooreplacer&lt;/a&gt; 必须升级到 W
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深学习 Lisp 宏之实战篇</title>
    <link href="http://liujiacai.net/blog/2017/10/01/macro-in-action/"/>
    <id>http://liujiacai.net/blog/2017/10/01/macro-in-action/</id>
    <published>2017-10-01T02:13:05.000Z</published>
    <updated>2019-12-24T10:59:14.610Z</updated>
    
    <content type="html"><![CDATA[<p>本文是宏系列的第二篇文章，侧重于实战，对于新手建议先阅读宏系列的<a href="/blog/2017/08/31/master-macro-theory/">理论篇</a>，之后再来看本文。当然如果你有一定基础，也可以直接阅读本文。<br>其次，希望读者能把本文的 Clojure 代码手动敲到 REPL 里面去运行、调试，直到完全理解。</p><h2 id="Code-as-data"><a href="#Code-as-data" class="headerlink" title="Code as data"></a>Code as data</h2><p>在<a href="/blog/2017/08/31/master-macro-theory/">理论篇</a>中，介绍了宏（macro）的本质：<code>在编译时期运行的函数</code>。宏相对于普通函数，具有如下特点：</p><ol><li>宏的参数不会求值（eval），是 symbol 字面量</li><li>宏的返回值是 code（在运行期执行），不是一般的数据。</li></ol><p>这两条特性蕴含着一非常重要的思想： <a href="https://en.wikipedia.org/wiki/Homoiconicity" target="_blank" rel="noopener">code as data</a> ，也被称为同像性（homoiconicity，来自希腊语单词 homo，意为与符号含义表示相同）。同像性使得在 Lisp 中去操作语法树（AST）显得十分自然，而这在非 Lisp 语言只能由编译器（Compiler）去操作。这里举一典型的例子：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> when [test &amp; body]</span><br><span class="line">  (<span class="name"><span class="builtin-name">list</span></span> 'if test (<span class="name"><span class="builtin-name">cons</span></span> 'do body)))</span><br></pre></td></tr></table></figure><p><code>&#39;</code>代表 quote，作用是阻止后面的表达式求值，如果不使用<code>&#39;</code>的话，在进行<code>(list &#39;if test ...)</code>求值时会报错，因为对 special form 单独进行求值是非法的，这里需要的仅仅是 <code>if</code> 字面量，list 函数执行后的结果（是一个 list）作为 code 插入到调用 when 的地方去执行。</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">even?</span></span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">100</span>))</span><br><span class="line">  (<span class="name">println</span> <span class="string">"good luck!"</span>)</span><br><span class="line">  (<span class="name">println</span> <span class="string">"lisp rocks!"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; when 展开后的形式 </span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">even?</span></span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">100</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">do</span></span> (<span class="name">println</span> <span class="string">"good luck!"</span>) (<span class="name">println</span> <span class="string">"lisp rocks!"</span>)))</span><br></pre></td></tr></table></figure><h3 id="syntax-quote-amp-unquote"><a href="#syntax-quote-amp-unquote" class="headerlink" title="syntax-quote &amp; unquote"></a>syntax-quote &amp; unquote</h3><p>对于一些简单的宏，可以采用像 when 那样的方式，使用 list 函数来形成要返回的 code，但对于复杂的宏，使用 list 函数来表示，会显得十分麻烦，看下 when-let 的实现：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> when-let [bindings &amp; body]</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [form (<span class="name">bindings</span> <span class="number">0</span>) tst (<span class="name">bindings</span> <span class="number">1</span>)]</span><br><span class="line">    `(<span class="name"><span class="builtin-name">let</span></span> [temp# ~tst]</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> temp#</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> [~form temp#]</span><br><span class="line">           ~@body)))))</span><br></pre></td></tr></table></figure><p>这里返回的 list 使用 <em>`</em>（backtick）进行了修饰，这称为 syntax-quote，它与 quote <code>&#39;</code> 类似，只不过在阻止表达式求值的同时，支持以下两个额外功能：</p><ol><li>表达式里的所有 symbol 会在当前 namespace 中进行 resolve，返回 fully-qualified symbol</li><li>允许通过 <code>~</code>(unquote) 或 <code>~@</code>(slicing-unquote) 阻止部分表达式的 quote，以达到对它们求值的效果</li></ol><p>可以通过下面一个例子来了解它们之间的区别：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [x '(<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">3</span>) y x]</span><br><span class="line">  (<span class="name">println</span> `y)</span><br><span class="line">  (<span class="name">println</span> ``y)</span><br><span class="line">  (<span class="name">println</span> ``~y)</span><br><span class="line">  (<span class="name">println</span> ``~~y)</span><br><span class="line">  (<span class="name">println</span> (<span class="name"><span class="builtin-name">eval</span></span> ``~~y))</span><br><span class="line">  (<span class="name">println</span> `[~@y]))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 依次输出</span></span><br><span class="line"></span><br><span class="line">user/y</span><br><span class="line">(<span class="name"><span class="builtin-name">quote</span></span> user/y)</span><br><span class="line">user/y</span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">[* <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>这里尤其要注意理解嵌套 syntax-quote 的情况，为了得到正确的值，需要 unquote 相应的次数（上例中的第四个println），这在 macro-writing macro 中十分有用，后面会介绍的。<br>最后需要注意一点，在整个 Clojure 程序生命周期中，<code>(syntax-)quote</code>, <code>(slicing-)unquote</code> 是 <a href="https://clojure.org/reference/reader" target="_blank" rel="noopener">Reader</a> 来解析的，详见 <a href="/blog/2017/02/05/clojure-compiler-analyze/#编译器工作流程">编译器工作流程</a>。可以通过<code>read-string</code>来验证：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user&gt; (read-string "`y")</span><br><span class="line">(<span class="name"><span class="builtin-name">quote</span></span> user/y)</span><br><span class="line">user&gt; (read-string "``y")</span><br><span class="line">(<span class="name">clojure.core/seq</span> (<span class="name">clojure.core/concat</span> (<span class="name">clojure.core/list</span> (<span class="name"><span class="builtin-name">quote</span></span> quote)) </span><br><span class="line">                                       (<span class="name">clojure.core/list</span> (<span class="name"><span class="builtin-name">quote</span></span> user/y))))</span><br><span class="line">user&gt; (read-string "``~y")</span><br><span class="line">(<span class="name"><span class="builtin-name">quote</span></span> user/y)</span><br><span class="line">user&gt; (read-string "``~~y")</span><br><span class="line">y</span><br></pre></td></tr></table></figure><h2 id="Macro-Rules-of-Thumb"><a href="#Macro-Rules-of-Thumb" class="headerlink" title="Macro Rules of Thumb"></a>Macro Rules of Thumb</h2><p>在正式实战前，这里摘抄 JoyOfClojure 一书中关于写宏的一般准则：</p><ol><li>如果函数能完成相应功能，不要写宏。在需要构造语法抽象（比如<code>when</code>）或新的binding 时再去用宏</li><li>写一个宏使用的 demo，并手动展开</li><li>使用<code>macroexpand</code>, <code>macroexpand-1</code> 与 <code>clojure.walk/macroexpand-all</code> 去验证宏是如何工作的</li><li>在 REPL 中测试</li><li>如果一个宏比较复杂，尽可能拆分成多个函数</li></ol><p>希望读者在写/读宏遇到困难时，思考是否对应了上述准则。</p><h2 id="In-Action"><a href="#In-Action" class="headerlink" title="In Action"></a>In Action</h2><p>前面介绍过，宏的一大应用场景是流程控制，比如上面介绍的 when、when-let，以及各种 do 的衍生品 dotimes、doseq，所以实战也从这里入手，构造一系列 do-primes，通过对它不断的完善修改，介绍写宏的技巧与注意事项。</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">do-primes</span> [n start end]</span><br><span class="line">  body)</span><br></pre></td></tr></table></figure><p>上面是 do-primes 的使用方式，它会遍历 <code>[start, end)</code> 范围内的素数，对于具体素数 n，执行 body 里面的内容。</p><h3 id="使用-gensym-保证宏-Hygiene"><a href="#使用-gensym-保证宏-Hygiene" class="headerlink" title="使用 gensym 保证宏 Hygiene"></a>使用 gensym 保证宏 Hygiene</h3><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> prime? [n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [guard (<span class="name"><span class="builtin-name">int</span></span> (<span class="name">Math/ceil</span> (<span class="name">Math/sqrt</span> n)))]</span><br><span class="line">    (<span class="name"><span class="builtin-name">loop</span></span> [i <span class="number">2</span>]</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">zero?</span></span> (<span class="name"><span class="builtin-name">mod</span></span> n i))</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> i guard)</span><br><span class="line">          <span class="literal">true</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">inc</span></span> i)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> next-prime [n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">prime?</span> n)</span><br><span class="line">    n</span><br><span class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">inc</span></span> n))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes [[variable start end] &amp; body]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">loop</span></span> [~variable ~start]</span><br><span class="line">     (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~end)</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">         ~@body)</span><br><span class="line">       (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable))))))</span><br></pre></td></tr></table></figure><p>上面的实现比较直接，首先定义了两个辅助函数，然后通过返回由 loop 构成的 code 来达到遍历的效果。简单测试下：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">do-primes</span> [n <span class="number">2</span> <span class="number">13</span>]</span><br><span class="line">  (<span class="name">println</span> n))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">loop</span></span> [n <span class="number">2</span>]</span><br><span class="line">  (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n <span class="number">13</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 最终输出 3 5 7 11</span></span><br></pre></td></tr></table></figure><p>达到预期。但上述实现有些问题：end 在循环中进行比较时多次进行了求值，如果传入的 end 不是固定的数字，而是一个函数，而我们又无法确定这个函数有无副作用，这就可能产生问题。<br>也许你会说，这个解决也很简单，在进行 loop 之前，用一个 let 先把 end 的值先算出来就可以了。这个确实能解决多次执行的问题，但是又引入另一个隐患：<strong>end 先于 start 执行</strong>。这会不会产生不良后果，我们同样无法预知，我们能做到的就是<strong>尽量不用暴露宏的实现细节</strong>，具体表现就是<strong>保证宏参数的求值顺序</strong>。所以有了下面的修改：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2 [[variable start end] &amp; body]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [start# ~start</span><br><span class="line">         end# ~end]</span><br><span class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable start#]</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable end#)</span><br><span class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">           ~@body)</span><br><span class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">do-primes2</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name">println</span> n))</span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [start__17380__auto__ <span class="number">2</span> end__17381__auto__ (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n start__17380__auto__]</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n end__17381__auto__)</span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure><p>在 syntax-quote 里面，使用了 <code>name#</code> 的形式来定义 locals，这是 gensym 机制，用来生成全局唯一的 symbol，保证宏的“卫生”（<a href="http://clojure-doc.org/articles/language/macros.html#macro-hygiene-and-gensym" target="_blank" rel="noopener">hygiene</a>）。如果这里不使用 gensym，在 Common Lisp 里面可能会污染全局里面的同名变量，在 Clojure 里面，为了避免污染全局环境，name 部分会 resolve 成当前命名空间里面的变量，例如</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2-danger [[variable start end] &amp; body]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [inner-start ~start</span><br><span class="line">         inner-end ~end]</span><br><span class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable inner-start]</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable inner-end)</span><br><span class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">           ~@body)</span><br><span class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">do-primes2-danger</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">                        (<span class="name">println</span> n))</span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [user/inner-start <span class="number">2</span></span><br><span class="line">      user/inner-end (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n user/inner-start] </span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n user/inner-end) </span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) </span><br><span class="line">        (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure><p>通过宏展开的代码可以看到，这明显不是我们想要的，运行上述代码会直接报错<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException：Can'<span class="built_in">t</span> let qualified <span class="built_in">na</span><span class="symbol">me:</span> user/inner-start</span><br></pre></td></tr></table></figure></p><p>所以在定义内部 locals 时，一定要用 gensym 机制。如果能确保使用的名字不会造成污染，也可以使用 <code>~&#39;name</code> 的形式来避免 resolve 这一过程。<code>~&#39;name</code> 其实就是 <code>~(quote name)</code> 的简写，它在 syntax-quote 里面求值的结果就是 symbol 字面量 <code>name</code>：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2-safe [[variable start end] &amp; body]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [~'inner-start ~start</span><br><span class="line">         ~'inner-end ~end]</span><br><span class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable ~'inner-start]</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~'inner-end)</span><br><span class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">           ~@body)</span><br><span class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">do-primes2-safe</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">                 (<span class="name">println</span> n))</span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [inner-start <span class="number">2</span> inner-end (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n inner-start]</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n inner-end)</span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure><h3 id="Macro-writing-macro"><a href="#Macro-writing-macro" class="headerlink" title="Macro-writing macro"></a>Macro-writing macro</h3><p>通过上面的例子，我们知道，gensym 是一种非常实用的技巧，所以我们完全有可能再进行一次抽象，构造 only-once 宏，来保证传入的参数按照顺序只求值一次：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> only-once [names &amp; body]</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [gensyms (<span class="name">repeatedly</span> (<span class="name"><span class="builtin-name">count</span></span> names) gensym)]</span><br><span class="line">    `(<span class="name"><span class="builtin-name">let</span></span> [~@(<span class="name">interleave</span> gensyms (<span class="name"><span class="builtin-name">repeat</span></span> '(<span class="name"><span class="builtin-name">gensym</span></span>)))]</span><br><span class="line">       `(<span class="name"><span class="builtin-name">let</span></span> [~~@(<span class="name"><span class="builtin-name">mapcat</span></span> #(<span class="name"><span class="builtin-name">list</span></span> %<span class="number">1</span> %<span class="number">2</span>) gensyms names)]</span><br><span class="line">          ~(<span class="name"><span class="builtin-name">let</span></span> [~@(<span class="name"><span class="builtin-name">mapcat</span></span> #(<span class="name"><span class="builtin-name">list</span></span> %<span class="number">1</span> %<span class="number">2</span>) names gensyms)]</span><br><span class="line">             ~@body)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes3 [[variable start end] &amp; body]</span><br><span class="line">  (<span class="name">only-once</span> [start end]</span><br><span class="line">             `(<span class="name"><span class="builtin-name">loop</span></span> [~variable ~start]</span><br><span class="line">                (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~end)</span><br><span class="line">                  (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">                    ~@body)</span><br><span class="line">                  (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">do-primes3</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name">println</span> n))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [G__18605 <span class="number">2</span> G__18606 (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n G__18605]</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n G__18606)</span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure><p>only-once 的核心思想是用 gensym 来替换掉传入的 symbol（即 names），为了达到这种效果，它首先定义出一组与参数数目相同的 gensyms（分别记为#s1 #s2），然后在第二层 let 为这些 gensyms 做 binding，value 也是用 gensym 生成的（分别记为#s3 #s4），这一层的 let 的返回值将内嵌到 do-primes3 内：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [#s1 #s3 #s2 #s4]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [#s3 ~start #s3 ~end]</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> [start #s1 end #s2]</span><br><span class="line">      ~@body)))</span><br></pre></td></tr></table></figure><p>第三层 let 的结果作为 code 内嵌到调用 do-primes3 处，即最终的展开式：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [#s3 <span class="number">2</span> #s4 (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n #s3]</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n #s4)</span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure><p>根据上述分析过程，可以看到第四层嵌套的 let 先于第三层嵌套的 let 执行，第四层 let 做 binding 时，是把 #s1 对应的 #s3 赋值给 start，#s2 对应的 #s4 赋值给 end，这样就成功的实现了 symbol 的替换。</p><p>only-once 属于 macro-writing macro 的范畴，就是说它使用的对象本身还是个宏，所以有一定的难度，主要是分清不同表达式的求值环境，这一点对于理解这一类宏非常关键。不过这一类宏大家应该很少能见到，更多的时候是使用辅助函数来分解复杂宏。比如我们这里就使用了两个辅助函数 prime? next-prime 来简化宏的写法。下面一个例子会阐述这一点。</p><h3 id="使用辅助函数定义简化宏"><a href="#使用辅助函数定义简化宏" class="headerlink" title="使用辅助函数定义简化宏"></a>使用辅助函数定义简化宏</h3><p><code>def-watched</code> 可以定义一个受监控的 var，在 root binding 改变时打印前后的值</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> def-watched [name &amp; value]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">     (<span class="name"><span class="builtin-name">def</span></span> ~name ~@value)</span><br><span class="line">     (<span class="name"><span class="builtin-name">add-watch</span></span> (<span class="name"><span class="builtin-name">var</span></span> ~name)</span><br><span class="line">                <span class="symbol">:re-bind</span></span><br><span class="line">                (<span class="name"><span class="builtin-name">fn</span></span> [~'key ~'r old# new#]</span><br><span class="line">                  (<span class="name">println</span> '~name old# <span class="string">" -&gt; "</span> new#)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">def-watched</span> foo <span class="number">1</span>)                  </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> foo <span class="number">2</span>)</span><br><span class="line"><span class="comment">;; 这时打印 foo 1  -&gt;  2</span></span><br></pre></td></tr></table></figure><p>为了简化 def-watched，可能会想把里面的函数提取出来：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> gen-watch-fn [name]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [k r o n]</span><br><span class="line">    (<span class="name">println</span> name <span class="string">":"</span> o <span class="string">" -&gt; "</span> n)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> def-watched2 [name &amp; value]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">     (<span class="name"><span class="builtin-name">def</span></span> ~name ~@value)</span><br><span class="line">     (<span class="name"><span class="builtin-name">add-watch</span></span> (<span class="name"><span class="builtin-name">var</span></span> ~name)</span><br><span class="line">                <span class="symbol">:re-bind</span> (<span class="name">gen-watch-fn</span> '~name))))</span><br><span class="line"></span><br><span class="line">(<span class="name">def-watched2</span> bar <span class="number">1</span>)                  </span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">def</span></span> bar <span class="number">1</span>) (<span class="name"><span class="builtin-name">add-watch</span></span> #'bar <span class="symbol">:re-bind</span> (<span class="name">gen-watch-fn</span> 'bar)))</span><br></pre></td></tr></table></figure><p>这时的效果和上面是一样的，请注意这里是把 gen-watch-fn 实现为了函数，如果用宏的话，会有什么效果呢？<br><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 将 gen-watch-fn 改为 defmacro，其他均不变 </span></span><br><span class="line"><span class="comment">;; (def-watched2 bar 1) 展开后变成了</span></span><br><span class="line">(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">  (<span class="name"><span class="builtin-name">def</span></span> bar <span class="number">1</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">add-watch</span></span></span><br><span class="line">    #'bar</span><br><span class="line">    <span class="symbol">:re-bind</span></span><br><span class="line">    #function[user/gen-watch-fn/fn--17288]))</span><br></pre></td></tr></table></figure></p><p>这直接会报 No matching ctor found for class #function[user/gen-watch-fn/fn–17288]，由于 gen-watch-fn 是宏，它返回的是 code，而不是一般的 data，这也就是问题发生的缘由。</p><p>回想本文一开始介绍的宏的两个特性：参数是否需要求值，返回值是 code 还是 data，这是决定是否用宏的关键。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一开始就明确指出 Lisp 中 code as data 的特性，这一点表面看似比较好理解，但是放到具体环境中时，就十分容易搞错，所以还是要多写宏，实战岀真知。<br>实战部分介绍了一些注意事项以及管用技巧，引入了相比来说难以理解的 macro-writing marco，完全理解它有一定难度，但也不是无法入手，理清 quote unquote 的作用机制，并且在 REPL 中不断调试，肯定能有所收获。<br>虽说不推荐使用宏解决问题，但是在有些时候，一个简单的宏不仅仅能省掉好几十行代码，而且能使逻辑更清晰，这时候也就不要“吝啬”了。</p><p>最后，希望通过宏系列这两篇文章的介绍，大家能对宏有更深的理解。如果有问题，欢迎留言讨论！<br>Happy Lisp！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://8thlight.com/blog/colin-jones/2012/05/22/quoting-without-confusion.html" target="_blank" rel="noopener">Quoting Without Confusion</a></li><li><a href="https://clojure.org/reference/reader#syntax-quote" target="_blank" rel="noopener">https://clojure.org/reference/reader#syntax-quote</a></li><li><a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html" target="_blank" rel="noopener">http://www.gigamonkeys.com/book/macros-defining-your-own.html</a></li><li><a href="https://hubpages.com/technology/Clojure-macro-writing-macros" target="_blank" rel="noopener">https://hubpages.com/technology/Clojure-macro-writing-macros</a></li><li><a href="https://xivilization.net/~marek/blog/2013/09/17/clojure-and-hygienic-macros/" target="_blank" rel="noopener">https://xivilization.net/~marek/blog/2013/09/17/clojure-and-hygienic-macros/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是宏系列的第二篇文章，侧重于实战，对于新手建议先阅读宏系列的&lt;a href=&quot;/blog/2017/08/31/master-macro-theory/&quot;&gt;理论篇&lt;/a&gt;，之后再来看本文。当然如果你有一定基础，也可以直接阅读本文。&lt;br&gt;其次，希望读者能把本文的 Clo
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深学习 Lisp 宏之理论篇</title>
    <link href="http://liujiacai.net/blog/2017/08/31/master-macro-theory/"/>
    <id>http://liujiacai.net/blog/2017/08/31/master-macro-theory/</id>
    <published>2017-08-31T14:17:52.000Z</published>
    <updated>2019-12-24T10:59:14.609Z</updated>
    
    <content type="html"><![CDATA[<p>宏（macro）是 Lisp 语言中最重要的武器，它可以自动生成运行时的代码。宏也是编写领域特定语言（DSL）的利器，可以在不改动语言本身的基础上，增加新的程序构造体，这在其他语言中是不可能。比如，现在比较流行的同步方式写异步代码的 async/await，在非 Lisp 语言需要语言本身支持，但是在 Lisp 里面可以通过几个宏来解决，可以参考：<a href="https://github.com/clojure/core.async" target="_blank" rel="noopener">core.async</a>。</p><blockquote><p>With great power comes great responsibility.</p></blockquote><p>由于宏的强大，掌握编写它的方法有较大的难度，所以社区一般会建议能不用就不要用它，我个人也比较认同这一点，但是对于一些场景用宏确实也很方便，能使程序简洁明了，所以还是有必要掌握它的，等有一定经验，就可以知道在什么场景下使用最合适了。</p><p>为了由浅入深、系统地介绍宏，打算分两篇文章来介绍，第一篇为理论篇，主要介绍 </p><ol><li>Clojure 语言中的基本语法，重点介绍 Symbol 数据类型，为什么需要它，非 Lisp 语言为什么没有</li><li>宏的本质，宏运行时期</li></ol><p>第二篇是实战篇，介绍宏的一些常见技巧以及一些通用宏。这两篇均以 Clojure 方言为示例，但其概念原理在其他 Lisp 中都是相通的。本文为第一篇。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Clojure 作为一门 Lisp 方言，其语言的基本单元是表达式（expression），通过不同表达式的组合形成最终的程序。非 Lisp 语言中除了「表达式」外，还有「声明（statement）」，声明没有返回值，只会产生一些副作用，比如<code>int a = 1</code>；而每个表达式都有一个返回值，极少数表达式具有副作用。Clojure 语言中有以下表达式字面量（literals）：</p><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; Numeric types</span></span><br><span class="line"><span class="number">42</span>              <span class="comment">; Long - 64-bit integer (from -2^63 to 2^63-1)</span></span><br><span class="line">6.022e23        ; Double - double-precision 64-bit floating point</span><br><span class="line">42N             ; BigInt - arbitrary precision integer</span><br><span class="line">1.0M            ; BigDecimal - arbitrary precision fixed-point decimal</span><br><span class="line">22/7            ; Ratio</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Character types</span></span><br><span class="line"><span class="string">"hello"</span>         <span class="comment">; String</span></span><br><span class="line">\e              ; Character</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Other types</span></span><br><span class="line"><span class="literal">nil</span>             <span class="comment">; null value</span></span><br><span class="line"><span class="literal">true</span>            <span class="comment">; Boolean (also, false)</span></span><br><span class="line">#"[0-9]+"       ; Regular expression</span><br><span class="line"><span class="symbol">:alpha</span>          <span class="comment">; Keyword</span></span><br><span class="line"><span class="symbol">:release/alpha</span>  <span class="comment">; Keyword with namespace</span></span><br><span class="line">map             ; Symbol</span><br><span class="line">+               ; Symbol - most punctuation allowed</span><br><span class="line">clojure.core/+  ; Namespaced symbol</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Collection types</span></span><br><span class="line">'(1 2 3)     ; list</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]      <span class="comment">; vector</span></span><br><span class="line">#&#123;1 2 3&#125;     ; set</span><br><span class="line">&#123;<span class="symbol">:a</span> <span class="number">1</span>, <span class="symbol">:b</span> <span class="number">2</span>&#125; <span class="comment">; map</span></span><br></pre></td></tr></table></figure><h3 id="结构与语义"><a href="#结构与语义" class="headerlink" title="结构与语义"></a>结构与语义</h3><p>在 Clojure 里面，有一个非 Lisp 语言中没有的 <a href="https://clojure.org/reference/data_structures#Symbols" target="_blank" rel="noopener">Symbol 类型</a>，定义如下：</p><blockquote><p>Symbols are identifiers that are normally used to refer to something else.</p></blockquote><p>可以说 symbol 就是一些标识符，用来代指其他东西，和英文中 he/she/it 等「代词」的作用差不多。现在大家所使用的高级语言，其语言构造体（language’s constructs）是由一些关键字与用户自定义变量组成，这些都是 symbol。看下面这个表达式：<br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2twOcjL6H8KJjSspmXXb2WXXa_!!581166664.png" alt="structure-and-semantics"></p><p>上面的绿色字标明这个表达式用到的数据结构，下面蓝色字标明这个表达式在运行时的含义。</p><p>大多数字面量进行求值（eval）时，都表示其自身，比如 <code>1</code> 就是数字 1，而 symbol 与 list 这两类则不同，它们在求值时，symbol 返回它所代指的值，list 表示函数调用。Clojure 里面提供了 def 这个<a href="https://clojure.org/reference/special_forms" target="_blank" rel="noopener">special form</a>来建立 symbol 到其他值的映射关系。例如：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user&gt; (<span class="function"><span class="keyword">def</span> <span class="title">cat</span></span> <span class="string">"Tom"</span>)</span><br><span class="line"><span class="comment">#'user/cat</span></span><br></pre></td></tr></table></figure></p><p>简单来说上面这一句把 symbol 字面量<code>cat</code>指向了字符串<code>Tom</code>，但是由于 Clojure 里面为了实现其动态特性，真实的情况稍微复杂一些，见下图：<br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2vBerXioaPuJjSsplXXbg7XXa_!!581166664.png" alt></p><p>Var 是Clojure里面提供的<a href="http://clojure-doc.org/articles/language/concurrency_and_parallelism.html#clojure-reference-types" target="_blank" rel="noopener">四种引用类型</a>中最常用的，支持动态作用域以及 thread-local 值。动态作用域是指函数内的自由变量的值是在运行时确定的，这里不清楚的可以参考我的另一篇文章<a href="/blog/2016/05/28/scope-closure/">《编程语言中的变量作用域与闭包》</a>，这里不在赘述。</p><p>继续回到上面的图，def 会把 cat 这个 symbol 指向同名的 var，同时把 var 指向字符串 Tom（叫做 root binding）。symbol 到 var 的映射关系保存在每个 namespace 中，可以用<code>resolve</code>来查询这个映射关系：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user&gt; (<span class="name">resolve</span> 'cat)</span><br><span class="line">#'user/cat</span><br></pre></td></tr></table></figure></p><p>最后一点需要注意的是，symbol 到 var 的映射关系只有在用 def（或其变体defn/defmacro） 定义时才具有，使用 let, loop 等定义的词法作用域（lexical context）里面的 binding 称为 <a href="https://groups.google.com/forum/#!topic/clojure/FLrtjyYJdRU" target="_blank" rel="noopener">locals</a>，没有这种映射关系，<a href="https://groups.google.com/forum/#!topic/clojure/PCKzXweeDeY" target="_blank" rel="noopener">locals 一旦创建后无法修改</a>。可以使用 <code>with-local-vars</code>（很少用到）宏来定义局部变量：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">with-local-vars</span> [<span class="name">x</span> <span class="number">1</span> y <span class="number">2</span>]</span><br><span class="line">  (<span class="name">var-set</span> x <span class="number">11</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">var-get</span> x) (<span class="name">var-get</span> y)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; =&gt; 13</span></span><br></pre></td></tr></table></figure></p><h2 id="quote"><a href="#quote" class="headerlink" title="quote"></a>quote</h2><p>由上面介绍我们知道，symbol 与 list 这两类字面量在求值时有特殊的处理方式，但在一些时间，不希望进行这种特殊处理，就希望 symbol 返回一个 symbol，list 不在表示函数调用，这时候就可以使用 <code>quote</code>（一般使用简化形式<code>&#39;</code>） 来实现：</p><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">user=&gt;</span><span class="clojure"> (<span class="name"><span class="builtin-name">quote</span></span> x)</span></span><br><span class="line">x</span><br><span class="line"><span class="meta">user=&gt;</span><span class="clojure"> 'x</span></span><br><span class="line">x</span><br><span class="line"><span class="meta">user=&gt;</span><span class="clojure"> '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span></span><br><span class="line">(1 2 3)</span><br></pre></td></tr></table></figure><p>一个常见的错误就是误把都是数据的 list 作为 code 去执行了：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">ClassCastException java<span class="built_in">.lang</span>.Long cannot be <span class="keyword">cast</span> <span class="keyword">to</span> clojure<span class="built_in">.lang</span>.IFn</span><br></pre></td></tr></table></figure></p><p>quote 在写宏时非常重要，我们这里只需要知道宏传入的参数都是 symbol 字面量即可，实战篇会详细介绍如何使用。下面仅举一例作为说明：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user&gt; (<span class="function"><span class="keyword">def</span> <span class="title">a</span></span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">#'user/a</span></span><br><span class="line">user&gt; (defmacro demo-<span class="function"><span class="keyword">macro</span> [<span class="title">params</span></span>] (println params))</span><br><span class="line"><span class="comment">#'user/demo-macro</span></span><br><span class="line">user&gt; (demo-<span class="function"><span class="keyword">macro</span> <span class="title">a</span></span>)</span><br><span class="line">a</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure></p><p>可以看到这里打印的是 symbol 字面量 <code>a</code>，而不是数字 1。由于<code>demo-macro</code>什么也没返回，所以在打印出 a 之后输出了 nil。</p><h2 id="宏的本质"><a href="#宏的本质" class="headerlink" title="宏的本质"></a>宏的本质</h2><p>由于 Lisp 采用 S-表达式（s-expression）作为其语言的构造体，所以天然具有 code as data 的特点，也就是说 Lisp 程序本身就是一个标准的 Lisp 数据结构，可以像操作其他数据类型一样来操作程序本身，这其实就是宏做的事情。老牌 Lisp hacker <a href="http://www.paulgraham.com" target="_blank" rel="noopener">Paul Graham</a> 在黑客与画家一书中有<a href="/blog/2016/12/31/dev-in-clojure/#Why-Lisp">提到</a>：</p><blockquote><p>Lisp 并不严格区分读取期、编译器、运行期。在编译期去运行就是宏，可以用来扩展语言。</p></blockquote><p>关于这三个时期的关系，可以用下面的图来表示<br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB27iCQbiIRMeJjy0FbXXbnqXXa_!!581166664.png" alt="Lisp 中不同时期的交互图"></p><p>由于运行期主要进行的是函数的调用，结合上面 symbol 的知识可以这么定义宏</p><blockquote><p>宏是编译期执行的函数，参数的类型是 symbol，返回值 symbol 数据结构（也是code）。返回值在运行时执行。</p></blockquote><p>定义宏的<code>defmacro</code>本身也是个宏，可以将其展开：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user&gt; (<span class="name">macroexpand</span> '(defmacro demo-macro [params] params))</span><br><span class="line"></span><br><span class="line">(<span class="name">do</span></span><br><span class="line">  (<span class="name">defn</span> demo-macro ([<span class="symbol">&amp;form</span> <span class="symbol">&amp;env</span> params] params))</span><br><span class="line">  (. #'demo-macro (<span class="name">setMacro</span>))</span><br><span class="line">  #'demo-macro)</span><br></pre></td></tr></table></figure></p><p>可以看到，Clojure 里面是调用 <code>setMacro</code> 来将宏与一般的函数分开。</p><h2 id="求值过程"><a href="#求值过程" class="headerlink" title="求值过程"></a>求值过程</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Clojure 语言本身 hosted 在 JVM 上，所以先看下 Java 是如何求值的：</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2vuFjjN6I8KJjSszfXXaZVXXa_!!581166664.png" alt="Java 求值过程"></p><p>在 Java 中，源代码（.java 文件）以字符流（characters）的形式被编译器（javac）处理，输出的 .class 文件包含了可以在 JVM 运行的 bytecode。</p><h3 id="Clojure"><a href="#Clojure" class="headerlink" title="Clojure"></a>Clojure</h3><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB25GXJcQfb_uJkHFrdXXX2IVXa_!!581166664.png" alt="Clojure 求值过程"></p><p>在 Clojure 中，源代码首先以字符流的形式被 Reader 处理，输出以 Clojure 数据结构表示的 code，之后编译器读入这些数据结构，输出 bytecode。</p><p>这里有非常重要的两点：</p><ol><li>Clojure 的源代码的基本单元是表达式，而不是源文件。这里的源文件可以是存在于磁盘上的 <code>.clj</code> 文件或 REPL。源文件被转化为一系列 表达式 后才被编译器处理</li><li>区分 Reader 与 Compiler 这两个过程是「宏」的基础，宏接受 Reader 处理后的code（也是数据），输出供 Compiler 执行的 code（也是数据）</li></ol><p>具体实现细节可以参考<a href="/blog/2017/02/05/clojure-compiler-analyze/#macroexpand">《Clojure 运行原理之编译器剖析篇》</a>：</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2j7k3dZtnpuFjSZFKXXalFFXa_!!581166664.png" alt="Clojure 编译器工作流程"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于初学 Lisp 的同学，对 symbol 类型不是很清楚，究其原因是这个类型在非 Lisp 语言中是不存在的，为什么不存在呢？主要是因为它们没法像 Lisp 一样具有 code as data 的特点，有些非 Lisp 语言可能也有所谓的 symbol 类型，像 ruby，但是其用法却与 Lisp 完全不同。区别可以参考<a href="https://www.slideshare.net/antoniogarrote/lisp-vs-ruby-metaprogramming-3222908" target="_blank" rel="noopener">下图</a></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2FQO3bnZRMeJjSspoXXcCOFXa_!!581166664.png" alt="Metaprogramming Ruby vs Lisp"></p><blockquote><p>What makes Lisp macros possible, is so far still unique to Lisp, perhaps because (a) it requires those parens, or something just as bad, and (b) if you add that final increment of power, you can no longer claim to have invented a new language, but only to have designed a new dialect of Lisp ; -)</p><blockquote><p>Paul Graham 「<a href="http://www.paulgraham.com/diff.html" target="_blank" rel="noopener">What makes Lisp different</a>」</p></blockquote></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://clojure.org/guides/learn/syntax#_structure_vs_semantics" target="_blank" rel="noopener">Learn Clojure - Syntax</a></li><li><a href="http://blog.cognitect.com/blog/2016/9/15/works-on-my-machine-understanding-var-bindings-and-roots" target="_blank" rel="noopener">WORKS ON MY MACHINE: UNDERSTANDING VAR BINDINGS AND ROOTS</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宏（macro）是 Lisp 语言中最重要的武器，它可以自动生成运行时的代码。宏也是编写领域特定语言（DSL）的利器，可以在不改动语言本身的基础上，增加新的程序构造体，这在其他语言中是不可能。比如，现在比较流行的同步方式写异步代码的 async/await，在非 Lisp 
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>《硅谷之谜》读后感</title>
    <link href="http://liujiacai.net/blog/2017/05/11/review-of-secret-of-silicon-valley/"/>
    <id>http://liujiacai.net/blog/2017/05/11/review-of-secret-of-silicon-valley/</id>
    <published>2017-05-10T23:07:31.000Z</published>
    <updated>2019-12-24T10:59:14.609Z</updated>
    
    <content type="html"><![CDATA[<p>吴军博士的<a href="https://book.douban.com/subject/26665230/" target="_blank" rel="noopener">《硅谷之谜》</a> 在年前就买了，可是一直迟迟没翻开。最近在一次出差的动车上把它看完了，可以说是一气呵成，根本停不下来，里面介绍的很多观点都比较深刻，而不仅仅是简单的罗列事实，更像是科学探究，试图找出每一个事情背后的原理。</p><p><img src="http://ww1.sinaimg.cn/large/5fee18eegy1ffh87lqu9uj20930bct92.jpg" alt="硅谷之谜"></p><p>下面内容来自书中的一些摘抄与笔记，不仅仅是解释硅谷之谜，更多的是对事物一般性的总结与归纳，发现背后的奥秘。</p><h2 id="伪论点"><a href="#伪论点" class="headerlink" title="伪论点"></a>伪论点</h2><p>本书一开始探讨过去媒体对硅谷成因的分析，并指出这些基本都是事后解释，其他很多地方都具有这些特点但却没有形成另一个奇迹，可以说是必要不充分条件。</p><ol><li>气候说，即硅谷拥有良好的气候条件</li><li>斯坦福之说，即硅谷是靠斯坦福大学不断孵化新的公司而维持繁荣的</li><li>风险投资</li><li>政府扶持</li><li>知识产权</li></ol><h2 id="叛逆精神"><a href="#叛逆精神" class="headerlink" title="叛逆精神"></a>叛逆精神</h2><p>在19世纪中叶时期，美国东海岸的淘金热催生了一个新的城市，后来为区别于澳大利亚墨尔本，改称为“旧金山”（又称三藩）。在行政区域划分上隶属加州，是加州仅次于洛杉矶的第二大城市。旧金山湾区（简称湾区）。是北加州围绕旧金山湾和圣巴勃罗湾河口的一片都会区。加州有三个主要城市都坐落在这里：旧金山、圣荷西和奥克兰。湾区聚集着大量的华人和墨西哥人，这里是中国富人移民的首选之地。硅谷主要分布在南湾附近。</p><p><img src="http://ww1.sinaimg.cn/large/5fee18eegy1ffh86rw9s5j20go0ca0yp.jpg" alt="硅谷坐标"><br><img src="http://ww1.sinaimg.cn/large/5fee18eegy1ffh4j95w0tj20go0ci78x.jpg" alt="硅谷公司"></p><p>从淘金开始，硅谷人血液里面就充满了叛逆、冒险。吴军更是把硅谷成功的奥秘首先归结为叛逆精神和对叛逆的宽容与支持。硅谷从很大程度上是从仙童半导体（Fairchild Semiconductor）开始的，从它“叛变”出了很多公司，英特尔就是其中之一，用今天的话说就是仙童系。</p><p><img src="http://ww1.sinaimg.cn/large/5fee18eegy1ffh4m4fhxhj20yw190ajb.jpg" alt="仙童系公司"></p><p><img src="http://ww1.sinaimg.cn/large/5fee18eegy1ffh4nthd5vj22io1w0kjl.jpg" alt="思科系公司"></p><h2 id="信息时代"><a href="#信息时代" class="headerlink" title="信息时代"></a>信息时代</h2><p>如果说叛逆精神是外因，那么什么是硅谷成功的内因呢？吴军博士这里从工业时代的企业开始谈起。</p><p>从瓦特的蒸汽机开始，标志着人类进入了工业时代，可以用物理动力代替人工。虽然在瓦特之前已经有了很简陋的蒸汽机，而且在他之后西门子等人利用电力能够提供能方便的动力，但是瓦特所发明的万用蒸汽机则使得人类第一次让一种工业品（瓷器）出现了供大于求的现象。当然瓦特也是站在巨人的肩膀之上，引领瓦特开启工业革命大门的是牛顿的巨作《自然哲学的数学原理》。</p><h3 id="机械思维"><a href="#机械思维" class="headerlink" title="机械思维"></a>机械思维</h3><p>在牛顿之后，人类开始学会用理性的眼光对待一切的已知和未知。在整个工业革命时期，一直到20世纪初，人们都习惯用机械的方法来实现所需要的一切产品。在瓦特之后，英国技师史蒂芬森利用机械发明了火车，英国发明家瑟伯（Charles Thurber）第一次用机械的方式实现了替代手写的转轮打字机，甚至连巴贝奇发明的能够进行复杂差分计算的计算机，也是通过机械实现的。</p><p>虽然现在一提到机械思维可能有些贬义，但是在工业时代却是相当时髦、先进。再次在机械思维的指导下，人们认为</p><blockquote><p>任何一个复杂的问题都可以分解成若干个简单的问题，解决这些简单问题之后，原先的复杂问题就必定有解。</p></blockquote><p>这一思想算是现在的<a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" target="_blank" rel="noopener">分治法</a>的起源。</p><p>机械开始代替大量人工之后，产品的标准化代替了个性化，而追求效率也成为工业企业提高竞争力几乎唯一的选择。在诸多企业管理理论中，最具代表性的是泰勒的理论。</p><h3 id="泰勒管理理论"><a href="#泰勒管理理论" class="headerlink" title="泰勒管理理论"></a>泰勒管理理论</h3><p><a href="https://en.wikipedia.org/wiki/Frederick_Winslow_Taylor" target="_blank" rel="noopener">弗雷德里克·泰勒</a>（Frederick Taylor, 1856–1915）是美国科学管理的创始人，被誉为科学管理之父。其理论可以包括下述四个方面：</p><ol><li>效率优先。怎么提高生产效率呢？泰勒最看重的是<strong>优化流程</strong>和<strong>标准化管理</strong>。流水线生产是机械思维在生产和管理上最具有代表性的产物。在整个工厂里，除了工厂主和主要工程师知道产品全貌，生产线的工人只知道自己所做的那一点东西。福特汽车就是在这种标准化的流水线中壮大起来的。在软件工程里面，“码农”对应了流水线工人，架构师对应于工厂主或工程师。</li><li>同构的树状组织架构。</li><li>人性化管理。二战后的日本，把这点发挥到了极致。员工一旦进入一家公司，一直干到退休，公司包管员工生活的方方面面。</li><li>可预测性</li></ol><p>上述四个特点是机械思维的典型产物，泰勒理论在工业革命时期极大的提高了全球生产率。但是到了信息社会，它在企业管理和协调劳资关系上的局限性越来越突出。</p><h3 id="信息时代的科学基础"><a href="#信息时代的科学基础" class="headerlink" title="信息时代的科学基础"></a>信息时代的科学基础</h3><p>本书最后一章介绍三论与管理，主要是克服泰勒理论固有的弊端，适应信息时代的要求。</p><p>三论具体是指控制论、信息论和系统论。三论与以往那些单一的学科不同，一方面它既是交叉学科也是边缘学科，另一方面是她们不仅被用于解决自身学科内的各种问题，而且它们还代表着一种新的思维方式和做事方法，成为一种全新的世界观与方法论。</p><ul><li>控制论的思维方式主要强调<strong>根据变化进行不断挑战</strong>。这与机械思维（做一种尽可能确定的预测）完全不同，适用于做复杂的产品。在软件开发过程中这一点尤为重要，因为产品会随着时间不断演化，必须做到顺势而变。</li><li>信息论的思维方式建立在<strong>不确定性的基础上</strong>。香农用热力学中熵的概念来描述不确定性。在我们生活中到处都充满了不确定性，要想消除这种不确定性，就需要引入信息。这个观点其实正好对应了现在的大数据时代，谁掌握了信息，谁就能够发大财，这就如同在工业时代，谁掌握了资本谁就能发大财一样。</li><li>系统论的思维方式主要强调<strong>局部最优不代表全局最优</strong>。书中举的智能手机的例子再合适不过。很多 Android 厂商一味追求各个部件的参数，甚至以跑分出高分为荣，相比之下 iPhone 从不鼓吹这些，但是却是现在最好用的智能手机。</li></ul><p>在解释信息论时，还提香农两大定律。</p><p>第一定律大致含义是：有 N 种可能性的信息源，对它发出的信息进行（不损失）编码，编码长度一定大于该信源的信息熵。一个实际例子：编码汉字，常用字可以编码短些，生僻字编码长些，但是无论怎么做，<strong>编码的平均长度一定会超过汉子的不确定性（即它们的信息熵）</strong>。<br>霍夫曼编码可以给出一种最优的编码方案，达到平均编码长度可以非常接近它的不确定性（熵）——比如对汉字进行编码只要把最短的编码分配给最常见汉字即可。吴军博士这里更是给出了霍夫曼编码原理的本质：</p><blockquote><p>把最好的资源分配给最有可能成功的事情。</p></blockquote><p>香农第二定律说的是，信息的传播速率不可能超过信道的容量。这两大定律在信息时代所起的作用堪比牛顿力学定律之于工业时代。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通读本书，觉得硅谷的成功真是来之不易，除了风险投资、汇聚于此的全世界的精英、对工程师的尊重等因素，更重要的是掌握了开启信息时代的大门的钥匙。<br>·<br>在大工业时代，效率来自于事先的规划和不断重复的操作；而在信息时代，效率来自沟通的带宽，以及共同遵守的协议。一个时代的来临，需要有相应的指导理论，三论作为信息时代的路标，其实已经在潜移默化中融入我们的生活，我们总是想获取更多信息以便将来更好的就业就是信息论的体现。</p><p>其次，本书纠正了我对专利的理解：</p><blockquote><p>专利真正保护的是一个过程（包括一种实现方法）和一个结果。比如：牛顿三个定律是不能申请专利的，而利用这些原理发明某一种工作方式下的蒸汽机就可以申请。</p></blockquote><p>最后希望身处信息时代的我们都能够阅读原作，相信一定会获益匪浅。给吴军老师点个赞。👍</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;吴军博士的&lt;a href=&quot;https://book.douban.com/subject/26665230/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《硅谷之谜》&lt;/a&gt; 在年前就买了，可是一直迟迟没翻开。最近在一次出差的动车上把它看完了，可以说是
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
      <category term="ideas" scheme="http://liujiacai.net/tags/ideas/"/>
    
  </entry>
  
  <entry>
    <title>Clojure Web 开发-- Ring 使用指南</title>
    <link href="http://liujiacai.net/blog/2017/04/02/clojure-web-dev-ring-usage/"/>
    <id>http://liujiacai.net/blog/2017/04/02/clojure-web-dev-ring-usage/</id>
    <published>2017-04-02T15:56:30.000Z</published>
    <updated>2019-12-24T10:59:14.609Z</updated>
    
    <content type="html"><![CDATA[<p>在 Clojure 众多的 Web 框架中，<a href="https://github.com/ring-clojure/ring" target="_blank" rel="noopener">Ring</a> 以其简单统一的 HTTP 抽象模型脱颖而出。Ring 充分体现了函数式编程的思想——通过一系列函数的组合形成了一个易于理解、扩展的 HTTP 处理链。</p><p>本篇文章首先介绍 Ring 核心概念及其实现原理，然后介绍如何基于 Ring + <a href="https://github.com/weavejester/compojure" target="_blank" rel="noopener">Compojure</a> 实现一 RESTful 服务。</p><h2 id="Ring-SPEC"><a href="#Ring-SPEC" class="headerlink" title="Ring SPEC"></a><a href="https://github.com/ring-clojure/ring/blob/master/SPEC" target="_blank" rel="noopener">Ring SPEC</a></h2><p>Ring 规范里面有如下5个核心概念：</p><ol><li>handlers，应用逻辑处理的主要单元，由一个普通的 Clojure 函数实现</li><li>middleware，为 handler 增加额外功能</li><li>adapter，将 HTTP 请求转为 Clojure 里的 map，将 Clojure 里的 map 转为 HTTP 相应</li><li>request map，HTTP 请求的 map 表示</li><li>response map，HTTP 相应的 map 表示</li></ol><p>这5个组件的关系可用下图表示（By <a href="https://github.com/ring-clojure/ring-defaults/issues/20" target="_blank" rel="noopener">Ring 作者</a>）：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|<span class="string">  Middleware   </span>|</span><br><span class="line">|<span class="string">  +---------+  </span>|<span class="string">             +---------+      +--------+</span></span><br><span class="line">|<span class="string">  </span>|<span class="string">         </span>|<span class="string">&lt;-- request ----</span>|<span class="string">         </span>|<span class="string">      </span>|<span class="string">        </span>|</span><br><span class="line">|<span class="string">  </span>|<span class="string"> Handler </span>|<span class="string">  </span>|<span class="string">             </span>|<span class="string"> Adapter </span>|<span class="string">&lt;----&gt;</span>|<span class="string"> Client </span>|</span><br><span class="line">|<span class="string">  </span>|<span class="string">         </span>|<span class="string">--- response --&gt;</span>|<span class="string">         </span>|<span class="string">      </span>|<span class="string">        </span>|</span><br><span class="line">|<span class="string">  +---------+  </span>|<span class="string">             +---------+      +--------+</span></span><br><span class="line"><span class="string">+---------------+</span></span><br></pre></td></tr></table></figure></p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> learn-ring.core</span><br><span class="line">  (<span class="symbol">:require</span> [ring.adapter.jetty <span class="symbol">:refer</span> [run-jetty]]))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> handler [req]</span><br><span class="line">  &#123;<span class="symbol">:headers</span> &#123;&#125;</span><br><span class="line">   <span class="symbol">:status</span> <span class="number">200</span></span><br><span class="line">   <span class="symbol">:body</span> <span class="string">"Hello World"</span>&#125;)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> middleware [handler]</span><br><span class="line">  <span class="string">"Audit a log per request"</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [req]</span><br><span class="line">    (<span class="name">println</span> (<span class="symbol">:uri</span> req))</span><br><span class="line">    (<span class="name">handler</span> req)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> app</span><br><span class="line">  (<span class="name"><span class="builtin-name">-&gt;</span></span> handler</span><br><span class="line">      middleware))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> -main [&amp; _]</span><br><span class="line">  (<span class="name">run-jetty</span> app &#123;<span class="symbol">:port</span> <span class="number">3000</span>&#125;))</span><br></pre></td></tr></table></figure><p>运行上面的程序，就可以启动一 Web 应用，然后在浏览器访问就可以返回<code>Hello World</code>，同时在控制台里面会打印出请求的 uri。</p><p><code>run-jetty</code> 是 Ring 提供的基于 jetty 的 adapter，方便开发测试。其主要功能是两个转换：</p><ol><li><code>HttpServletRequest</code> —&gt; <code>request map</code></li><li><code>response map</code> —&gt; <code>HttpServletResponse</code></li></ol><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; ring.adapter.jetty</span></span><br><span class="line">(<span class="name"><span class="builtin-name">defn-</span></span> <span class="comment">^AbstractHandler</span> proxy-handler [handler]</span><br><span class="line">  (<span class="name"><span class="builtin-name">proxy</span></span> [AbstractHandler] []</span><br><span class="line">    (<span class="name">handle</span> [_ <span class="comment">^Request</span> base-request request response]</span><br><span class="line">      (<span class="name"><span class="builtin-name">let</span></span> [request-map  (<span class="name">servlet/build-request-map</span> request)</span><br><span class="line">            response-map (<span class="name">handler</span> request-map)]</span><br><span class="line">        (<span class="name">servlet/update-servlet-response</span> response response-map)</span><br><span class="line">        (<span class="name">.setHandled</span> base-request <span class="literal">true</span>)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; ring.util.servlet</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; HttpServletRequest --&gt; request map</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> build-request-map</span><br><span class="line">  <span class="string">"Create the request map from the HttpServletRequest object."</span></span><br><span class="line">  [<span class="comment">^HttpServletRequest</span> request]</span><br><span class="line">  &#123;<span class="symbol">:server-port</span>        (<span class="name">.getServerPort</span> request)</span><br><span class="line">   <span class="symbol">:server-name</span>        (<span class="name">.getServerName</span> request)</span><br><span class="line">   <span class="symbol">:remote-addr</span>        (<span class="name">.getRemoteAddr</span> request)</span><br><span class="line">   <span class="symbol">:uri</span>                (<span class="name">.getRequestURI</span> request)</span><br><span class="line">   <span class="symbol">:query-string</span>       (<span class="name">.getQueryString</span> request)</span><br><span class="line">   <span class="symbol">:scheme</span>             (<span class="name"><span class="builtin-name">keyword</span></span> (<span class="name">.getScheme</span> request))</span><br><span class="line">   <span class="symbol">:request-method</span>     (<span class="name"><span class="builtin-name">keyword</span></span> (<span class="name">.toLowerCase</span> (<span class="name">.getMethod</span> request) Locale/ENGLISH))</span><br><span class="line">   <span class="symbol">:protocol</span>           (<span class="name">.getProtocol</span> request)</span><br><span class="line">   <span class="symbol">:headers</span>            (<span class="name">get-headers</span> request)</span><br><span class="line">   <span class="symbol">:content-type</span>       (<span class="name">.getContentType</span> request)</span><br><span class="line">   <span class="symbol">:content-length</span>     (<span class="name">get-content-length</span> request)</span><br><span class="line">   <span class="symbol">:character-encoding</span> (<span class="name">.getCharacterEncoding</span> request)</span><br><span class="line">   <span class="symbol">:ssl-client-cert</span>    (<span class="name">get-client-cert</span> request)</span><br><span class="line">   <span class="symbol">:body</span>               (<span class="name">.getInputStream</span> request)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; response map --&gt; HttpServletResponse</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> update-servlet-response</span><br><span class="line">  <span class="string">"Update the HttpServletResponse using a response map. Takes an optional</span></span><br><span class="line"><span class="string">  AsyncContext."</span></span><br><span class="line">  ([response response-map]</span><br><span class="line">   (<span class="name">update-servlet-response</span> response <span class="literal">nil</span> response-map))</span><br><span class="line">  ([<span class="comment">^HttpServletResponse</span> response context response-map]</span><br><span class="line">   (<span class="name"><span class="builtin-name">let</span></span> [&#123;<span class="symbol">:keys</span> [status headers body]&#125; response-map]</span><br><span class="line">     (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">nil?</span></span> response)</span><br><span class="line">       (<span class="name"><span class="builtin-name">throw</span></span> (<span class="name">NullPointerException.</span> <span class="string">"HttpServletResponse is nil"</span>)))</span><br><span class="line">     (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">nil?</span></span> response-map)</span><br><span class="line">       (<span class="name"><span class="builtin-name">throw</span></span> (<span class="name">NullPointerException.</span> <span class="string">"Response map is nil"</span>)))</span><br><span class="line">     (<span class="name"><span class="builtin-name">when</span></span> status</span><br><span class="line">       (<span class="name">.setStatus</span> response status))</span><br><span class="line">     (<span class="name">set-headers</span> response headers)</span><br><span class="line">     (<span class="name"><span class="builtin-name">let</span></span> [output-stream (<span class="name">make-output-stream</span> response context)]</span><br><span class="line">       (<span class="name">protocols/write-body-to-stream</span> body response-map output-stream)))))</span><br></pre></td></tr></table></figure><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a><a href="https://github.com/ring-clojure/ring/wiki/Middleware-Patterns" target="_blank" rel="noopener">Middleware</a></h2><p>Ring 里面采用 Middleware 模式去扩展 handler 的功能，这其实是函数式编程中常用的技巧，用高阶函数去组合函数，实现更复杂的功能。在 Clojure 里面，函数组合更常见的是用 <code>comp</code>，比如<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="builtin-name">comp</span></span> #(<span class="name"><span class="builtin-name">*</span></span> % <span class="number">2</span>) inc) <span class="number">1</span>)</span><br><span class="line"><span class="comment">;; 4</span></span><br></pre></td></tr></table></figure></p><p>这对一些简单的函数非常合适，但是如果逻辑比较复杂，Middleware 模式就比较合适了。例如可以进行一些逻辑判断决定是否需要调用某函数：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> middleware-comp [handler]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [x]</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">zero?</span></span> <span class="number">0</span>)</span><br><span class="line">      (<span class="name">handler</span> (<span class="name"><span class="builtin-name">inc</span></span> x))</span><br><span class="line">      (<span class="name">handler</span> x))))</span><br><span class="line"></span><br><span class="line">((<span class="name"><span class="builtin-name">-&gt;</span></span> #(<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> %)</span><br><span class="line">      middleware-comp) <span class="number">1</span>)</span><br><span class="line"><span class="comment">;; 4</span></span><br><span class="line">((<span class="name"><span class="builtin-name">-&gt;</span></span> #(<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> %)</span><br><span class="line">      middleware-comp) <span class="number">0</span>)</span><br><span class="line"><span class="comment">;; 2</span></span><br></pre></td></tr></table></figure></p><p>虽然 Middleware 使用非常方便，但是有一点需要注意：多个 middleware 组合的顺序。后面在讲解 RESTful 示例时会演示不同顺序的 middleware 对请求的影响。</p><p>Middleware 这一模式在函数式编程中非常常见，Clojure 生态里面新的构建工具 <a href="https://github.com/boot-clj/boot" target="_blank" rel="noopener">boot-clj</a> 里面的 task 也是通过这种模式组合的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat build.boot</span><br><span class="line">(deftask inc-if-zero-else-dec</span><br><span class="line">  [n number NUM int "number to test"]</span><br><span class="line">  (fn [<span class="keyword">handler</span>]</span><br><span class="line">    (fn [fileset]</span><br><span class="line">      (<span class="keyword">if</span> (zero? <span class="built_in">number</span>)</span><br><span class="line">        (<span class="keyword">handler</span> (<span class="keyword">merge</span> fileset &#123;:<span class="built_in">number</span> (inc <span class="built_in">number</span>)&#125;))</span><br><span class="line">        (<span class="keyword">handler</span> (<span class="keyword">merge</span> fileset &#123;:<span class="built_in">number</span> (<span class="built_in">dec</span> <span class="built_in">number</span>)&#125;))))))</span><br><span class="line"></span><br><span class="line">(deftask printer</span><br><span class="line">  []</span><br><span class="line">  (fn [<span class="keyword">handler</span>]</span><br><span class="line">    (fn [fileset]</span><br><span class="line">      (println (<span class="keyword">str</span> <span class="string">"number is "</span> (:<span class="built_in">number</span> fileset)))</span><br><span class="line">      fileset)))</span><br><span class="line"></span><br><span class="line">$ boot inc-<span class="keyword">if</span>-zero-<span class="keyword">else</span>-<span class="built_in">dec</span> -n <span class="number">0</span>    printer</span><br><span class="line"><span class="built_in">number</span> <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">$ boot inc-<span class="keyword">if</span>-zero-<span class="keyword">else</span>-<span class="built_in">dec</span> -n <span class="number">1</span>    printer</span><br><span class="line"><span class="built_in">number</span> <span class="keyword">is</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="RESTful-实战"><a href="#RESTful-实战" class="headerlink" title="RESTful 实战"></a>RESTful 实战</h2><p>由于 Ring 只是提供了一个 Web 服务最基本的抽象功能，很多其他功能，像 url 路由规则，参数解析等均需通过其他模块实现。<a href="https://github.com/weavejester/compojure" target="_blank" rel="noopener">Compojure</a> 是 Ring 生态里面默认的路由器，同样短小精悍，功能强大。基本用法如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> handlers</span><br><span class="line">  (<span class="name">routes</span></span><br><span class="line">   (<span class="name">GET</span> <span class="string">"/"</span> [] <span class="string">"Hello World"</span>)</span><br><span class="line">   (<span class="name">GET</span> <span class="string">"/about"</span> [] <span class="string">"about page"</span>)</span><br><span class="line">   (<span class="name">route/not-found</span> <span class="string">"Page not found!"</span>)))</span><br></pre></td></tr></table></figure><p>使用这里的 handlers 代替上面 Hello World 的示例中的 handler 即可得到一个具有2条路由规则的 Web 应用，同时针对其他路由返回 <code>Page not found!</code>。</p><p>Compojure 里面使用了大量宏来简化路由的定义，像上面例子中的<code>GET</code>、<code>not-found</code>等。Compojure 底层使用 <a href="https://github.com/weavejester/clout" target="_blank" rel="noopener">clout</a> 这个库实现，而 clout 本身是基于一个 parser generator（<a href="https://github.com/Engelberg/instaparse" target="_blank" rel="noopener">instaparse</a>） 定义的“路由”领域特定语言。<a href="https://github.com/weavejester/clout/blob/master/src/clout/core.clj#L56" target="_blank" rel="noopener">核心规则</a>如下：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(def ^:private route-parser</span><br><span class="line">  (insta/parser</span><br><span class="line">   "route    = (scheme / part) part*</span><br><span class="line">    scheme   = #'(https?:)?//'</span><br><span class="line">    &lt;part&gt;   = literal | escaped | wildcard | param</span><br><span class="line">    literal  = #'(:[^<span class="symbol">\\</span>p&#123;L&#125;_*&#123;&#125;<span class="symbol">\\</span><span class="symbol">\\</span>]|[^:*&#123;&#125;<span class="symbol">\\</span><span class="symbol">\\</span>])+'</span><br><span class="line">    escaped  = #'<span class="symbol">\\</span><span class="symbol">\\</span>.'</span><br><span class="line">    wildcard = '*'</span><br><span class="line">    param    = key pattern?</span><br><span class="line">    key      = &lt;':'&gt; #'([<span class="symbol">\\</span>p&#123;L&#125;_][<span class="symbol">\\</span>p&#123;L&#125;_0-9-]*)'</span><br><span class="line">    pattern  = '&#123;' (#'(?:[^&#123;&#125;<span class="symbol">\\</span><span class="symbol">\\</span>]|<span class="symbol">\\</span><span class="symbol">\\</span>.)+' | pattern)* '&#125;'"</span><br><span class="line">   :no-slurp true))</span><br></pre></td></tr></table></figure></p><p>Compojure 中路由匹配的方式也非常巧妙，这里详细介绍一下。</p><h3 id="Compojure-路由分发"><a href="#Compojure-路由分发" class="headerlink" title="Compojure 路由分发"></a>Compojure 路由分发</h3><p>Compojure 通过 routes 把一系列 handler 封装起来，其内部调用 routing 方法找到正确的 handler。这两个方法代码非常简洁：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(defn routing</span><br><span class="line">  <span class="string">"Apply a list of routes to a Ring request map."</span></span><br><span class="line">  [request &amp; handlers]</span><br><span class="line">  (some #(% request) handlers))</span><br><span class="line"></span><br><span class="line">(defn routes</span><br><span class="line">  <span class="string">"Create a Ring handler by combining several handlers into one."</span></span><br><span class="line">  [&amp; handlers]</span><br><span class="line">  #(apply<span class="built_in"> routing </span>% handlers))</span><br></pre></td></tr></table></figure></p><p>routing 里面通过调用 <code>some</code> 函数返回第一个非 nil 调用，这样就解决了路由匹配的问题。由这个例子可以看出 Clojure 语言的表达力。</p><p>在使用 <code>GET</code> 等这类宏定义 handler 时，会调用<code>wrap-route-matches</code> 来包装真正的处理逻辑，逻辑如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn-</span></span> wrap-route-matches [handler method path]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [request]</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">method-matches?</span> request method)</span><br><span class="line">       (<span class="name"><span class="builtin-name">if-let</span></span> [request (<span class="name">route-request</span> request path)]</span><br><span class="line">         (<span class="name"><span class="builtin-name">-&gt;</span></span> (<span class="name">handler</span> request)</span><br><span class="line">             (<span class="name">head-response</span> request method))))))</span><br></pre></td></tr></table></figure><p>这里看到只有在 url 与 http method 均匹配时，才会去调用 handler 处理 http 请求，其他情况直接返回 nil，这与前面讲的 some 联合起来就形成了完整的路由功能。</p><p>由于 <code>routes</code> 的返回值与 handler 一样，是一个接受 request map 返回 response map 的函数，所以可以像堆积木一样进行任意组合，实现类似于 <a href="http://flask.pocoo.org/docs/0.12/blueprints/" target="_blank" rel="noopener">Flask 中 blueprints</a> 的模块化功能。例如：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; cat student.clj</span></span><br><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> demo.student</span><br><span class="line">  (<span class="symbol">:require</span> [compojure.core <span class="symbol">:refer</span> [GET POST defroutes context]])</span><br><span class="line"></span><br><span class="line">(<span class="name">defroutes</span> handlers</span><br><span class="line">  (<span class="name">context</span> <span class="string">"/student"</span> []</span><br><span class="line">    (<span class="name">GET</span> <span class="string">"/"</span> [] <span class="string">"student index"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;cat demo.teacher</span></span><br><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> demo.teacher</span><br><span class="line">  (<span class="symbol">:require</span> [compojure.core <span class="symbol">:refer</span> [GET POST defroutes context]])</span><br><span class="line"></span><br><span class="line">(<span class="name">defroutes</span> handlers</span><br><span class="line">  (<span class="name">context</span> <span class="string">"/teacher"</span> []</span><br><span class="line">    (<span class="name">GET</span> <span class="string">"/"</span> [] <span class="string">"teacher index"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; cat demo.core.clj</span></span><br><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> demo.core</span><br><span class="line">  (<span class="symbol">:require</span> [demo.student <span class="symbol">:as</span> stu]</span><br><span class="line">            [demo.teacher <span class="symbol">:as</span> tea])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; core 里面进行 handler 的组合</span></span><br><span class="line">(<span class="name">defroutes</span> handlers</span><br><span class="line">  (<span class="name">GET</span> <span class="string">"/"</span> [] <span class="string">"index"</span>)</span><br><span class="line">  (<span class="name">stu/handlers</span>)</span><br><span class="line">  (<span class="name">tea/handlers</span>))</span><br></pre></td></tr></table></figure><h3 id="Middleware-功能扩展"><a href="#Middleware-功能扩展" class="headerlink" title="Middleware 功能扩展"></a>Middleware 功能扩展</h3><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>Compojure 解决了路由问题，参数获取是通过定制不能的 middleware 实现的，<code>compojure.handler</code> 命名空间提供了常用的 middleware 的组合，针对 RESTful 可以使用 <a href="https://github.com/weavejester/compojure/blob/master/src/compojure/handler.clj#L22" target="_blank" rel="noopener">api</a> 这个组合函数，它会把 QueryString 中的参数解析到 request map 中的<code>:query-params</code> key 中，表单中的参数解析到 request map 中的 <code>:form-params</code>。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> app</span><br><span class="line">  (<span class="name"><span class="builtin-name">-&gt;</span></span> handlers</span><br><span class="line">      handler/api))</span><br></pre></td></tr></table></figure></p><h4 id="JSON-序列化"><a href="#JSON-序列化" class="headerlink" title="JSON 序列化"></a>JSON 序列化</h4><p>由于 RESTful 服务中，请求的数据与返回的数据通常都是 JSON 格式，所以需要增加两个额外的功能来实现 JSON 的序列化。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 首先引用 ring.middleware.json</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> app</span><br><span class="line">  (<span class="name"><span class="builtin-name">-&gt;</span></span> handlers</span><br><span class="line">      wrap-json-response</span><br><span class="line">      wrap-json-body</span><br><span class="line">      handler/api))</span><br></pre></td></tr></table></figure></p><h4 id="纪录请求时间"><a href="#纪录请求时间" class="headerlink" title="纪录请求时间"></a>纪录请求时间</h4><p>通常，我们需要纪录每个请求的处理时间，这很简单，实现个 <code>record-response-time</code> 即可：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> record-response-time [handler]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [req]</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> [start-date (<span class="name">System/currentTimeMillis</span>)]</span><br><span class="line">      (<span class="name">handler</span> req)</span><br><span class="line">      (<span class="name"><span class="builtin-name">let</span></span> [res-time (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">System/currentTimeMillis</span>) start-date)]</span><br><span class="line">        (<span class="name">println</span> (<span class="name"><span class="builtin-name">format</span></span>  <span class="string">"%s took %d ms"</span> (<span class="symbol">:uri</span> req) res-time))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> app</span><br><span class="line">  (<span class="name"><span class="builtin-name">-&gt;</span></span> handlers</span><br><span class="line">      wrap-json-response</span><br><span class="line">      wrap-json-body</span><br><span class="line">      handler/api</span><br><span class="line">      record-response-time))</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>record-response-time</code> 需要放在 middleware 最外层，这样它才能纪录一个请求经过所有 middleware + handler 处理的时间。</p><h4 id="封装异常"><a href="#封装异常" class="headerlink" title="封装异常"></a>封装异常</h4><p>其次，另一个很常见的需求就是封装异常，当服务端出现错误时返回给客户端友好的错误信息，而不是服务端的错误堆栈。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> wrap-exception</span><br><span class="line">  [handler]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [request]</span><br><span class="line">    (<span class="name"><span class="builtin-name">try</span></span></span><br><span class="line">      (<span class="name">handler</span> request)</span><br><span class="line">      (<span class="name">catch</span> Throwable e</span><br><span class="line">        (<span class="name">response</span> &#123;<span class="symbol">:code</span> <span class="number">20001</span></span><br><span class="line">                   <span class="symbol">:msg</span>  <span class="string">"inner error&#125;)))))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(def app</span></span><br><span class="line"><span class="string">  (-&gt; handlers</span></span><br><span class="line"><span class="string">      wrap-json-response</span></span><br><span class="line"><span class="string">      wrap-json-body</span></span><br><span class="line"><span class="string">      handler/api</span></span><br><span class="line"><span class="string">      wrap-exception</span></span><br><span class="line"><span class="string">      record-response-time))</span></span><br></pre></td></tr></table></figure></p><h4 id="顺序！顺序！顺序！"><a href="#顺序！顺序！顺序！" class="headerlink" title="顺序！顺序！顺序！"></a>顺序！顺序！顺序！</h4><p>一个 App 中的 middleware 调用顺序非常重要，因为不同的 middleware 之间 request map 与 response map 是相互依赖的，所以在定义 middleware 时一定要注意顺序。一图胜千言：</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2BkmmmohnpuFjSZFEXXX0PFXa_!!581166664.png" alt="middleware 应用顺序图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Java EE 中，编写 Web 项目通常是配置各种 XML 文件，代码还没开始写就配置了一大堆jar包依赖，这些 jar 包很有可能会冲突，然后需要花大量时间处理这些依赖冲突，真心麻烦。</p><p>Ring 与其说是一个框架，不如说是由各个短小精悍的函数组成的 lib，充分展示了 Clojure 语言的威力，通过函数的组合定义出一套完整的 HTTP 抽象机制，通过宏来实现“路由”特定领域语言，极大简化了路由的定义，方便了模块的分解。</p><p>除了上面的介绍，Ring 生态里面还有 <a href="https://github.com/weavejester/lein-ring" target="_blank" rel="noopener">lein-ring</a> ，它可以在不重启服务的情况下重新加载有修改的命名空间（以及其影响的），开发从未如何顺畅。</p><p>Ring + Compojure + lein-ring 你值得拥有。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="http://www.braveclojure.com/appendix-b/" target="_blank" rel="noopener">Boot, the Fancy Clojure Build Framework</a></li><li><a href="http://www.lispcast.com/what-web-framework-should-i-use" target="_blank" rel="noopener">http://www.lispcast.com/what-web-framework-should-i-use</a></li><li><a href="https://github.com/luminus-framework/luminus/blob/master/resources/md/html_templating.md" target="_blank" rel="noopener">https://github.com/luminus-framework/luminus/blob/master/resources/md/html_templating.md</a></li><li><a href="https://stackoverflow.com/questions/3488353/whats-the-big-idea-behind-compojure-routes" target="_blank" rel="noopener">https://stackoverflow.com/questions/3488353/whats-the-big-idea-behind-compojure-routes</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Clojure 众多的 Web 框架中，&lt;a href=&quot;https://github.com/ring-clojure/ring&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ring&lt;/a&gt; 以其简单统一的 HTTP 抽象模型脱颖而出。Ring 充
      
    
    </summary>
    
      <category term="Web" scheme="http://liujiacai.net/categories/Web/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>“玩转” 技术面试——链表的函数表示法</title>
    <link href="http://liujiacai.net/blog/2017/03/22/ace-technical-interview/"/>
    <id>http://liujiacai.net/blog/2017/03/22/ace-technical-interview/</id>
    <published>2017-03-22T03:31:11.000Z</published>
    <updated>2019-12-24T10:59:14.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://aphyr.com/posts/340-acing-the-technical-interview" target="_blank" rel="noopener">《Acing the technical interview》</a>，老外写的白板面试的调侃文，声色并茂，兼具叙述文的生动与技术文的抽象。文中用函数来模拟链表的表示法我在<a href="/blog/2014/10/12/lambda-calculus-introduction/">《编程语言的基石——Lambda calculus》</a>里面有深入讲解，感兴趣的读者可以参考。本文最后，给出了 Python、Ruby 语言中链表的函数表示。</p><p>文中个别语句我翻译的不是很好或者没有翻译，希望感兴趣的读者予以补充。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果你打算找一份程序员（software witch）的工作，那么你极有可能需要通过白板面试。白板面试已经成了我们程序员的家常便饭：在电脑桌面上排列出一组好看的 <code>xterm</code>，不由自主地在周边的文件夹里运行<code>ls</code>，以防环境在昨晚有什么变动——这就像在厨房的抽屉里找东西，而这个厨房储藏了各种奇怪的法兰（flanges，使管子与管子及和阀门相互连接的零件）、螺丝刀以及各种不知名的家用电器上掉下来的零件形成的各种奇怪的塑料碎片，现在谁也不知道这些家用电器的用途，或许从来就没知道过，但即使如此，我们还必须小心翼翼的对待它们。我现在给你分析一个非常常见的面试问题：反转链表（reverse linked list）。</p><p>首先，我们需要一个链表。清空你工作空间里面不必要的<code>xterm</code>窗口，然后递归地在具有保护性的括号（译者注：Lisp 里面用括号分割代码块）里面撒些盐（译者注：这句话非常形象，想想我们做菜时放盐的场景，表示要开始了，忽略某些人后放盐）。从零开始反转一个链表。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> cons [h t] #(<span class="name"><span class="builtin-name">if</span></span> % h t))</span><br></pre></td></tr></table></figure><p>“这不是一个链表，这只是一个<code>if</code>语句”，面试官说。<br>“但其他部分是链表，还有什么问题嘛？”你回答到，同时不屑地翻了一个白眼。<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">user=&gt;</span><span class="clojure"> (<span class="name"><span class="builtin-name">def</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">2</span> <span class="literal">nil</span>)))</span></span><br><span class="line">#'user/x</span><br><span class="line"><span class="meta">user=&gt;</span><span class="clojure"> (<span class="name">x</span> <span class="literal">true</span>)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">user=&gt;</span><span class="clojure"> ((<span class="name">x</span> <span class="literal">false</span>) <span class="literal">true</span>)</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>“<code>x</code>到底是什么？”面试官尽量让自己看起来友善些。<br>答案在 REPL 里，但是不要被它一时误导了，它们可不是你的朋友。这与你在接待厅的誓言是相违背的（译者注：宣誓时一般都要求虔诚对待别人）。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; x</span><br><span class="line"><span class="meta">#</span><span class="bash">object[user<span class="variable">$cons</span><span class="variable">$cell__4431</span> 0x3b89cc1c <span class="string">"user<span class="variable">$cons</span><span class="variable">$cell__4431</span>@3b89cc1c"</span>]</span></span><br></pre></td></tr></table></figure></p><p>“了解一个事物最好的方式就是对它命名”，你建议到。好的名字非常有意义（True names have power）。由 Ursula K. Le Guin 发明的 <a href="https://en.wikipedia.org/wiki/K_%28programming_language%29" target="_blank" rel="noopener">K 语言</a>是最古老、最精练的魔幻型语言之一。让一个新语言映射成你自己的词汇需要忘掉自己之前的认知，原有知识会让你的记忆疼痛（译者注：作者是想表达 Lisp 里面惯用法与常见的语言差距比较大，不能简单类比）。</p><p>“呃… 那好，那你会怎么从这个链表里面取出一个元素呢？”</p><p>在你脑海中有非常漂亮解决方式，就像你赤裸的双脚下铺开了红地毯。奥斯卡的明星昨晚在这里出席过，但你还是等待着不同的明星来亲吻你。这就像你住在<a href="https://en.wikipedia.org/wiki/S%C3%B8r%C3%B8ya" target="_blank" rel="noopener">瑟略島</a>（挪威第八大岛） 的山上时，月亮就是你的爱人。（译者注：这里作者应该是想表达 s-expression 很优美）。除了一些边界条件的检查，你在第一时间写出了正确的获取一个元素的代码：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> nth [l n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">when</span></span> l (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> <span class="number">0</span> n)</span><br><span class="line">            (<span class="name">l</span> <span class="literal">true</span>)</span><br><span class="line">            (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">l</span> <span class="literal">false</span>) (<span class="name"><span class="builtin-name">dec</span></span> n)))))</span><br></pre></td></tr></table></figure></p><p>“你能不能给我写一个正常的链表，像 Python 里面的那样？”</p><p>你摩拳擦掌起来，双脚站在地板上，从头开始写出了一个具有良好缩进格式的<code>print</code>函数。现在你的手掌长满老茧，眼睑里流露出晶莹的、碳黑的雪花（译者注：这是可能是说作者写这种函数很多次了，不屑于写了）。每一个函数都是有代价的，当然，除非它们是无副作用的纯函数。<br><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> prn-list [l]</span><br><span class="line">  (<span class="name"><span class="builtin-name">print</span></span> <span class="string">"("</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [l l]</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">nil?</span> l)</span><br><span class="line">      (<span class="name"><span class="builtin-name">print</span></span> <span class="string">")\n"</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">print</span></span> (<span class="name">l</span> <span class="literal">true</span>))</span><br><span class="line">          (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">l</span> <span class="literal">false</span>)</span><br><span class="line">            (<span class="name"><span class="builtin-name">print</span></span> <span class="string">" "</span>))</span><br><span class="line">          (<span class="name">recur</span> (<span class="name">l</span> <span class="literal">false</span>))))))</span><br></pre></td></tr></table></figure></p><p>没有时间去想有意义的变量名、示例、帮助文档（译者注：docstring，Clojure里面函数的注释）。在白板面试过程中，时间就是一切。 Pretend you are a Haskell programmer, as your grandmother was, before her continuation passed。（译者注：不清楚这句话作者想表达神马意思，懂 Haskell 同学解释下？）<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">user=&gt;</span><span class="clojure"> (<span class="name">prn-list</span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">2</span> (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> <span class="literal">nil</span>))))</span></span><br><span class="line">(1 2 3)</span><br></pre></td></tr></table></figure></p><p>这时面试官终于安心地笑了，最起码上面的输出看起来终于正常了。“那么，开始反转吧，你需要….”</p><p>你突然攥住面试官的双手，这时他的大脑像紧张忙乱的闹钟发条似的发生了扭曲，飞掠而过心脏里面的绦虫，拍挞拍挞的心发生了偏斜，并且用古老的语言默背一首讽刺诗。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defn</span> reverse [l]</span><br><span class="line">  (<span class="name">loop</span> [r <span class="literal">nil</span>, l l]</span><br><span class="line">    (<span class="name">if</span> l</span><br><span class="line">      (<span class="name">recur</span> (<span class="name">cons</span> (<span class="name">l</span> true) r) (<span class="name">l</span> false))</span><br><span class="line">      r)))</span><br><span class="line"></span><br><span class="line">user=&gt; (<span class="name">prn-list</span> (<span class="name">reverse</span> (<span class="name">cons</span> <span class="number">1</span> (<span class="name">cons</span> <span class="number">2</span> (<span class="name">cons</span> <span class="number">3</span> <span class="literal">nil</span>)))))</span><br><span class="line">(<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>当你放开面试官的手，他结结巴巴的说了些有礼貌的东西，拉上了兜帽上衣的拉锁来掩盖自己冷汗。下面这里会有其他会议，但是你不需要参加，你快点走吧（Send an eagle in your place ？是这么翻译嘛）。</p><p>他们肯定会决绝你，而且会嗤之以鼻，说你不符合他们的公司文化。Alight upon your cloud-pine, and exit through the window. （神马意思？）这地方不适合你。</p><h2 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cons</span><span class="params">(h, t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: h <span class="keyword">if</span> x <span class="keyword">else</span> t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">(l)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">"nil"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            e = l(<span class="literal">True</span>)</span><br><span class="line">            print(e, end=<span class="string">' '</span>)</span><br><span class="line">            l = l(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(l)</span>:</span></span><br><span class="line">    reversed_l = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> l:</span><br><span class="line">        e = l(<span class="literal">True</span>)</span><br><span class="line">        reversed_l = cons(e, reversed_l)</span><br><span class="line">        l = l(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reversed_l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = cons(<span class="number">3</span>, cons(<span class="number">2</span>, cons(<span class="number">1</span>, <span class="literal">None</span>)))</span><br><span class="line"></span><br><span class="line">printer(l)</span><br><span class="line"><span class="comment"># 3 2 1</span></span><br><span class="line"></span><br><span class="line">printer((reverse(l)))</span><br><span class="line"><span class="comment"># 1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cons</span><span class="params">(h, t)</span></span></span><br><span class="line">  lambda &#123; <span class="params">|e|</span> e ? h : t &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">(l)</span></span></span><br><span class="line">  <span class="keyword">while</span> l</span><br><span class="line">    e = l.call <span class="literal">true</span></span><br><span class="line">    print e, <span class="string">' '</span></span><br><span class="line">    l = l.call <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  puts <span class="string">''</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(l)</span></span></span><br><span class="line">  reversed_l = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">while</span> l</span><br><span class="line">    e = l.call <span class="literal">true</span></span><br><span class="line">    reversed_l = cons e, reversed_l</span><br><span class="line">    l = l.call <span class="literal">false</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> reversed_l</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">l = cons(<span class="number">3</span>, cons(<span class="number">2</span>, cons(<span class="number">1</span>, <span class="literal">nil</span>)))</span><br><span class="line">printer l</span><br><span class="line"><span class="comment"># 3 2 1</span></span><br><span class="line">printer reverse l</span><br><span class="line"><span class="comment"># 1 2 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://aphyr.com/posts/340-acing-the-technical-interview&quot; ta
      
    
    </summary>
    
      <category term="他山之石" scheme="http://liujiacai.net/categories/reproduce/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>辨析 Ruby 中的 Method 与 Proc</title>
    <link href="http://liujiacai.net/blog/2017/03/05/method-vs-proc-in-ruby/"/>
    <id>http://liujiacai.net/blog/2017/03/05/method-vs-proc-in-ruby/</id>
    <published>2017-03-05T07:26:28.000Z</published>
    <updated>2019-12-24T10:59:14.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Ruby is simple in appearance, but is very complex inside, just like our human body.  </p><blockquote><p>– Matz  <a href="https://www.ruby-lang.org/en/about" target="_blank" rel="noopener">https://www.ruby-lang.org/en/about</a></p></blockquote></blockquote><p>Ruby 与 Python、Scala 类似，在一切皆是对象（Seeing Everything as an Object）的基础上，支持函数式编程，这意味着函数是一等成员，可以作为参数传入，也可以作为函数值返回。</p><p>但是，Ruby 中的函数并没有其他动态语言中那么简单，它提供了 <a href="http://ruby-doc.org/core-2.4.0/Method.html" target="_blank" rel="noopener">Method</a> 与 <a href="http://ruby-doc.org/core-2.4.0/Proc.html" target="_blank" rel="noopener">Proc</a> 两个类来表示函数的概念，对于这两个类的区别无论是官方文档还是 Stackoverflow 上的问题，解释的都非常模糊。在其他语言函数很习以为常的用法在 Ruby 中却行不通，就其原因还是不清楚这两个类的区别，希望这篇文章能够帮助大家理解好 Ruby 中的“函数”概念，做到深入浅出，与其他函数式语言融会贯通。</p><h2 id="Block-oriented-Programming"><a href="#Block-oriented-Programming" class="headerlink" title="Block-oriented Programming"></a>Block-oriented Programming</h2><p>Ruby 中代码块最常见的形式既不是 Proc 也不是 Method，而是 <code>block</code>。比如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历 Range/Array 等</span></span><br><span class="line">(<span class="number">0</span>..<span class="number">10</span>).each <span class="keyword">do</span> <span class="params">|num|</span></span><br><span class="line">    puts num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  读取文件</span></span><br><span class="line">File.foreach(<span class="string">'README.md'</span>).with_index <span class="keyword">do</span> <span class="params">|line, line_num|</span></span><br><span class="line">  puts <span class="string">"<span class="subst">#&#123;line_num&#125;</span>: <span class="subst">#&#123;line&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">#  遍历文件</span></span><br><span class="line">Dir.glob(<span class="string">'*.rb'</span>) &#123;<span class="params">|ruby_src|</span> puts <span class="string">"found <span class="subst">#&#123;ruby_src&#125;</span>"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>上面示例演示了<code>block</code>的两种字面量（literal）形式，非常方便简洁。但有一点需要注意，<code>block</code> 仅仅是 Ruby 提供的一语法糖衣，并不把其赋值给某一变量。如果自定义函数需要调用传入的<code>block</code>，需要采用<code>yield</code>方式。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Array 类中添加自定义函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_each</span></span></span><br><span class="line">    <span class="number">0</span>.upto(size) <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">self</span>[i]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">%w(a b c)</span>.my_each <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">  puts item</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="面向函数式的-Proc"><a href="#面向函数式的-Proc" class="headerlink" title="面向函数式的 Proc"></a>面向函数式的 Proc</h2><p><code>block</code> 的优势是简洁，但是有个缺点就是无法复用，因为并不存在<code>block</code>类型。但在其他语言中，函数名可以随意传递，下面举一 Python 的例子：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myinc</span><span class="params">(x)</span></span><span class="symbol">:</span></span><br><span class="line">true<span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">map(myinc, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># =&gt; [2, 3, 4]</span></span><br><span class="line">map(myinc, [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])<span class="comment"># =&gt; [5, 6, 7]</span></span><br></pre></td></tr></table></figure></p><p>Ruby 中与其对应的是<code>过程</code>（Proc），与上面功能等价的 Ruby 代码为：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myinc = Proc.<span class="built_in">new</span> &#123;|<span class="built_in">num</span>| <span class="built_in">num</span> + <span class="number">1</span>&#125;</span><br><span class="line"># 或下面两种方式</span><br><span class="line"># myinc = proc &#123;|<span class="built_in">num</span>| <span class="built_in">num</span> + <span class="number">1</span>&#125;</span><br><span class="line"># myinc = <span class="built_in">lambda</span> &#123;|<span class="built_in">num</span>| <span class="built_in">num</span> + <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="built_in">map</span>(&amp;myinc)</span><br></pre></td></tr></table></figure></p><p>上面代码最关键的是<code>&amp;myinc</code>中的<code>&amp;</code>，由于 map 函数后面可以跟一个 block，所以需要把 Proc 转为 block。</p><blockquote><p>当<code>&amp;</code>符号出现在函数参数列表中时，会把其后面的参数转为 Proc，并且把转化后的参数作为 block 传递给调用者。</p><blockquote><p><a href="http://stackoverflow.com/a/9429972/2163429" target="_blank" rel="noopener">http://stackoverflow.com/a/9429972/2163429</a></p></blockquote></blockquote><p>我这里有个更好的理解大家可以参考：</p><blockquote><p><code>&amp;</code>在C语言中为取地址符，Ruby 中的函数参数后面可以跟一个 block，由于这个 block 不是参数的一部分，所以没有名字，这很理所当然可以把 block 理解为一内存地址，<code>block_given?</code> 函数可以检查这个<code>block</code>是否存在。<code>&amp;myinc</code> 可以理解为取 Proc 的地址传给 map 函数。</p></blockquote><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(myinc)</span><br><span class="line"><span class="meta"># 这种写法会报下面的错误</span></span><br><span class="line"><span class="meta"># in `map': wrong number of arguments (given 1, expected 0) (ArgumentError)</span></span><br></pre></td></tr></table></figure><p>所以，Ruby 中的 Proc 和其他动态语言的函数是等价的，下面再举一例说明<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfilter</span><span class="params">(arr, validator)</span></span></span><br><span class="line">  arr.each <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">    <span class="keyword">if</span> validator.call(item)</span><br><span class="line">      puts item</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myfilter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], lambda &#123;<span class="params">|num|</span> num &gt; <span class="number">3</span>&#125;)  <span class="comment"># 输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外， 还可以在定义 myfilter 时，利用 &amp; 将最后的 block 转为 Proc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfilter</span><span class="params">(arr, &amp;validator)</span></span></span><br><span class="line">  arr.each <span class="keyword">do</span> <span class="params">|item|</span></span><br><span class="line">    <span class="keyword">if</span> validator.call(item)</span><br><span class="line">      puts item</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myfilter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) &#123;<span class="params">|num|</span> num &gt; <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 输出 4</span></span><br></pre></td></tr></table></figure></p><h3 id="proc-vs-lambda"><a href="#proc-vs-lambda" class="headerlink" title="proc vs. lambda"></a>proc vs. lambda</h3><p>上面介绍过，Proc 有两种字面量形式：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myinc = proc &#123;|<span class="built_in">num</span>| <span class="built_in">num</span> + <span class="number">1</span>&#125;   # 与 Proc.<span class="built_in">new</span> 等价</span><br><span class="line">myinc = <span class="built_in">lambda</span> &#123;|<span class="built_in">num</span>| <span class="built_in">num</span> + <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这两种形式的 Proc 有以下两点不同：</p><ol><li><p><code>proc</code>形式不限制参数个数；而<code>lambda</code>形式严格要求一致</p> <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myadd = proc &#123;|x, y| puts x&#125;</span><br><span class="line"></span><br><span class="line">myadd.<span class="built_in">call</span>(<span class="number">1</span>)        <span class="meta"># ok</span></span><br><span class="line">myadd.<span class="built_in">call</span>(<span class="number">1</span>, <span class="number">2</span>)     <span class="meta"># ok</span></span><br><span class="line">myadd.<span class="built_in">call</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="meta"># ok</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myadd = lambda &#123;|x, y| puts x&#125;</span><br><span class="line"></span><br><span class="line">myadd.<span class="built_in">call</span>(<span class="number">1</span>)        <span class="meta"># ArgumentError</span></span><br><span class="line">myadd.<span class="built_in">call</span>(<span class="number">1</span>, <span class="number">2</span>)     <span class="meta"># ok</span></span><br><span class="line">myadd.<span class="built_in">call</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="meta">#ArgumentError</span></span><br></pre></td></tr></table></figure></li><li><p><code>proc</code>中的<code>return</code>语句对调用方有效；而<code>lambda</code>仅仅对其本身起作用</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(some_proc)</span></span></span><br><span class="line">  some_proc.call</span><br><span class="line">  puts <span class="string">"foo over"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 正常输出 in lambda、foo over</span></span><br><span class="line">foo(lambda <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">"in lambda"</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="comment"># 2. 输出 in new 后报  unexpected return (LocalJumpError)</span></span><br><span class="line">foo(Proc.new <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">"in new"</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="comment"># 3. 输出 in proc 后报  unexpected return (LocalJumpError)</span></span><br><span class="line">foo(proc <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">"in proc"</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="面向对象的-Method"><a href="#面向对象的-Method" class="headerlink" title="面向对象的 Method"></a>面向对象的 Method</h2><p>Ruby 中使用<code>def</code>定义的“函数”为<code>Method</code>类型，专为面向对象特性设计，面向对象更一般的说法是消息传递，通过给一对象发送不同消息，对象作出不同相应，这一点与 <a href="/blog/2015/12/26/sicp-chapter3-summary/#用变动的数据做模拟">SICP 第三章</a>的内容不谋而合。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(width, height)</span></span></span><br><span class="line">    @width = width</span><br><span class="line">    @height = height</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">area</span></span></span><br><span class="line">    @width * @height</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">rect = Rectangle.new <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"><span class="comment"># 传统方式</span></span><br><span class="line">puts rect.area</span><br><span class="line"><span class="comment"># 消息传递方式</span></span><br><span class="line">puts rect.send <span class="symbol">:area</span></span><br></pre></td></tr></table></figure><p>由于 Ruby 中方法名表示的是调用，所以一般可用与方法同名的 <a href="http://ruby-doc.org/core-2.4.0/Symbol.html" target="_blank" rel="noopener">Symbol</a> 来表示。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puts rect<span class="function">.<span class="keyword">method</span><span class="params">(:area)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#&lt;<span class="title">Method</span>:</span> Rectangle#area&gt;</span><br></pre></td></tr></table></figure></p><p>可以通过 <code>Method</code> 的 <code>to_proc</code> 方法可以将 Method 转为功能等价的 Proc。比如：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def myinc(num)</span><br><span class="line">  num + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(&amp;<span class="function"><span class="keyword">method</span><span class="params">(:myinc)</span>.<span class="title">to_proc</span>)</span></span><br><span class="line"><span class="function"># =&gt; [2,3,4]</span></span><br><span class="line"><span class="function"># 在 <span class="title">Ruby</span> 源文件的顶层定义的函数属于 <span class="title">main</span> 对象（<span class="title">Object</span> 类），所以上面的调用相当于：</span></span><br><span class="line"><span class="function"># [1,2,3].<span class="title">map</span><span class="params">(&amp;Object.<span class="keyword">method</span>(:myinc)</span>)</span></span><br></pre></td></tr></table></figure><p>通过 <code>define_method</code> 可以将 Proc 转为某对象的实例方法<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo</span><br><span class="line">  define_method <span class="symbol">:pp</span> &#123; puts <span class="string">"p"</span> &#125;</span><br><span class="line">end</span><br><span class="line">Foo.new.pp</span><br><span class="line">=&gt; p</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>block</code> 为 Proc 的语法糖衣，用于单次使用时</li><li><code>Proc</code> 专为函数式编程设计，与其他动态语言的函数等价</li><li><code>Method</code> 专为面向对象设计，消息传递的第一个参数</li></ul><p>弄清 Method 与 Proc 的区别后，不得不欣赏 Ruby 语言设计的巧妙，兼具函数式与面向对象的精髓。实在是程序员必备利器。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Method_Calls" target="_blank" rel="noopener">https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Method_Calls</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Ruby is simple in appearance, but is very complex inside, just like our human body.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;– Matz  &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Ruby" scheme="http://liujiacai.net/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>Clojure 运行原理之字节码生成篇</title>
    <link href="http://liujiacai.net/blog/2017/02/09/clojure-compiler-analyze-2/"/>
    <id>http://liujiacai.net/blog/2017/02/09/clojure-compiler-analyze-2/</id>
    <published>2017-02-09T13:51:29.000Z</published>
    <updated>2019-12-24T10:59:14.608Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/blog/2017/02/05/clojure-compiler-analyze/">上一篇文章</a>讲述了 Clojure 编译器工作的整体流程，主要涉及 LispReader 与 Compiler 这两个类，而且指出编译器并没有把 Clojure 转为相应的 Java 代码，而是直接使用 ASM 生成可运行在 JVM 中的 bytecode。本文将主要讨论 Clojure 编译成的 bytecode 如何实现动态运行时以及为什么 Clojure 程序启动慢，这会涉及到 JVM 的类加载机制。</p><h2 id="类生成规则"><a href="#类生成规则" class="headerlink" title="类生成规则"></a>类生成规则</h2><p>JVM 设计之初只是为 Java 语言考虑，所以最基本的概念是 class，除了八种基本类型，其他都是对象。Clojure 作为一本函数式编程语言，最基本的概念是函数，没有类的概念，那么 Clojure 代码生成以类为主的 bytecode 呢？</p><p>一种直观的想法是，每个命名空间（namespace）是一个类，命名空间里的函数相当于类的成员函数。但仔细想想会有如下问题：</p><ol><li>在 REPL 里面，可以动态添加、修改函数，如果一个命名空间相当于一个类，那么这个类会被反复加载</li><li>由于函数和字符串一样是一等成员，这意味这函数既可以作为参数、也可以作为返回值，如果函数作为类的方法，是无法实现的</li></ol><p>上述问题 2 就要求必须将函数编译成一个类。根据 <a href="https://clojure.org/reference/compilation" target="_blank" rel="noopener">Clojure 官方文档</a>，对应关系是这样的：</p><ul><li>函数生成一个类</li><li>每个文件（相当于一个命名空间）生成一个<code>&lt;filename&gt;__init</code> 的加载类</li><li><code>gen-class</code> 生成固定名字的类，方便与 Java 交互</li><li><code>defrecord</code>、<code>deftype</code>生成同名的类，<code>proxy</code>、<code>reify</code>生成匿名的类</li></ul><p>需要明确一点，只有在 AOT 编译时，Clojure 才会在本地生成 <code>.class</code> 文件，其他情况下生成的类均在内存中。</p><h2 id="动态运行时"><a href="#动态运行时" class="headerlink" title="动态运行时"></a>动态运行时</h2><p>明确了 Clojure 类生成规则后，下面介绍 Clojure 是如何实现动态运行时。这一问题将分为 AOT 编译与 DynamicClassLoader 类的实现两部分。</p><h3 id="AOT-编译"><a href="#AOT-编译" class="headerlink" title="AOT 编译"></a>AOT 编译</h3><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB26GwHd4xmpuFjSZFNXXXrRXXa_!!581166664.png" alt><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat src<span class="regexp">/how_clojure_work/</span>core.clj</span><br><span class="line"></span><br><span class="line">(ns how-clojure-work.core)</span><br><span class="line"></span><br><span class="line">(defn -main [&amp; _]</span><br><span class="line"> (<span class="keyword">println</span> <span class="string">"Hello, World!"</span>))</span><br></pre></td></tr></table></figure></p><p>使用 <code>lein compile</code> 编译这个文件，会在<code>*compile-path*</code>指定的文件夹（一般是项目的<code>target</code>）下生成如下文件：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls target/classes/how_clojure_work/</span><br><span class="line"></span><br><span class="line">core$fn__38<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">core$loading__5569__auto____36<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">core$main<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">core__init<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p><code>core$main.class</code>与<code>core__init.class</code>分别表示原文件的<code>main</code>函数与命名空间加载类，那么剩下两个类是从那里来的呢？</p><p>我们知道 Clojure 里面很多“函数”其实是用宏实现的，宏在编译时会进行展开，生成新代码，上面代码中的<code>ns</code>、<code>defn</code>都是宏，展开后（在 Cider + Emacs 开发环境下，<code>C-c  M-m</code>）可得<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">  (<span class="name"><span class="builtin-name">in-ns</span></span> 'how-clojure-work.core)</span><br><span class="line">  ((<span class="name">fn*</span></span><br><span class="line">     loading__5569__auto__</span><br><span class="line">     ([]</span><br><span class="line">       (<span class="name"><span class="builtin-name">.</span></span> clojure.lang.Var</span><br><span class="line">        (<span class="name">clojure.core/pushThreadBindings</span></span><br><span class="line">          &#123;clojure.lang.Compiler/LOADER</span><br><span class="line">           (<span class="name"><span class="builtin-name">.</span></span> (<span class="name"><span class="builtin-name">.</span></span> loading__5569__auto__ getClass) getClassLoader)&#125;))</span><br><span class="line">       (<span class="name"><span class="builtin-name">try</span></span></span><br><span class="line">         (<span class="name"><span class="builtin-name">refer</span></span> 'clojure.core)</span><br><span class="line">         (<span class="name">finally</span></span><br><span class="line">           (<span class="name"><span class="builtin-name">.</span></span> clojure.lang.Var (<span class="name">clojure.core/popThreadBindings</span>)))))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">.</span></span> 'how-clojure-work.core equals 'clojure.core)</span><br><span class="line">    <span class="literal">nil</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">      (<span class="name"><span class="builtin-name">.</span></span> clojure.lang.LockingTransaction</span><br><span class="line">       (<span class="name">clojure.core/runInTransaction</span></span><br><span class="line">         (<span class="name">fn*</span></span><br><span class="line">           ([]</span><br><span class="line">             (<span class="name"><span class="builtin-name">commute</span></span></span><br><span class="line">               (<span class="name"><span class="builtin-name">deref</span></span> #'clojure.core/*loaded-libs*)</span><br><span class="line">               conj</span><br><span class="line">               'how-clojure-work.core)))))</span><br><span class="line">      <span class="literal">nil</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> main (<span class="name">fn*</span> ([&amp; _] (<span class="name">println</span> <span class="string">"Hello, World!"</span>))))</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>ns</code>展开后的代码里面包含了两个匿名函数，对应本地上剩余的两个文件。下面依次分析这四个<code>class</code>文件</p><h4 id="core-init"><a href="#core-init" class="headerlink" title="core__init"></a>core__init</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ javap core__init<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">how_clojure_work</span>.<span class="title">core__init</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.Var const__0;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.AFn const__1;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.AFn const__2;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.Var const__3;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.AFn const__11;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">__init0</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Clojure 里面所有的函数都继承 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/IFn.java" target="_blank" rel="noopener">IFn 接口</a>，该接口有 20 个重载的 invoke 方法，之所以有这么多 invoke 方法，是因为 <a href="http://stackoverflow.com/a/2736636/2163429" target="_blank" rel="noopener">JVM 擅长根据参数数目进行方法调度（dispatch）</a>。<br><a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/AFn.java" target="_blank" rel="noopener">抽象类 AFn</a> 为 IFn 里的 20 个 invoke 方法提供了的默认实现（通过抛 throwArity 异常），这样其他函数就只需要继承 AFn 并重写相应 invoke 方法即可。</p></blockquote><p>可以看到，命名空间加载类里面有一些<code>Var</code>与<code>AFn</code>变量，可以认为一个<code>Var</code>对应一个<code>AFn</code>。使用 Intellj 或 <a href="http://jd.benow.ca/" target="_blank" rel="noopener">JD</a> 打开这个类文件，首先查看静态代码快。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    __init0()<span class="comment">;</span></span><br><span class="line">    Compiler.pushNSandLoader(RT.classForName(<span class="string">"how_clojure_work.core__init"</span>).getClassLoader())<span class="comment">;</span></span><br><span class="line">    try &#123;</span><br><span class="line">        load()<span class="comment">;</span></span><br><span class="line">    &#125; catch (Throwable var1) &#123;</span><br><span class="line">        Var.popThreadBindings()<span class="comment">;</span></span><br><span class="line">        throw var1<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    Var.popThreadBindings()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里面会先调用<code>__init0</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> __init0() &#123;</span><br><span class="line">    const__0 = (Var)RT.<span class="keyword">var</span>(<span class="string">"clojure.core"</span>, <span class="string">"in-ns"</span>);</span><br><span class="line">    const__1 = (AFn)<span class="built_in">Symbol</span>.intern((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"how-clojure-work.core"</span>);</span><br><span class="line">    const__2 = (AFn)<span class="built_in">Symbol</span>.intern((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"clojure.core"</span>);</span><br><span class="line">    const__3 = (Var)RT.<span class="keyword">var</span>(<span class="string">"how-clojure-work.core"</span>, <span class="string">"main"</span>);</span><br><span class="line">    const__11 = (AFn)RT.map(<span class="keyword">new</span> <span class="built_in">Object</span>[] &#123;</span><br><span class="line">        RT.keyword((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"arglists"</span>), PersistentList.create(Arrays.asList(<span class="keyword">new</span> <span class="built_in">Object</span>[] &#123;</span><br><span class="line">            Tuple.create(<span class="built_in">Symbol</span>.intern((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"&amp;"</span>),</span><br><span class="line">            <span class="built_in">Symbol</span>.intern((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"_"</span>))</span><br><span class="line">        &#125;)),</span><br><span class="line">        RT.keyword((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"line"</span>), Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">        RT.keyword((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"column"</span>), Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">        RT.keyword((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"file"</span>), <span class="string">"how_clojure_work/core.clj"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>RT</code> 是 Clojure runtime 的实现，在<code>__init0</code>里面会对命名空间里面出现的 var 进行赋值。</p><p>接下来是<code>pushNSandLoader</code>（内部用<code>pushThreadBindings</code>实现），它与后面的 <code>popThreadBindings</code> 形成一个 binding，功能等价下面的代码：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">binding</span> [clojure.core/*ns* <span class="literal">nil</span></span><br><span class="line">          clojure.core/*fn-loader* RT.classForName(<span class="string">"how_clojure_work.core__init"</span>).getClassLoader()</span><br><span class="line">          clojure.core/*read-eval <span class="literal">true</span>]</span><br><span class="line">  (<span class="name"><span class="builtin-name">load</span></span>))</span><br></pre></td></tr></table></figure></p><p>接着查看<code>load</code>的实现：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 in-ns，传入参数 how-clojure-work.core</span></span><br><span class="line">    ((IFn)const__0.getRawRoot()).invoke(const__1);</span><br><span class="line">    <span class="comment">// 执行 loading__5569__auto____36，功能等价于 (refer clojure.core)</span></span><br><span class="line">    ((IFn)(<span class="keyword">new</span> loading__5569__auto____36())).invoke();</span><br><span class="line">    Object var10002;</span><br><span class="line">    <span class="comment">// 如果当前的命名空间不是 clojure.core 那么会在一个 LockingTransaction 里执行 fn__38</span></span><br><span class="line">    <span class="comment">// 功能等价与(commute (deref #'clojure.core/*loaded-libs*) conj 'how-clojure-work.core)</span></span><br><span class="line">    <span class="keyword">if</span>(((Symbol)const__1).<span class="keyword">equals</span>(const__2)) &#123;</span><br><span class="line">        var10002 = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LockingTransaction.runInTransaction((Callable)(<span class="keyword">new</span> fn__38()));</span><br><span class="line">        var10002 = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Var var10003 = const__3;</span><br><span class="line">    <span class="comment">// 为 main 设置元信息，包括行号、列号等</span></span><br><span class="line">    const__3.setMeta((IPersistentMap)const__11);</span><br><span class="line">    var10003.bindRoot(<span class="keyword">new</span> main());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，命名空间加载类就分析完了。</p><h4 id="loading-5569-auto-36"><a href="#loading-5569-auto-36" class="headerlink" title="loading_5569_auto____36"></a>loading_5569_auto____36</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ javap core\$loading__5569__auto____36<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">Compiled</span> <span class="title">from</span> "<span class="title">core</span>.<span class="title">clj</span>"</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">class</span> <span class="title">how_clojure_work</span>.<span class="title">core$loading__5569__auto____36</span> <span class="keyword">extends</span> <span class="title">clojure</span>.<span class="title">lang</span>.<span class="title">AFunction</span> </span>&#123;</span><br><span class="line">  public static <span class="keyword">final</span> clojure.lang.<span class="type">Var</span> const__0;</span><br><span class="line">  public static <span class="keyword">final</span> clojure.lang.<span class="type">AFn</span> const__1;</span><br><span class="line">  public how_clojure_work.core$loading__5569__auto____36(); <span class="comment">// 构造函数</span></span><br><span class="line">  public java.lang.<span class="type">Object</span> invoke();</span><br><span class="line">  public static &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>core__init</code> 类结构，包含一些 var 赋值与初始化函数，同时它还继承了<code>AFunction</code>，从名字就可以看出这是一个函数的实现。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是 var 赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Var const__0 = (Var)RT.var(<span class="string">"clojure.core"</span>, <span class="string">"refer"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AFn const__1 = (AFn)Symbol.intern((<span class="keyword">String</span>)<span class="keyword">null</span>, <span class="string">"clojure.core"</span>);</span><br><span class="line"><span class="comment">// invoke 是方法调用时的入口函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> invoke() &#123;</span><br><span class="line">    Var.pushThreadBindings((Associative)RT.mapUniqueKeys(<span class="keyword">new</span> <span class="keyword">Object</span>[]&#123;Compiler.LOADER, ((Class)<span class="keyword">this</span>.getClass()).getClassLoader()&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Object</span> var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var1 = ((IFn)const__0.getRawRoot()).invoke(const__1);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Var.popThreadBindings();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>invoke</code>方法等价于<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">binding</span> [<span class="name">Compiler.LOADER</span> (<span class="name">Class</span>)this.getClass()).getClassLoader()]</span><br><span class="line">  (<span class="name">refer</span> <span class="symbol">'clojure.core</span>))</span><br></pre></td></tr></table></figure></p><p><code>fn__38</code>与<code>loading__5569__auto____36</code> 类似， 这里不在赘述。</p><h4 id="core-main"><a href="#core-main" class="headerlink" title="core$main"></a>core$main</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ javap  core\$main.<span class="keyword">class</span></span><br><span class="line">Compiled <span class="keyword">from</span> <span class="string">"core.clj"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> how_clojure_work.core$main <span class="keyword">extends</span> clojure.lang.RestFn &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.Var const__0;</span><br><span class="line">  <span class="keyword">public</span> how_clojure_work.core$main();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> java.lang.Object invokeStatic(clojure.lang.ISeq);</span><br><span class="line">  <span class="keyword">public</span> java.lang.Object doInvoke(java.lang.Object);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> getRequiredArity();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>main</code>函数的参数数量是可变的，所以它继承了<code>RestFn</code>，除了 var 赋值外，重要的是以下两个函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Object <span class="title">invokeStatic</span><span class="params">(ISeq _)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// const__0 = (Var)RT.var("clojure.core", "println");</span></span><br><span class="line">    <span class="keyword">return</span> ((IFn)const__0.getRawRoot()).invoke(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">doInvoke</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">    ISeq var10000 = (ISeq)var1;</span><br><span class="line">    var1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">invokeStatic</span><span class="params">(var10000)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的分析，我们可以发现，每个函数在被调用时，会去调用<code>getRawRoot</code>函数得到该函数的实现，这种重定向是 Clojure 实现动态运行时非常重要一措施。这种重定向在开发时非常方便，可以用 <a href="https://github.com/clojure/tools.nrepl" target="_blank" rel="noopener">nrepl</a> 连接到正在运行的 Clojure 程序，动态修改程序的行为，无需重启。<br>但是在正式的生产环境，这种重定向对性能有影响，而且也没有重复定义函数的必要，所以可以在服务启动时指定<code>-Dclojure.compiler.direct-linking=true</code>来避免这类重定向，官方称为 <a href="https://clojure.org/reference/compilation#directlinking" target="_blank" rel="noopener">Direct linking</a>。可以在定义 var 时指定<code>^:redef</code>表示必须重定向。<code>^:dynamic</code>的 var 永远采用重定向的方式确定最终值。</p><p>需要注意的是，var 重定义对那些已经 direct linking 的代码是透明的。</p><h3 id="DynamicClassLoader"><a href="#DynamicClassLoader" class="headerlink" title="DynamicClassLoader"></a>DynamicClassLoader</h3><p>熟悉 JVM 类加载机制（不清楚的推荐我另一篇文章<a href="/blog/2014/07/12/order-of-initialization-in-java/">《JVM 的类初始化机制》</a>）的都会知道，</p><blockquote><p>一个类只会被一个 ClassLoader 加载一次。</p></blockquote><p>仅仅有上面介绍的重定向机制是无法实现动态运行时的，还需要一个灵活的 ClassLoader，可以在 REPL 做如下实验：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">user&gt;</span><span class="bash"> (defn foo [] 1)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">'user/foo</span></span></span><br><span class="line"><span class="meta">user&gt;</span><span class="bash"> (.. foo getClass getClassLoader)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">object[clojure.lang.DynamicClassLoader 0x72d256 <span class="string">"clojure.lang.DynamicClassLoader@72d256"</span>]</span></span><br><span class="line"><span class="meta">user&gt;</span><span class="bash"> (defn foo [] 1)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">'user/foo</span></span></span><br><span class="line"><span class="meta">user&gt;</span><span class="bash"> (.. foo getClass getClassLoader)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">object[clojure.lang.DynamicClassLoader 0x57e2068e <span class="string">"clojure.lang.DynamicClassLoader@57e2068e"</span>]</span></span><br></pre></td></tr></table></figure></p><p>可以看到，只要对一个函数进行了重定义，与之相关的 ClassLoader 随之也改变了。下面来看看 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/DynamicClassLoader.java#L72-L82" target="_blank" rel="noopener">DynamicClassLoader</a> 的核心实现：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放已经加载的类</span></span><br><span class="line"><span class="keyword">static</span> ConcurrentHashMap&lt;String, Reference&lt;<span class="keyword">Class</span>&gt;&gt;classCache =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, Reference&lt;<span class="keyword">Class</span>&gt; &gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// loadClass 会在一个类第一次主动使用时被 JVM 调用</span></span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">true<span class="keyword">Class</span> c = findLoadedClass(name);</span><br><span class="line">true<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">truetruec = findInMemoryClass(name);</span><br><span class="line">truetrue<span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">truetruetruec = <span class="keyword">super</span>.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="keyword">if</span> (resolve)</span><br><span class="line">truetrueresolveClass(c);</span><br><span class="line">true<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户可以调用 defineClass 来动态生成类</span></span><br><span class="line"><span class="comment">// 每次调用时会先清空缓存里已加载的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span> defineClass(String name, <span class="keyword">byte</span>[] bytes, Object srcForm)&#123;</span><br><span class="line">trueUtil.clearCache(rq, classCache);</span><br><span class="line">true<span class="keyword">Class</span> c = defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    classCache.put(name, <span class="keyword">new</span> SoftReference(c,rq));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过搜索 Clojure 源码，只有在 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/RT.java#L2126" target="_blank" rel="noopener">RT.java 的 makeClassLoader 函数</a> 里面有<code>new DynamicClassLoader</code>语句，继续通过 Intellj 的 Find Usages 发现有如下三处调用<code>makeClassLoader</code>：<a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L7455" target="_blank" rel="noopener">Compiler/compile1</a>、<a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L6897" target="_blank" rel="noopener">Compiler/eval</a>、<a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L7352" target="_blank" rel="noopener">Compiler/load</a>。</p><p>正如<a href="/blog/2017/02/05/clojure-compiler-analyze/#Compiler-java">上一篇文章</a>的介绍，这三个方法正是 Compiler 的入口函数，这也就解释了上面 REPL 中的实验：</p><blockquote><p>每次重定义一个函数，都会生成一个新 DynamicClassLoader 实例去加载其实现。</p></blockquote><h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>明白了 Clojure 是如何实现动态运行时，下面分析 Clojure 程序为什么启动慢。</p><p>首先需要明确一点，<a href="http://stackoverflow.com/questions/2163411/is-java-really-slow" target="_blank" rel="noopener">JVM 并不慢</a>，我们可以将之前的 Hello World 打成 uberjar，运行测试下时间。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;; (:gen-class) 指令能够生成与命名空间同名的类</span><br><span class="line">(ns how-clojure-work.core</span><br><span class="line">  (:gen-class))</span><br><span class="line"></span><br><span class="line">(defn -main [&amp; _]</span><br><span class="line">  (println <span class="string">"Hello, World!"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了能用 java -jar 方式运行，需要在 project.clj 中添加</span></span><br><span class="line"><span class="comment"># :main how-clojure-work.core</span></span><br><span class="line">$ lein uberjar</span><br><span class="line">$ time java -jar target/how-clojure-work-0.1.0-SNAPSHOT-standalone.jar</span><br><span class="line">Hello, World!</span><br><span class="line"></span><br><span class="line">real0m0.900s</span><br><span class="line">user0m1.422s</span><br><span class="line">sys0m0.087s</span><br></pre></td></tr></table></figure></p><p>在启动时加入<code>-verbose:class</code> 参数，可以看到很多 clojure.core 开头的类<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[Loaded clojure.core$cond__GT__GT_ from <span class="string">file:</span><span class="regexp">/Users/</span>liujiacai<span class="regexp">/codes/</span>clojure<span class="regexp">/how-clojure-work/</span>target/how-clojure-work<span class="number">-0.1</span><span class="number">.0</span>-SNAPSHOT-standalone.jar]</span><br><span class="line">[Loaded clojure.core$as__GT_ from <span class="string">file:</span><span class="regexp">/Users/</span>liujiacai<span class="regexp">/codes/</span>clojure<span class="regexp">/how-clojure-work/</span>target/how-clojure-work<span class="number">-0.1</span><span class="number">.0</span>-SNAPSHOT-standalone.jar]</span><br><span class="line">[Loaded clojure.core$some__GT_ from <span class="string">file:</span><span class="regexp">/Users/</span>liujiacai<span class="regexp">/codes/</span>clojure<span class="regexp">/how-clojure-work/</span>target/how-clojure-work<span class="number">-0.1</span><span class="number">.0</span>-SNAPSHOT-standalone.jar]</span><br><span class="line">[Loaded clojure.core$some__GT__GT_ from <span class="string">file:</span><span class="regexp">/Users/</span>liujiacai<span class="regexp">/codes/</span>clojure<span class="regexp">/how-clojure-work/</span>target/how-clojure-work<span class="number">-0.1</span><span class="number">.0</span>-SNAPSHOT-standalone.jar]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>把生成的 uberjar 解压打开，可以发现 clojure.core 里面的函数都在，这些函数在程序启动时都会被加载。</p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2Hb_NdHXlpuFjSszfXXcSGXXa_!!581166664.png" alt="Clojure 版本 Hello World"><br></center><p>这就是 Clojure 启动慢的原因：加载大量用不到的类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Clojure 作为一门 host 在 JVM 上的语言，其独特的实现方式让其拥动态的运行时的同时，方便与 Java 进行交互。当然，Clojure 还有很多可以提高的地方，比如上面的慢启动问题。另外，JVM 7 中增加了 <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html" target="_blank" rel="noopener">invokedynamic</a> 指令，可以让运行在 JVM 上的动态语言通过实现一个 CallSite （可以认为是函数调用）的 <code>MethodHandle</code> 函数来帮助编译器找到正确的实现，这无异会提升程序的执行速度。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.ndk.io/clojure-compilation2.html" target="_blank" rel="noopener">http://blog.ndk.io/clojure-compilation2.html</a></li><li><a href="http://stackoverflow.com/questions/7471316/how-does-clojure-class-reloading-work" target="_blank" rel="noopener">http://stackoverflow.com/questions/7471316/how-does-clojure-class-reloading-work</a></li><li><a href="http://blog.headius.com/2011/10/why-clojure-doesnt-need-invokedynamic.html" target="_blank" rel="noopener">http://blog.headius.com/2011/10/why-clojure-doesnt-need-invokedynamic.html</a></li><li><a href="http://www.deepbluelambda.org/programming/clojure/how-clojure-works-a-simple-namespace" target="_blank" rel="noopener">http://www.deepbluelambda.org/programming/clojure/how-clojure-works-a-simple-namespace</a></li><li><a href="https://8thlight.com/blog/aaron-lahey/2016/07/20/relationship-between-clojure-functions-symbols-vars-namespaces.html" target="_blank" rel="noopener">https://8thlight.com/blog/aaron-lahey/2016/07/20/relationship-between-clojure-functions-symbols-vars-namespaces.html</a></li><li><a href="http://blog.cognitect.com/blog/2016/9/15/works-on-my-machine-understanding-var-bindings-and-roots" target="_blank" rel="noopener">http://blog.cognitect.com/blog/2016/9/15/works-on-my-machine-understanding-var-bindings-and-roots</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/blog/2017/02/05/clojure-compiler-analyze/&quot;&gt;上一篇文章&lt;/a&gt;讲述了 Clojure 编译器工作的整体流程，主要涉及 LispReader 与 Compiler 这两个类，而且指出编译器并没有把 Clojure 
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>Clojure 运行原理之编译器剖析篇</title>
    <link href="http://liujiacai.net/blog/2017/02/05/clojure-compiler-analyze/"/>
    <id>http://liujiacai.net/blog/2017/02/05/clojure-compiler-analyze/</id>
    <published>2017-02-05T00:53:24.000Z</published>
    <updated>2019-12-24T10:59:14.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Clojure is a compiled language, yet remains completely dynamic – every feature supported by Clojure is supported at runtime.        </p><blockquote><p>Rich Hickey   <a href="https://clojure.org/" target="_blank" rel="noopener">https://clojure.org/</a></p></blockquote></blockquote><p>这里的 runtime 指的是 JVM，JVM 之初是为运行 Java 语言而设计，而现在已经发展成一重量级平台，除了 Clojure 之外，<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages" target="_blank" rel="noopener">很多动态语言</a>也都选择基于 JVM 去实现。<br>为了更加具体描述 Clojure 运行原理，会分两篇文章来介绍。<br>本文为第一篇，涉及到的主要内容有：编译器工作流程、Lisp 的宏机制。<br>第二篇将主要讨论 Clojure 编译成的 bytecode 如何实现动态运行时以及为什么 Clojure 程序启动慢，这会涉及到 JVM 的类加载机制。</p><h2 id="编译型-VS-解释型"><a href="#编译型-VS-解释型" class="headerlink" title="编译型 VS. 解释型"></a>编译型 VS. 解释型</h2><p>SO 上有个问题 <a href="http://stackoverflow.com/questions/5669933/is-clojure-compiled-or-interpreted" target="_blank" rel="noopener">Is Clojure compiled or interpreted</a>，根据本文开始部分的官网引用，说明 Clojure 是门编译型语言，就像 Java、Scala。但是 Clojure 与 Java 不一样的地方在于，Clojure 可以在运行时进行编译然后加载，而 Java 明确区分编译期与运行期。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB26GwHd4xmpuFjSZFNXXXrRXXa_!!581166664.png" alt><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2WNsBd.hnpuFjSZFPXXb_4XXa_!!581166664.png" alt></p><h2 id="编译器工作流程"><a href="#编译器工作流程" class="headerlink" title="编译器工作流程"></a>编译器工作流程</h2><p>与解释型语言里的解释器类似，编译型语言通过编译器（Compiler）来将源程序编译为字节码。一般来说，编译器包括<a href="https://en.wikipedia.org/wiki/Compiler#Three_phases_compiler_structure" target="_blank" rel="noopener">两个部分</a>：</p><ul><li>前端：<a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" rel="noopener">词法分析</a> –&gt; <a href="https://en.wikipedia.org/wiki/Parsing" target="_blank" rel="noopener">语法分析</a> –&gt; <a href="https://en.wikipedia.org/wiki/Semantic_analysis_%28compilers%29" target="_blank" rel="noopener">语义分析</a></li><li>后端：<a href="https://en.wikipedia.org/wiki/Optimizing_compiler" target="_blank" rel="noopener">分析、优化</a> –&gt; <a href="https://en.wikipedia.org/wiki/Code_generation_%28compilers%29" target="_blank" rel="noopener">目标代码生成</a></li></ul><p>Clojure 的编译器也遵循这个模式，大致可以分为以下两个模块：</p><ul><li>读取 Clojure 源程序 –&gt; 分词 –&gt; 构造 S-表达式，由 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/LispReader.java#L223-L294" target="_blank" rel="noopener">LispReader.java</a> 类实现</li><li>宏扩展 –&gt; 语义分析 –&gt; 生成 JVM 字节码，由 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L7446-L7481" target="_blank" rel="noopener">Compiler.java</a> 类实现</li></ul><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2j7k3dZtnpuFjSZFKXXalFFXa_!!581166664.png" alt="Clojure 编译器工作流"><br></center><p>上图给出了不同阶段的输入输出，具体实现下面一一讲解。</p><h3 id="LispReader-java"><a href="#LispReader-java" class="headerlink" title="LispReader.java"></a><a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/LispReader.java" target="_blank" rel="noopener">LispReader.java</a></h3><p>一般来说，具有复杂语法的编程语言会把词法分析与语法分析分开实现为 Lexer 与 Parser，但在 Lisp 家族中，源程序的语法就已经是 AST 了，所以会把 Lexer 与 Parser 合并为一个过程 Reader，<a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/LispReader.java#L223-L294" target="_blank" rel="noopener">核心代码</a>实现如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="comment">; ; ) &#123;</span></span><br><span class="line"></span><br><span class="line">    if (<span class="name">pendingForms</span> instanceof List <span class="symbol">&amp;&amp;</span> !((<span class="name">List</span>) pendingForms).isEmpty())</span><br><span class="line">        return ((<span class="name">List</span>) pendingForms).remove(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    int ch = read1(<span class="name">r</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    while (<span class="name">isWhitespace</span>(<span class="name">ch</span>))</span><br><span class="line">        ch = read1(<span class="name">r</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (<span class="name">ch</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">        if (<span class="name">eofIsError</span>)</span><br><span class="line">            throw Util.runtimeException(<span class="string">"EOF while reading"</span>)<span class="comment">;</span></span><br><span class="line">        return eofValue<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (<span class="name">returnOn</span> != null <span class="symbol">&amp;&amp;</span> (<span class="name">returnOn</span>.charValue() == ch)) &#123;</span><br><span class="line">        return returnOnValue<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (<span class="name">Character</span>.isDigit(<span class="name">ch</span>)) &#123;</span><br><span class="line">        Object n = readNumber(<span class="name">r</span>, (<span class="name">char</span>) ch)<span class="comment">;</span></span><br><span class="line">        return n<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IFn macroFn = getMacro(<span class="name">ch</span>)<span class="comment">;</span></span><br><span class="line">    if (<span class="name">macroFn</span> != null) &#123;</span><br><span class="line">        Object ret = macroFn.invoke(<span class="name">r</span>, (<span class="name">char</span>) ch, opts, pendingForms)<span class="comment">;</span></span><br><span class="line">        //no op macros return the reader</span><br><span class="line">        if (<span class="name">ret</span> == r)</span><br><span class="line">            continue<span class="comment">;</span></span><br><span class="line">        return ret<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (<span class="name">ch</span> == '+' || ch == '-') &#123;</span><br><span class="line">        int ch2 = read1(<span class="name">r</span>)<span class="comment">;</span></span><br><span class="line">        if (<span class="name">Character</span>.isDigit(<span class="name">ch2</span>)) &#123;</span><br><span class="line">            unread(<span class="name">r</span>, ch2)<span class="comment">;</span></span><br><span class="line">            Object n = readNumber(<span class="name">r</span>, (<span class="name">char</span>) ch)<span class="comment">;</span></span><br><span class="line">            return n<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        unread(<span class="name">r</span>, ch2)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String token = readToken(<span class="name">r</span>, (<span class="name">char</span>) ch)<span class="comment">;</span></span><br><span class="line">    return interpretToken(<span class="name">token</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reader 的行为是由内置构造器（目前有数字、字符、Symbol 这三类）与一个称为<code>read table</code>的扩展机制（getMacro）驱动的，<code>read table</code> 里面每项记录提供了由特性符号（称为<code>macro characters</code>）到特定读取行为（称为<code>reader macros</code>）的映射。</p><p>与 Common Lisp 不同，普通用户无法扩展 Clojure 里面的<code>read table</code>。关于扩展<code>read table</code>的好处，可以参考 StackOverflow 上的 <a href="http://stackoverflow.com/questions/5746801/what-advantage-does-common-lisp-reader-macros-have-that-clojure-does-not-have" target="_blank" rel="noopener">What advantage does common lisp reader macros have that Clojure does not have?</a>。Rich Hickey 在<a href="https://groups.google.com/forum/#!topic/clojure/8RSLNWno0nU" target="_blank" rel="noopener">一 Google Group</a>里面有阐述不开放 <code>read table</code> 的理由，这里摘抄如下：</p><blockquote><p>I am unconvinced that reader macros are needed in Clojure at this<br>time. They greatly reduce the readability of code that uses them (by<br>people who otherwise know Clojure), encourage incompatible custom mini-<br>languages and dialects (vs namespace-partitioned macros), and<br>complicate loading and evaluation.<br>To the extent I’m willing to accommodate common needs different from<br>my own (e.g. regexes), I think many things that would otherwise have<br>forced people to reader macros may end up in Clojure, where everyone<br>can benefit from a common approach.<br>Clojure is arguably a very simple language, and in that simplicity<br>lies a different kind of power.<br>I’m going to pass on pursuing this for now,</p></blockquote><p>截止到 Clojure 1.8 版本，共有如下九个<code>macro characters</code>:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Quote</span> (')</span><br><span class="line"><span class="selector-tag">Character</span> (\)</span><br><span class="line"><span class="selector-tag">Comment</span> (;)</span><br><span class="line"><span class="selector-tag">Deref</span> (@)</span><br><span class="line"><span class="selector-tag">Metadata</span> (^)</span><br><span class="line"><span class="selector-tag">Dispatch</span> (#)</span><br><span class="line"><span class="selector-tag">Syntax-quote</span> (`)</span><br><span class="line"><span class="selector-tag">Unquote</span> (~)</span><br><span class="line"><span class="selector-tag">Unquote-splicing</span> (~@)</span><br></pre></td></tr></table></figure></p><p>它们的具体含义可参考<a href="https://clojure.org/reference/reader#macrochars" target="_blank" rel="noopener">官方文档 reader#macrochars</a>。</p><h3 id="Compiler-java"><a href="#Compiler-java" class="headerlink" title="Compiler.java"></a><a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java" target="_blank" rel="noopener">Compiler.java</a></h3><p>Compiler 类主要有三个入口函数：</p><ul><li><a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L7483-L7646" target="_blank" rel="noopener">compile</a>，当调用<code>clojure.core/compile</code>时使用</li><li><a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L7344-L7399" target="_blank" rel="noopener">load</a>，当调用<code>clojure.core/require</code>、<code>clojure.core/use</code>时使用</li><li><a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L6893-L6946" target="_blank" rel="noopener">eval</a>，当调用<code>clojure.core/eval</code>时使用</li></ul><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2i5Medl0kpuFjSsziXXa.oVXa_!!581166664.png" alt="Compiler 类的 UML"><br></center><p>这三个入口函数都会依次调用 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L6836-L6841" target="_blank" rel="noopener">macroexpand</a>、<a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L6628-L6692" target="_blank" rel="noopener">analyze</a> 方法，生成<code>Expr</code>对象，compile 函数还会额外调用 emit 方法生成 bytecode。</p><h4 id="macroexpand"><a href="#macroexpand" class="headerlink" title="macroexpand"></a>macroexpand</h4><p>Macro 毫无疑问是 Lisp 中的屠龙刀，可以在<code>编译时</code>自动生成代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">Object</span> macroexpand(<span class="built_in">Object</span> form) &#123;</span><br><span class="line">    <span class="built_in">Object</span> exf = macroexpand1(form);</span><br><span class="line">    <span class="keyword">if</span> (exf != form)</span><br><span class="line">        <span class="keyword">return</span> macroexpand(exf);</span><br><span class="line">    <span class="keyword">return</span> form;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L6763-L6834" target="_blank" rel="noopener">macroexpand1</a> 函数进行主要的扩展工作，它会调用<code>isMacro</code>判断当前<code>Var</code>是否为一个宏，而这又是通过检查<code>var</code>是否为一个函数，并且元信息中<code>macro</code>是否为<code>true</code>。<br>Clojure 里面通过<code>defmacro</code>函数创建宏，它会调用<code>var</code>的<code>setMacro</code>函数来设置元信息<code>macro</code>为<code>true</code>。</p><h4 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">eval</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emit</span><span class="params">(C context, ObjExpr objx, GeneratorAdapter gen)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasJavaClass</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">getJavaClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Expr <span class="title">analyze</span><span class="params">(C context, Object form, String name)</span></span></span><br></pre></td></tr></table></figure><p>analyze 进行主要的语义分析，<code>form</code>参数即是宏展开后的各种数据结构（String/ISeq/IPersistentList 等），返回值类型为<code>Expr</code>，可以猜测出，<code>Expr</code>的子类是程序的主体，遵循模块化的编程风格，每个子类都知道如何对其自身求值（eval）或输出 bytecode（emit）。</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2M8IrdbtlpuFjSspoXXbcDpXa_!!581166664.png" alt="Expr 类继承关系（部分）"><br></center><h4 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h4><p>这里需要明确一点的是，Clojure 编译器并没有把 Clojure 代码转为相应的 Java 代码，而是借助 bytecode 操作库 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM</a> 直接生成可运行在 JVM 上的 bytecode。</p><p>根据 JVM bytecode 的规范，每个<code>.class</code>文件都必须由类组成，而 Clojure 作为一个函数式语言，主体是函数，通过 namespace 来封装、隔离函数，你可能会想当然的认为每个 namespace 对应一个类，namespace 里面的每个函数对应类里面的方法，而实际上并不是这样的，根据 <a href="https://clojure.org/reference/compilation" target="_blank" rel="noopener">Clojure 官方文档</a>，对应关系是这样的：</p><ul><li>函数生成一个类</li><li>每个文件（相当于一个命名空间）生成一个<code>&lt;filename&gt;__init</code> 的加载类</li><li><code>gen-class</code> 生成固定名字的类，方便与 Java 交互</li></ul><p>生成的 bytecode 会在本系列第二篇文章中详细介绍，敬请期待。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>每个 <code>Expr</code> 的子类都有 eval 方法的相应实现。下面的代码片段为 <code>LispExpr.eval</code> 的实现，其余子类实现也类似，这里不在赘述。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object eval() &#123;</span><br><span class="line">    IPersistentVector <span class="keyword">ret</span> = PersistentVector.EMPTY;</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; <span class="keyword">args</span>.<span class="keyword">count</span>(); i++)</span><br><span class="line">        <span class="comment">// 这里递归的求列表中每项的值</span></span><br><span class="line">        <span class="keyword">ret</span> = (IPersistentVector) <span class="keyword">ret</span>.<span class="keyword">cons</span>(((Expr) <span class="keyword">args</span>.nth(i)).eval());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ret</span>.seq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前看 SICP 后实现过几个解释器，但是相对来说都比较简单，通过分析 Clojure 编译器的实现，加深了对 <a href="/blog/2015/10/03/first-toy-scheme/#求值过程">eval-apply 循环</a>的理解，还有一点就是揭开了宏的真实面貌，之前一直认为宏是个很神奇的东西，其实它只不过是<code>编译时运行的函数</code>而已，输入与输出的内容既是构成程序的数据结构，同时也是程序内在的 AST。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.guillermowinkler.com/blog/2014/04/21/decompiling-clojure-ii/" target="_blank" rel="noopener">Decompiling Clojure II, the Compiler</a></li><li><a href="http://blog.ndk.io/clojure-compilation.html" target="_blank" rel="noopener">Clojure Compilation: Parenthetical Prose to Bewildering Bytecode</a></li><li><a href="http://blog.fogus.me/2012/04/25/the-clojurescript-compilation-pipeline/" target="_blank" rel="noopener">The ClojureScript Compilation Pipeline</a></li><li><a href="https://clojure.org/reference/compilation" target="_blank" rel="noopener">Ahead-of-time Compilation and Class Generation</a></li><li><a href="https://clojure.org/reference/reader" target="_blank" rel="noopener">The Reader</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Clojure is a compiled language, yet remains completely dynamic – every feature supported by Clojure is supported at runtime.
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>2016 年终总结</title>
    <link href="http://liujiacai.net/blog/2017/01/08/review-2016/"/>
    <id>http://liujiacai.net/blog/2017/01/08/review-2016/</id>
    <published>2017-01-08T01:30:31.000Z</published>
    <updated>2019-12-24T10:59:14.608Z</updated>
    
    <content type="html"><![CDATA[<p>又到一年总结时，本来想着在农历年前考完科目三拿到驾照后再写的，目前来看希望不大了，这个目标只能留在17年去实现了，有种书到用时方恨晚的感觉。<br>一个词来总结 16 年——“运动元年”，算是完成了 <a href="/blog/2016/01/08/review-2015/#减肥">15 年一小目标</a>。OK，下面简单回顾下 16 年那些“重大事件”吧。</p><h2 id="强身健体"><a href="#强身健体" class="headerlink" title="强身健体"></a>强身健体</h2><h3 id="减肥大计"><a href="#减肥大计" class="headerlink" title="减肥大计"></a>减肥大计</h3><p>从 4 月初开始到现在，体重大概从100KG减到现在的85KG，最轻的时候到了80KG，冬天又反弹了5KG左右。单看数字其实并没有什么，网上很多人在半年内都能做到，但是对我来说意义要更深远。从去健身房开始，发现了另一种生活方式，生活不在只有代码，生活可以更丰富多彩，在此期间我也跑了<a href="/blog/2016/11/07/run-2-marathon-in-a-week/">两次马拉松</a>，爬了好多山。对自己的身体也有了更多的了解，之前认为减肥就是体重下降，其实这时非常肤浅的，如果健身能够让你改变之前懒散的生活方式，周末走出房门，拥抱大自然，认识更多的朋友，那么体重对你来说还那么重要嘛。</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB28ADTc5RnpuFjSZFCXXX2DXXa_!!581166664.png" alt="健身打卡1"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2.342cCtkpuFjy0FhXXXQzFXa_!!581166664.png" alt="健身打卡2"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2YmZacY4npuFjSZFmXXXl4FXa_!!581166664.jpg" alt="我与教练"><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2H6nZcZtnpuFjSZFKXXalFFXa_!!581166664.jpg" alt="晨跑"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2URzWcYJmpuFjSZFBXXXaZXXa_!!581166664.png_620x10000.jpg" alt="运动日记"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2b68KcU5O.eBjSZFxXXaaJFXa_!!581166664.jpg_620x10000.jpg" alt="杭州全马终点"><br></center><h3 id="乒乓球"><a href="#乒乓球" class="headerlink" title="乒乓球"></a>乒乓球</h3><p>在我运动细胞高涨期间，组织了公司的乒乓球协会，并在年底的比赛中获得第二名。乒乓球从小就喜欢玩，可以是之前体重的缘故，只能玩这种小球😂，大二体育课还选修了一年。在协会里认识了各类高手，每天下班后去打两局也成了常态，心里的满足感极高。</p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2Y54QcuJ8puFjy1XbXXagqVXa_!!581166664.png_620x10000.jpg" alt="选手风采"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2w6J4cB0kpuFjy1zdXXXuUVXa_!!581166664.jpg_620x10000.jpg" alt="前三名"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2jhh8crplpuFjSspiXXcdfFXa_!!581166664.gif" alt="开局前三板"><br></center><h2 id="天天向上"><a href="#天天向上" class="headerlink" title="天天向上"></a>天天向上</h2><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>16 年读的书不多，15 年终总结时<a href="/blog/2016/01/08/review-2015/#读书-1">列出的书</a>只完成了两本。</p><p>上半年终于完成《SICP》的阅读，<a href="https://github.com/jiacai2050/sicp" target="_blank" rel="noopener">Github 上的笔记</a> 有了 248 个 star、37 个 fork、33 个 watch，读完这本书，不仅仅是对编程语言有了新的认识，更重要的是挑战自己，看看是否能坚持做好一件事。</p><p>另一本看完的书是<a href="http://book.douban.com/subject/1494026/" target="_blank" rel="noopener">《CODE》</a>，这本书相对来说偏硬件，科普类型，但是对理解计算机内部构造还是非常有帮助的，从简单的门电路，到二八译码器，锁存器，二极管，一步步深入，建议每一位同学都读读。</p><p>上面两本是计划内的，此外还完成了<a href="https://book.douban.com/subject/4743790/" target="_blank" rel="noopener">《The Joy of Clojure》</a>、<a href="https://book.douban.com/subject/25783324/" target="_blank" rel="noopener">《 Clojure Cookbook 》</a>。<br><a href="https://book.douban.com/subject/3273420/" target="_blank" rel="noopener">《Python Essential Reference》</a> 看到了第13章，占全书的37%左右。</p><p>前几天看到一篇文章<a href="http://www.jianshu.com/p/0e22c900809b" target="_blank" rel="noopener">《买个书，你还凑什么运费？》</a>，是的，就像该文说的，我也有囤书“病”，其实这个道理大家都懂，就是做起来比较难而已，这里再把 16 年年初定的目标拿过来，17 年继续：</p><ul><li><a href="http://book.douban.com/subject/1230413/" target="_blank" rel="noopener">Computer Systems: A Programmer’s Perspective</a>，这本书主要是让我能够更好的理解操作系统。</li><li><a href="http://book.douban.com/subject/25854634/" target="_blank" rel="noopener">公共问题经济学</a>，主要是一些经济学知识，在现代社会，每个人都需要懂一些经济学，不是嘛</li><li><a href="http://book.douban.com/subject/1888733/" target="_blank" rel="noopener">Java Concurrency in Practice</a>，主要讲授多线程方面的知识。</li><li><a href="http://book.douban.com/subject/1632977/" target="_blank" rel="noopener">The Little Schemer - 4th Edition</a>，这是一本小巧精炼的书，主要讲解 Scheme 方面的东西，对理解一些概念，像递归、lambda 很有帮助，是 SICP 很好的辅助书籍。</li><li><a href="http://book.douban.com/subject/1726083/" target="_blank" rel="noopener">The Seasoned Schemer</a>，TLS 的晋级篇</li><li><a href="https://book.douban.com/subject/1432683/" target="_blank" rel="noopener">On Lisp</a>，Advanced Techniques for Common LISP，主要是学习 Lisp 中宏的强大</li></ul><p><del>为了不重蹈覆辙，之后会做个详细的读书计划</del>，目标太大不容易实现，切分成小目标就好多了，和减肥一个道理。目标是在 17 年把上面几本书全部消灭。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2mf.BancCL1FjSZFPXXXZgpXa_!!581166664.png" alt="17 年读书计划时间表，From 日事清APP"></p><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2F20LcwJlpuFjSspjXXcT.pXa_!!581166664.png" alt="16 年的 Github Contributions"></p><p>从数字来看，370 次比去年的 459 次少了些，提交也基本上是在上半年，应该也是在看 SICP 的阶段，7 月份后业余时间都用在了健身上，看书与写代码的时间确实少了不少。</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2kFyjcrRkpuFjSspmXXc.9XXa_!!581166664.png" alt></p><ul><li>15年十一期间写了 <a href="https://github.com/jiacai2050/JCScheme" target="_blank" rel="noopener">Java 版 Scheme</a>，16 年用 Clojure <a href="https://github.com/jiacai2050/scheme.clj" target="_blank" rel="noopener">重新实现</a>了次，目前有 3 个 watch，11 个 star；</li><li>还写了一个浏览器插件 <a href="https://github.com/jiacai2050/better-history" target="_blank" rel="noopener">Advance History</a>，用于统计分析流量纪录，目前有 83 个 star，6 个 watch，11 个 fork</li><li>看 Python Essential 期间，写了个 <a href="https://github.com/jiacai2050/pysh/" target="_blank" rel="noopener">Python 版的 Shell</a>，主要是用generator 来实现不同命令间的 pipeline，可惜目前没有持续开发，17 年应该会再在这个项目上发力。目前 3 个 watch，19 个 star。</li></ul><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>现在来看看 16 年的博客，产量明显低于预期，没能做到每月都有产出。</p><ul><li>质量最高的应该算<a href="/blog/2016/10/31/socket-programming/">《Socket 编程实战》</a>，现在的开发离不开网络，但是对于网络通信，很多人不是非常了解，这篇文章算是给出了较为详细的解释；</li><li>最装 X 的文章应该是<a href="/blog/2016/11/07/run-2-marathon-in-a-week/">《我为什么一周内连跑 2 个马拉松》</a>，用了“洪荒之力”才完成的，主要纪录自己从一个小胖子，怎么一步步完成全马（42.195KM）的心理历程；</li><li><a href="/blog/2016/02/22/recursion-without-name/">《如何实现一个没有名字的递归函数》</a> 主要写的是 Y 算子，算是<a href="/blog/2014/10/12/lambda-calculus-introduction/">《 编程语言的基石——Lambda calculus 》</a>的继承篇，但是感觉这两篇文章写的都不是很好，17 年理解加深后需要再完善这两个函数式编程中的基本概念；</li><li><a href="/blog/2016/05/28/scope-closure/">《编程语言中的变量作用域与闭包》</a>算是在 SICP 第四章环境模型的基础上，重点介绍了 JS 与 Python 中的变量作用域，之后一句话解释什么是闭包：<code>一个闭包对象包含：一个函数与声明函数时的环境</code>，闭包是为了解决自由变量作用域的问题而提出的概念；</li><li><a href="/blog/2016/03/26/python-ruby-javascript/">《python, ruby, javascript 浅析》 </a> 这篇文章第一次涉及到了 Ruby 语言，相比 Python，Ruby 更灵活，更适合元编程；</li><li><a href="/blog/2016/04/23/sicp-chapter4-summary/">《SICP 第四章总结》</a>、<a href="/blog/2016/05/21/sicp-chapter5-summary/">《SICP 第五章总结》</a> 是 SICP 一书最后两章，第五章偏重编译器实现的细节，看到不是很详细，以后可能会有 Clojure 把 SICP 上的重要习题再做一遍，温故知新；</li><li><a href="/blog/2016/12/07/hello-jeju/">《韩国济州岛4日游》</a>、<a href="/blog/2016/12/18/zoo-hupao-of-hangzhou/">《夜爬初体验》</a> 是两次非常愉快的经历，第一次走出国门，第一次黑夜爬山，都非常难忘；</li><li><a href="/blog/2016/12/31/dev-in-clojure/">《Clojure 开发那些事》</a> 16 年最后一篇文章，看完 SICP 以后就觉得要找一门 Lisp 方言作为主力语言，这篇文章算是开个头，预计接下来的几年内都会重点使用 Lisp。</li></ul><p>技术文章除了发在个人博客，今年依次开通了<a href="http://weixin.sogou.com/weixin?query=keepwritingcodes" target="_blank" rel="noopener">微信公众号</a>，<a href="https://gold.xitu.io/user/57c2431b165abd00665ee39f" target="_blank" rel="noopener">掘金专栏</a>，一方面是提升自己文章曝光率，建立自己的品牌；另一方面是找到志同道合的小伙伴，个人博客文章难免会有遗漏、错误的地方，需要志同道合者指出，共同进步。为了区分生活类文章，开通<a href="http://www.jianshu.com/u/8a5466e37198" target="_blank" rel="noopener">简书</a>，以后生活感悟的文章主要会放在这里。</p><h3 id="学洋文"><a href="#学洋文" class="headerlink" title="学洋文"></a>学洋文</h3><p>16 年初决定用扇贝打卡，到今天为止打卡 167 天，不到半年。而且有些天水分也比较大，基本上 2 分钟就打卡了。</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2TpGdcB8kpuFjSspeXXc7IpXa_!!581166664.jpg_620x10000.jpg" alt="扇贝打卡纪录"><br></center><p>期间也买过 iPhone 上的<a href="https://itunes.apple.com/ec/app/voa-ying-yu-ting-li-xin-wen/id1010195720?l=en&amp;mt=8" target="_blank" rel="noopener">VOA集合</a>，听了两天也没坚持下来，虽然计算机方面的书能看英文我尽量看英文，但是英文阅读能力还是每提高多少，就其原因，觉得还是大多数时候我都不求甚解，很多复杂句式自己也懒得去分析，久而久之可能就丧失了这种能力，加上手机上阅读本身就能难集中注意力，所以一年下来英语水平还是那么样。</p><p>前两天看到一篇文章<a href="http://www.jianshu.com/p/74ec33aa2038" target="_blank" rel="noopener">《没人会等你优秀，遇到别人时你必须已经很优秀》</a>，自己想出国但是语言又一直原地打转怎么可以呢？机会是留给有准备的人。17 年的英语学习计划要多去动笔动脑，学习英语时直接开飞行模式，把干扰降到最低，正好扇贝有个<a href="https://www.shanbay.com/web/annual-plan/intro" target="_blank" rel="noopener">新年计划</a>，交费20.17元，定个300天打卡的小目标，等到 18 年再见证效果。</p><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>16 年是正式工作的第二年，这一年的工作平淡无奇，没什么特别突出的地方，代码风格相对来说还是比较满意，总结出了 <a href="http://python-best-practice.liujiacai.net/#/" target="_blank" rel="noopener">Python 最佳实践</a>，并在实际项目中应用；用 Node.js 完成了一内部工具，供 BI 的同学使用，这个项目陆陆续续做了一年半，事实证明 Node.js 的回调确实挺坑，维护起来成本略高；年底时，把 Clojure 正式应用到工作中，算是跨出 Lisp 大门的第一步，后面打算在公司内部做几次分享，来推广 Clojure，平时也会多去学习 Github 上的开源项目，Clojure 第三方库一般都比较短小精悍，由于其语言本身的扩展性非常好，所以可以用较少的代码来实现同样的功能，17 年会写几篇文章来总结这方面的经验。</p><p>如果说 16 年是运动元年，那么 17 年将会是运动翌年，健身应该是一件很享受的事情，跑步机上挥汗如雨之后，练练肩，练练腿，最后冲个澡，回去大睡一觉，生活还能更美好嘛？！17 年还应该会去爬黄山、庐山、华山。</p><p>16 年高质量文章较少，17 年会在阅读经典书籍的同时，多去总结，发散思维，最少做到每月一篇高质量博客，现在有了<a href="http://weixin.sogou.com/weixin?query=keepwritingcodes" target="_blank" rel="noopener">公众号</a>后，更要勤奋，把自己的品牌（KeepWritingCodes）建立起来。</p><p>好了，总结的差不多了，最后放几张有意义的照片告别2016，迎接崭新的2017。<code>&lt;/2016&gt;Hello World&lt;2017&gt;</code></p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB24FskXS0mpuFjSZPiXXbssVXa_!!581166664.jpg" alt="韩国济州岛，清晨"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2y9z6c.lnpuFjSZFjXXXTaVXa_!!581166664.jpg" alt="韩国济州岛，汉拿山"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2z2kdc9FmpuFjSZFrXXayOXXa_!!581166664.jpg_620x10000.jpg" alt="杭州，曲院风荷"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2faKbcB0kpuFjSsziXXa.oVXa_!!581166664.jpg" alt="杭州，北高峰"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2yBr6c.lnpuFjSZFjXXXTaVXa_!!581166664.jpg_620x10000.jpg" alt="北京，鸟巢"><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB29fMfcYBmpuFjSZFAXXaQ0pXa_!!581166664.jpg" alt="临沂，天蒙，家辉"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2zP.bc5pnpuFjSZFkXXc4ZpXa_!!581166664.jpg_620x10000.jpg" alt="临沂，天蒙，家钰"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB23mv2cYJmpuFjSZFwXXaE4VXa_!!581166664.jpg" alt="家辉写的天蒙一日游"><br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又到一年总结时，本来想着在农历年前考完科目三拿到驾照后再写的，目前来看希望不大了，这个目标只能留在17年去实现了，有种书到用时方恨晚的感觉。&lt;br&gt;一个词来总结 16 年——“运动元年”，算是完成了 &lt;a href=&quot;/blog/2016/01/08/review-2015
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Clojure 开发那些事</title>
    <link href="http://liujiacai.net/blog/2016/12/31/dev-in-clojure/"/>
    <id>http://liujiacai.net/blog/2016/12/31/dev-in-clojure/</id>
    <published>2016-12-31T08:49:17.000Z</published>
    <updated>2019-12-24T10:59:14.607Z</updated>
    
    <content type="html"><![CDATA[<p>Clojure —— 新世纪的 Lisp 方言，相信大多数同学多多少少都听过，毕竟有个杀手级应用 <a href="http://storm.apache.org/" target="_blank" rel="noopener">Storm</a>，但是真正去写 Clojure 的同学估计不多，国内也罕见哪个公司招 Clojure 程序员。<br>作为推广 Clojure 万里长城的第一步，这篇文章首先介绍为什么要使用 Lisp 开发，之后开始介绍 Clojure 语法入门，紧接着介绍 Clojure 开发环境搭建，然后介绍使用第三方库时的一些注意点，最后介绍一下常见的测试方法。本篇文章所介绍内容都是我自己实践得出，不足之处请各位 Clojurians 指出。</p><h2 id="Why-Lisp"><a href="#Why-Lisp" class="headerlink" title="Why Lisp"></a>Why Lisp</h2><p>Lisp 语言诞生这么久了，为什么一直那么小众？原因就在于 Lisp 语言过于强大，不必也不可能像 Java 那么普及。你能要求每个人都能为 CTO 吗？<br>硅谷创业之父 <a href="http://www.paulgraham.com/" target="_blank" rel="noopener">Paul Graham</a> 在其著作<a href="https://book.douban.com/subject/6021440/" target="_blank" rel="noopener">《黑客与画家》</a>中极力推荐 Lisp 语言，并且讲到很多 Lisp 的特性逐渐融入到其他语言中。该书中列举了 Lisp 中 9 种新思想，依次为：</p><ol><li>条件结构 if-then-else</li><li>函数也是一种数据类型</li><li>递归</li><li>变量的动态类型，所有变量都是指针</li><li>垃圾回收机制</li><li>程序由表达式组成</li><li>符号类型，符合实际是一种指针，指向存储在哈希表中的字符串</li><li>代码使用符号和常量组成的树形表示法</li><li>无论什么时刻，整个语言都是可用。Lisp 并不真正区分读取期、编译期和运行期</li></ol><p>前 7 种特性可以在如今较流行的编程语言找到，但最后两种是 Lisp 特有的。Lisp 最擅长的领域是写编辑器（元编程）、领域特定语言DSL，现在用的最广的是 Emacs 与 AutoACD，其对应的脚本语言分别是 <a href="https://en.wikipedia.org/wiki/Emacs_Lisp" target="_blank" rel="noopener">Emacs Lisp</a>、<a href="https://en.wikipedia.org/wiki/AutoLISP" target="_blank" rel="noopener">AutoLisp</a>。<br>可以好不夸张的说，软件也复杂，越适合用 Lisp。其次，Clojure 作为新世纪的 Lisp 方言，在 Web 、大数据、数据库等现在常见领域都有丰富的类库与文档。</p><p>目前国内使用 Clojure 成功案例较少，<a href="https://leancloud.cn/jobs/" target="_blank" rel="noopener">LeanCloud</a> 在其招聘网页上写到其成员都是 Clojure 社区成员，但并不了解其内部使用情况。国外的就比较多了，可以参考 Clojure 之父 Rich Hickey 所在公司 Congitect 列举的 <a href="http://cognitect.com/resources#success-stories" target="_blank" rel="noopener">Success Stories</a>。</p><h2 id="语法入门"><a href="#语法入门" class="headerlink" title="语法入门"></a>语法入门</h2><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>Lisp 语法最显著的特点是“括号多”，不过这只是其外在表现，内在表现是阅读代码的方式，需要从最里面的表达式开始，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;; Clojure</span><br><span class="line">&gt; (split (upper-<span class="keyword">case</span> <span class="string">"hello, world"</span>) <span class="comment">#", ")</span></span><br><span class="line">[<span class="string">"HELLO"</span> <span class="string">"WORLD"</span>]</span><br><span class="line"></span><br><span class="line">;; Python</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="string">"hello, world"</span>.upper().split(<span class="string">", "</span>)</span><br><span class="line">[<span class="string">'HELLO'</span>, <span class="string">'WORLD'</span>]</span><br></pre></td></tr></table></figure><p>为了防止过度嵌套，需要经常定义一些辅助函数，很幸运，Clojure 里面函数是一级成员，这意味着函数可以作为参数传入，也可以作为函数值返回，能够进行这两类操作的函数称为“高阶函数”（high-order functions），这在任何一门函数式语言中都很普及。</p><p>除了最基本的圆括号<code>()</code>外，方括号<code>[]</code>与花括号<code>{}</code>在 Clojure 用的也比其他 Lisp 方言中多。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1 2</span> <span class="string">"buckle my shoe"</span>]        ;; 数组</span><br><span class="line">&#123;<span class="symbol">:ace</span> <span class="number">1</span>, <span class="symbol">:deuce</span> <span class="number">2</span>, <span class="string">"trey"</span> <span class="number">3</span>&#125;  ;; 哈希表</span><br><span class="line"><span class="comment">#&#123;:a :b :c&#125;                   ;; 集合</span></span><br></pre></td></tr></table></figure><p>Clojure 中基本的数据结构可以参考其<a href="http://clojure.org/reference/data_structures" target="_blank" rel="noopener">官方网站</a>，我个人觉得，Lisp 方言的英文介绍往往过于精炼、晦涩，不适合初学者直接阅读，为了夯实基础，还是建议大家找本书来看，看书的好处是不仅仅知道某个知识点，更重要的是了解不同知识点之间的区别与联系，初学期间，我阅读了下面两本书：</p><ul><li><a href="https://book.douban.com/subject/4743790/" target="_blank" rel="noopener">The Joy of Clojure</a>，这本书对我帮助比较大，但是网上普遍说这本书比较难懂，我只能说萝卜青菜各有所爱。</li><li><a href="https://book.douban.com/subject/21661495/" target="_blank" rel="noopener">Clojure编程</a>，这本书应该毋庸置疑是新手的必须书</li></ul><p>除了看书外，下面的文档也非常 newbie-friendly，推荐大家多去逛逛：</p><ul><li><a href="http://clojure-doc.org/" target="_blank" rel="noopener">http://clojure-doc.org/</a>，对 Clojure 语言的整个生态有非常详细的介绍</li><li><a href="https://clojuredocs.org/" target="_blank" rel="noopener">https://clojuredocs.org/</a>，可以方便查看具体函数的使用方法</li></ul><h3 id="数据不可变"><a href="#数据不可变" class="headerlink" title="数据不可变"></a>数据不可变</h3><p>括号问题适应后，另一个比较挑战的是数据的不可变性，这融合在 Clojure 语言的设计之中，表象就是没有赋值语句了，但在实现时，为了达到时间、空间上的高效，采用了非常复杂的算法，我到现在也还是一知半解，不是很清楚。《The Joy of Clojure》一书中有简单介绍，不过我觉得初学者可以完全不用去关心实现的细节，在遇到性能问题时在考虑去优化。我这里放一些相关的资料，有兴趣的读者可以自取：</p><ul><li><a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" target="_blank" rel="noopener">Understanding Clojure’s Persistent Vectors</a></li><li><a href="https://www.youtube.com/watch?v=7BFF50BHPPo" target="_blank" rel="noopener">What Lies Beneath - A Deep Dive Into Clojure’s Data Structures</a> YouTube 视频，需翻墙</li></ul><h3 id="托管型语言"><a href="#托管型语言" class="headerlink" title="托管型语言"></a>托管型语言</h3><blockquote><p><a href="http://clojure.org/about/jvm_hosted" target="_blank" rel="noopener">Clojure is desgined to be a hosted language</a>.</p></blockquote><p>这一点非常重要，估计也是为什么 Clojure 较其他 Lisp 方言更流行的原因。Clojure 的宿主平台现在主要有两个：一个是 JVM；另一个是微软 .NET （<a href="https://github.com/clojure/clojure-clr" target="_blank" rel="noopener">Clojure-CLR</a>），现在还有一个发展迅猛的 ClojureScript，可以将 Clojure 代码编译为无处不在的 Javascript。</p><p>这也就意味我们或多或少需要了解这些宿主语言，比如 Clojure 里面没有提供直接操作文件系统、网络的类库，而是采用间接的方法去调用其宿主语言的相应类库。这一点也让 Clojure 在生产环境中使用变得可能，比如 <a href="https://github.com/dakrone/clj-http" target="_blank" rel="noopener">clj-http</a> 就是对 <a href="http://hc.apache.org/httpcomponents-client-ga/" target="_blank" rel="noopener">Apache HttpComponents</a> 的包装，更符合 Clojure 使用习惯而已。</p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>工欲善其事，必先利其器。<br>这里主要介绍 Intellj + Cursive 与 Emacs + Cider 两个环境，这两个是我用的最顺手，也是现在较为流行的方式。</p><h3 id="Intellj-Cursive"><a href="#Intellj-Cursive" class="headerlink" title="Intellj + Cursive"></a>Intellj + Cursive</h3><p>在上面语法入门部分就介绍了，Clojure 与宿主语言经常需要交互，毋庸置疑 <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">Intellj</a> 是 Java 开发的利器，社区版足以满足需要，不用再去做找破解版那些不道德的事情，如果你还在用 Eclipse，可以考虑迁移了。<br><a href="https://cursive-ide.com/" target="_blank" rel="noopener">Cursive</a> 做到了开箱即用，而且足够的好用，而且也有<a href="https://cursive-ide.com/buy.html" target="_blank" rel="noopener">非商业免费版</a>，这极大方便了学生党，适应了中国国情。</p><p>安装、使用比较简单，通过 Intellj 插件管理器安装后，设置下<a href="https://cursive-ide.com/userguide/keybindings.html" target="_blank" rel="noopener">快捷键类型</a>就可以使用了。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2McCFcbxmpuFjSZJiXXXauVXa_!!581166664.png" alt="Cursive 快捷键设置"></p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2th5wcohnpuFjSZFpXXcpuXXa_!!581166664.png" alt="Cursive REPL"></p><h3 id="Emacs-Cider"><a href="#Emacs-Cider" class="headerlink" title="Emacs + Cider"></a>Emacs + Cider</h3><p>作为一门 Lisp 方言，怎么能没有一个好的 Emacs mode 呢？<a href="https://github.com/clojure-emacs/cider" target="_blank" rel="noopener">Cider</a> 全称</p><blockquote><p>The Clojure Interactive Development Environment that Rocks for Emacs</p></blockquote><p>而且 Emacs 本身就是个用 Lisp 方言写的“操作系统”，对以括号著称的 Lisp 语言有天然的支持，括号匹配主要是 Paredit mode，可以方便的把括号作为一个整体操作，不过像 Cursive 这种插件也集成了 Paredit 的主要功能，所以不用 Emacs 的同学也不用担心，毕竟 Emacs 学习成本实在是太高，我个人觉得比 Vim 有过之而无不及，相对于 Vim 的模态概念，Emacs 里面通过 Ctrl 与 Meta 键来与一般按键区别，这里我们不必对某个编辑器有过多的偏见，它们都是生产力的工具而已，写好代码才是重要的。</p><p>初学者如果要尝试 Emacs 建议参考《Clojure For the Brave and True》的第二章<a href="http://www.braveclojure.com/basic-emacs/" target="_blank" rel="noopener">How to Use Emacs, an Excellent Clojure Editor</a>，我最初的环境也是仿照这份配置，然后一点点根据自己的需求增加的。<a href="https://github.com/jiacai2050/conf/tree/master/.emacs.d" target="_blank" rel="noopener"> .emacs.d</a> 是我的配置，供大家参考。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB26VWrchtmpuFjSZFqXXbHFpXa_!!581166664.png" alt="Emacs + Cider 编程环境"></p><p>Emacs + Cider 的组合相比 Intellj ＋ Cursive 最大的优势就是对宏的支持，Cider 提供了对宏展开的快捷键，但在 Cursive 中我没找到，不过宏也是比较高级的功能，初学者应该用不到，等到用的多的时候，就可以把 Emacs 环境熟悉起来了。</p><p>最后还是建议初学者不要用 Emacs，学习成本太大，而且很容易就把注意力转移到编辑器的学习上，等到学习了一段时间后在尝试不迟。</p><h2 id="第三方类库的选择"><a href="#第三方类库的选择" class="headerlink" title="第三方类库的选择"></a>第三方类库的选择</h2><p>由于 Clojure 语言定位就是个寄宿语言，所以无论是 Web 框架，还是数据库连接池，Clojure 里都有与 Java 版相对应包装类库，大家不必担心要使用某个功能，而没有相应库的问题，但是这里我必须说明一点，Clojure 类库的文档对初学者不够友好，最起码对我来说是的，我相信我不可能是个例。就拿打印日志来说，Github 上搜一下，应该能够找到最 idiomatic 应该是 <a href="https://github.com/ptaoussanis/timbre" target="_blank" rel="noopener">timbre</a>，通读其 README 后，怎么配置还不是很清楚，继续 Google，找到</p><ul><li><a href="https://github.com/palletops/log-config" target="_blank" rel="noopener">log-config</a></li><li><a href="http://www.filmspringopen.eu/blog-entry-blogentryid-447808.html" target="_blank" rel="noopener">Custom logging with timbre</a></li></ul><p>这时我才能够知道怎么去定制他的<code>appenders</code>等各种参数，也可能是我个人的理解能力比较差，不过这里介绍一个非常实用并且适用于所有语言的方法，那就是看这个项目的test，test 里面核心的功能肯定会涉及到，然后照猫画虎就可以了。</p><p>其实，在使用第三方类库之余，多去了解其实现，代码从 Github 上 Clone 下来，慢慢看，Clojure 里面提供了很多实用的小方法，像<code>partition</code>, <code>juxt</code>, <code>group-by</code>等等不一而足，最好带着 issue 里面的问题去看代码，说不定你就从使用者变成了开发者呢，我第一个尝试给了 <a href="https://github.com/dakrone/clj-http/pull/341" target="_blank" rel="noopener">http-clj</a>。</p><h2 id="调试-debug"><a href="#调试-debug" class="headerlink" title="调试 debug"></a>调试 debug</h2><p>代码一次写对的几率基本为0，掌握一定的测试技能是每个同学的基本功，下面简单介绍下 Clojure里面常用的调试方法。</p><h3 id="println"><a href="#println" class="headerlink" title="println"></a>println</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [headers         (<span class="symbol">:headers</span> ring-request)</span><br><span class="line">      header-names    (<span class="name"><span class="builtin-name">keys</span></span> headers)</span><br><span class="line">      <span class="comment">;; The following underscore is a convention for "unused variable"</span></span><br><span class="line">      _               (<span class="name">println</span> <span class="string">"Headers:"</span> header-names)  <span class="comment">;; &lt;-- this</span></span><br><span class="line">      header-keywords (<span class="name"><span class="builtin-name">map</span></span> keyword header-names)]</span><br><span class="line"><span class="comment">;; etc</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最简单实用的 <code>println</code>，但问题是我们需要把要监控的变量打两次，这在变量比较多的时候比较麻烦，可以采用下面的 spyscope</p><h3 id="spyscope"><a href="#spyscope" class="headerlink" title="spyscope"></a>spyscope</h3><p><a href="https://github.com/dgrnbrg/spyscope" target="_blank" rel="noopener">Spyscope</a> 库可以解决上<code>println</code>的问题，他提供三个<code>reader tags</code>来监控变量，用法极为简单：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [headers         (<span class="symbol">:headers</span> ring-request)</span><br><span class="line">      header-names    #spy/p (<span class="name"><span class="builtin-name">keys</span></span> headers)       <span class="comment">;; &lt;-- print out what header-names is</span></span><br><span class="line">      header-keywords (<span class="name"><span class="builtin-name">map</span></span> keyword header-names)]</span><br><span class="line"><span class="comment">;; etc</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="debux"><a href="#debux" class="headerlink" title="debux"></a><a href="https://github.com/philoskim/debux" target="_blank" rel="noopener">debux</a></h3><p>一个非常好用的测试库，可以把嵌套函数调用的每一步打印出来。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">dbg</span> (<span class="name"><span class="builtin-name">-&gt;</span></span> <span class="string">"a b c d"</span></span><br><span class="line">         .toUpperCase</span><br><span class="line">         (<span class="name">.replace</span> <span class="string">"A"</span> <span class="string">"X"</span>)</span><br><span class="line">         (<span class="name">.split</span> <span class="string">" "</span>)</span><br><span class="line">         first))</span><br><span class="line"><span class="comment">;=&gt; "X"</span></span><br></pre></td></tr></table></figure><p>REPL 中会打印：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dbg: (-&gt; <span class="string">"a b c d"</span> .toUpperCase (.<span class="built_in">replace</span> <span class="string">"A"</span> <span class="string">"X"</span>) (.<span class="built_in">split</span> <span class="string">" "</span>) <span class="built_in">first</span>)</span><br><span class="line">  <span class="string">"a b c d"</span> =&gt;</span><br><span class="line">    <span class="string">"a b c d"</span></span><br><span class="line">  .toUpperCase =&gt;</span><br><span class="line">    <span class="string">"A B C D"</span></span><br><span class="line">  (.<span class="built_in">replace</span> <span class="string">"A"</span> <span class="string">"X"</span>) =&gt;</span><br><span class="line">    <span class="string">"X B C D"</span></span><br><span class="line">  (.<span class="built_in">split</span> <span class="string">" "</span>) =&gt;</span><br><span class="line">    [<span class="string">"X"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]</span><br><span class="line">  <span class="built_in">first</span> =&gt;</span><br><span class="line">    <span class="string">"X"</span></span><br><span class="line">=&gt;</span><br><span class="line">  <span class="string">"X"</span></span><br></pre></td></tr></table></figure></p><h3 id="tools-trace"><a href="#tools-trace" class="headerlink" title="tools.trace"></a>tools.trace</h3><p>上面介绍的方法都需要修改源代码，有没有不用修改的呢？答案是肯定的，<a href="https://github.com/clojure/tools.trace" target="_blank" rel="noopener">clojure.tools.trace</a>，Github 上的 README 比较详细，大家可以可以去了解，我目前在自己的项目里面还没有采用过这个方法。</p><h3 id="Intellj-Debug"><a href="#Intellj-Debug" class="headerlink" title="Intellj Debug"></a>Intellj Debug</h3><p>借助于 IDE 的优势，我们可以打断点，一步一步调试，但是 Cursive 对宏的支持比较有限，目前出来把宏展开外，没找到好的调试宏的好方法。<br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2HEWIcb4npuFjSZFmXXXl4FXa_!!581166664.png_620x10000.jpg" alt="Intellj debug"></p><h3 id="nrepl"><a href="#nrepl" class="headerlink" title="nrepl"></a>nrepl</h3><p>Clojure 的 REPL 可以连接到远程服务器上的进程中，直接对进程中的函数或变量进行修改，这是非常便利的，对于很多运行时的错误可以采用这种方式解决，Emacs 与 Intellj 里面都提供了连接远程 REPL server 的方式。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2KcGIcbBmpuFjSZFuXXaG_XXa_!!581166664.png" alt="Intellj 连接远程 REPL"></p><p>Emacs 里面是：<code>M-x cider-connect</code><br>lein 里面是：<code>lein repl :connect 192.168.50.101:4343</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Clojure 在国内算是非常非常小众，介绍 Clojure 开发的文章也比较少，仅有的也只是一些简单的语法介绍或者概念阐述。<br>我从<a href="https://github.com/jiacai2050/sicp" target="_blank" rel="noopener">读完 SICP</a> 后就一直想把 Lisp 作为我的主力语言，正好趁着这次机会，希望能够弥补国内 Clojure 文档较匮乏的情况，之后我会陆陆续续把自己使用 Clojure 开发的经历分享出来，供后来的 Clojurians 参考，这也算是 17 年的第一个小目标吧。</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2OEGwcmVmpuFjSZFFXXcZApXa_!!581166664.png" alt="关于 Clojure 的 RSS 收集 "></p><p>上面是我目前收集关于 Clojure 的 RSS，大家可以根据标题去搜索，热爱 Clojure ，从不做伸手党开始。😊</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.cis.upenn.edu/~matuszek/Concise%20Guides/Concise%20Clojure.html#basic_types" target="_blank" rel="noopener">A Concise Guide to Clojure</a></li><li><a href="http://owenrh.me.uk/blog/2015/08/24/" target="_blank" rel="noopener">The Beauty of Clojure</a></li><li><a href="https://www.infoq.com/articles/in-depth-look-clojure-collections" target="_blank" rel="noopener">An In-Depth Look at Clojure Collections</a></li><li><a href="https://www.youtube.com/channel/UCaLlzGqiPE2QRj6sSOawJRg" target="_blank" rel="noopener">Clojure TV on YouTube</a> 里面有很多大牛分享 Clojure 实战，还能锻炼英文</li><li><a href="http://blog.fnil.net/blog/categories/clojure/" target="_blank" rel="noopener">LeanCloud 工程师庄晓丹个人博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Clojure —— 新世纪的 Lisp 方言，相信大多数同学多多少少都听过，毕竟有个杀手级应用 &lt;a href=&quot;http://storm.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Storm&lt;/a&gt;，但是真正去写 Cloju
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Clojure" scheme="http://liujiacai.net/tags/Clojure/"/>
    
  </entry>
  
  <entry>
    <title>韩国济州岛4日游</title>
    <link href="http://liujiacai.net/blog/2016/12/07/hello-jeju/"/>
    <id>http://liujiacai.net/blog/2016/12/07/hello-jeju/</id>
    <published>2016-12-07T13:51:40.000Z</published>
    <updated>2019-12-24T10:59:14.607Z</updated>
    
    <content type="html"><![CDATA[<p>公司年底 outing，济州岛 4 日游（12/2-12/5）。济州岛对国人不需要签证，从杭州坐飞机去不到2个小时，绝对是旅游胜地。济州岛在韩国算乡下，但其依靠旅游业，硬生生的把 GDP 带上去了，听导游说一洗碗工月工资都能达到一万二，加个班一万八没问题。没去过的同学有机会一定要去体验一次，这里不仅仅有欧巴、化妆品，自然风景更是让人流连忘返，PM 2.5 基本都在 20 以内，你还等什么呢。</p><p>本篇文章首先依次介绍我这次行程中去过的景点，晒一晒照片；然后根据我自身经历，总结一份攻略，共今后去的同学参考。</p><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>我们是9点的飞机，到济州岛是11：40，济州岛时区是东九区，所以比北京时间快一个小时。飞机到济州岛后没有立刻着陆，而是围着岛转了一圈，估计是航空管制的缘故，我正好也趁这个机会窥视她的全貌：</p><blockquote><p>济州岛是由火山喷发而形成，是典型的火山岛。最高的山是汉拿山，海拔1950米，也是韩国最高峰。</p></blockquote><p>在机场上看到一个大大的凹坑，没错那就是之前的火山口。语文学的不好，除了美不知道怎么形容这里的风景了。大家自己看图吧。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2NV3hXJBopuFjSZPcXXc9EpXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2RCskXH4npuFjSZFmXXXl4FXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2UUAjXSFmpuFjSZFrXXayOXXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2h9GDXHFkpuFjy1XcXXclapXa_!!581166664.png_620x10000.jpg" alt></p><p>下了飞机后，坐上大巴车，去吃午饭，没错，是泡菜。长相和自家的酸白菜差不多，貌似口感好一点点（可能是我们预算偏少，才4000韩元，所以大家普遍都喊没吃饱😳）。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2M69AXR0lpuFjSszdXXcdxFXa_!!581166664.jpg_620x10000.jpg" alt="韩国泡菜"></p><h3 id="小人国主题公园"><a href="#小人国主题公园" class="headerlink" title="小人国主题公园"></a>小人国主题公园</h3><p>吃完就开始我们第一个景点——小人国主题公园，其实就是把全世界的有名景点缩小集合到一起，后来和同事聊，应该和深圳的世界之窗差不多。</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2JL.jXOlnpuFjSZFgXXbi7FXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2UAZjXNhmpuFjSZFyXXcLdFXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2NrghXJBopuFjSZPcXXc9EpXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2eaoiXNtmpuFjSZFqXXbHFpXa_!!581166664.jpg" alt></p><h3 id="泰迪熊博物馆"><a href="#泰迪熊博物馆" class="headerlink" title="泰迪熊博物馆"></a>泰迪熊博物馆</h3><p>第二个景点是泰迪熊博物馆，小孩子应该挺喜欢的，可惜我已经没童心了，觉得一般般。</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2QAOCXG8lpuFjy0FpXXaGrpXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2KgBxX9VmpuFjSZFFXXcZApXa_!!581166664.jpg_620x10000.jpg" alt="奥巴马"></p><h3 id="乱打秀"><a href="#乱打秀" class="headerlink" title="乱打秀"></a>乱打秀</h3><p>这个真是不错，一个多小时的时间，那五个人凭借自己的肢体动作，让大家都看的很尽兴，貌似这个表演还上过<a href="http://www.mgtv.com/b/18/2951177.html" target="_blank" rel="noopener">天天向上</a>，强烈推荐大家去看，现场不让拍照，我偷拍了几张，供大家欣赏。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2GoQkXHxmpuFjSZJiXXXauVXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2eeKCXHRkpuFjSspmXXc.9XXa_!!581166664.jpg_620x10000.jpg" alt></p><h3 id="炸鸡与啤酒"><a href="#炸鸡与啤酒" class="headerlink" title="炸鸡与啤酒"></a>炸鸡与啤酒</h3><p>看完乱打秀，就直接回酒店了，我们入住的是离海不远的太平洋酒店，总体还是不错的。由于当天大家普遍没吃饱，所以当天晚上大家就出来觅食，一大群中国人拿着地图导航，找了半天最后找了一家炸鸡店，开吃！</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2Dh.kXOBnpuFjSZFzXXaSrpXa_!!581166664.jpg_620x10000.jpg" alt></p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="早安"><a href="#早安" class="headerlink" title="早安"></a>早安</h3><p>酒店离海边比较近，大清早打开窗帘就可以看到晨曦映在海面上，惬意的很。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB27yokXHxmpuFjSZJiXXXauVXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB24FskXS0mpuFjSZPiXXbssVXa_!!581166664.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2VUcjXOBnpuFjSZFzXXaSrpXa_!!581166664.png_620x10000.jpg" alt></p><h3 id="涉地可支"><a href="#涉地可支" class="headerlink" title="涉地可支"></a>涉地可支</h3><p>酒店吃完早餐，我们就出发去今天的第一站了——涉地可支。</p><blockquote><p>“涉地”是这一地区古代时的名称，“可支”是济州岛方言，意思是向外突出的地形。涉地可支所在的海岸悬崖上是一片宽阔的草地，这里一棵树也看不到，海岸上耸立着一块叫仙石的岩石。</p></blockquote><p>这里确实风景旖旎，但是导游不知道怎么想的，就给了我们半个小时，灯塔都没走的就要离开了，可惜，下次再来这里一定好好欣赏。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2c.5DXMxlpuFjy0FoXXa.lXXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2dpwjXHJmpuFjSZFwXXaE4VXa_!!581166664.jpg" alt></p><h3 id="城山日出峰"><a href="#城山日出峰" class="headerlink" title="城山日出峰"></a>城山日出峰</h3><p>行程中第一座山，虽然海拔只有182米，但在山顶依然可以俯瞰大地，在这里可以遇到海女潜水表演，可惜我们时间有限，所以也擦肩而过。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2AaolXNlmpuFjSZPfXXc9iXXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2ZkKBXS0jpuFjy0FlXXc0bpXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2lfoiXItnpuFjSZFvXXbcTpXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2NV8xX0FopuFjSZFHXXbSlXXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2N31BXHplpuFjSspiXXcdfFXa_!!581166664.jpg" alt></p><h4 id="海女来历"><a href="#海女来历" class="headerlink" title="海女来历"></a>海女来历</h4><blockquote><p>济州岛是一个远离陆地的孤岛，很久以前，下海捕捞是当地生活的主要来源。历史上，济州岛的海女可追溯到6世纪。当时岛上的习俗是男主内，女主外，于是潜水就成了女人们代代相传的一项重要的生存本领，“海女”这个称呼也由此而生。</p></blockquote><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2qGUjXNhmpuFjSZFyXXcLdFXa_!!581166664.jpg_620x10000.jpg" alt></p><h3 id="山君不离"><a href="#山君不离" class="headerlink" title="山君不离"></a>山君不离</h3><p>好浪漫的名字，虽然只是个火山口，但我觉得大多人提到这个名字应该是情侣相拥殉情的画面，类似中国的梁山伯与祝英台的故事。济州岛上分布着360多处火山，山君不离是其中最特别的一处。因为其余火山在爆发后都被岩浆覆盖，唯独山君不离在喷发时，没有被覆盖，形成了现在的洞口，称为“地平火山口”。</p><p>这里让人印象最深的怕是那一望无际的金色芦苇，情侣们一定不要放过这个地方。我们在这里拍了唯一的合影，不容易，冥冥之中正好映衬了山君不离😊。</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2BMWBXMRkpuFjy1zeXXc.6FXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB27jezXRNkpuFjy0FaXXbRCVXa_!!581166664.jpg_620x10000.jpg" alt="选景没选好，有些逆光"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2R8JvX9VmpuFjSZFFXXcZApXa_!!581166664.jpg" alt="自己拍的实在不行，从网上找一个"></p><h3 id="免税店"><a href="#免税店" class="headerlink" title="免税店"></a>免税店</h3><p>来济州岛不买几片面膜真不好意思说来过，我们依次去了乐天与新罗。整个免税店都是买买买的中国人，好恐怖的，相信同行的大多数女生们都非常期待这个地方，我实在是不感冒，给即将结婚的同学买了两件化妆品后，和两个小伙伴去周边找了个店喝茶去了。</p><h3 id="ICE冰雕馆-3D视觉摄影区"><a href="#ICE冰雕馆-3D视觉摄影区" class="headerlink" title="ICE冰雕馆+3D视觉摄影区"></a>ICE冰雕馆+3D视觉摄影区</h3><p>冰雕馆在一楼，是真的很冷，我受不了很快的就出来了，看到同行的小伙伴玩的还挺开心的。顾名思义，3D视觉摄影区就是让大家拍照的地方，还是挺有意思的。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2k34xX5lnpuFjSZFgXXbi7FXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2Vs2CXM0kpuFjSspdXXX4YXXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2RF8yX00opuFjSZFxXXaDNVXa_!!581166664.jpg_620x10000.jpg" alt></p><h3 id="汗蒸幕"><a href="#汗蒸幕" class="headerlink" title="汗蒸幕"></a>汗蒸幕</h3><p>今天最后一个项目——汗蒸幕。其实和洗温泉差不多，洗完蒸。最高的好像70多度，没敢去。这里本地人不少，大多都慵懒的躺着，喝着饮料，看着韩剧，扯着家常。美中不足的是这里停留时间太多，没蒸够就又走了。这里就没照片了。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="晨跑"><a href="#晨跑" class="headerlink" title="晨跑"></a>晨跑</h3><p>由于昨天早上看到那么美的晨曦，就决定今天要早起晨跑，可惜的是除了第一天是晴天，在济州岛的其他天都是阴天，没能看到日出。但清晨的风景，没因阴天而丝毫减半，而是另一种神韵。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2gjIjXSFmpuFjSZFrXXayOXXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2R5kiXUhnpuFjSZFPXXb_4XXa_!!581166664.jpg_620x10000.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2hCJzX5pnpuFjSZFkXXc4ZpXa_!!581166664.jpg_620x10000.jpg" alt></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2AV_GXSBjpuFjSsplXXa5MVXa_!!581166664.jpg" alt><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB24XaBXHtlpuFjSspfXXXLUpXa_!!581166664.png_620x10000.jpg" alt></p><h3 id="汉拿山"><a href="#汉拿山" class="headerlink" title="汉拿山"></a>汉拿山</h3><p>今天是自由行，终于到我最期待的项目了——横穿汉拿山。前一天晚上就查好了路线，怕找不到地方，我还专门找酒店一楼的服务员大哥用韩语写了御里牧登登山口，虽然他汉语一般般，但勉强知道我的意思，非常感谢他。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2rVSCXMJlpuFjSspjXXcT.pXa_!!581166664.jpg_620x10000.jpg" alt></p><p>爬山的小伙伴有四个，我们打车去的御里牧登登山口，原计划沿着观音寺路线下山，没想到最后迷路从最不推荐的顿乃克路线下去了，都是泪。</p><p>之前就听说爬汉拿山的中国人没几个，我们一路上也没遇到个同胞，基本都是济州岛本地人。由于汉拿山是火山喷发而形成，道路十分不好走，一大半路都是火山石铺出来了，我们也没准备登山棍，真是苦了膝盖。爬的过程中不时有乌鸦“哇哇”叫两声，回来才知道乌鸦在韩国是吉祥的鸟，汉拿山的乌鸦更是以嘴大著称，早知道就给它拍几张照片了。</p><p>我们这条登山路线有两处泉水，同行的女生一开始爬山就是吃不消，喝了这个泉水后，生龙活虎起来，我们戏称这真是神仙水。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2L3AlXS8mpuFjSZFMXXaxpVXa_!!581166664.jpg_620x10000.jpg" alt="神仙水"></p><p>爬山途中还有一景点也挺让人难忘的——鸟接岳。这里比较荒凉，四处都是枯枝败叶，看了景点牌才知道这里是由于登山者随意丢弃烟头而造成火灾，千年树木葬身火海，只剩下如今萧条景象。真的很让人伤心。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2TuBBX00opuFjSZFxXXaDNVXa_!!581166664.jpg_620x10000.jpg" alt="鸟接岳1"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2EZEmXJXnpuFjSZFoXXXLcpXa_!!581166664.jpg_620x10000.jpg" alt="鸟接岳2"></p><p>由于偏离了之前的下山路线，我们之后做公交回去，在语言不通的情况下，我们四个人又是英文，又是翻译软件，拿酒店名片给司机看，不容易的在顿乃克路线旁坐上了3路公交，之后换乘781，坐了30多站，终于回到免税店附近，最后一顿黑猪肉犒劳自己。现在回想，还历历在目，这种在异国他乡的经历非常刺激，不亲身经历是不能理解的。</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2VagmXHxmpuFjSZJiXXXauVXa_!!581166664.jpg_620x10000.jpg" alt="1300"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2prUmXJXnpuFjSZFoXXXLcpXa_!!581166664.jpg_620x10000.jpg" alt="1400"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2MZGCXR0kpuFjSsziXXa.oVXa_!!581166664.jpg_620x10000.jpg" alt="1500"><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2A3qBXHFlpuFjy0FgXXbRBVXa_!!581166664.jpg_620x10000.jpg" alt="1700"><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2d2OCXHJkpuFjy1zcXXa5FFXa_!!581166664.jpg_620x10000.jpg" alt="休息室"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2MiUmXHBmpuFjSZFuXXaG_XXa_!!581166664.jpg_620x10000.jpg" alt="就生标志"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2q5gkXNBmpuFjSZFsXXcXpFXa_!!581166664.jpg_620x10000.jpg" alt="台阶"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2q..kXS0mpuFjSZPiXXbssVXa_!!581166664.jpg_620x10000.jpg" alt="火山岩台阶"><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2rogkXS0mpuFjSZPiXXbssVXa_!!581166664.jpg_620x10000.jpg" alt="云海缭绕"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2pTsjXOlnpuFjSZFgXXbi7FXa_!!581166664.jpg_620x10000.jpg" alt="开始下山了"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB28uyAXSXlpuFjy0FeXXcJbFXa_!!581166664.jpg_620x10000.jpg" alt="顿乃克山脚下"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2.u9AXM0kpuFjSspdXXX4YXXa_!!581166664.jpg_620x10000.jpg" alt="坐在回程的公交车上"><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2ZguCXR8lpuFjSspaXXXJKpXa_!!581166664.jpg_620x10000.jpg" alt="烤黑猪肉"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2oGCCXHVkpuFjSspcXXbSMVXa_!!581166664.png_620x10000.jpg" alt="横穿汉拿山"></p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>最后一天，我们是9：30在酒店集合，然后去机场，每个人都大包小包，相信都是“满载”而归。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2d5NBX0RopuFjSZFtXXcanpXa_!!581166664.jpg_620x10000.jpg" alt="排队安检"></p><p>感谢公司提供这个 outing 的机会，感谢行政的同事忙前忙后给我们制定行程、订机票酒店，我好几次看到 katty 很晚还在公司给我们填写各种出行的表格，非常感谢。</p><p>Bye jeju, I will be back.</p><h2 id="总结攻略"><a href="#总结攻略" class="headerlink" title="总结攻略"></a>总结攻略</h2><ol><li>提前换好韩元，由于韩元是小币种，最好去中国银行，可以适当多换些，花不了在济州岛机场有免费兑换人民币的点。</li><li>不要相信导游让你掏钱的任何话。这也没办法，导游不满足基本工资，一路上给我们推销各种吃的，玩的，还好我们比较明智，一个都没去，最后导游都有些生气了，哈哈。大家不要担心自己找不到地方，回酒店慢慢 Google（是的，可以随便上这些被墙网站了），各种点评软件都可以参考。</li><li>大众点评上的好评店不一定真的好，很有可能是刷上去，后来听一些同事说，直接去逛市场，看到那个店韩国人就去试试，效果一般都不错。</li><li>带好各种地图。去汉拿山明显准备不足，明明可以找好路线，最后还是费了些周折，回到酒店才发现有公交车图。一般飞机场、酒店都有免费的地铁，大家可以多去找找，不要老是拍照而遗漏了这些重要物质。还有一点是提前在百度地图或谷歌地图里下载好离线地图，想我们在汉拿山上信号不会，定位非常慢。</li><li>不用把所有景点都着急逛完，留着下次再来也更好嘛，去一个点就细细体会，感受这不同的风景。这次我就故意留了牛岛没去。</li><li>写游记。每个人到一个景点都是拍拍拍，然后发发朋友圈，朋友圈一缺点是承载的信息有限，而且时效性非常强，以后让人看到的几率比较低。为了更好的纪录，必须写游记。✌️</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>洋洋洒洒写了不少，照片也晒了不少，其实这次收获最多不是欣赏到多么美的风景，而是认识了更多的同事，一些平时很少有交集的同事也可以聊上两句，这在套路如此深的社会实属不易，最脑洞大开的是一同事给我讲述其恋爱史与笔友史，真是让我脑洞大开，希望他能根据自身经历，写个小说出来，说不定就成网红了呢。期待…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司年底 outing，济州岛 4 日游（12/2-12/5）。济州岛对国人不需要签证，从杭州坐飞机去不到2个小时，绝对是旅游胜地。济州岛在韩国算乡下，但其依靠旅游业，硬生生的把 GDP 带上去了，听导游说一洗碗工月工资都能达到一万二，加个班一万八没问题。没去过的同学有机会
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>我为什么一周内连跑 2 个马拉松</title>
    <link href="http://liujiacai.net/blog/2016/11/07/run-2-marathon-in-a-week/"/>
    <id>http://liujiacai.net/blog/2016/11/07/run-2-marathon-in-a-week/</id>
    <published>2016-11-07T14:47:55.000Z</published>
    <updated>2019-12-24T10:59:14.607Z</updated>
    
    <content type="html"><![CDATA[<p>我微信里的朋友应该都知道，上周（2016/11/06）与大上周（2016/10/30）我分别跑了杭州与上海的马拉松，第一场上海站完成了人生首个半马，第二场杭州站完成了人生首个全马（42.195KM），现趁着腿还有一些酸痛，回顾下当初为什么要参加马拉松，以及在跑全马最后十公里时那种全身酸痛到最后看到终点线并穿过时的心情，最后分享些注意事项给初次跑马拉松的同学。</p><p>这两次马拉松的成绩并不好，半马用了两个半小时，全马用了六个小时，基本上都关门了。运动健将们不要嘲笑我，大家开心就好。</p><h2 id="事出有因"><a href="#事出有因" class="headerlink" title="事出有因"></a>事出有因</h2><p>一句话概括：减肥。毫不客气的说我是胖二十多年了，之前尝试过无数次减肥，每一次都偃旗息鼓。今年年初，受了一次打击，无论如何要减了。说干就干，知道自己的惰性，所以直接去健身房请了私教，效果还不错，截止到10月份大概用了6个月的样子，减了35斤左右。也是在这次减肥过程中逐渐喜欢上了跑步，一开始在跑步机上跑，会觉得有些无聊，尝试找些音乐来听，后来觉得也不是很方便就干脆不听了，回忆回忆白天上班时候的事情，时间倒是也过的充实多了。</p><p>杭州自然环境比较好（北京的同学可以来亲身体验），我住的地方距离余杭塘河比较近，所以在那里晨跑过一段时间，从刚开始的 3KM，5KM，到最后的 10KM，那段时间也养成了早睡早起的习惯，精神状态也好多了。周末一个人没事也去跑上两圈，今年的夏天就在这样大汗淋漓的跑道上度过了大半部分。</p><p>跑马拉松的想法也就是在这时候产生的，记得期间听过狗熊有话说 podcast 的一期<a href="http://m.qingting.fm/vchannels/38116/programs/1723095" target="_blank" rel="noopener">《124期：现场·当我在跑马拉松时我会聊什么》</a>，没跑过的可以去听听。不要再犹豫、怀疑自己到底行不行，去试试就知道了，不行就下来，这样也没啥遗憾。</p><h2 id="上海半马"><a href="#上海半马" class="headerlink" title="上海半马"></a>上海半马</h2><p>上马（上海马拉松）开跑时间是早上7点，所以我提前一天坐动车到了上海，住在之前一个同事那里，第二天早上我们6点起床，每人吃了两个肉包子，然后就坐地铁向南京东路杀过去了。</p><p>整个半马过程也没啥特别的，我们跟随大部队，记得大概到了18KM左右，我才觉得有些累，不过还好，终点就在眼前了。由于这次上马没啥压力，我也就坚定了要挑战杭州全马的决心。下面贴几张当时的照片，以作纪念：</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2dgjVbW9I.eBjy0FeXXXqwFXa_!!581166664.jpg_620x10000.jpg" alt="终点就在眼前"><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2.eTQcA1M.eBjSZPiXXawfpXa_!!581166664.jpg_620x10000.jpg" alt="越过终点线"><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB29DRIcNaK.eBjSZFAXXczFXXa_!!581166664.jpg_620x10000.jpg" alt="奖牌"></p><h2 id="杭州全马"><a href="#杭州全马" class="headerlink" title="杭州全马"></a>杭州全马</h2><p>上次跑没有装备，早上跑（杭马是8点）的比较早一开始还比较冷，所以这次我提前买好了跑步运动鞋与衣服，事后来看效果还是比较满意的。</p><p>可能是上周跑完上马还没恢复好，在跑前18KM时明显觉得比上马累，而且杭马当天太阳当头，晒的人有力使不出。在快到半马终点时，膝盖也有些痛，这时心里第一次犹豫要不要放弃，想想牛逼都吹出去了，再跑个半马和上次一样，有啥意义呢，于是在半马全马分界线路口，选了全马。</p><p>跑的时候就听其他跑友说我们算是全马靠后的位置了，我在跑过22KM标志后想再加个速，没想到这时第一次腿开始抽筋，一阵一阵的，痛的走都不敢走了，看着一个个跑友从我身边经过，真是又慌又急，做了大概五分钟的拉伸，吃了个能量棒，渐渐可以走了，正好这时也到了杭州最美跑道，我就走了大概二十多分钟，欣赏欣赏风景。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2QZtLcmiJ.eBjSspiXXbqAFXa_!!581166664.jpg_620x10000.jpg" alt="杭马最美跑道"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2GvRAcheI.eBjSsplXXX6GFXa_!!581166664.jpg_620x10000.jpg" alt="来个自拍"></p><p>距开跑四个小时，12点左右，我来到了30KM标志处，距离终点还有12多公里，算下来基本上是每小时6KM的样子，想想应该没啥压力，就继续开跑了。这时正是太阳最毒的时候，加上每个服务点的喷雾（防腿抽筋）都用光了，脚底板有些酸痛，真的可以说是“体无完肤”，没跑多久就又开始走了，腿一用力就可能抽筋，这时心里第二次打了退堂鼓，安慰自己：30多公里差不多了。而且这时不定时会有救援车在你旁边经过，十分具有诱惑性。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2A_0DccaJ.eBjy0FbXXcwrFXa_!!581166664.jpg_620x10000.jpg" alt="看不到终点时犹豫的眼神"></p><p>大概又走了二十分钟，来到了钱塘江大桥，桥上风比较大，对于此时的我来说，真是雨后甘霖，一下吹走了身上的疲倦。但是脚还是一样酸痛，于是走着过了桥。再次开启欣赏风景模式。身边的跑友也基本上都是走的过了桥。<br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB29QXPcmCI.eBjy1XbXXbUBFXa_!!581166664.jpg_620x10000.jpg" alt="桥上明显比较开心"></p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB22xNBcg1J.eBjy0FaXXaXeVXa_!!581166664.jpg_620x10000.jpg" alt="这应该是雾霾"></p><p>下了钱塘江大桥后，觉得可能没戏了，看了看时间，发现才过了半个时间，向前走几步就到了32.5KM 的标志牌。算算我也没差太多，应该能在关门前赶到终点，于是又开始跑起来了。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2TKF1cRaM.eBjSZFMXXcypVXa_!!581166664.jpg_620x10000.jpg" alt></p><p>跑的时候和 600 关门兔遇到了好几次，跑累了走时他又把我超了，最后也是没能跟上他们，这时候道路基本上都解封了，机动车也多了起来，路上的行人时不时给我们最后这一批加油。我这时全身酸痛到了极点了，看着两旁的路人，有说有笑，心里却是在滴血，真想推辆旁边的公共自行车骑上那么一段，心里是纠结了好久，幸好又到了一个补给点，喝了点饮料，吃了几小块香蕉，体力算是有所恢复，这时候跑道剩下的跑友也不多了，估计都上了那诱人的救援车。</p><p>跑友虽然不多了，但是其中不乏几个精神矍铄的老年人，看着他们还在慢慢跑，我有什么理由放弃呢，我又把放弃的心思给压下去，咬着牙，又开始跑起来，自己给自己喊加油。路边的啦啦队虽然没有了，但是激励语还在，比如下图：</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2CiJQcQ1M.eBjSZPiXXawfpXa_!!581166664.jpg_620x10000.jpg" alt="还有6公里就可以发朋友圈了"></p><p>想想我这一路也是没少得瑟，要是最后没坚持下来是多丢人的事呀，调整心态，向最后6公里进发，这时已经下午1点左右，距离终点还有6KM。</p><p>最后这 6KM 真是让人望眼欲穿，走走跑跑，期间和一个大爷聊了会天，大爷说咱这个速度是到不了终点了，我一听不行呀，我怎么说也要在关门前冲进去，咬咬牙，使劲又跑了两公里，然后彻底废了，走了一段时间后好像又被那个大爷超了😂，这下是怎么也跑不动了，脚每走一步都酸痛无比，也不敢休息，生怕时间不够用。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2cHNQcOGO.eBjSZFjXXcU9FXa_!!581166664.jpg_620x10000.jpg" alt="13:40左右到达40KM 标志"></p><p>剩下的时间就是走路了，在13:40左右到达 40KM 标志，心想20分钟走2KM应该没问题吧，于是喝光了身上带的饮料，快步走了起来，这时候已经完全没有跑道的痕迹，马路也出现了带着奖牌的跑友，看着他们脸上表情，我知道他们是在享受着“长征”后的果实，我却时怎么也跑不动了，就这么走着走着，到了42KM，到了终点。</p><h3 id="终点感想"><a href="#终点感想" class="headerlink" title="终点感想"></a>终点感想</h3><p>其实到你终点你会发现，前面的一切都是值得的。内心的那种喜悦，无法通过文字与别人分享，只能自己去经历、去体会。看着那些拍照留恋的跑友，我知道他们和我一样，又会向着下一个挑战出发。事情往往就是这样，结果只是一瞬间，重要的同时也是最艰难漫长的部分是前面的过程。我觉得有意义的人生，应该是充满许多个这样挑战，起起伏伏，无休无止。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB22U40cgOI.eBjSszhXXbHvFXa_!!581166664.jpg_620x10000.jpg" alt="42KM 标志处"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2b68KcU5O.eBjSZFxXXaaJFXa_!!581166664.jpg_620x10000.jpg" alt="FINISH LINE"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2EutRcOGO.eBjSZFEXXcy9VXa_!!581166664.jpg_620x10000.jpg" alt="奖牌"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2j9VQcFOP.eBjSZFHXXXQnpXa_!!581166664.jpg_620x10000.jpg" alt="跑过风景，跑过你"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先吐个槽，相比上马，杭马确实有点 low 了。首先是跑道不够宽，那么多人，中间还堵了两次，这在上海是绝对没有的事；其实是跑道两侧的啦啦队，上马一路上基本都有人，杭马基本上就起点和终点多些，其他点人比较少。但不可否则，杭州的风景比上海好多了。</p><p>如果说，人生是一场马拉松，那么二十来岁的我们应该相当于10KM处，这时候应该是干劲十足，雄心满满的时候。可是回想自己毕业才两年左右，当初定的目标还记得嘛？自己的五年计划还能找到痕迹嘛？单词背了多少了？多少的周末是在虚度中耗尽？买的书看了多少？</p><p>都说一个人的时候是提升自我价值的黄金时期，时间多是多，但是如果计划不好，收获也甚微。好了，只是想通过这次跑马告诉自己，不要偏离了方向，向着前方，大步向前，终有达到终点的那一刻。与大家共勉。</p><h3 id="跑马建议"><a href="#跑马建议" class="headerlink" title="跑马建议"></a>跑马建议</h3><p>最后给想跑马但还没尝试过的同学提几点建议，供大家参考：</p><ul><li>如果是深秋，准备个长袖跑衣，淘宝搜索马拉松运动服多的是。</li><li>运动鞋，最好带气垫。与鞋搭配的还有运动袜，不要小看袜子，我跑杭马就随便穿了个，结果和鞋一直有摩擦，这也是造成了我脚酸痛的原因之一。</li><li>自带喷雾。说实话我跑上马不知道喷雾是干嘛的，只是看到有人去喷，杭马腿抽筋才知道那东西能抑制抽筋，像我跑在最后，基本上每个服务点都喷没了，所以自带还是有必要的。</li><li>肩包或腰包。吃的喝的服务点都有，自己可以不用带；主要是放手机、钥匙、喷雾、现金。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我微信里的朋友应该都知道，上周（2016/11/06）与大上周（2016/10/30）我分别跑了杭州与上海的马拉松，第一场上海站完成了人生首个半马，第二场杭州站完成了人生首个全马（42.195KM），现趁着腿还有一些酸痛，回顾下当初为什么要参加马拉松，以及在跑全马最后十公里
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Socket 编程实战</title>
    <link href="http://liujiacai.net/blog/2016/10/31/socket-programming/"/>
    <id>http://liujiacai.net/blog/2016/10/31/socket-programming/</id>
    <published>2016-10-31T08:24:17.000Z</published>
    <updated>2019-12-24T10:59:14.606Z</updated>
    
    <content type="html"><![CDATA[<p>Socket 在英文中的含义为“（连接两个物品的）凹槽”，像<code>the eye socket</code>，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常是指一个连接的两个端点，这里的连接可以是同一机器上的，像<a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">unix domain socket</a>，也可以是不同机器上的，像<a href="https://en.wikipedia.org/wiki/Network_socket" target="_blank" rel="noopener">network socket</a>。</p><p>本文着重介绍现在用的最多的 network socket，包括其在网络模型中的位置、API 的编程范式、常见错误等方面，最后用 Python 语言中的 socket API 实现几个实际的例子。Socket 中文一般翻译为“套接字”，不得不说这是个让人摸不着头脑的翻译，我也没想到啥“信达雅”的翻译，所以本文直接用其英文表述。本文中所有代码均可在 <a href="https://github.com/jiacai2050/socket.py" target="_blank" rel="noopener">socket.py</a> 仓库中找到。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Socket 作为一种通用的技术规范，首次是由 Berkeley 大学在 1983 为 4.2BSD Unix 提供的，后来逐渐演化为 POSIX 标准。Socket API 是由操作系统提供的一个编程接口，让应用程序可以控制使用 socket 技术。Unix 哲学中有一条<code>一切皆为文件</code>，所以 <code>socket</code> 和 <code>file</code> 的 API 使用很类似：可以进行<code>read</code>、<code>write</code>、<code>open</code>、<code>close</code>等操作。</p><p>现在的网络系统是分层的，理论上有<a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI模型</a>，工业界有<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">TCP/IP协议簇</a>。其对比如下：</p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2V0wfbmqJ.eBjy1zbXXbx8FXa_!!581166664.gif" alt=" osi vs tcp/ip"><br></center><br>每层上都有其相应的协议，socket API 不属于TCP/IP协议簇，只是操作系统提供的一个用于网络编程的接口，工作在应用层与传输层之间：<br><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2fzkbbhmJ.eBjy0FhXXbBdFXa_!!581166664.gif" alt="where socket works in tcp/ip"><br></center><p>我们平常浏览网站所使用的http协议，收发邮件用的smtp与imap，都是基于 socket API 构建的。</p><p>一个 socket，包含两个必要组成部分：</p><ol><li>地址，由 ip 与 端口组成，像<code>192.168.0.1:80</code>。</li><li>协议，socket 所是用的传输协议，目前有三种：<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">TCP</a>、<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener">UDP</a>、<a href="https://en.wikipedia.org/wiki/Raw_socket" target="_blank" rel="noopener">raw IP</a>。</li></ol><p>地址与协议可以确定一个socket；一台机器上，只允许存在一个同样的socket。TCP 端口 53 的 socket 与 UDP 端口 53 的 socket 是两个不同的 socket。</p><p>根据 socket 传输数据方式的不同（使用协议不同），可以分为以下三种：</p><ol><li><a href="https://en.wikipedia.org/wiki/Stream_socket" target="_blank" rel="noopener">Stream sockets</a>，也称为“面向连接”的 socket，使用 TCP 协议。实际通信前需要进行连接，传输的数据没有特定的结构，所以高层协议需要自己去界定数据的分隔符，但其优势是数据是可靠的。</li><li><a href="https://en.wikipedia.org/wiki/Datagram_socket" target="_blank" rel="noopener">Datagram sockets</a>，也称为“无连接”的 socket，使用 UDP 协议。实际通信前不需要连接，一个优势时 UDP 的数据包自身是可分割的（self-delimiting），也就是说每个数据包就标示了数据的开始与结束，其劣势是数据不可靠。</li><li><a href="https://en.wikipedia.org/wiki/Raw_socket" target="_blank" rel="noopener">Raw sockets</a>，通常用在路由器或其他网络设备中，这种 socket 不经过TCP/IP协议簇中的传输层（transport layer），直接由网络层（Internet layer）通向应用层（Application layer），所以这时的数据包就不会包含 tcp 或 udp 头信息。<br><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2qOeFX3hJc1FjSZFDXXbvnFXa_!!581166664.png_310x310.jpg" alt=" 数据包在各个层间的变更"><br></center><h2 id="Python-socket-API"><a href="#Python-socket-API" class="headerlink" title="Python socket API"></a>Python socket API</h2></li></ol><p>Python 里面用<code>(ip, port)</code>的元组来表示 socket 的地址属性，用<code>AF_*</code>来表示协议类型。<br>数据通信有两组动词可供选择：<code>send/recv</code> 或 <code>read/write</code>。<code>read/write</code> 方式也是 Java 采用的方式，这里不会对这种方式进行过多的解释，但是需要注意的是：</p><blockquote><p><code>read/write</code> 操作的具有 buffer 的“文件”，所以在进行读写后需要调用<code>flush</code>方法去真正发送或读取数据，否则数据会一直停留在缓冲区内。</p></blockquote><h3 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h3><p>TCP socket 由于在通信前需要建立连接，所以其模式较 UDP socket 复杂些。具体如下：</p><center><br><img width="400px" height="700px" src="https://img.alicdn.com/imgextra/i1/581166664/TB2egBSbOKO.eBjSZPhXXXqcpXa_!!581166664.png_620x10000.jpg" alt="TCP socket API "><br></center><p>API 的具体含义这里不在赘述，可以查看<a href="https://en.wikipedia.org/wiki/Berkeley_sockets#Socket_API_functions" target="_blank" rel="noopener">手册</a>，这里给出 Python 语言实现的 echo server。</p><ul><li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_tcp_echo/echo_server.py" target="_blank" rel="noopener">echo_server.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(client_sock, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'new client from %s:%s'</span> % addr)</span><br><span class="line">        msg = client_sock.recv(<span class="number">100</span>)</span><br><span class="line">        client_sock.send(msg)</span><br><span class="line">        print(<span class="string">'received data[%s] from %s:%s'</span> % ((msg,) + addr))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        client_sock.close()</span><br><span class="line">        print(<span class="string">'client[%s:%s] socket closed'</span> % addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket</span></span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind((<span class="string">''</span>, <span class="number">5500</span>))</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        client_sock, addr = sock.accept()</span><br><span class="line">        handler(client_sock, addr)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_tcp_echo/echo_client.py" target="_blank" rel="noopener">echo_client.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    data_to_sent = <span class="string">'hello tcp socket'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect((<span class="string">''</span>, <span class="number">5500</span>))</span><br><span class="line"></span><br><span class="line">        sent = sock.send(data_to_sent)</span><br><span class="line">        print(sock.recv(<span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br><span class="line">print(<span class="string">'socket closed'</span>)</span><br></pre></td></tr></table></figure><p>上面代码有一点需要注意：server 端的 socket 设置了<code>SO_REUSEADDR</code>为1，目的是可以立即使用处于<code>TIME_WAIT</code>状态的socket，那么<code>TIME_WAIT</code>又是什么意思呢？后面在讲解 <a href="#TCP_的状态机">tcp 状态机</a>时再做详细介绍。</p><h3 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h3><center><br><img width="400px" height="400px" src="https://img.alicdn.com/imgextra/i3/581166664/TB2.pEmbmGI.eBjSspcXXcVjFXa_!!581166664.jpg_620x10000.jpg" alt=" udp_socket_api"><br></center><p>UDP 版的 socket server 的代码在进行<code>bind</code>后，无需调用<code>listen</code>方法。</p><ul><li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_udp_echo/echo_server.py" target="_blank" rel="noopener">udp_echo_server.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket</span></span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">''</span>, <span class="number">5500</span>))</span><br><span class="line"><span class="comment"># 没有调用 listen</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        data, addr = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'new client from %s:%s'</span> % addr)</span><br><span class="line">        sock.sendto(data, addr)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_udp_echo/echo_client.py" target="_blank" rel="noopener">udp_echo_client.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">udp_server_addr = (<span class="string">''</span>, <span class="number">5500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    data_to_sent = <span class="string">'hello udp socket'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sent = sock.sendto(data_to_sent, udp_server_addr)</span><br><span class="line">        data, server = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">'receive data:[%s] from %s:%s'</span> % ((data,) + server))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br></pre></td></tr></table></figure><h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><h3 id="忽略返回值"><a href="#忽略返回值" class="headerlink" title="忽略返回值"></a>忽略返回值</h3><p>本文中的 echo server 示例因为篇幅限制，也忽略了返回值。网络通信是个非常复杂的问题，通常无法保障通信双方的网络状态，很有可能在发送/接收数据时失败或部分失败。所以有必要对发送/接收函数的返回值进行检查。本文中的 tcp echo client 发送数据时，正确写法应该如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total_send = <span class="number">0</span></span><br><span class="line">content_length = len(data_to_sent)</span><br><span class="line"><span class="keyword">while</span> total_send &lt; content_length:</span><br><span class="line">    sent = sock.send(data_to_sent[total_send:])</span><br><span class="line">    <span class="keyword">if</span> sent == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"socket connection broken"</span>)</span><br><span class="line">    total_send += total_send + sent</span><br></pre></td></tr></table></figure><p>同理，接收数据时也应该检查返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chunks = []</span><br><span class="line">bytes_recd = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> bytes_recd &lt; MSGLEN:   <span class="comment"># MSGLEN 为实际数据大小</span></span><br><span class="line">    chunk = self.sock.recv(min(MSGLEN - bytes_recd, <span class="number">2048</span>))</span><br><span class="line">    <span class="keyword">if</span> chunk == <span class="string">b''</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"socket connection broken"</span>)</span><br><span class="line">    chunks.append(chunk)</span><br><span class="line">    bytes_recd = bytes_recd + len(chunk)</span><br><span class="line"><span class="keyword">return</span> <span class="string">b''</span>.join(chunks)</span><br></pre></td></tr></table></figure><p><code>send/recv</code>操作的是网络缓冲区的数据，它们不必处理传入的所有数据。</p><blockquote><p>一般来说，当网络缓冲区填满时，<a href="https://docs.python.org/3/library/socket.html#socket.socket.send" target="_blank" rel="noopener">send函数</a>就返回了；当网络缓冲区被清空时，<a href="https://docs.python.org/3/library/socket.html#socket.socket.recv" target="_blank" rel="noopener">recv 函数</a>就返回。</p></blockquote><p>可以通过下面的方式设置缓冲区大小。</p><pre><code>s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, buffer_size)  # 发送s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, buffer_size)  # 接受</code></pre><h3 id="误认为-TCP-具有-framing"><a href="#误认为-TCP-具有-framing" class="headerlink" title="误认为 TCP 具有 framing"></a>误认为 TCP 具有 framing</h3><p>TCP 不提供 framing，这使得其很适合于传输数据流。这是其与 UDP 的重要区别之一。UDP 是一个面向消息的协议，能保持一条消息在发送者与接受者之间的完备性。</p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2SB4bbB9J.eBjy0FoXXXyvpXa_!!581166664.gif" alt="Framing capabilities of UDP and the lack of framing in TCP"><br></center><p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/tree/master/framing_assumptions" target="_blank" rel="noopener">framing_assumptions</a></p><h2 id="TCP-的状态机"><a href="#TCP-的状态机" class="headerlink" title="TCP 的状态机"></a>TCP 的状态机</h2><p>在前面echo server 的示例中，提到了TIME_WAIT状态，为了正式介绍其概念，需要了解下 TCP 从生成到结束的状态机。（<a href="https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.htm" target="_blank" rel="noopener">图片来源</a>）</p><center><br><img width="500px" height="600px" src="https://img.alicdn.com/imgextra/i2/581166664/TB2Us0HbNeK.eBjSZFlXXaywXXa_!!581166664.gif" alt=" tcp_state transition"><br></center><p>这个状图转移图非常非常关键，也比较复杂，总共涉及了 11 种状态。我自己为了方便记忆，对这个图进行了拆解，仔细分析这个图，可以得出这样一个结论：</p><blockquote><p>连接的打开与关闭有被动（passive）与主动（active）两种情况。主动关闭时，涉及到的状态转移最多，包括FIN_WAIT_1、FIN_WAIT_2、CLOSING、TIME_WAIT。（是不是有种 no zuo no die 的感觉）</p></blockquote><p>此外，由于 TCP 是可靠的传输协议，所以每次发送一个数据包后，都需要得到对方的确认（ACK），有了上面这两个知识后，再来看下面的图：（<a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">图片来源</a>）</p><center><br><img width="400px" height="500px" src="https://img.alicdn.com/imgextra/i4/581166664/TB2nwCFbNaK.eBjSZFwXXXjsFXa_!!581166664.jpg" alt=" tcp 关闭时的状态转移时序图"><br></center><p>我们重点分析上图中链接断开的过程，其中主动关闭端为 Client，被动关闭端为 Server 。</p><ol><li>Client 调用 <code>close</code> 方法的同时，会向 Server 发送一个 FIN，然后自己处于 FIN_WAIT_1 状态，在收到 server ACK 回应后变为 FIN_WAIT_2</li><li>Server 收到 FIN 后，向 Client 回复 ACK 确认，状态变化为 CLOSE_WAIT，然后开始进行一些清理工作</li><li>在 Server 清理工作完成后，会调用<code>close</code>方法，这时向 Client 发送 FIN 信号，状态变化为 LAST_ACK</li><li>Client 接收到 FIN 后，状态由 FIN_WAIT_2 变化为 TIME_WAIT，同时向 Server 回复 ACK</li><li>Server 收到 ACK 后，状态变化为 CLOSE，表明 Server 端的 socket 已经关闭</li><li>处于 TIME_WAIT 状态的 Client 不会立刻转为 CLOSED 状态，而是需要等待 2MSL（max segment life，一个数据包在网络传输中最大的生命周期），以确保 Server 能够收到最后发出的 ACK。如果 Server 没有收到最后的 ACK，那么 Server 就会重新发送 FIN，所以处于TIME_WAIT的 Client 会再次发送一个 ACK 信号，这么一来（FIN来）一回（ACK），正好是两个 MSL 的时间。如果等待的时间小于 2MSL，那么新的 socket 就可以收到之前连接的数据。</li></ol><p>上面是正常逻辑时的关闭顺序，如果任意一步出现问题都会导致 Socket 状态变化出现问题，下面说几种常见的问题：</p><ol><li>在上述过程第二步，回复完 ACK 后，如果忘记调用 CLOSE 方法，那么 Server 端在会一直处于 CLOSE_TIME 状态，处于 FIN_WAIT_2 状态的 Client 端会在 60 秒后超时，直接关闭。这个问题的具体案例可参考<a href="https://blog.cloudflare.com/this-is-strictly-a-violation-of-the-tcp-specification" target="_blank" rel="noopener">《This is strictly a violation of the TCP specification》</a></li><li>前面 echo server 的示例也说明了，处于 TIME_WAIT 并不是说一定不能使用，可以通过设置 socket 的 <code>SO_REUSEADDR</code> 属性以达到不用等待 2MSL 的时间就可以复用socket 的目的，当然，这仅仅适用于测试环境，正常情况下不要修改这个属性。</li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="HTTP-UA"><a href="#HTTP-UA" class="headerlink" title="HTTP UA"></a>HTTP UA</h3><p>http 协议是如今万维网的基石，可以通过 socket API 来简单模拟一个浏览器（UA）是如何解析 HTTP 协议数据的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket<span class="selector-class">.AF_INET</span>, socket.SOCK_STREAM)</span><br><span class="line">baidu_ip = socket.gethostbyname(<span class="string">'baidu.com'</span>)</span><br><span class="line">sock.connect((baidu_ip, <span class="number">80</span>))</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'connected to %s'</span> % baidu_ip)</span></span></span><br><span class="line"></span><br><span class="line">req_msg = [</span><br><span class="line">    <span class="string">'GET / HTTP/1.1'</span>,</span><br><span class="line">    <span class="string">'User-Agent: curl/7.37.1'</span>,</span><br><span class="line">    <span class="string">'Host: baidu.com'</span>,</span><br><span class="line">    <span class="string">'Accept: */*'</span>,</span><br><span class="line">]</span><br><span class="line">delimiter = <span class="string">'\r\n'</span></span><br><span class="line"></span><br><span class="line">sock.send(delimiter.join(req_msg))</span><br><span class="line">sock.send(delimiter)</span><br><span class="line">sock.send(delimiter)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'%sreceived%s'</span> % (<span class="string">'-'</span>*<span class="number">20</span>, <span class="string">'-'</span>*<span class="number">20</span>)</span></span>)</span><br><span class="line">http_response = sock.recv(<span class="number">4096</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(http_response)</span></span></span><br></pre></td></tr></table></figure><p>运行上面的代码可以得到下面的输出</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">--------------------received--------------------</span></span><br><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Tue,</span> <span class="number">01</span> <span class="string">Nov</span> <span class="number">2016</span> <span class="number">12</span><span class="string">:16:53</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Apache</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Tue,</span> <span class="number">12</span> <span class="string">Jan</span> <span class="number">2010</span> <span class="number">13</span><span class="string">:48:00</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">ETag:</span> <span class="string">"51-47cf7e6ee8400"</span></span><br><span class="line"><span class="attr">Accept-Ranges:</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">81</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">max-age=86400</span></span><br><span class="line"><span class="attr">Expires:</span> <span class="string">Wed,</span> <span class="number">02</span> <span class="string">Nov</span> <span class="number">2016</span> <span class="number">12</span><span class="string">:16:53</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;meta</span> <span class="string">http-equiv="refresh"</span> <span class="string">content="0;url=http://www.baidu.com/"&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p><code>http_response</code>是通过直接调用<code>recv(4096)</code>得到的，万一真正的返回大于这个值怎么办？我们前面知道了 TCP 协议是面向流的，它本身并不关心消息的内容，需要应用程序自己去界定消息的边界，对于应用层的 HTTP 协议来说，有几种情况，最简单的一种时通过解析返回值头部的<code>Content-Length</code>属性，这样就知道<code>body</code>的大小了，对于 HTTP 1.1版本，支持<code>Transfer-Encoding: chunked</code>传输，对于这种格式，这里不在展开讲解，大家只需要知道， TCP 协议本身无法区分消息体就可以了。对这块感兴趣的可以查看 CPython 核心模块 <a href="https://github.com/python/cpython/blob/master/Lib/http/client.py" target="_blank" rel="noopener">http.client</a></p><h3 id="Unix-domain-socket"><a href="#Unix-domain-socket" class="headerlink" title="Unix_domain_socket"></a>Unix_domain_socket</h3><p>UDS 用于同一机器上不同进程通信的一种机制，其API适用与 network socket 很类似。只是其连接地址为本地文件而已。</p><p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/uds_server.py" target="_blank" rel="noopener">uds_server.py</a>、<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/uds_client.py" target="_blank" rel="noopener">uds_client.py</a></p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping 命令作为检测网络联通性最常用的工具，其适用的传输协议既不是TCP，也不是 UDP，而是 <a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol" target="_blank" rel="noopener">ICMP</a>。<br>ICMP 消息（messages）通常用于诊断 IP 协议产生的错误，traceroute 命令也是基于 ICMP 协议实现。利用 Python raw sockets API 可以模拟发送 ICMP 消息，实现类似 ping 的功能。</p><p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/ping.py" target="_blank" rel="noopener">ping.py</a></p><h3 id="netstat-vs-ss"><a href="#netstat-vs-ss" class="headerlink" title="netstat vs ss"></a>netstat vs ss</h3><p>netstat 与 ss 都是类 Unix 系统上查看 Socket 信息的命令。netstat 是比较老牌的命令，常用的选择有</p><ul><li><code>-t</code>，只显示 tcp 连接</li><li><code>-u</code>，只显示 udp 连接</li><li><code>-n</code>，不用解析hostname，用 IP 显示主机，可以加快执行速度</li><li><code>-p</code>，查看连接的进程信息</li><li><code>-l</code>，只显示监听的连接</li></ul><p>ss 是新兴的命令，其选项和 netstat 差不多，主要区别是能够进行过滤（通过<code>state</code>与<code>exclude</code>关键字）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ss -o state time-wait -n | head</span></span><br><span class="line">Recv-Q Send-Q             Local Address:Port               Peer Address:Port</span><br><span class="line">0      0                 10.200.181.220:2222              10.200.180.28:12865  timer:(timewait,33sec,0)</span><br><span class="line">0      0                      127.0.0.1:45977                 127.0.0.1:3306   timer:(timewait,46sec,0)</span><br><span class="line">0      0                      127.0.0.1:45945                 127.0.0.1:3306   timer:(timewait,6.621ms,0)</span><br><span class="line">0      0                 10.200.181.220:2222              10.200.180.28:12280  timer:(timewait,12sec,0)</span><br><span class="line">0      0                 10.200.181.220:2222              10.200.180.28:35045  timer:(timewait,43sec,0)</span><br><span class="line">0      0                 10.200.181.220:2222              10.200.180.28:42675  timer:(timewait,46sec,0)</span><br><span class="line">0      0                      127.0.0.1:45949                 127.0.0.1:3306   timer:(timewait,11sec,0)</span><br><span class="line">0      0                      127.0.0.1:45954                 127.0.0.1:3306   timer:(timewait,21sec,0)</span><br><span class="line">0      0               ::ffff:127.0.0.1:3306           ::ffff:127.0.0.1:45964  timer:(timewait,31sec,0)</span><br></pre></td></tr></table></figure><p>这两个命令更多用法可以参考：</p><ul><li><a href="http://www.cyberciti.biz/files/ss.html" target="_blank" rel="noopener">SS Utility: Quick Intro</a></li><li><a href="http://www.binarytides.com/linux-netstat-command-examples/" target="_blank" rel="noopener">10 basic examples of linux netstat command</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们的生活已经离不开网络，平时的开发也充斥着各种复杂的网络应用，从最基本的数据库，到各种分布式系统，不论其应用层怎么复杂，其底层传输数据的的协议簇是一致的。Socket 这一概念我们很少直接与其打交道，但是当我们的系统出现问题时，往往是对底层的协议认识不足造成的，希望这篇文章能对大家编程网络方面的程序有所帮助。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.python.org/3/howto/sockets.html" target="_blank" rel="noopener">Socket Programming HOWTO</a></li><li><a href="https://benohead.com/tcp-about-fin_wait_2-time_wait-and-close_wait/" target="_blank" rel="noopener">TCP: About FIN_WAIT_2, TIME_WAIT and CLOSE_WAIT</a></li><li><a href="http://www.ibm.com/developerworks/library/l-sockpit/" target="_blank" rel="noopener">Five pitfalls of Linux sockets programming</a></li><li><a href="http://www.ibm.com/developerworks/linux/tutorials/l-sock/" target="_blank" rel="noopener">Programming Linux sockets, Part 1: Using TCP/IP</a></li><li><a href="http://stackoverflow.com/questions/10328675/how-to-know-content-length" target="_blank" rel="noopener">http://stackoverflow.com/questions/10328675/how-to-know-content-length</a></li><li><a href="http://electronicdesign.com/what-s-difference-between/what-s-difference-between-osi-seven-layer-network-model-and-tcpip" target="_blank" rel="noopener">What’s The Difference Between The OSI Seven-Layer Network Model And TCP/IP?</a></li><li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li><li><a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html" target="_blank" rel="noopener">Coping with the TCP TIME-WAIT state on busy Linux servers</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Socket 在英文中的含义为“（连接两个物品的）凹槽”，像&lt;code&gt;the eye socket&lt;/code&gt;，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常是指一个连接的两个端点，这里的连接可以是同一机器上的，像&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="Python" scheme="http://liujiacai.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python2 中的编码问题</title>
    <link href="http://liujiacai.net/blog/2016/06/30/python2-encoding/"/>
    <id>http://liujiacai.net/blog/2016/06/30/python2-encoding/</id>
    <published>2016-06-30T08:13:17.000Z</published>
    <updated>2019-12-24T10:59:14.606Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一个异常信息：</p><blockquote><p>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 51-52: ordinal not in range(128)</p></blockquote><p>相信每个 Python 程序员对上面这个错误都再熟悉不过了，也许你这个问题的根源以及解决方法不是很清楚，那么这篇文章将尝试解答你心中的疑惑。</p><h2 id="什么是字符串"><a href="#什么是字符串" class="headerlink" title="什么是字符串"></a>什么是字符串</h2><blockquote><p>Everything you thought you knew about strings is wrong.</p></blockquote><p>计算机中，处理字符串是一个看似简单但及其复杂的问题。推荐我之前写的一文章<a href="/blog/2015/11/20/strings/">《字符串，那些你不知道的事》</a>。</p><h2 id="Python-2-中的字符类型"><a href="#Python-2-中的字符类型" class="headerlink" title="Python 2 中的字符类型"></a>Python 2 中的字符类型</h2><p>Python 2 中有两种字符类型：<code>str</code>与<code>unicode</code>，其<a href="http://stackoverflow.com/a/10288345/2163429" target="_blank" rel="noopener">区别</a>是：</p><blockquote><p>str is text representation in bytes, unicode is text representation in characters.</p></blockquote><p>字符字面量是<code>str</code>类型，也就是说<code>foo = &quot;你好&quot;</code>这一赋值语句表示的是把<code>你好</code>所对应的二进制字节（这里的字节就是Python解释器读取源文件时读取到的）赋值给变量<code>foo</code>，在 Python 2 中的<code>str</code>类型相当于其他语言的<code>byte</code>类型。<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; "你好"</span><br><span class="line">'<span class="symbol">\x</span>e4<span class="symbol">\x</span>bd<span class="symbol">\x</span>a0<span class="symbol">\x</span>e5<span class="symbol">\x</span>a5<span class="symbol">\x</span>bd'</span><br></pre></td></tr></table></figure></p><p><code>unicode</code>对象保存的是字符的<a href="https://pythonhosted.org/kitchen/glossary.html#term-code-point" target="_blank" rel="noopener">code point</a>。在 Python 2 如果想表示 <code>unicode</code> 类型，有下面三种方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u"你好"</span></span><br><span class="line"><span class="string">u'\u4f60\u597d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"你好"</span>.decode(<span class="string">"utf8"</span>)</span><br><span class="line"><span class="string">u'\u4f60\u597d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unicode(<span class="string">"你好"</span>, <span class="string">"utf8"</span>)</span><br><span class="line"><span class="string">u'\u4f60\u597d'</span></span><br></pre></td></tr></table></figure></p><h2 id="Python-2-中的默认编码"><a href="#Python-2-中的默认编码" class="headerlink" title="Python 2 中的默认编码"></a>Python 2 中的默认编码</h2><p><code>sys.getdefaultencoding()</code>可以得到当前 Python 环境的默认编码，Python 2 中为<code>ascii</code>。<code>str</code>与<code>unicode</code>两种字符类型中转化时，如果没有明确指定编码方式，就会用这个默认编码。</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2A3eksXXXXXaqXpXXXXXXXXXX_!!581166664.png" alt=" str与unicode转化方式"><br></center><h2 id="Python-2-中编码问题出现根源"><a href="#Python-2-中编码问题出现根源" class="headerlink" title="Python 2 中编码问题出现根源"></a>Python 2 中编码问题出现根源</h2><p>了解了 Python 2 中的两种字符类型以及默认编码，现在就可以分析与编码相关的问题出现的原因了。</p><p>在 Python 2 的世界中，很多 API 对这两种字符类型的使用比较混乱，有的可以混用这两种，有的只能使用其中之一，如果在调用 API 时传入了错误的字符类型，Python 2 会自动去转为正确的字符类型，问题就出现在自动转化时用的编码默认是<code>ascii</code>，所以经常会出现<code>UnicodeDecodeError</code>或<code>UnicodeEncodeError</code>错误了。</p><p>随着 unicode 的普及，Python 2 中越来越多的 API 使用 <code>unicode</code> 类型的字符串作为参数与返回值，我们在设计 API 时，也尽可能要使用<code>unicode</code>类型。那是不是说，把程序里面的所有字符串都用<code>unicode</code>类型表示，就不会出错了呢？也不尽然，一般有如下准则：</p><ul><li>在进行文本处理（如查找一个字符串中字符的个数，分割字符串等）时，使用<code>unicode</code>类型</li><li>在进行<code>I/O</code>处理（如，读写磁盘上的文件，打印一个字符串，网络通信等）时，使用<code>str</code>类型</li></ul><p>想想也很好理解，因为 Python 2 中的<code>str</code>类型相当于其他语言的<code>byte</code>类型，在进行<code>I/O</code>时操作的是一个个的字节。</p><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><p>知道了问题出现的原因，下面举一些常见的与编码相关的错误代码，演示如何正确的使用。</p><h3 id="字符串拼接、比较"><a href="#字符串拼接、比较" class="headerlink" title="字符串拼接、比较"></a>字符串拼接、比较</h3><p>Python 中字符串在进行拼接与比较时，如果一个是<code>str</code>类型，另一个是<code>unicode</code>类型，那么会把<code>str</code>隐式转为<code>unicode</code>类型。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">"%s, %s"</span> % (u<span class="string">"你好"</span>, <span class="string">"中国"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="literal">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: <span class="symbol">'ascii</span>' codec can<span class="symbol">'t</span> decode byte <span class="number">0</span>xe4 <span class="keyword">in</span> position <span class="number">0</span>: ordinal <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">128</span>)</span><br><span class="line">&gt;&gt;&gt; u<span class="string">"你好"</span> &gt; <span class="string">"中国"</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, <span class="literal">line</span> <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: <span class="symbol">'ascii</span>' codec can<span class="symbol">'t</span> decode byte <span class="number">0</span>xe4 <span class="keyword">in</span> position <span class="number">0</span>: ordinal <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">128</span>)</span><br></pre></td></tr></table></figure><p>解决方法也很简单，就像上面说的，只要不涉及到<code>I/O</code>操作，一律用<code>unicode</code>类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u"%s, %s"</span> % (<span class="string">u"你好"</span>, <span class="string">u"中国"</span>)</span><br><span class="line"><span class="string">u'\u4f60\u597d, \u4e2d\u56fd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u"你好"</span> &gt; <span class="string">u"中国"</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>内置函数 [open(name<a href="https://docs.python.org/2/library/functions.html#open" target="_blank" rel="noopener">, mode[, buffering]])</a> 可以返回一个文件类型的对象，这里返回的文件对象操作的是<code>str</code>类型的字符，我们可以手动将读到的内容转为<code>unicode</code>类型，但是这里有个问题， 对于多字节编码来说，一个 unicode 字符可能被数目不同的字节表示，如果我们读取了任意固定大小（比如1K，或4K）的数据块，这个数据快的最后几个字节很可能是某个 unicode 字符的前几个字节，我们需要去处理这种异常，一个比较笨的解决方式是把所有数据读取到内存中，然后再去转码，显然这不适合大数据的情况。一个比较好的方法是使用<code>codecs</code>模块的<code>open(filename, mode=&#39;rb&#39;, encoding=None, errors=&#39;strict&#39;, buffering=1)</code>方法，这个方法返回的文件对象操作的是<code>unicode</code>类型的字符，<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /tmp/debug.log</span></span><br><span class="line">你好</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; with open(<span class="string">'/tmp/debug.log'</span>) as <span class="symbol">f:</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;     s = f.read(<span class="number">1</span>)    <span class="comment"># 读一个字节</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;     print type(s)    <span class="comment"># str</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;     print s          <span class="comment"># 无意义的一个符号</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; import codecs</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; with codecs.open(<span class="string">'/tmp/debug.log'</span>, encoding=<span class="string">'utf-8'</span>) as <span class="symbol">f:</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;     s = f.read(<span class="number">1</span>)    <span class="comment"># 读一个字符</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;     print type(s)    <span class="comment"># unicode</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;     print s          <span class="comment"># 你</span></span><br></pre></td></tr></table></figure></p><p>如果我们用内置的<code>open</code>进行写文件，必须将<code>unicode</code>字符转为<code>str</code>字符，否则会报错。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'/tmp/debug.log'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">u'你好'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure></p><p>这个错误很典型，就是因为用默认的<code>ascii</code>去编码<code>你好</code>导致的，显然<code>你好</code>不在<code>ascii</code>字符集内，正确的方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'/tmp/debug.log'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">u'你好'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">$ cat /tmp/debug.log</span><br><span class="line">你好</span><br></pre></td></tr></table></figure></p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p>首先需要注意的是 <a href="https://docs.python.org/2/reference/simple_stmts.html#print" target="_blank" rel="noopener">print</a> 在 Python 2 中是一个表达式（和if、return同一级别），而不是一个函数。<br><code>print</code>有两种语法形式：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_stmt ::=  <span class="string">"print"</span> ([<span class="keyword">expression</span> (<span class="string">","</span> <span class="keyword">expression</span>)* [<span class="string">","</span>]]</span><br><span class="line">                | <span class="string">"&gt;&gt;"</span> <span class="keyword">expression</span> [(<span class="string">","</span> <span class="keyword">expression</span>)+ [<span class="string">","</span>]])</span><br></pre></td></tr></table></figure></p><p>默认情况下<code>print</code>打印到标准输出<code>sys.stdout</code>中，可以使用<code>&gt;&gt;</code>后跟一个<code>file-like</code>的对象（具有<code>write</code>方法）进行重定向。例如：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/debug.log'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span> &gt;&gt; f, <span class="string">'你好'</span></span><br></pre></td></tr></table></figure></p><p>因为<code>print</code>的参数为<code>str</code>类型的字符，所以在打印到标准输出（一般为终端，例如Mac的iTerm2）时有个隐式转码的过程，这个转码过程默认用的编码在类unix系统上是通过环境变量<code>LC_ALL</code>指定的，在 Windows 系统中，终端默认只能显示256个字符（<a href="http://en.wikipedia.org/wiki/Code_page_437" target="_blank" rel="noopener">cp437</a> 指定）。</p><p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2DlbxsXXXXXcyXpXXXXXXXXXX_!!581166664.png" alt="Python 解释器内部 print 数据流程"><br></center><br>自 Python 2.6 起，Python 解释器在启动时可以通过指定 <a href="https://docs.python.org/2.7/using/cmdline.html#envvar-PYTHONIOENCODING" target="_blank" rel="noopener">PYTHONIOENCODING</a> 这个环境变量来指定。<br>在程序里面，我们可以通过只读属性<code>sys.stdout.encoding</code>查看。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat encode.py</span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">print</span> sys.stdout.encoding</span><br><span class="line"><span class="keyword">print</span> <span class="string">u"你好"</span></span><br><span class="line"></span><br><span class="line">$ python encode.py</span><br><span class="line">UTF<span class="number">-8</span></span><br><span class="line">你好</span><br><span class="line"></span><br><span class="line">$ LC_ALL=C python encode.py</span><br><span class="line">US-ASCII</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"encode.py"</span>, line <span class="number">21</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">u"你好"</span></span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure></p><p>当 <code>print</code> 通过重定向，不是打印到标准输出<code>sys.stdout</code>时，由于它不知道目标文件的<code>locale</code>，所以它又会用默认的<code>ascii</code>进行编码了。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">encode</span>.py &gt; abc</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"encode.py"</span>, <span class="keyword">line</span> 21, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">print</span> <span class="keyword">u</span><span class="string">"你好"</span></span><br><span class="line">UnicodeEncodeError: 'ascii' codec can't <span class="keyword">encode</span> characters <span class="keyword">in</span> position 0-1: ordinal not <span class="keyword">in</span> <span class="keyword">range</span>(128)</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">cat</span> abc</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">$ PYTHONIOENCODING=UTF-8 python <span class="keyword">encode</span>.py &gt; abc</span><br><span class="line">$ <span class="keyword">cat</span> abc</span><br><span class="line">UTF-8</span><br><span class="line">你好</span><br></pre></td></tr></table></figure><p>可以看到，在不指定<code>PYTHONIOENCODING</code>时，<code>sys.stdout.encoding</code>输出<code>None</code>了，并且执行<code>print u&quot;你好&quot;</code>时报错了。</p><p>为了解决打印unicode字符的问题，我们可以通过<a href="http://docs.python.org/library/codecs.html#codecs.StreamWriter" target="_blank" rel="noopener">codecs.StreamWriter</a>来包装一次<code>sys.stdout</code>对象。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat encode2.py</span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">UTF8Writer = codecs.getwriter(<span class="string">'utf8'</span>)</span><br><span class="line">sys.stdout = UTF8Writer(sys.stdout)</span><br><span class="line"><span class="keyword">print</span> <span class="string">u'你好'</span></span><br><span class="line"></span><br><span class="line">$ python encode2.py &gt; abc</span><br><span class="line">$ cat abc</span><br><span class="line">你好</span><br></pre></td></tr></table></figure></p><p>需要注意的是，通过<code>codecs.StreamWriter</code>包装后的<code>print</code>，在输出<code>str</code>类型的字符时，会先把这个字符转为<code>unicode</code>类型，然后再转为<code>str</code>类型，这两个转化过程用的也是默认的<code>ascii</code>编码， 所以很有可能又会出错。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> encode3.<span class="keyword">py</span></span><br><span class="line"># codin<span class="variable">g:</span> utf-<span class="number">8</span></span><br><span class="line">import codecs</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">UTF8Writer = codecs.getwriter(<span class="string">'utf8'</span>)</span><br><span class="line">sys.stdout = UTF8Writer(sys.stdout)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'你好'</span></span><br><span class="line"></span><br><span class="line">$ <span class="keyword">python</span> encode3.<span class="keyword">py</span> &gt; <span class="keyword">abc</span></span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">"encode3.py"</span>, <span class="built_in">line</span> <span class="number">7</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'你好'</span></span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/codecs.py"</span>, <span class="built_in">line</span> <span class="number">351</span>, in <span class="keyword">write</span></span><br><span class="line">    data, consumed = self.encode(object, self.errors)</span><br><span class="line">UnicodeDecodeError: <span class="string">'ascii'</span> codec can<span class="string">'t decode byte 0xe4 in position 0: ordinal not in range(128)</span></span><br></pre></td></tr></table></figure></p><p>你可能会问，有没有一劳永逸的解决方法，第三方模块<a href="https://pypi.python.org/pypi/kitchen" target="_blank" rel="noopener">kitchen</a>可以解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ pip install kitchen</span><br><span class="line">$ cat encode4.py</span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> kitchen.text.converters <span class="keyword">import</span> getwriter</span><br><span class="line">UTF8Writer = getwriter(<span class="string">'utf8'</span>)</span><br><span class="line">sys.stdout = UTF8Writer(sys.stdout)</span><br><span class="line"><span class="keyword">print</span> <span class="string">u'你好'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'你好'</span></span><br><span class="line"></span><br><span class="line">$ python encode4.py &gt; abc</span><br><span class="line">$ cat abc</span><br><span class="line">你好</span><br><span class="line">你好</span><br></pre></td></tr></table></figure><p>可以看到，两种类型的<code>你好</code>均被正确重定向到文件中。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>我上面重点讲解了输入输出时的常见编码错误，其他的编码错误基本上就是 API 参数类型不匹配的参数。自己代码推荐还比较好解决，第三方模块里面的就不好调试了，如果遇到了，只能通过hack的方式来修改第三方模块的源代码了。</p><p>一个比较好的建议是，<code>str</code>类型的变量名前面用<code>b_</code>标示，比如<code>b_search_hits</code>，表示返回的搜索结果的类型是<code>str</code>。</p><h2 id="never-reload-sys"><a href="#never-reload-sys" class="headerlink" title="never reload(sys)"></a>never reload(sys)</h2><p>互联网上比较常见的一个解决编码的方式是：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">reload</span><span class="params">(sys)</span></span></span><br><span class="line">sys.setdefaultencoding(<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure></p><p>这种解决方式带来的弊远远大于利，下面一个简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"你好"</span> == <span class="string">u"你好"</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"你好"</span> == <span class="string">u"你好"</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure></p><p>可以看到，设置默认编码之后，程序的逻辑已经发生了改变，最主要的是，如果我们改变了默认编码，我们所引用的所有第三方模块，也都会改变，就像这里举的例子，程序的逻辑很有可能会改变。关于这个问题的详尽解释，可以参考<a href="http://stackoverflow.com/q/28657010/2163429" target="_blank" rel="noopener">Dangers of sys.setdefaultencoding(‘utf-8’)</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，想象大家对 Python 2 中为什么会出现那么多的编码错误有所了解，根本原因就在于 Python 设计早期混淆了<code>byte</code>类型与<code>str</code>类型，好歹在 Python 3 解决了这个设计错误。<br>在另一方面，这里的编码问题对我们理解计算机的运行原理很有帮助，也反映出<code>copy &amp; paste</code>的危害，希望大家看了我这篇文章之后，严禁<code>reload(sys)</code>这种做法，推荐使用<code>from __future__ import unicode_literals</code>来将所有字符字面量表示为 unicode。</p><p>如果大家对 Python 2 中的编码问题，还有任何疑问，欢迎留言讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://python-future.org/unicode_literals.html" target="_blank" rel="noopener">Should I import unicode_literals?</a></li><li><a href="https://pythonhosted.org/kitchen/unicode-frustrations.html" target="_blank" rel="noopener">Overcoming frustration: Correctly using unicode in python2</a></li><li><a href="https://wiki.python.org/moin/PrintFails" target="_blank" rel="noopener">PrintFails</a></li><li><a href="https://docs.python.org/2/howto/unicode.html" target="_blank" rel="noopener">Unicode HOWTO</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先来看一个异常信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 51-52: ordinal not in range(128)&lt;/p&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Python" scheme="http://liujiacai.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>编程语言中的变量作用域与闭包</title>
    <link href="http://liujiacai.net/blog/2016/05/28/scope-closure/"/>
    <id>http://liujiacai.net/blog/2016/05/28/scope-closure/</id>
    <published>2016-05-28T12:44:34.000Z</published>
    <updated>2019-12-24T10:59:14.606Z</updated>
    
    <content type="html"><![CDATA[<p>如果你写过 javascript，应该听说过<a href="https://en.wikipedia.org/wiki/JavaScript_syntax#hoisting" target="_blank" rel="noopener">变量提升</a>（hoisting），如果你自诩“Life is short, I use Python”，那么多多少少会用过<code>global</code>、<code>nonlocal</code>这两个关键字。无论新手还是老手，遇到这些时都会觉得很别扭，稍不留神就会出现意想不到的 bug，如果你仔细观察就会发现，它们其实是一个问题：变量作用域的问题。</p><p>其次，随着函数式编程的日趋火热，<a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" target="_blank" rel="noopener">闭包</a>逐渐成为了 buzzword，但我相信没几个人（希望你是那少数人）能够准确概括出闭包的精髓，而其实闭包这一概念也是解决变量作用域问题。</p><p>这篇文章首先介绍作用域相关的知识，主要是比较 dynamic scope 与 static(或lexical) scope 语言的优劣势；然后分析 Python 中为什么需要<code>global</code>和<code>nonlocal</code>，Javascript 为什么有<code>变量提升</code>，我这里不仅仅是介绍what，更重要的是why，要知道这两门语言的设计者都是深耕CS领域多年的老手，不会轻易犯错的，肯定有“不为人知”的一面，但遗憾的是网上大部分文章就是解释what，很少有涉及到why的，希望我这篇文章能够填充这一空缺；最后介绍闭包这一重要概念。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>简单来说，作用域限定了程序中变量的查找范围。</p><p>在编程语言中有子过程（subroutine，也称为函数、过程）之前，所有的变量都在一个称为“global”的环境中，现在来看这当然是非常不合理，所以在之后有子过程的大部分静态语言（变量的类型不可变）里面，不同的 block（像if、while、for、函数等），具有不同的环境。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);  <span class="comment">// error: use of undeclared identifier 'i'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码片段是一简单的 C 语言程序，在执行 if 代码块时，会新创建一个环境（称为E1，其外围环境为全局环境E0。见下图），然后在 E1 中定义变量<code>i</code>，在 if 代码块结束后，E1 这个环境就会被删除，这时 main 函数后面的程序就无法访问 if 代码块的变量了。</p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2SPDZpFXXXXaVXXXXXXXXXXXX_!!581166664.png" alt=" if 代码块示意图"><br></center><p>上面这一做法符合我们的直观印象，也是比较合理的设计。但是在一些动态语言（变量的类型可以任意改变）中，并没有变量声明与使用的区别，而是在第一次使用时去声明这个变量，像下面这个 Python 示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> i  <span class="comment"># 输出 1</span></span><br></pre></td></tr></table></figure></p><p>在 Python 中，执行 if 代码块时不会去创建新的环境，而是在 if 代码块所处的环境中去执行。</p><p>根据我目前所了解到的：</p><ul><li>静态语言（C、Java、C#等）具有块级别（block level，包含if、while、for、switch、函数等）的变量作用域；</li><li>动态语言（Javascript、Python、Ruby等）只具有函数级别（function level）的变量作用域</li></ul><h3 id="dynamic-scope-vs-static-scope"><a href="#dynamic-scope-vs-static-scope" class="headerlink" title="dynamic scope vs. static scope"></a>dynamic scope vs. static scope</h3><p>首先声明一点，这里的dynamic与static是指的变量的作用域，不是指变量的类型，与动态语言与静态语言要区分开。</p><p>在上面我们了解到，所有的高级语言都具有函数作用域。我们一般是这样使用函数的，先声明再使用，也就是说函数的声明与使用是分开的，这就涉及到一个问题，函数作用域的外围环境是声明时的还是运行时的呢？不同的外围环境对应不同的语言：</p><ul><li>dynamic scope 的语言，函数作用域的外围环境是<code>运行时</code></li><li>static scope 的语言，函数作用域的外围环境是<code>声明时</code></li></ul><p>看下面这个 Python 示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># foo.py</span></span><br><span class="line">s = <span class="string">"foo"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># bar.py</span></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> foo</span><br><span class="line">s = <span class="string">"bar"</span></span><br><span class="line">foo()   <span class="comment"># 输出 foo</span></span><br></pre></td></tr></table></figure></p><p>上面的示例包括两个文件：<code>foo.py</code>、<code>bar.py</code>，在<code>bar.py</code>中调用<code>foo.py</code>的<code>foo</code>函数，因为 Python 属于 static scope 的语言，所以这时的环境是这样的：</p><p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2yp6lpFXXXXXAXFXXXXXXXXXX_!!581166664.png" alt=" 在 bar 中调用 foo 函数时的环境示意图"><br></center><br>在调用 foo 时，会创建一新环境E1，E1 虽然是在 bar 的全局环境中创建的，但是其外围指向的是 foo 的全局环境。在执行 foo 函数时，变量的查找顺序是这样的：</p><ol><li>首先在 E1 中找到，找不到就会去其外围环境中去查找；找到则直接返回</li><li>在E1外围环境中查找，如果找到直接返回，如果找不到则再在外围环境的外围环境中继续查找，止到外围环境为空（foo、bar 模块的全局环境的外围指向均为空）</li><li>去语言内置的变量中去查找，找到则直接返回；找不到就会报错。</li></ol><p>static scope 是比较符合正常思维的，也是比较正确的实现方式，否则我们在使用第三份类库时，很容易就会发生变量冲突或覆盖的情况。采用 dynamic scope 的语言都是比较古老的，现在还比较常见的是 Shell，想想大家在写 Shell 时是多痛苦就知道 dynamic scope 是多么反人类了。</p><h2 id="JavaScript-中的变量作用域"><a href="#JavaScript-中的变量作用域" class="headerlink" title="JavaScript 中的变量作用域"></a>JavaScript 中的变量作用域</h2><p>就像前面说的，Javascript 具有 function level 的 static scope，但是这里有一个常见的问题，具体代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + i));</span><br><span class="line"></span><br><span class="line">    item.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"Item "</span> + i + <span class="string">" is clicked."</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    list.appendChild(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也许会想当然的认为依次单击时每个Item会依次显示1,2,3…，但其实这里无论你单击那个Item，都只会显示6，你可以去 <a href="https://jsfiddle.net/jiacai2050/w6agke9d/" target="_blank" rel="noopener">JSFiddle</a> 测试下。<br>究其原因，就是因为每个item click 所对应的回调函数的声明与执行是分开的，而且 Javascript 中只有 function level 的作用域，所以在单击Item时的环境是这样的：</p><p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2YEkppFXXXXXbXXXXXXXXXXXX_!!581166664.png" alt=" 使用 var 定义 i 时，单击 Item 时的环境模型示意图"><br></center><br>在 for 代码块执行完后，<code>i</code> 的值为6，又因为Javascript 中只有 function level 的作用域，所以这里的 <code>i</code> 被定义在了 E0 中。</p><p>为了解决这个问题，ES6 引入了<code>let</code>，使用<code>let</code>定义的变量具有 block level 的作用域，所以如果把上面的代码片段中的<code>var</code>换成<code>let</code>，环境会变成下面的形式：</p><p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB29sDTpFXXXXXpXpXXXXXXXXXX_!!581166664.png" alt=" 使用 let 定义 i 时，单击 Item 时的环境模型示意图"><br></center><br>相信大家通过上面的图示，可以解决心中的疑惑了。最后，给出一个思考，下面的代码片段输出什么值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"before"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">"after"</span>;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br><span class="line">bar(foo);   <span class="comment">// 输出 ？</span></span><br></pre></td></tr></table></figure></p><h3 id="hoisting"><a href="#hoisting" class="headerlink" title="hoisting"></a>hoisting</h3><p>先看一个比较典型的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><p>你也许知道，这里弹出的值是10，而不是1，因为javascript会把所有的变量提前（hositing），也就是说，上面的代码等价于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        foo = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><p>上面这个例子就简单演示了什么是变量提升，下面重点讲述为什么要这么设计？首先看下面一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> is_odd(n - <span class="number">1</span>);      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_even(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> is_even(n - <span class="number">1</span>);      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照常规思维，在运行<code>is_even(2);</code> 时，会去调用还没定义的<code>is_odd</code>函数，所以应该会报错，但是由于 Javascript 里面有 hositing，所以是可以运行，但是为什么要这么设计呢？<br>这要追溯到 Javascript 语言设计者的初衷了，Brendan Eich 在创造这门世界级语言时，一开始打算用 Scheme 的思想来实现，而且当时 Brendan 也是在看 SICP 这本书，<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.6" target="_blank" rel="noopener">SICP 4.1.6</a> 在介绍内部定义时，给出了解决变量同一时刻定义的一种解决方式：将所有的变量名提前。这样同一环境中的其他地方就能够使用所有的定义了。需要注意的是，这里只是将变量名提前，赋值的动作不变，显然，Javascript 采用了这一思想（这其实是<a href="https://en.wikipedia.org/wiki/Forward_declaration" target="_blank" rel="noopener">forward_declaration</a> 技术的一种实现手段）。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; SICP 书中的示例代码</span></span><br><span class="line">(<span class="name">lambda</span> &lt;vars&gt;</span><br><span class="line">  (<span class="name">define</span> u &lt;e1&gt;)</span><br><span class="line">  (<span class="name">define</span> v &lt;e2&gt;)</span><br><span class="line">  &lt;e3&gt;)</span><br><span class="line"><span class="comment">;; 转为下面的形式</span></span><br><span class="line">(<span class="name">lambda</span> &lt;vars&gt;</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">u</span> '*unassigned*)</span><br><span class="line">        (<span class="name">v</span> '*unassigned*))</span><br><span class="line">    (<span class="name">set!</span> u &lt;e1&gt;)</span><br><span class="line">    (<span class="name">set!</span> v &lt;e2&gt;)</span><br><span class="line">    &lt;e3&gt;))</span><br></pre></td></tr></table></figure></p><p>这个问题有人在 Twitter <a href="https://twitter.com/BrendanEich/status/33403701100154880" target="_blank" rel="noopener">问过 Brendan 这个问题</a>，Brendan是这么回答的：</p><blockquote><p>Function declaration hoisting is for mutual recursion &amp; generally to avoid painful bottom-up ML-like order</p></blockquote><p>对 Javascript 历史感兴趣的同学可以看看 Brendan 本人的自述：</p><ul><li><a href="https://brendaneich.com/2011/06/new-javascript-engine-module-owner/" target="_blank" rel="noopener">https://brendaneich.com/2011/06/new-javascript-engine-module-owner/</a></li></ul><h2 id="Python-中的变量作用域"><a href="#Python-中的变量作用域" class="headerlink" title="Python 中的变量作用域"></a>Python 中的变量作用域</h2><p>准确来说，Python 里面有四种作用域：<code>function</code>, <code>module</code>, <code>global</code>和 <code>class</code> 作用域。由于 Python 不区分变量的声明，所以在第一次初始化变量时（必须为赋值操作）将变量加入当前环境中。如果在没对变量进行初始化的情况下使用该变量就会报运行时异常，但如果仅仅是访问（并不赋值）的情况下，查找变量的顺序会按照 LEGB 规则 (Local, Enclosing, Global, Built-in)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"hello"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    s += <span class="string">"world"</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># UnboundLocalError: local variable 's' referenced before assignment</span></span><br></pre></td></tr></table></figure><p>由于在函数 foo 中在没有对 s 初始化的情况下使用了该值，所以这里会报异常，解决的办法就是使用 global 关键字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"hello"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> s</span><br><span class="line">    s += <span class="string">" world"</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># return "hello world"</span></span><br></pre></td></tr></table></figure></p><p>但由于 global 关键字只能限定在<code>global</code>作用域内查找变量，在有嵌套定义的时候就有问题了，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="string">"hello"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> s     <span class="comment"># NameError: global name 's' is not defined</span></span><br><span class="line">        s += <span class="string">" world"</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line">foo()()</span><br></pre></td></tr></table></figure></p><p>Python 3 中引入了 <code>nonlocal</code> 关键字来解决这个问题，：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="string">"hello"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> s</span><br><span class="line">        s += <span class="string">" world"</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line">foo()()   <span class="comment"># return "hello world"</span></span><br></pre></td></tr></table></figure></p><p>在 Python 2 中，我们可以通过引入一可变容器解决（其实就是绕过直接修改 <code>s</code> 的值）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    s = [<span class="string">"hello"</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        s[<span class="number">0</span>] += <span class="string">" world"</span></span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line">foo()()   <span class="comment"># return "hello world"</span></span><br></pre></td></tr></table></figure></p><h3 id="类级别作用域"><a href="#类级别作用域" class="headerlink" title="类级别作用域"></a>类级别作用域</h3><p>还是先看代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    username = <span class="string">"Foo"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Hello %s"</span> % username</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">foo.say_hello()  <span class="comment"># NameError: global name 'username' is not defined</span></span><br></pre></td></tr></table></figure></p><p><code>username</code>是定义在<code>Foo</code>类级别的，内部的<code>say_hello</code>方法在查找自由变量<code>username</code>的作用域会按照上面说的LEGB 规则 (Local, Enclosing, Global, Built-in)，并不会去查找类级别作用域的变量，所以这里会报错。修改的方法也很简单：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello %s"</span> % Foo.username</span><br></pre></td></tr></table></figure></p><p>可以看到，Python 在试图省略掉变量声明的同时，反而造成了更复杂的情况，相关讨论在 Python mail-list 里面讨论也很火热，有兴趣的读者可以参考：</p><ul><li><a href="http://legacy.python.org/dev/peps/pep-3104/" target="_blank" rel="noopener">PEP 3104 – Access to Names in Outer Scopes</a></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>还是先看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add3 = add(<span class="number">3</span>);</span><br><span class="line">alert(add3(<span class="number">4</span>));  <span class="comment">// return 7</span></span><br></pre></td></tr></table></figure><p>这里的<code>add3</code>就是一闭包对象，它包括两部分，一个<code>函数</code>与声明函数时的<code>环境</code>。这就是闭包的核心，没有任何神奇的地方，闭包就是解决自由变量作用域的问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="noopener">JavaScript Scoping and Hoisting</a></li><li><a href="http://dmitrysoshnikov.com/notes/note-4-two-words-about-hoisting/" target="_blank" rel="noopener">Note 4. Two words about “hoisting”</a></li><li><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/" target="_blank" rel="noopener">ES6 In Depth: let and const</a></li><li><a href="https://docs.python.org/3.5/reference/executionmodel.html#interaction-with-dynamic-features" target="_blank" rel="noopener">The Python Language Reference 4. Execution model</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你写过 javascript，应该听说过&lt;a href=&quot;https://en.wikipedia.org/wiki/JavaScript_syntax#hoisting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;变量提升&lt;/a&gt;（hoisting
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="JavaScript" scheme="http://liujiacai.net/tags/javascript/"/>
    
      <category term="Python" scheme="http://liujiacai.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SICP 第五章总结</title>
    <link href="http://liujiacai.net/blog/2016/05/21/sicp-chapter5-summary/"/>
    <id>http://liujiacai.net/blog/2016/05/21/sicp-chapter5-summary/</id>
    <published>2016-05-21T08:04:15.000Z</published>
    <updated>2019-12-24T10:59:14.605Z</updated>
    
    <content type="html"><![CDATA[<p>经过第四章元语言抽象的洗礼，我们已经能够深谙编译器内部的原理，核心就是<code>eval-apply</code>循环，只是说基于这个核心可以有各种延伸，像延迟求值、amb 不定选择求值、逻辑求值等等，有了这层的理解，我们应该能够透过各种花哨的<a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener">语法糖</a>，看出其本质来，像 Node.js 中的 Promise、 Python 中的 coroutine，都是 <a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="noopener">continuation</a> 的一种应用而已。</p><p>但是，我们还无法解释子表达式的求值怎样返回一个值，以便送给使用这个值的表达式，也无法解释为什么有些递归过程能产生迭代型的计算过程，而另一些递归过程却生产递归型的计算。就其原因，是因为我们所实现的求值器是 Scheme 程序，它继承并利用了基础系统的控制结构。要想进一步理解 Scheme 的控制结构，必须转到更低的层面，研究更多细节，而这些，就是第五章的主要内容。</p><h2 id="寄存器机器的设计"><a href="#寄存器机器的设计" class="headerlink" title="寄存器机器的设计"></a>寄存器机器的设计</h2><p>为了探讨底层的控制结构，本章基于传统计算机的一步一步操作，描述一些计算过程，这类计算机称为寄存器机器，它的主要功能就是<code>顺序的</code>执行一条条指令，操作一组存储单元。本章不涉及具体机器，还是研究一些 Scheme 过程，并考虑为每个过程设计一个特殊的寄存器机器。</p><p>第一步工作像是设计一种硬件体系结构，其中将：</p><ol><li>开发一些机制支持重要程序结构，如递归，过程调用等</li><li>设计一种描述寄存器机器的语言</li><li>做一个 Scheme 程序来解释用这种语言描述的机器</li></ol><p>寄存器机器包含<code>数据通路(寄存器和操作)</code>和确定操作顺序的<code>控制器</code>。书中以 gcd 算法为例介绍：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">gcd</span></span> a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> b <span class="number">0</span>)</span><br><span class="line">    a</span><br><span class="line">    (<span class="name"><span class="builtin-name">gcd</span></span> b (<span class="name">remainer</span> a b))))</span><br></pre></td></tr></table></figure><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB280XDppXXXXXWXXXXXXXXXXXX_!!581166664.png" alt="GCD 数据通路"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2S63.pXXXXXXXXpXXXXXXXXXX_!!581166664.png" alt=" GCD 控制器"><br></center><p>为了描述复杂的过程，书中采用如下的语言来描述寄存器机器：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">controller</span></span><br><span class="line">  test-b</span><br><span class="line">    (<span class="name">test</span> (<span class="name">op</span> =) (<span class="name">reg</span> a) (<span class="name">const</span> <span class="number">0</span>))</span><br><span class="line">    (<span class="name">branch</span> (<span class="name">label</span> gcd-done))</span><br><span class="line">    (<span class="name">assign</span> <span class="literal">t</span> (<span class="name">op</span> rem) (<span class="name">reg</span> a) (<span class="name">reg</span> b))</span><br><span class="line">    (<span class="name">assign</span> a (<span class="name">reg</span> b))</span><br><span class="line">    (<span class="name">assign</span> b (<span class="name">reg</span> <span class="literal">t</span>))</span><br><span class="line">    (<span class="name">goto</span> (<span class="name">label</span> test-b))</span><br><span class="line">  gcd-done)</span><br></pre></td></tr></table></figure></p><h3 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h3><p>直接带入更基本操作的结构，可能使控制器变得非常复杂，希望能够作出某种安排，维持机器的简单性，而且避免重复的结构，比如如果机器两次用GCD，最好公用一个 GCD 部件，这是可行的，因为任一时刻，只能进行一个 GCD 操作，只是输入输出的寄存器不一样而已。思路：</p><blockquote><p>调用 GCD 代码前把一个寄存器(如 continue)设置为不同的值,在 GCD 代码的出口根据该寄存器跳到正确位置</p></blockquote><p>具体代码与图示可参考：<a href="https://github.com/jiacai2050/sicp/blob/master/2016-05/2015-05-12_subroutes.md" target="_blank" rel="noopener">2015-05-12_subroutes.md</a></p><h3 id="采用堆栈实现递归"><a href="#采用堆栈实现递归" class="headerlink" title="采用堆栈实现递归"></a>采用堆栈实现递归</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(define (factorial <span class="built_in">n</span>)</span><br><span class="line">  (<span class="built_in">if</span> (= <span class="built_in">n</span> <span class="number">1</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    (* <span class="built_in">n</span> (factorial (- <span class="built_in">n</span> <span class="number">1</span>)))))</span><br><span class="line">```    </span><br><span class="line">表面看计算阶乘需要嵌套的无穷多部机器,但任何时刻只用一部。要想 用同一机器完成所有计算,需要做好安排,在遇到子问题时中断当前计算,解决子问题后回到中断的原计算。注意<span class="symbol">:</span></span><br><span class="line"></span><br><span class="line">- 进入子问题时的状态与处理原问题时不同(如 <span class="built_in">n</span> 变成 <span class="built_in">n</span>-<span class="number">1</span>)</span><br><span class="line">- 为了将来能继续中断的计算,必须保存当时状态(当时 <span class="built_in">n</span> 的值)</span><br><span class="line"></span><br><span class="line">控制问题<span class="symbol">:</span>子程序结束后应该返回哪里？</span><br><span class="line"></span><br><span class="line">- continue 里保存返回位置,递归使用同一机器时也要用这个寄存 器,给它赋了新值就会丢掉当时保存其中准备返回的位置</span><br><span class="line">- 为了能正确返回,调用前也需要把 continue 的值入栈</span><br><span class="line"></span><br><span class="line">阶乘算法的具体解释与图示可参考：[<span class="number">2016</span>-<span class="number">05</span>-<span class="number">16</span>_recursion_stack.md](htt<span class="symbol">ps:</span>//github.com/jiacai2050/sicp/blob/master/<span class="number">2016</span>-<span class="number">05</span>/<span class="number">2016</span>-<span class="number">05</span>-<span class="number">16</span>_recursion_stack.md)</span><br><span class="line"></span><br><span class="line">这里比较难理解的是 fib 算法，因为这里涉及到两次递归调用：</span><br></pre></td></tr></table></figure><p>(define (fib n)<br>  (if (&lt; n 2)<br>    n<br>    (+ (fib (- n 1))<br>       (fib (- n 2)))))</p><p>(controller<br>  (assign continue (label fib-done))<br>fib-loop<br>  (test (op &lt;) (reg n) (const 2))<br>  (branch (label immediate-answer))<br>  ;; set up to compute Fib(n-1)<br>  (save continue)<br>  (assign (continue (label afterfib-n-1))<br>  (save n)                                ; save old value of n<br>  (assign n (op -) (reg n) (const 1)))    ; clobber n to n-1<br>  (goto (label fib-loop))                 ; perform recursive call<br>afterfib-n-1                              ; upon return, val contains Fib(n-1)<br>  (restore n)<br>  (restore continue)<br>  ;; set up to compute Fib(n-2)<br>  (assign n (op -) (reg n) (const 2))<br>  (save continue)<br>  (assign continue (label afterfib-n-2))<br>  (save val)                               ; save Fib(n-1)<br>  (goto (label fib-loop))<br>afterfib-n-2                               ; upon return, val contains Fib(n-2)<br>  (assign n (reg val))                     ; n now contains Fib(n-2)<br>  (restore val)                            ; val now contains Fib(n-1)<br>  (restore continue)<br>  (assign val (op +) (reg val) (reg n))    ; return to caller, answer is in val<br>  (goto (reg continue))<br>immediate-answer<br>  (assign val (reg n))                     ; base case: Fib(n) = n<br>  (goto (reg continue))<br>fib-done)</p><p>;; afterfib-n-1 中先把 continue 释放，然后又保存起来，中间什么操作也没有<br><code>`</code></p><p><a href="https://github.com/jiacai2050/sicp/blob/master/exercises/05/5.6.scm" target="_blank" rel="noopener">习题5.6</a>、<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/05/5.11.md" target="_blank" rel="noopener">习题5.11</a> 对这一算法进行了分析与修改，建议大家看看。</p><h2 id="一个寄存器机器模拟器"><a href="#一个寄存器机器模拟器" class="headerlink" title="一个寄存器机器模拟器"></a>一个寄存器机器模拟器</h2><p>这是5.2小节的内容，主要是用一种寄存器机器语言（即上面描述 gcd、fib 的语言）描述的机器构造一个模拟器。这一模拟器是一个 Scheme 程序，采用第三章介绍的消息传递的编程风格，将模拟器封装为一个对象，通过给它发送消息来模拟运行。</p><p>这一模拟器的代码主要可以分为两部分：<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/05/lib/assemble.scm" target="_blank" rel="noopener">assemble.scm</a>、<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/05/lib/machine.scm" target="_blank" rel="noopener">machine.scm</a>，有需要的可以结合书中解释看看。</p><p>这里让我为之惊叹的一点是，本书作者采用之前一贯的风格，用 Scheme 实现了一台寄存器机器，和第四章中各种解释器一样，通过层层数据抽象，让你觉得计算机也没那么深不可测，也是可以通过基本过程构造出来的。</p><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><p>为了实现 Scheme 解释器,还需要考虑表结构的表示和处理（5.3节内容）：</p><ul><li>需要实现基本的表操作</li><li>实现作为运行基础的巧妙的存储管理机制 后面讨论有关的基础技术(可能简单介绍)</li></ul><p>有了基本语言和存储管理机制之后,就可以做出一部机器（5.4节内容）,它能</p><ul><li>实现第四章介绍的元循环解释器</li><li>而且为解释器的细节提供了清晰的模型</li></ul><p>这一章的最后（5.5节内容）讨论和实现了一个编译器</p><ul><li>把 Scheme 语言程序翻译到这里的寄存器机器语言</li><li>还支持解释代码和编译代码之间的连接,支持动态编译等</li></ul><p>这里由于时间与精力的缘故，最后三小节没有进行细致的阅读，在将来需要时再回来阅读。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于到了这一天，历时一年多，终于还是把这本书看完了，算是了了一个心结，大概在大三的时候就知道了这本书，算算到现在完整的看完，有四年时间了。在最近这一年中，这本书带给我了无数的灵感与启发，这种感觉真的无法描述，只有你亲自体会。</p><p>此时此刻印象最深的有两点：</p><ul><li>对现实世界中时间与空间的模拟，没有最优解，不管是延时求值的流还是封装属性的对象，都有其局限性。也可能是我们人类对世界的认识还不够。摘抄书中P219一段话：</li></ul><blockquote><p>从本质上看，在并发控制中，任何时间概念都必然与通信有内在的密切联系。有意思的是，时间与通信之间的这种联系也出现在相对论里，在那里的光速（可能用于同步事件的最快信号）是与时间和空间有关的基本常量。在处理时间和状态时，我们在计算模型领域所遭遇的复杂性，事实上，可能就是物理世界中最基本的复杂性的一种反映。</p></blockquote><ul><li>深刻认识了<code>计算</code>二字的含义，明白了计算机的局限性（<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/04/4.15.md" target="_blank" rel="noopener">停机问题</a>），并不是所有问题都有解的；</li></ul><p>当然，并不是说看完这本书就是“武林高手”了，今后还是要在不断实践中总结、积累，成为一位真正的 hacker。</p><p>好了，今天写到这里，作为万里长城的一个终点。😊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过第四章元语言抽象的洗礼，我们已经能够深谙编译器内部的原理，核心就是&lt;code&gt;eval-apply&lt;/code&gt;循环，只是说基于这个核心可以有各种延伸，像延迟求值、amb 不定选择求值、逻辑求值等等，有了这层的理解，我们应该能够透过各种花哨的&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="研习经典" scheme="http://liujiacai.net/categories/%E7%A0%94%E4%B9%A0%E7%BB%8F%E5%85%B8/"/>
    
    
      <category term="sicp" scheme="http://liujiacai.net/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>SICP 第四章总结</title>
    <link href="http://liujiacai.net/blog/2016/04/23/sicp-chapter4-summary/"/>
    <id>http://liujiacai.net/blog/2016/04/23/sicp-chapter4-summary/</id>
    <published>2016-04-23T11:50:56.000Z</published>
    <updated>2019-12-24T10:59:14.605Z</updated>
    
    <content type="html"><![CDATA[<p>本书的前三章分别讨论了<code>数据抽象</code>、<code>过程抽象</code>、<code>模块化</code>三种程序设计的技术，这些都是编程的问题，一直采用的是 Scheme 作为编程语言。如果遇到的问题更复杂，或者需要解决某领域的大量问题，有可能发现现实可用的语言(Lisp，或其他)都不够满意或不够方便，因此第四章主要就是讲述如何设计和实现一门新语言。</p><p>第四章首先介绍了一个解释器（本书中文翻译为“求值器”）最核心的部分（eval与apply），然后基于这个核心，做了一系列的扩展，下面让我们一起回顾总结下。</p><h2 id="元语言抽象"><a href="#元语言抽象" class="headerlink" title="元语言抽象"></a>元语言抽象</h2><p>4.1 小节告诉我们<code>语言的解释器自身也是一个过程</code>而已，送给它的输入是相应语言的表达式（即程序），它就会完成该表达式要求做的动作。所以我们完全可以用 Scheme 写出一个 Scheme 的解释器，学习求值器实现，有助于理解语言本身和语言实现中的问题。而且  Scheme 语言有强大的符号处理能力，特别适合用于做这种工作。</p><p>在阅读4.1章节之前，我用 Java 尝试实现了一个 Scheme 解释器 JCScheme，之前也写过<a href="/blog/2015/10/03/first-toy-scheme/">文章</a>介绍，最核心的就是下面两个过程：</p><ul><li>eval 在一个环境里的求值一个表达式</li><li>apply 将一个过程对象应用于一组实际参数</li></ul><p><center><br>    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB2KjMVfFXXXXbOXpXXXXXXXXXX_!!581166664.png" alt="SICP-eval-apply"><br></center><br>eval、apply 这两个规则描述了求值过程的核心部分，这是任何解释器的基本循环。在这一循环中</p><blockquote><p>表达式在环境中的求值被规约到过程对实际参数的应用，而这种应用又被规约到新的表达式在新的环境中的求值，如此下去，直到下降到符号（其值可以在环境中找到）或者基本过程（它们可以直接应用）。</p></blockquote><p>后面的 amb 解释器、查询语言的解释器都是在这个基本循环的基础上改造来的。</p><h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><p>4.1.5 小节中，将程序看成一种抽象的机器的一个描述，按照这种观点，求值器可以看作一部非常特殊的机器，它要求以一部机器的描述作为输入，给定了一个输入后，求值器就能够规划自己的行为，模拟被描述机器的执行过程。</p><p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2PWTZnFXXXXaRXXXXXXXXXXXX_!!581166664.png" alt=" evaluator_machine"><br></center><br>这里的深刻思想是：</p><blockquote><p>任一求值器都能够模拟其他的求值器</p></blockquote><p>这样，有关“原则上说什么可以计算（忽略掉时间与空间的实践性问题）”的概念就是与语言或者计算机无关了，它反映的是一个有关<code>可计算性</code>的基本概念。图灵1936年的论文阐述了这个问题，并声称：</p><blockquote><p>任何“有效过程”都可以描述为这种机器的一个程序</p></blockquote><p>而后图灵实现了一台通用机器，即一台图灵机，其行为就像是所有图灵机程序的求值器。</p><p>这一求值器是违反直觉的，因为它是由一个相对简单的过程实现，却能去模拟可能比求值器本身还复杂的各种程序，通用求值器的存在是计算的一种深刻而美妙的性质。递归论是数理逻辑的一个分支，这一理论研究计算的逻辑极限，<a href="https://book.douban.com/subject/1291204/" target="_blank" rel="noopener">《GEB》</a>里也探讨了一些思想，有兴趣的可以把这本书加入书单。</p><p>其他领域中也有这种通用功能的东西，像电子书、音乐播放器等都属于“专用的通用设备”，计算机（一个编程语言就是一种抽象的计算机）比它们更进一步：它能模拟自己。</p><p>这里比较有意思的是<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/04/4.15.md" target="_blank" rel="noopener">习题4.15</a>的停机问题，本小节所有解释器的代码可以参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/04/lib/main.scm" target="_blank" rel="noopener">main.scm</a>。</p><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>4.1.7小节中将语法分析与执行分开，这里的做法类似于高级语言的解释和编译：</p><ul><li>直接解释,就是一遍遍分析程序代码,实现其语义。例如最早的 BASIC 语言实现</li><li>编译把实现程序功能的工作分为两步:<ul><li>通过一次分析生成一个可执行的程序</li><li>在此之后可以任意地多次执行这个程序    </li></ul></li></ul><p>这里做的是从 Scheme 源程序(元循环解释器/求值器处理的“数据”)到 Scheme 可执行程序的翻译，这是一种 <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">Just In-time Translation，JIT(即时翻译)</a>，目前成熟的Java虚拟机都采用这种技术来提高执行效率。在实际中应用,还需进一步考虑整体效率问题。</p><h2 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h2><p>4.1 小节实现的求值器采用的应用序求值（过程应用之前完成对所有参数的求值），4.2 小节修改之前的求值器，使之能够按照正则序求值，也称为惰性求值。惰性求值的可以用来实现第三章介绍的流，而且也可以避免下面的问题：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">(define</span> <span class="string">(try</span> <span class="string">a</span> <span class="string">b)</span></span><br><span class="line">  <span class="string">(if</span> <span class="string">(=</span> <span class="string">a</span> <span class="number">0</span><span class="string">)</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="string">b))</span></span><br><span class="line"></span><br><span class="line"><span class="string">(try</span> <span class="number">0</span> <span class="string">(/</span> <span class="number">1</span> <span class="number">0</span><span class="string">))</span></span><br><span class="line"><span class="comment"># 如果采用正则序，这里不会抱错，因为 try 函数中根本就没用的b的值</span></span><br></pre></td></tr></table></figure></p><p>这里要做的修改不是很多，只是在过程的参数上包一层，加一个<code>trunk</code>，真正需要计算时在求值，核心代码可以参考 <a href="https://github.com/jiacai2050/sicp/blob/master/exercises/04/lib/trunk.scm" target="_blank" rel="noopener">trunk.scm</a>，此外，处于性能方便的考虑，一般会对求过的参数进行缓存。</p><p>我自己实现的 JCScheme 也支持这种正则序求值，感兴趣的<a href="https://github.com/jiacai2050/JCScheme/tree/normal-order" target="_blank" rel="noopener">参考</a>。</p><h2 id="amb-非确定性计算"><a href="#amb-非确定性计算" class="headerlink" title="amb 非确定性计算"></a>amb 非确定性计算</h2><p>amb 的名字来自 ambiguous(歧义,多义)，4.3小节在 Scheme 里扩充非确定性计算功能。非确定性计算里最关键的思想：</p><ul><li>允许一个表达式有多个可能的值</li><li><p>在求值这种表达式时,求值器可以自动选出一个值<br>  可能从可以选的值中任意选出一个。还需要维持与选择相关的轨迹(知道哪些元素已经选过,哪些没选过。在后续计算中要保证不出现重选的情况)</p></li><li><p>如果已做选择不能满足后面的要求,求值器就会回到有关的表里再 次选择,直至求值成功;或者所有选择都已用完时求值失败</p></li></ul><p>非确定性计算的过程将通过求值器自动进行的搜索实现，选择和重新选择的方法和实际过程都隐藏在求值器的实现里,程序员不需要关心,不需要做任何与之相关的事情，这一修改的意义深远,语言扩充了,语义有重要改变。</p><h3 id="非确定性计算与流处理"><a href="#非确定性计算与流处理" class="headerlink" title="非确定性计算与流处理"></a>非确定性计算与流处理</h3><p>非确定性求值和流处理有相似的地方，现在比较一下非确定性求值和流处理中时间的表现形式：</p><ul><li><p>流处理中,通过惰性求值,松解潜在的(有可能是无穷的)流和流元素 的实际产生时间之间的紧密联系</p><ul><li>造成的假象是整个流似乎都存在</li><li>元素的产生并没有严格的时间顺序</li></ul></li><li><p>非确定性计算的表达式表示对一批“可能世界”的探索</p><ul><li>每个世界由一串选择确定</li><li>求值器造成的假相：时间好像能分叉</li><li>求值器保存着所有可能的执行历史</li><li>计算遇到死路时退回前面选择点转到另一分支,换一个探索空间</li></ul></li></ul><h3 id="continuation-继续"><a href="#continuation-继续" class="headerlink" title="continuation 继续"></a>continuation 继续</h3><p>“继续”是一种过程参数，它总是在过程的最后一步调用。带有“继续”参数的过程不准备返回，过程的最后一步是调用某个“继续”过程。“继续”是“尾调用”,调用过程的代码已经全部执行完毕。</p><p>amb 分析器产生的执行过程要求三个参数：</p><ul><li>一个环境</li><li>一个成功继续</li><li>一个失败继续</li></ul><p>执行过程的体求值结束前的最后一步总是调用这两个过程之一</p><ul><li>如果求值工作正常完成并得到结果,就调用由“成功继续”参数 得到的那个过程</li><li>如果求值进入死胡同,就调用“失败继续”参数过程</li></ul><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (<span class="name">env</span> succeed fail)</span><br><span class="line">  <span class="comment">;; succeed is a (lambda (value fail) ...)</span></span><br><span class="line">  <span class="comment">;; fail is a (lambda () ...)</span></span><br><span class="line">...)</span><br></pre></td></tr></table></figure><p>这里需要注意的是要恢复破坏性操作(如赋值等),必须设法保存恢复信息。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-assignment</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">var</span> (<span class="name">assignment-variable</span> exp))</span><br><span class="line">        (<span class="name">vproc</span> (<span class="name">analyze</span> (<span class="name">assignment-value</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">vproc</span> env</span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (val fail2)</span><br><span class="line">               (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">old-value</span> (<span class="name">lookup-variable</span> var env)))</span><br><span class="line">                 (<span class="name">set-variable-value!</span> var val env)</span><br><span class="line">                 (<span class="name">succeed</span> <span class="symbol">'ok</span></span><br><span class="line">                          (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                            (<span class="name">set-variable-value!</span> var</span><br><span class="line">                                                 old-value</span><br><span class="line">                                                 env)</span><br><span class="line">                            (<span class="name">fail2</span>)))))</span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure></p><p>amb 求值器的完整代码可以参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/04/lib/main-amb.scm" target="_blank" rel="noopener">main-amb.scm</a>。</p><h2 id="逻辑程序设计"><a href="#逻辑程序设计" class="headerlink" title="逻辑程序设计"></a>逻辑程序设计</h2><p>本书一开始就强调了：</p><blockquote><p>数学处理说明式知识；计算机科学处理命令式知识</p></blockquote><p>程序语言要求用算法的方式描述解决问题的过程，大多数程序语言要求用定义数学函数的方式组织程序：</p><ul><li>程序要描述“怎么做”的过程</li><li>所描述的计算有明确方向,从输入到输出</li><li>描述经计算的表达式,给出了从一些值算出结果的方法(和过程) </li><li>定义过程描述如何从参数计算出结果</li></ul><p>但是也有例外，第三章介绍的约束传递系统中的计算对象是约束关系,没有明确计算方向和顺序，它的基础系统要做很多工作以支持相应的计算。4.3小节的非确定性程序求值器里的表达式可有多个值,求值器设法根据表达式描述的关系找出满足要求的值。</p><p>逻辑程序设计可看作上面想法的推广，一个“是什么”的描述可能蕴涵许多“怎样做”的过程。考虑 append:<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">append</span></span> x y)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> x)</span><br><span class="line">    y</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> x) (<span class="name"><span class="builtin-name">append</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> x) y))))</span><br></pre></td></tr></table></figure></p><p>可认为,这个程序表达了两条规则:</p><ol><li>对任何一个表 <code>y</code>，空表与其拼接得到的表是 <code>y</code> 本身</li><li>任何表 <code>u</code>, <code>v</code>, <code>y</code>, <code>z</code>，<code>(cons u v)</code> 与 <code>y</code> 拼接得到 <code>(cons u z)</code> 的条件是 ￼<code>v</code>与<code>y</code>的拼接得到<code>z</code></li></ol><p>append 的过程定义和上述两条规则都可以回答下面问题:</p><ul><li>找出<code>(a b)</code>和<code>(c d)</code>的append</li></ul><p>这两条规则还可以回答(但 append 过程不行):</p><ul><li>找出一个表<code>y</code>使<code>(a b)</code>与它的拼接得到<code>(a b c d)</code></li><li>找出所有拼接起来将得到<code>(a b c d)</code>的表<code>x</code>和<code>y</code></li></ul><p>在逻辑式程序语言里,可以写出与上面两条规则直接对应的表达式,求值器可以基于它得到上面各问题的解。但各种逻辑语言(包括本小节介绍的)都有缺陷,简单提供“做什么” 知识 有时会使求值器陷入无穷循环,或产生了不是用户希望的行为，这个领域最新的方向是<a href="https://en.wikipedia.org/wiki/Constraint_programming" target="_blank" rel="noopener">constraint programming</a>。</p><h3 id="查询系统"><a href="#查询系统" class="headerlink" title="查询系统"></a>查询系统</h3><p>本系统所使用的语言为查询语言，该语言的三要素分别是：</p><ul><li><p><code>基本元素</code>，简单查询</p>  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    (job ?persion (computer programmer))</span><br><span class="line">    ```    </span><br><span class="line"></span><br><span class="line">- `组合手段`，复合查询</span><br></pre></td></tr></table></figure><p>  (and</p><pre><code>(job ?persion (computer programmer))(address ?persion ?where))</code></pre>  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `抽象手段`，规则</span><br></pre></td></tr></table></figure><p>  (rule ⟨conclusion⟩ ⟨body⟩)</p><p>  (rule (lives-near ?persion-1 ?persion-2)</p><pre><code>(and (address ?persion-1 (?town . ?rest-1))     (address ?persion-2 (?town . ?rest-2))     (not (same ?persion-1 ?persion-2))))</code></pre>  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以认为一条规则表示了很大(甚至无穷大)的一集断言,其元素是 由 `&lt;conclusion&gt;` 求出的所有满足 `&lt;body&gt;` 的赋值。对简单查询,如果其中变量的某个赋值满足某查询模式,那么用这个赋值实例化模式得到的断言一定在数据库里但满足规则的断言不一定实际存在在数据库里(推导出的事实)。</span><br><span class="line"></span><br><span class="line">### 将逻辑看作程序</span><br><span class="line"></span><br><span class="line"><span class="title">规则可看作逻辑蕴涵式:</span>若对所有模式变量的赋值能满足一条规则的体, 则它就满足其结论。可认为查询语言就是基于规则做逻辑推理。还是用 `append` 为例：</span><br></pre></td></tr></table></figure></li></ul><p>(rule (append-to-form () ?y ?y))<br>(rule (append-to-form (?u . ?v) ?y (?u . ?z))<br>  (append-to-form ?v ?y ?z))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有了上面的规则，可以做许多查询</span><br></pre></td></tr></table></figure></p><p>;;; Query input:<br>(append-to-form (a b) (c d) ?z)<br>;;; Query results:<br>(append-to-form (a b) (c d) (a b c d))</p><p>;;; Query input:<br>(append-to-form (a b) ?y (a b c d))<br>;;; Query results:<br>(append-to-form (a b) (c d) (a b c d))</p><p>;;; Query input:<br>(append-to-form ?x ?y (a b c d))<br>;;; Query results:<br>(append-to-form () (a b c d) (a b c d))<br>(append-to-form (a) (b c d) (a b c d))<br>(append-to-form (a b) (c d) (a b c d))<br>(append-to-form (a b c) (d) (a b c d))<br>(append-to-form (a b c d) () (a b c d))</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这些例子展示了不同方向的计算,正是前面提出希望解决的问题。</span><br><span class="line"></span><br><span class="line">### 查询系统原理</span><br><span class="line"></span><br><span class="line">查询系统的组织围绕着两个核心操作：</span><br><span class="line"></span><br><span class="line">- `模式匹配(pattern match)`，操作实现简单查询和复合查询</span><br><span class="line">- `合一(unification)`，是模式匹配的推广,用于实现规则</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 逻辑程序设计和数理逻辑</span><br><span class="line"></span><br><span class="line">查询语言的组合符对应于常用逻辑连接词，查询操作看起来也具有逻辑 可靠性(例如，and 查询要经过两个子成分处理等)</span><br><span class="line">但这种对应关系并不严格，因为查询语言的基础是求值器，其中隐含着控制结构和控制流程，是采用过程的方式解释逻辑语句。</span><br><span class="line"></span><br><span class="line">这种隐含的控制结构我们有可能利用，例如,要找程序员的上司,下面两种写法都行:</span><br></pre></td></tr></table></figure><p>(and (job ?x (computer programmer))<br>     (supervisor ?x ?y))</p><p>(and (supervisor ?x ?y)<br>     (job ?x (computer programmer)))<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">如果公司里的有关上司关系的事实比有关程序员的事实更多,第一种写法的查询效率更高。</span><br><span class="line"></span><br><span class="line">逻辑程序设计的目标是开发一种技术,把计算问题分为“要计算什么”和 “怎样计算”两个相互独立的子问题,方法是:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>找出逻辑语言的一个子集,其</span><br><span class="line"><span class="bullet">    - </span>功能足够强,足以描述人们想考虑的某类计算</span><br><span class="line"><span class="bullet">    - </span>又不过分的强,有可能为它定义一种过程式的解释</span><br><span class="line"><span class="bullet">- </span>实现一个求值器(解释器),执行对用这种逻辑子集写出的规则和 断言的解释(实现其语义,形式上是做推理)</span><br><span class="line"></span><br><span class="line">上面提出的两方面性质保证了逻辑程序设计语言程序的有效性。</span><br><span class="line"></span><br><span class="line">本小节的查询语言是这种想法的一个具体实施:</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>查询语言是数理逻辑的一个可以过程式解释的子集</span><br><span class="line"><span class="bullet">- </span>一个断言描述一个简单事实</span><br><span class="line"><span class="bullet">- </span>一条规则表示一个蕴涵,能使规则体成立的情况都使结论成立</span><br><span class="line"><span class="bullet">- </span>规则有自然的过程式解释:要得到其结论,只需确定其体成立</span><br><span class="line"></span><br><span class="line"><span class="section">### not 问题</span></span><br></pre></td></tr></table></figure></p><p>(and (supervisor ?x ?y)<br>     (not (job ?x (computer programmer))))</p><p>(and (not (job ?x (computer programmer)))<br>     (supervisor ?x ?y))<br><code>`</code><br>这两个查询会得到不同结果(与逻辑里的情况不同)：</p><ul><li>第一个查询找出所有与 <code>(supervisor ?x ?y)</code> 匹配的条目，从得到的框架中删去 ?x 满足 <code>(job ?x (computer programmer))</code> 的框架</li><li>第二个查询从初始框架流(只包含一个空框架)开始检查能否扩展 出与 <code>(job ?x (computer programmer))</code> 匹配的框架。显然空框架可扩展，not 删除流中的空框架得到空流，查询最后返回空流</li></ul><p>逻辑程序语言里的 not 反映的是一种“封闭世界假说”，认为所有知识都包含在数据库里,凡是没有的东西其 not 都成立。这显然不符合形式化的数理逻辑,也不符合人们的直观推理。</p><p>查询语言的完整代码，可以参考<a href="https://github.com/jiacai2050/sicp/tree/master/exercises/04/lib/ql" target="_blank" rel="noopener">这里</a>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先恭喜我“完成”第四章，算算大概用了4个月，太多不定因素了，不过还好自己找到了当初的感觉，坚持了下来。</p><p>这一章的内容很多，毕竟是设计一门语言，而且还介绍了两种大变种，把书上的代码调通就要花好久，不过也确实开了眼界，通过最基本的eval、apply 循环扩展出了 amb 非确定性求值器与逻辑语言求值器，其实这章的难度并不大，只是涉及的内容广而已。</p><p>通过看完这章，发现了很多本质性的东西，像 Node.js 里面的 callback、Python 里面的 generator 不都是 continuation 的糖衣嘛，JIT 也不过尔尔，这章更偏向的是元编程领域，通过 <a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL</a> 来减轻业务代码的逻辑，想象如果语言本身就支持分布式事务，程序员要少写多少代码呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本书的前三章分别讨论了&lt;code&gt;数据抽象&lt;/code&gt;、&lt;code&gt;过程抽象&lt;/code&gt;、&lt;code&gt;模块化&lt;/code&gt;三种程序设计的技术，这些都是编程的问题，一直采用的是 Scheme 作为编程语言。如果遇到的问题更复杂，或者需要解决某领域的大量问题，有可能发现现实
      
    
    </summary>
    
      <category term="研习经典" scheme="http://liujiacai.net/categories/%E7%A0%94%E4%B9%A0%E7%BB%8F%E5%85%B8/"/>
    
    
      <category term="sicp" scheme="http://liujiacai.net/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>python, ruby, javascript 浅析</title>
    <link href="http://liujiacai.net/blog/2016/03/26/python-ruby-javascript/"/>
    <id>http://liujiacai.net/blog/2016/03/26/python-ruby-javascript/</id>
    <published>2016-03-26T09:03:40.000Z</published>
    <updated>2019-12-24T10:59:14.605Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在看红宝石（ruby）语言，到现在为止，算是对其设计有一些了解。作为一动态语言，ruby 经常会拿来与 python 对比，确实这两门语言在语法层面、实现层面有很多共同的地方，但是它们也在很多设计理念上存在重要差异，通过对比这些相同点、异同点，更加有助于理解这两门语言。同时，Node.js、React Native 的出现，将 javascript 这门“前端”语言推向了全栈，同样作为一门动态语言，javascript 与 ruby、python 在很多概念上也存在很多相同点、异同点。</p><p>本篇文章着重从编程语言设计的角度进行阐述，希望对编程语言爱好者理解这三门语言有所帮助，做到融会贯通。</p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2kVcxcByN.eBjSZFgXXXmGXXa_!!581166664.png" alt=" js_python_ruby"><br></center><h2 id="讨论范围"><a href="#讨论范围" class="headerlink" title="讨论范围"></a>讨论范围</h2><p>Python、Ruby、Javascript(ECMAScript) 准确说是一种语言规范，规范可以有多种实现，这体现在不同的解释器上。</p><ul><li>Python 的解释器主要有 CPython、IronPython、Jython、PyPy</li><li>Ruby 的解释器主要有 Ruby MRI(CRuby)、JRuby、MacRuby、IronRuby</li><li>Javascript 的解释器主要有 Chakra, SpiderMonkey, V8</li></ul><p>本文主要讨论的是 CPython、CRuby，它们是其语言作者亲自设计的，也是应用场景最广的。<br>Javascript 在语言设计之初根本没考虑到其应用范围会如此之广，所以相比其他语言，它语言内置的功能要弱很多，<a href="http://es6-features.org/" target="_blank" rel="noopener">ES6</a> 的出现就是为了解决这个问题，本文所涉及的 javascript 运行在基于 V8 引擎的 Node.js 中，且具备 ES6 语法。</p><h2 id="语言定义"><a href="#语言定义" class="headerlink" title="语言定义"></a>语言定义</h2><p>首先看一下 wikipedia 上对这三门语言的定义：</p><ul><li>Python is a widely used <code>high-level</code>, <code>general-purpose</code>, <code>interpreted</code>, <code>dynamic</code> programming language</li><li>Ruby is a <code>dynamic</code>, <code>reflective</code>, <code>object-oriented</code>, <code>general-purpose</code> programming language.</li><li>JavaScript is a <code>high-level</code>, <code>dynamic</code>, <code>untyped</code>, and <code>interpreted</code> programming language.</li></ul><p>其实上面标红的关键字对于这三门语言来说都适用，只是每个语言的强调点不一样而已。</p><p>通常会称这三门语言为<code>动态语言</code>，支持<code>函数式</code>、<code>面向对象</code>两种编程范式，这两点其实是最重要的。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p><code>既轻量又强大</code>是大多数动态语言相通的设计理念，关于 javascript 设计理念更多的介绍可以参考我的<a href="http://liujiacai.net/blog/2015/02/01/javascript-oop/#设计理念">这篇文章介绍</a>。至于 Python 与 Ruby 设计理念的区别，一句话即可概括：</p><ul><li>Python: 一件事情只有一种方法做</li><li>Ruby: 一件事情有多种方法做</li></ul><p>比如，Python 中 Tuple, Array, String 没有相应获取大小的方法，而是提供了统一的<code>len</code>来解决这个问题<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; len(<span class="string">"hello world"</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line">&gt;&gt;&gt; len((<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>至于 Ruby 的<code>一件事情有多种方法做</code>的理念，后面我在讲解 lambda 与字符串拼接时再介绍。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>如果你之前没接触过 ruby、python 的语法，推荐先去了解下：</p><ul><li>官方文档 <a href="https://www.ruby-lang.org/en/documentation/quickstart/" target="_blank" rel="noopener">Ruby in Twenty Minutes</a></li><li><a href="http://www.techotopia.com/index.php/Ruby_Essentials" target="_blank" rel="noopener">Ruby Essentials</a>，两个小时绝对看完了</li><li><a href="http://python-best-practice.liujiacai.net" target="_blank" rel="noopener">python 最佳实践</a>，应该用不了半个小时</li></ul><p>javascript 实在是太简单了，就不用特别看了。</p><p>综合来说，python、javascript 还是比较中规中矩的，即使 ES6 里面加了<a href="https://github.com/lukehoban/es6features" target="_blank" rel="noopener">很多花哨的语法糖衣</a>，但是也比较直观，但是 ruby 这个语言就比较变态了，各种符号，像<code>class Son &lt; Father</code>表示类的基础，<code>&quot;hello&quot; &lt;&lt; &quot; world&quot;</code>表示字符串的拼接，<code>@var</code>表示对象的成员变量，<code>@@var</code>表示类的成员变量，<code>$var</code>表示全局变量。</p><p>而且在 ruby 中，方法调用时的括号可有可无，即使有参数也可以省略：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; def add(a, b)</span><br><span class="line">&gt;     a + b</span><br><span class="line">&gt; end</span><br><span class="line">&gt;</span><br><span class="line">&gt; add <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">=&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>如果你对 Scheme 熟悉，上面的代码还能像下面这么写，是不是很亲切<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; (def add a, b</span><br><span class="line">&gt;     a + b</span><br><span class="line">&gt; end)</span><br><span class="line"></span><br><span class="line">&gt; (add <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">=&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>这也就是充分说明，括号在 ruby 中只是起到了“分割”的作用，并没有什么语法含义。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象主要的核心是用<code>对象</code>来达到数据封装的目的。</p><ul><li>javascript 基于原型链实现面向对象，更详细的介绍可以参考<a href="http://liujiacai.net/blog/2015/02/01/javascript-oop/">《javascript中的面向对象编程》</a></li><li>python、ruby 基于类来实现面向对象，和 java 类似，但是更纯粹些。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span></span>: return <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; type(func)</span><br><span class="line">&lt;type <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; func2 = lambda <span class="symbol">x:</span> x</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; type(func2)</span><br><span class="line">&lt;type <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; type(<span class="number">1</span>)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; dir(<span class="number">1</span>)</span><br><span class="line">[<span class="string">'__abs__'</span>, <span class="string">'__add__'</span>, .....]</span><br><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line">$ irb</span><br><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span></span></span><br><span class="line">&gt;    a + b</span><br><span class="line">&gt; <span class="keyword">end</span></span><br><span class="line">&gt; method(<span class="symbol">:add</span>)</span><br><span class="line">=&gt; #&lt;Method: Object#add&gt;</span><br><span class="line"><span class="comment"># 上面 ruby 的例子中，使用了 Symbol 来表示 add 方法，这是由于 ruby 中直接写 add 表示函数调用</span></span><br><span class="line">&gt; <span class="number">1</span>.methods</span><br><span class="line">=&gt; [<span class="symbol">:%</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:*</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:/</span>, .....]</span><br></pre></td></tr></table></figure><p>可以看到，在 python、ruby 中，像<code>1</code>这样的数字字面量也是对象。</p><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p>lambda 表达式表示的是匿名函数。由于在这三门语言中，函数均是一等成员，所以可以很方便的进行函数式编程<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">node</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">[1,2,3].map((x)</span> <span class="string">=&gt;</span> <span class="string">x</span> <span class="string">+</span> <span class="number">1</span><span class="string">)</span></span><br><span class="line"><span class="string">[</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span> <span class="string">]</span></span><br><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line"><span class="string">$</span> <span class="string">python</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span> <span class="string">map(lambda</span> <span class="attr">x:</span> <span class="string">x+1,</span> <span class="string">[1,2,3])</span></span><br><span class="line"><span class="string">[2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">]</span></span><br><span class="line"><span class="comment">#--------------------------------------------------#</span></span><br><span class="line"><span class="string">$</span> <span class="string">irb</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">[1,2,3].map</span> <span class="string">&amp;(lambda</span> <span class="string">&#123;|x|</span> <span class="string">x+1&#125;)</span></span><br><span class="line"> <span class="string">=&gt;</span> <span class="string">[2,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">]</span></span><br></pre></td></tr></table></figure></p><p>Python 的 lambda 表达式是这三者中最弱的一个，只能包含一个表达式，javascript 与 ruby 的则没有这种限制。</p><p>细心的读者会发现上面 ruby 版本的 lambda 前有个<code>&amp;</code>，这是必须的，否则会报下面的错误<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ArgumentError:</span> <span class="string">wrong</span> <span class="string">number</span> <span class="string">of</span> <span class="string">arguments</span> <span class="string">(given</span> <span class="number">1</span><span class="string">,</span> <span class="string">expected</span> <span class="number">0</span><span class="string">)</span></span><br></pre></td></tr></table></figure></p><p>这是因为在 ruby 中，方法除了接受参数外，还可以接受一个代码块(block)，代码块在 ruby 中有两种写法：</p><ul><li>一行的话用<code>{}</code></li><li>多行的话用<code>do ... end</code>    <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].each &#123; |num| print <span class="string">"#&#123;num&#125;! "</span> &#125;</span><br><span class="line"><span class="number">1</span>! <span class="number">2</span>! <span class="number">3</span>!</span><br><span class="line">=&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].each do |num|</span><br><span class="line">&gt;    print <span class="string">"#&#123;num&#125;!"</span></span><br><span class="line">&gt; end</span><br><span class="line"><span class="number">1</span>! <span class="number">2</span>! <span class="number">3</span>!</span><br><span class="line"> =&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]         # Identical to the first case.</span><br></pre></td></tr></table></figure></li></ul><p><code>&amp;</code> 的作用是告诉解释器，现在传入的不是正常的参数，而是一个代码块。这个传入的代码块在方法内通过<code>yield</code>进行调用。这里可以做个演示：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_each</span></span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="keyword">self</span>.size</span><br><span class="line">        <span class="keyword">yield</span>(<span class="keyword">self</span>[i])  </span><br><span class="line">        i+=<span class="number">1</span>      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].my_each &#123; <span class="params">|num|</span> print <span class="string">"<span class="subst">#&#123;num&#125;</span>!"</span> &#125;</span><br><span class="line"><span class="number">1</span>! <span class="number">2</span>! <span class="number">3</span>!</span><br><span class="line">=&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>Ruby 中 lambda 表达式属于 <a href="http://ruby-doc.org/core-2.2.0/Proc.html" target="_blank" rel="noopener">Proc 类型</a>，<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; lambda &#123;|x| x&#125;.class</span><br><span class="line">=&gt; Proc</span><br></pre></td></tr></table></figure></p><p>这里可以看到，只是对于闭包的支持，Ruby 就提供了多种方案。更多可以参考：</p><ul><li><a href="http://www.eriktrautman.com/posts/ruby-explained-blocks-procs-and-lambdas-aka-closures" target="_blank" rel="noopener">Ruby Explained: Blocks, Procs, and Lambdas, aka “Closures”</a></li><li><a href="https://blog.newrelic.com/2015/04/30/weird-ruby-part-4-code-pods/" target="_blank" rel="noopener">Weird Ruby Part 4: Code Pods (Blocks, Procs, and Lambdas)</a></li></ul><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>就像上面说的，ruby 中 <code>yield</code> 就是表示代码块的调用，没有其他含义。而在 python 与 javascript <code>yield</code> 是用来构造<a href="https://wiki.python.org/moin/Generators" target="_blank" rel="noopener">生成器（generator）</a>的，都是用来控制程序运行流程，相当于用户态的“线程”：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">def iter():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">yield</span> x</span><br><span class="line"></span><br><span class="line">foo = iter()</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">next</span>(foo)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">next</span>(foo)</span><br><span class="line">#<span class="comment">--------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">$ node</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iter</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="built_in">yield</span> i</span><br><span class="line">&#125;</span><br><span class="line">var foo = iter()</span><br><span class="line">console.<span class="built_in">log</span>(foo.<span class="built_in">next</span>().value)</span><br><span class="line">console.<span class="built_in">log</span>(foo.<span class="built_in">next</span>().value)</span><br></pre></td></tr></table></figure></p><p>上面两份代码都依次打印出<code>0</code>, <code>1</code>。</p><p>关于生成器的更多资料，可以参考：</p><ul><li><a href="https://strongloop.com/strongblog/how-to-generators-node-js-yield-use-cases/" target="_blank" rel="noopener">Generators in Node.js: Common Misconceptions and Three Good Use Cases</a></li><li><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf" target="_blank" rel="noopener">More details on Python generators and coroutines</a>（强烈推荐 Python 读者看）</li></ul><p>在 ruby 中，与生成器对应的概念是 <a href="http://ruby-doc.org/core-2.2.0/Fiber.html" target="_blank" rel="noopener">Fiber</a>，例如：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iter = Fiber.<span class="keyword">new</span> <span class="keyword">do</span></span><br><span class="line">  (<span class="number">0.</span><span class="number">.10</span>).<span class="keyword">each</span> <span class="keyword">do</span> |x|</span><br><span class="line">    Fiber.<span class="keyword">yield</span> x</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts iter.<span class="keyword">resume</span></span><br><span class="line">puts iter.<span class="keyword">resume</span></span><br></pre></td></tr></table></figure></p><p>上面的代码也依次打印出<code>0</code>, <code>1</code>。</p><p>关于生成器与 Fiber 的关系，可以参考：</p><ul><li><a href="https://nikolaygrozev.wordpress.com/2015/07/14/overview-of-modern-concurrency-and-parallelism-concepts/comment-page-1" target="_blank" rel="noopener">Overview of Modern Concurrency and Parallelism Concepts</a> （需翻墙，强烈推荐读者看）</li><li><a href="http://merbist.com/2011/02/22/concurrency-in-ruby-explained/" target="_blank" rel="noopener">http://merbist.com/2011/02/22/concurrency-in-ruby-explained/</a></li></ul><p>其实，生成器、Fiber 以及相关概念背后的理论基础是 <a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="noopener">continuation</a>，continuation 的应用场景非常广泛，各种编程语言中的<a href="https://en.wikipedia.org/wiki/Exception_handling" target="_blank" rel="noopener">异常处理</a>也是基于它来实现的。鉴于这个话题比较大，这里不再展开叙述，感兴趣的读者可以参考<a href="http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/" target="_blank" rel="noopener">这篇文章</a>，后面我也会单独再写一篇文章进行介绍。<br>这里仅仅给出 continuation 的一个简单示例以飨读者：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Scheme 语言中没有 return 语句，利用 continuation 可以模拟 return</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> return)</span><br><span class="line">  (<span class="name">return</span> <span class="number">2</span>)</span><br><span class="line">  <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">display</span></span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) x))) <span class="comment">; displays 3</span></span><br><span class="line">(<span class="name"><span class="builtin-name">display</span></span> (<span class="name"><span class="builtin-name">call-with-current-continuation</span></span> f)) <span class="comment">; displays 2</span></span><br></pre></td></tr></table></figure></p><p>关于这里例子详细的解释可以参考<a href="https://en.wikipedia.org/wiki/Call-with-current-continuation#Examples" target="_blank" rel="noopener">WIKI Call-with-current-continuation</a>。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="immutable-vs-mutable"><a href="#immutable-vs-mutable" class="headerlink" title="immutable vs mutable"></a>immutable vs mutable</h4><p><a href="/blog/2015/11/20/strings/">字符串</a>作为对字符的一种抽象，实现时有两种选择：可变的与不可变的。这两种实现的优缺点如下：</p><ul><li><p>可变的字符串，这意味着对字符串进行修改、追加等操作时可在原有字符串基础上直接操作，比较节省空间。但是可变的特点会导致如下几个问题：</p><ul><li><p>相等性（equality）。如果一个对象是可变的，我们应该如何判断两个对象是相等的呢？这里还有个容易混淆的概念：同一性（identity），同一性是指两个变量指向同一个对象，相等性指两个变量指向不同的两个对象，但这两个对象的值是一样的。<br>  <img src="https://img.alicdn.com/imgextra/i3/581166664/TB29NApmFXXXXbvXpXXXXXXXXXX_!!581166664.png" alt="string_identity_equal"></p></li><li><p>并发性（concurrence）。在多线程的环境中，需要对可变对象进行各种复杂的锁机制来保障其正确性。</p></li></ul></li><li><p>不可变字符串没有上面的两个问题，但是不可变字符串在进行修改时由于会新生成一个对象，所以会比较消耗空间，所以这采用不可变字符串实现的语言一般都会提供一个具备 buffer 的字符串构造对象来生成字符串，像 Java 中的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html" target="_blank" rel="noopener">StringBuffer</a>，Python 中的 <a href="https://docs.python.org/2/library/stringio.html" target="_blank" rel="noopener">StringIO</a>。</p></li></ul><p>Ruby 中字符串是<code>可变</code>的，但是 Ruby 中提供了不可变字符串的替代品 Symbol，而且 Ruby 2.3 也提供了<code>--enable-frozen-string-literal</code> 选项用以声明字符串是不可变的。具体可参考：</p><ul><li><a href="https://wyeworks.com/blog/2015/12/1/-strings-in-ruby-2-dot-3" target="_blank" rel="noopener">https://wyeworks.com/blog/2015/12/1/-strings-in-ruby-2-dot-3</a></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ irb</span><br><span class="line">&gt; <span class="string">"a"</span>.equal? <span class="string">"a"</span>   <span class="comment"># equals?--- identity comparison</span></span><br><span class="line"> =&gt; false</span><br><span class="line">&gt; <span class="string">"a"</span>.eql? <span class="string">"a"</span>     <span class="comment"># eql?   --- hash equality</span></span><br><span class="line"> =&gt; true</span><br><span class="line">&gt; <span class="string">"a"</span> == <span class="string">"a"</span>       <span class="comment"># ==     --- generic "equality"</span></span><br><span class="line"> =&gt; true</span><br><span class="line">&gt; str = <span class="string">"hello"</span></span><br><span class="line"> =&gt; <span class="string">"hello"</span></span><br><span class="line">&gt; str.__id_<span class="number">_</span></span><br><span class="line"> =&gt; <span class="number">70099860517540</span></span><br><span class="line">&gt; <span class="string">"hello"</span>.__id_<span class="number">_</span></span><br><span class="line"> =&gt; <span class="number">70099856137920</span></span><br><span class="line">&gt; str &lt;&lt; <span class="string">" world"</span></span><br><span class="line"> =&gt; <span class="string">"hello world"</span></span><br><span class="line">&gt; str.__id_<span class="number">_</span></span><br><span class="line"> =&gt; <span class="number">70099860517540</span>     <span class="comment"># 与之前的 id 一样，说明 str 所指向的对象没变</span></span><br><span class="line"></span><br><span class="line">&gt; str = <span class="string">"hello"</span></span><br><span class="line"> =&gt; <span class="string">"hello"</span></span><br><span class="line">&gt; str.__id_<span class="number">_</span></span><br><span class="line"> =&gt; <span class="number">70099860630880</span></span><br><span class="line">&gt; str += <span class="string">" world"</span></span><br><span class="line"> =&gt; <span class="string">"hello world"</span></span><br><span class="line">&gt; str.__id_<span class="number">_</span></span><br><span class="line"> =&gt; <span class="number">70099856250160</span>    <span class="comment"># 与之前的 id 不一样，说明 += 在进行字符串拼接时，会生成一新对象</span></span><br></pre></td></tr></table></figure><p>Python、Javascript 中字符串都是<code>不可变</code>的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; str = <span class="string">"hello world"</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; str2 = str.replace(<span class="string">"o"</span>, <span class="string">"oo"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; str</span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; str2</span><br><span class="line"><span class="string">'helloo woorld'</span></span><br><span class="line"></span><br><span class="line">$ node</span><br><span class="line">&gt; str = <span class="string">"hello world"</span></span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line">&gt; str2 = str.replace(<span class="string">"o"</span>, <span class="string">"oo"</span>)</span><br><span class="line"><span class="string">'helloo world'</span></span><br><span class="line">&gt; str</span><br><span class="line"><span class="string">'hello world'</span></span><br><span class="line">&gt; str2</span><br><span class="line"><span class="string">'helloo world'</span></span><br></pre></td></tr></table></figure><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>大多数语言都可以直接通过<code>+</code>进行字符串的拼接，但是这样做既不优雅，效率也低，所以一些语言会有些替代方案。<br>Ruby 与 Python 中对这块的支持比较强大，ES6 中借鉴了以上两门语言的语法，引入了 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">template_string</a>，这在极大程度上方便了字符串的拼接。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> var a = 5;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> var b = 10;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> console.log(`Fifteen is <span class="variable">$&#123;a + b&#125;</span> and\nnot <span class="variable">$&#123;2 * a + b&#125;</span>.`);</span></span><br><span class="line">// "Fifteen is 15 and</span><br><span class="line">// not 20."</span><br><span class="line"><span class="meta">#</span><span class="bash">--------------------------------------------------<span class="comment">#</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> long_string = <span class="string">""</span><span class="string">"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> my name is &#123;username&#125;,</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> my age is &#123;age&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">""</span><span class="string">".format(username="</span>zhangsan<span class="string">", age=10)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">--------------------------------------------------<span class="comment">#</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> irb</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> long_string = <span class="string">""</span><span class="string">"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> my name is %&#123;username&#125;,</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> my age is %&#123;age&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">""</span><span class="string">" % &#123;username: "</span>zhangsan<span class="string">", age:10&#125;</span></span></span><br></pre></td></tr></table></figure></p><p>就是上面不可变字符串缺点中说的，对字符串进行追加时效率比较低，那么在 Python 与 Javascript 中进行大量字符串拼接时该采用什么方式呢？下面给出我的两组测试：</p><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">time</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">from</span> StringIO import StringIO</span><br><span class="line">except ImportError:</span><br><span class="line">    <span class="built_in">from</span> io import StringIO  <span class="comment"># StringIO is in package io in python 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    xrange</span><br><span class="line">except NameError:</span><br><span class="line">    xrange = range  <span class="comment"># xrange is gone in python 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def method1(loop_count):</span><br><span class="line">    <span class="built_in">start</span> = <span class="built_in">time</span>.<span class="built_in">time</span>()</span><br><span class="line">    out_str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">num</span> <span class="keyword">in</span> xrange(loop_count):</span><br><span class="line">        out_str += repr(<span class="built_in">num</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"+= : %f seconds"</span> % (<span class="built_in">time</span>.<span class="built_in">time</span>() - <span class="built_in">start</span>))</span><br><span class="line">    <span class="literal">return</span> out_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def method2(loop_count):</span><br><span class="line">    <span class="built_in">start</span> = <span class="built_in">time</span>.<span class="built_in">time</span>()</span><br><span class="line">    str_list = []</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">num</span> <span class="keyword">in</span> xrange(loop_count):</span><br><span class="line">        str_list.append(repr(<span class="built_in">num</span>))</span><br><span class="line">    out_str = <span class="string">''</span>.join(str_list)</span><br><span class="line">    print(<span class="string">"list + join : %f seconds"</span> % (<span class="built_in">time</span>.<span class="built_in">time</span>() - <span class="built_in">start</span>))</span><br><span class="line">    <span class="literal">return</span> out_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def method3(loop_count):</span><br><span class="line">    <span class="built_in">start</span> = <span class="built_in">time</span>.<span class="built_in">time</span>()</span><br><span class="line">    out_str = <span class="string">''</span>.join([repr(<span class="built_in">num</span>) <span class="keyword">for</span> <span class="built_in">num</span> <span class="keyword">in</span> xrange(loop_count)])</span><br><span class="line">    print(<span class="string">"list comprehension + join : %f seconds"</span> % (<span class="built_in">time</span>.<span class="built_in">time</span>() - <span class="built_in">start</span>))</span><br><span class="line">    <span class="literal">return</span> out_str</span><br><span class="line"></span><br><span class="line">def method4(loop_count):</span><br><span class="line">    <span class="built_in">start</span> = <span class="built_in">time</span>.<span class="built_in">time</span>()</span><br><span class="line">    file_str = StringIO()</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">num</span> <span class="keyword">in</span> xrange(loop_count):</span><br><span class="line">        file_str.<span class="built_in">write</span>(repr(<span class="built_in">num</span>))</span><br><span class="line"></span><br><span class="line">    out_str = file_str.getvalue()</span><br><span class="line">    print(<span class="string">"StringIO : %f seconds"</span> % (<span class="built_in">time</span>.<span class="built_in">time</span>() - <span class="built_in">start</span>))</span><br><span class="line">    <span class="literal">return</span> out_str</span><br><span class="line"></span><br><span class="line">loop_count = <span class="number">1000000</span></span><br><span class="line">method1(loop_count)</span><br><span class="line">method2(loop_count)</span><br><span class="line">method3(loop_count)</span><br><span class="line">method4(loop_count)</span><br></pre></td></tr></table></figure><p>下面给出统计结果</p><table><thead><tr><th>python版本</th><th>+=</th><th>list + join</th><th>list comprehension + join</th><th>stringIO</th></tr></thead><tbody><tr><td>2.7.6</td><td>0.181868</td><td>0.219901</td><td>0.194387</td><td>1.085162</td></tr><tr><td>3.5.0</td><td>0.330583</td><td>0.271803</td><td>0.229952</td><td>0.313573</td></tr></tbody></table><p>从上面的比较可以看出，<code>list comprehension + join</code> 的方式时最快，而且写法也比较优雅的。</p><h5 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method1</span>(<span class="params">loop_count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out_str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;loop_count;i++) &#123;</span><br><span class="line">        out_str += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`+= cost : <span class="subst">$&#123;<span class="built_in">Date</span>.now() - start&#125;</span> ms`</span>);</span><br><span class="line">    <span class="keyword">return</span> out_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method2</span>(<span class="params">loop_count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []</span><br><span class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;loop_count;i++) &#123;</span><br><span class="line">        arr.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> out_str = arr.join(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`arr + join cost : <span class="subst">$&#123;<span class="built_in">Date</span>.now() - start&#125;</span> ms`</span>);</span><br><span class="line">    <span class="keyword">return</span> out_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method3</span>(<span class="params">loop_count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out_str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;loop_count;i++) &#123;</span><br><span class="line">        out_str.concat(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`str.concat cost: <span class="subst">$&#123;<span class="built_in">Date</span>.now() - start&#125;</span> ms`</span>);</span><br><span class="line">    <span class="keyword">return</span> out_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loop_count = <span class="number">1000000</span>;</span><br><span class="line">method1(loop_count)</span><br><span class="line">method2(loop_count)</span><br><span class="line">method3(loop_count)</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>+=</th><th>arr + join</th><th>str.concat</th></tr></thead><tbody><tr><td>耗时（单位：ms）</td><td>199</td><td>230</td><td>126</td></tr></tbody></table><p>上面的测试结果使用 Node v5.9.1 测试出来的，从结果来看，<code>str.concat</code> 是速度最快的。</p><h3 id="查看值类型"><a href="#查看值类型" class="headerlink" title="查看值类型"></a>查看值类型</h3><p>动态语言最主要的特点就是<code>变量无类型</code>，利用<a href="https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29" target="_blank" rel="noopener">反射机制</a>可以查看<code>运行时变量的值的类型</code>。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> str = <span class="string">"hello world"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> typeof str     </span></span><br><span class="line">'string'</span><br><span class="line"><span class="meta">#</span><span class="bash">------------------------------<span class="comment">#</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> irb</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> str = <span class="string">"hello world"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> str.class</span></span><br><span class="line">String</span><br><span class="line"><span class="meta">#</span><span class="bash">------------------------------<span class="comment">#</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> str = <span class="string">"hello world"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">type</span>(str)</span></span><br><span class="line">&lt;type 'str'&gt;</span><br></pre></td></tr></table></figure></p><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><ul><li>Python，<a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">PyPI</a>，多版本兼容推荐使用 <a href="https://virtualenv.pypa.io" target="_blank" rel="noopener">virtualenv</a> 管理</li><li>Ruby， <a href="https://rubygems.org/" target="_blank" rel="noopener">GEMS</a>，多版本兼容，推荐使用 <a href="https://rvm.io/" target="_blank" rel="noopener">rvm</a> + <a href="http://bundler.io/" target="_blank" rel="noopener">bundler</a> 管理</li><li>Node.js，由于 Node.js 出现较晚，它避免了Python、Ruby 包全局污染的问题，而是选择将第三份模块安装在项目内的<code>node_modules</code>文件夹内</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面简短的介绍，我相信大家对这三门语言有了全面的理解，多了解一门语言，也就是多个解决问题的思路。</p><p>个人感觉，Python、Javascript 的语法比较中规中矩，适合大部分程序员学习。Ruby 更适合 geek 去学，因为它的很多奇特语法会让你思考语言的设计细节，而不仅仅是使用这么简单。</p><p>最近我在看<a href="https://book.douban.com/subject/7056800/" target="_blank" rel="noopener">Ruby元编程</a>，里面的很多内容就很有意思，一些内容在看 SICP 时就已经遇到，这种似曾相识的感觉很棒，我相信对编程语言的了解又加深了一步。谢谢 <a href="https://en.wikipedia.org/wiki/Yukihiro_Matsumoto" target="_blank" rel="noopener">Yukihiro Matsumoto</a>大叔，带给我们 ruby 这么美妙的语言。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://stackoverflow.com/questions/7299010/why-is-string-concatenation-faster-than-array-join" target="_blank" rel="noopener">http://stackoverflow.com/questions/7299010/why-is-string-concatenation-faster-than-array-join</a></li><li><a href="https://waymoot.org/home/python_string/" target="_blank" rel="noopener">https://waymoot.org/home/python_string/</a></li><li><a href="https://wyeworks.com/blog/2015/12/1/immutable-strings-in-ruby-2-dot-3" target="_blank" rel="noopener">https://wyeworks.com/blog/2015/12/1/immutable-strings-in-ruby-2-dot-3</a></li><li><a href="http://stackoverflow.com/questions/7156955/whats-the-difference-between-equal-eql-and" target="_blank" rel="noopener">http://stackoverflow.com/questions/7156955/whats-the-difference-between-equal-eql-and</a></li><li><a href="http://stackoverflow.com/questions/214714/mutable-vs-immutable-objects" target="_blank" rel="noopener">http://stackoverflow.com/questions/214714/mutable-vs-immutable-objects</a></li><li><a href="https://kentreis.wordpress.com/2007/02/08/identity-and-equality-in-ruby-and-smalltalk/" target="_blank" rel="noopener">https://kentreis.wordpress.com/2007/02/08/identity-and-equality-in-ruby-and-smalltalk/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直在看红宝石（ruby）语言，到现在为止，算是对其设计有一些了解。作为一动态语言，ruby 经常会拿来与 python 对比，确实这两门语言在语法层面、实现层面有很多共同的地方，但是它们也在很多设计理念上存在重要差异，通过对比这些相同点、异同点，更加有助于理解这两门语
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="JavaScript" scheme="http://liujiacai.net/tags/javascript/"/>
    
      <category term="Python" scheme="http://liujiacai.net/tags/python/"/>
    
      <category term="Ruby" scheme="http://liujiacai.net/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个没有名字的递归函数</title>
    <link href="http://liujiacai.net/blog/2016/02/22/recursion-without-name/"/>
    <id>http://liujiacai.net/blog/2016/02/22/recursion-without-name/</id>
    <published>2016-02-22T13:31:11.000Z</published>
    <updated>2019-12-24T10:59:14.605Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29" target="_blank" rel="noopener">递归</a> 作为计算机科学中很重要的一个概念，应用范围非常广泛。比较重要的数据结构，像树、图，本身就是递归定义的。<br>比较常见的递归算法有<code>阶乘</code>、<code>斐波那契数</code>等，它们都是在定义函数的同时又引用本身，对于初学者来说也比较好理解，但是如果你对编程语言，特别是函数式语言，有所研究，可能就会有下面的疑问：</p><blockquote><p>一个函数在还没有定义完整时，为什么能够直接调用的呢？</p></blockquote><p>这篇文章主要是解答上面这个问题。阅读下面的内容，你需要有些函数式编程的经验，为了保证你能够比较愉快的阅读本文，你至少能看懂<code>前缀表达式</code>。相信读完本文后，你将会对编程语言有一全新的认识。<br>本文所有演示代码有<code>Scheme</code>、<code>JS</code>两个版本。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>下面的讲解以<code>阶乘</code>为例子：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; Scheme</span><br><span class="line">(define (<span class="built_in">FACT</span> <span class="built_in">n</span>)</span><br><span class="line">  (<span class="built_in">if</span> (= <span class="built_in">n</span> <span class="number">0</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    (* <span class="built_in">n</span> (<span class="built_in">FACT</span> (- <span class="built_in">n</span> <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">; JS</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">FACT</span> = function(<span class="built_in">n</span>) &#123;</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">n</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return <span class="built_in">n</span> * <span class="built_in">FACT</span>(<span class="built_in">n</span>-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的阶乘算法比较直观，这里就不再进行解释了。重申下我们要探究的问题</p><blockquote><p><code>FACT</code> 这个函数为什么在没有被定义完整时，就可以调用了呢？</p></blockquote><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>解决一个新问题，常见的做法就是类比之前解决的问题。我们要解决的这个问题和求解下面的等式很类似：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">2x</span> = x + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>在等号两边都出现了<code>x</code>，要想解决这个问题，最简单的方式就是将等号右边的<code>x</code>移到左边即可。这样就知道<code>x</code>是什么值了。</p><p>但是我们的问题比这个要复杂些了，因为我们这里需要用<code>if</code>、<code>n</code>、<code>*</code>、<code>-</code>这四个符号来表示<code>FACT</code>，可以这么类比是因为一个程序无非就是通过一些具有特定语意的符号（编程语言规定）构成的。</p><p>再进一步思考，<code>FACT</code> 需要用四个符号来表示，这和我们求解多元方程组的解不是很像嘛：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> + y = <span class="number">3</span></span><br><span class="line"><span class="keyword">x</span> - y = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>为了求解上面方程组，一般可以转为下面的形式：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span> = <span class="number">3</span> - y</span><br><span class="line"><span class="attr">y</span> = x - <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>即<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">x</span>, y) = T (<span class="name">x</span>, y)</span><br></pre></td></tr></table></figure></p><p>其中的<code>T</code>为一个转换，在线性代数其实就是个矩阵，根据矩阵<code>T</code>的一些性质，我们可以判定<code>(x ,y)</code>是否有解，以及解的个数。</p><p>对比此，我们可以把问题转化为下面的形式：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FACT</span> = F (<span class="built_in">FACT</span>)</span><br></pre></td></tr></table></figure></p><p>上面的<code>F</code>为某种转换，在这里其实就是个需要一个函数作为参数并且返回一个函数的函数。如果存在这么个<code>F</code>函数，那么我们就可以通过求解<code>F</code>的<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9" target="_blank" rel="noopener">不动点</a>来求出<code>FACT</code>了。</p><p>但这里有个问题，即便我们知道了<code>F</code>的存在，我们也无法确定其是否存在不动点，以及如果存在，不动点的个数又是多少？</p><p>计算机科学并不像数学领域有那么多可以套用的定理。</p><h2 id="寻找转换函数-F"><a href="#寻找转换函数-F" class="headerlink" title="寻找转换函数 F"></a>寻找转换函数 F</h2><p>证明<code>F</code>是否存在是个比较难的问题，不在本文的讨论范围内，这涉及到<a href="https://en.wikipedia.org/wiki/Denotational_semantics" target="_blank" rel="noopener">Denotational semantics</a>领域的知识，感兴趣的读者可以自己去网上查找相关资料。</p><p>这里直接给出<code>FACT</code>对应的函数<code>F</code>的定义：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; Scheme</span><br><span class="line">(define F</span><br><span class="line">  (lambda (g)</span><br><span class="line">    (lambda (n)</span><br><span class="line">      (<span class="keyword">if</span> (= n <span class="number">0</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (* n (g (- n <span class="number">1</span>)))))))</span><br><span class="line"></span><br><span class="line">; JS</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span><span class="params">(g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x * g(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，对比递归版本的<code>FACT</code>变动不大，就是把函数内<code>FACT</code>的调用换成了参数<code>g</code>而已，其实我们常见的递归算法都可以这么做。</p><h2 id="寻找转换函数-F-的不动点"><a href="#寻找转换函数-F-的不动点" class="headerlink" title="寻找转换函数 F 的不动点"></a>寻找转换函数 F 的不动点</h2><p>找到了转换函数<code>F</code>后，下一步就是确定其不动点了，而这个不动点就是我们最终想要的<code>FACT</code>。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FACT = (<span class="name">F</span> (<span class="name">F</span> (<span class="name">F</span> ...... (<span class="name">F</span> FACT) ...... )))</span><br></pre></td></tr></table></figure></p><p>假设我们已经知道了<code>FACT</code>非递归版本了，记为<code>g</code>，那么<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E0 = (F g)      这时(E0 <span class="number">0</span>) 对应 (FACT <span class="number">0</span>)得值，这时用不到 g</span><br><span class="line">E1 = (F E0)     这时(E1 <span class="number">0</span>)、(E1 <span class="number">1</span>)分别对应(FACT <span class="number">0</span>)、(FACT <span class="number">1</span>)的值</span><br><span class="line">E2 = (F E1)     这时(E2 <span class="number">0</span>)、(E2 <span class="number">1</span>)、(E2 <span class="number">2</span>)分别对应(FACT <span class="number">0</span>)、(FACT <span class="number">1</span>)、(FACT <span class="number">2</span>)的值</span><br><span class="line">.....</span><br><span class="line">En = (F En<span class="number">-1</span>)   这时....(En n)分别对应.... (FACT n)的值</span><br></pre></td></tr></table></figure></p><p>可以看到，我们在求出<code>(FACT n)</code>时完全没有用到初始的<code>g</code>，换句话说就是<code>g</code>的取值不影响我们计算<code>(FACT n)</code>。<br>那么我们完全可以这么定义<code>FACT</code>：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FACT = (<span class="name">F</span> (<span class="name">F</span> (<span class="name">F</span> ...... (<span class="name">F</span> <span class="number">1</span>) ...... )))</span><br></pre></td></tr></table></figure></p><p>可惜，我们不能这么写，我们必须想个办法表示无穷。在函数式编程中，最简单的无穷循环是：</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Scheme</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (<span class="name">x</span>) (<span class="name">x</span> x))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (<span class="name">x</span>) (<span class="name">x</span> x)))</span><br><span class="line"></span><br><span class="line"><span class="comment">; JS</span></span><br><span class="line">(<span class="name">function</span> (<span class="name">x</span>) &#123;</span><br><span class="line">    return x(<span class="name">x</span>)<span class="comment">;</span></span><br><span class="line">&#125;)(<span class="name">function</span>(<span class="name">x</span>) &#123;</span><br><span class="line">    return x(<span class="name">x</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>基于此，我们就得到函数式编程中一重要概念 <a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90" target="_blank" rel="noopener">Y 算子</a>，关于 Y 算子的严格推导，可以在参考这篇文章 <a href="http://mvanier.livejournal.com/2897.html" target="_blank" rel="noopener">The Y combinator (Slight Return)</a>，这里直接给出：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; Scheme</span><br><span class="line">(define Y</span><br><span class="line">  (lambda (f)</span><br><span class="line">    ((lambda (x) (f (x x))</span><br><span class="line">      (lambda (x) (f (x x)))))))</span><br><span class="line"></span><br><span class="line">(define FACT (Y F))</span><br><span class="line"></span><br><span class="line">; JS</span><br><span class="line"><span class="keyword">var</span> Y = <span class="function"><span class="keyword">function</span><span class="params">(f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(x(x));</span><br><span class="line">    &#125;)(<span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(x(x));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> FACT = Y(F);</span><br></pre></td></tr></table></figure><p>这样我们就得到的<code>FACT</code>了，但这里得到的<code>FACT</code>并不能在<code>Scheme</code>或<code>JS</code>解释器中运行，因为就像上面说的，这其实是个死循环，如果你把上面代码拷贝到解释器中运行，一般可以得到下面的错：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RangeError: Maximum call <span class="built_in">stack</span> <span class="built_in">size</span> exceeded</span><br></pre></td></tr></table></figure></p><h2 id="正则序-vs-应用序"><a href="#正则序-vs-应用序" class="headerlink" title="正则序 vs. 应用序"></a>正则序 vs. 应用序</h2><p>为了得到能够在<code>Scheme</code>或<code>JS</code>解释器中可以运行的代码，这里需要解释复合函数在调用时传入参数的两种求值策略：</p><ul><li>正则序（Normal Order），完全展开而后归约求值。惰性求值的语言采用这种顺序。</li><li>应用序（Applicative Order），先对参数求值而后应用。我们常用的大部分语言都采用应用序。</li></ul><p>举个简单的例子：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">; Scheme</span><br><span class="line">(define (p)</span><br><span class="line">  (p))</span><br><span class="line"></span><br><span class="line">(define (test x y)</span><br><span class="line">  (<span class="keyword">if</span> (= x <span class="number">0</span>)</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    y))</span><br><span class="line">(test <span class="number">0</span> (p))</span><br><span class="line"></span><br><span class="line">; JS</span><br><span class="line"><span class="keyword">var</span> p = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">0</span>, (p));</span><br></pre></td></tr></table></figure></p><p>上面这个例子，采用应用序的语言会产生死循环；而采用正则序的语言可以正常返回<code>0</code>，因为<code>test</code>的第二个参数只有在<code>x</code>不等于0时才会去求值。</p><p>我们上面给出的<code>var FACT = Y(F)</code>在正则序的语言中是可行的，因为<code>Y(F)</code>中的返回值只有在真正需要时才进行求值，而在<code>F</code>中，<code>n</code>等于0时是不需要对<code>g(n-1)</code>进行求值的，所以这时<code>Y(F)(5)</code>就能够正常返回<code>120</code>了。</p><blockquote><p>如果你觉得上面这段话很绕，一时不能理解，这样很正常，我也是花了很久才弄明白，你可以多找些惰性求值的文章看看。</p></blockquote><p>为了能够得出在应用序语言可用的<code>FACT</code>，我们需要对上面的<code>Y</code>做进一步处理。思路也很简单，为了不立即求值表达式，我们可以在其外部包一层函数，假设这里有个表达式<code>p</code>：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; Scheme</span><br><span class="line">(define lazy_p</span><br><span class="line">  (lambda () p))</span><br><span class="line"></span><br><span class="line">; JS</span><br><span class="line"><span class="keyword">var</span> lazy_p = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br></pre></td></tr></table></figure></p><p>这时如果想得到<code>p</code>的值，就需要<code>(lazy_p)</code>才可以得到了。基于这个原理，下面给出最终版本的<code>Y 算子</code>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; Scheme</span><br><span class="line">(define Y</span><br><span class="line">  (lambda (f)</span><br><span class="line">    ((lambda (x) (x x))</span><br><span class="line">     (lambda (x) (f (lambda (y) ((x x) y)))))))</span><br><span class="line"></span><br><span class="line">(define FACT (Y F))</span><br><span class="line">(FACT <span class="number">5</span>)   ;===&gt; <span class="number">120</span></span><br><span class="line"></span><br><span class="line">; JS</span><br><span class="line"> <span class="keyword">var</span> Y = <span class="function"><span class="keyword">function</span><span class="params">(f)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> x(x)</span><br><span class="line">     &#125;(<span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> f(<span class="function"><span class="keyword">function</span><span class="params">(y)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> x(x)(y)</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> FACT = Y(F)</span><br><span class="line"> FACT(<span class="number">5</span>)   ;===&gt; <span class="number">120</span></span><br></pre></td></tr></table></figure></p><p>好了，到现在为止，我们已经得到了可以在<code>Scheme</code>或<code>JS</code>解释器中运行<code>FACT</code>了，可以看到，这里面没有使用函数名也实现了递归方式求阶乘。<br>本文一开始给出的<code>FACT</code>版本在解释器内部也会转换为这种形式，这也就解释了本文所提出的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文大部分内容由 SICP 4.1 小节延伸而来，写的相对比较粗糙，很多点都没有展开讲的原因是我自己也还没理解透彻，为了不误导大家，所以这里就省略了（后面理解的更深刻后再来填坑😊）。希望感兴趣的读者能够自己去搜索相应知识点，相信肯定会受益匪浅。</p><p>最后，希望这篇文章对大家理解编程语言有一些帮助。有什么不对的地方请留言指出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;递归&lt;/a&gt; 作为计算机科学中很重要的一个概念，应用范围非常广泛。
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="Lambda" scheme="http://liujiacai.net/tags/lambda/"/>
    
      <category term="Lisp" scheme="http://liujiacai.net/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>2015 年终总结</title>
    <link href="http://liujiacai.net/blog/2016/01/08/review-2015/"/>
    <id>http://liujiacai.net/blog/2016/01/08/review-2015/</id>
    <published>2016-01-08T15:27:21.000Z</published>
    <updated>2019-12-24T10:59:14.604Z</updated>
    
    <content type="html"><![CDATA[<p>今天，已经是 2016 年的第八天了。时间总是这样，当我们身处其中时觉得很漫长，但是过后看看，也没觉得什么。<br>2015 年是毕业后正式工作的第一年，地点从上海转到了杭州，<a href="/blog/2014/12/29/review-2014/">2014 年终总结</a>时做的那些计划，貌似也没能全部实现。<br>这篇文章主要回忆 2015 年中那些印象深刻的事与人，同时展望美好的 2016。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><h3 id="再见，上海"><a href="#再见，上海" class="headerlink" title="再见，上海"></a>再见，上海</h3><p>毕业后找到第一份工作是在上海的 Ucloud，干的不是很开心，所以在15年年初趁着跳槽高峰期，我也离开了，来到了现在的公司——有赞。</p><p>现在还记得当时我是怎么去 Ucloud 面试的，当时办公地点还是在五角场，是租的创新工厂的办公区，里面聚集了很多创业公司，记得没事的时候就去楼梯间打打乒乓球，也是挺开心的。换了隆昌路新的办公室后，就没这个条件了。<br>在上海的生活也还可以，和一个学英语的男生合租的，平时也会自己做些饭，所以这段时间体重也没下来过。<br>房东人是对老夫妻，七八十岁的样子，人很好，我们刚搬进来的时候他们就嘱咐楼上楼下的邻居照顾我们，也会和我说些年轻人应该怎么闯闯之类的话，也是挺感谢的，希望他们身体健康。</p><p>在上海还有一件印象深刻的是，在元旦我和熊俊去外滩玩，那天我们去的早，后来人越来越多，我们就走了，第二天一看新闻，说外滩发生了<a href="http://baike.baidu.com/link?url=dIgFFsxQmmTosB4q81HTUi2L3vI9dLBlTo3Yoz3V7QeykjMCPH7G3SsnjFcLulfOsHPTYRVjHEIIu8amz2DL9M4hLyoEAYryU7wNiAoP1d4_KINL2VYKQGnfU8ll7yPCz6N_RkyhPzsjgS6bxVqKoPcAms5rNMK0T-DXco17q7LiTvmbcZqq2qEehMqQph1E4YhT-DL6HdjbAhZ8ZcF4zl0VU0snJTtr2g0xW06-4YKfsFvu-KH1QifcD4qlIKkDezoZJxMrvQkj6HGUR3CG7ZlO9u2-jRLYxcg0R4eY-YS" target="_blank" rel="noopener">踩踏事件</a>，一身冷汗，现在想想也是挺后怕的。正好最近看到一篇<a href="http://www.17bdc.com/read/article/reviews/61444/?social_service=s" target="_blank" rel="noopener">英文文章</a>，学到了一个词，stampede，表示“(人群的)蜂拥，恐慌”，看到一位网友调侃道：</p><blockquote><p>去年的新年第一天，上海 stampede；今年的股市第一天，上海再一次 stampede。</p></blockquote><h3 id="加入有赞"><a href="#加入有赞" class="headerlink" title="加入有赞"></a>加入有赞</h3><p>离开 Ucloud 后，来到了现在的公司，之前也写过一篇文章<a href="/blog/2015/04/03/leave-ucloud-to-youzan/">我来有赞了</a> 记录初到有赞的感受，准确应该是3月底加入有赞的，还记得当时在上海转租房子，没找到合适的人，我就和房东说了下自己的情况，然后东西一打包，就来杭州了。来杭州也没房子，住在公司附近的布丁酒店一周多，后来经同事介绍来到了现在住的<a href="http://baike.baidu.com/link?url=r_xfu5sjiUU_uR7DvifUkDB14TCthfbyMPn5lrA7-sJdJ3X3TS-ZmHf4G4Ctc42SSt4ll6mSmWKSmvnc11ED_Frggi5BergYX25tyT56tu6lVgdHs1WD9YIbh6-kQCD8" target="_blank" rel="noopener">望月公寓</a>。</p><p>这边的工作氛围比上海我觉得要好些，比较自由，时间规定也没那么严格。在这边的工作的收获也自然更多，不过也觉得不是特别满意，这边和 Ucloud 做基础云计算不一样，业务会多一些，所以我的专业知识提高的没我想的多，更多的是去熟悉业务。我不知道这种状态是好是坏，从 Ucloud 出来也没能摸清下面这些问题：</p><blockquote><p>到底该如何专注一个方向？现在这样的工作状态是我想要的嘛？我到底想要什么？</p></blockquote><p>杭州的生活也要比上海好些，没有那么多高楼大厦，自然也就没那么压抑。夏天那会还经常跑跑步，周末搞一些小东西，写写博客，挺开心的。</p><p>今天小兰实习正式结束了，虽然平时我对他也不知道“友好”，但他这么一走，我心里还真是有些不舍，也不知道怎么表达，祝小兰前途一切顺利，改日有机会再聚。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>14 年年终总结时说要看完下面三本书：</p><ul><li><a href="http://book.douban.com/subject/1148282/" target="_blank" rel="noopener">SICP</a></li><li><a href="http://book.douban.com/subject/1885170/" target="_blank" rel="noopener">算法导论</a></li><li><a href="http://book.douban.com/subject/1291204/" target="_blank" rel="noopener">哥德尔、艾舍尔、巴赫</a>，英文书名：Gödel, Escher, Bach，简写 GEB。</li></ul><p>到今天，是一个都没完成。当时自己确实没能很好评估这三本书的“质量”，这三本书并不是“十天教你学会C语言”之类的书籍，它们每一本都需要花费大量时间去思考、揣摩，像《GEB》这部著作怕是需要较深的数学功底与AI方面的知识才能领略其精髓。SICP 中文版在268页的<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#footnote_Temp_554" target="_blank" rel="noopener">注解224</a>中有提到 GEB 的部分内容，这里做个摘抄：</p><blockquote><p>有人觉得这样的求值器是违反直觉的，因为它由一个相对简单的过程实现，却能去模拟可能比求值器本身还要负责的各种程序。通用求值器的存在是计算的一种深刻而美妙的性质。递归论是数理逻辑的一个分支，这一理论研究计算的逻辑限制。<a href="https://en.wikipedia.org/wiki/Douglas_Hofstadter" target="_blank" rel="noopener">Douglas Hofstadter</a> 的美妙著作《GEB》（1979）里探索了其中的一些思想。</p></blockquote><p>在公司内部搞了个 <a href="https://github.com/sicper" target="_blank" rel="noopener">SICP 读书小组</a>，每周分享、讲解习题，开始进行的挺好，后来随着大家激情的消退，进度也一再推迟，现在印象比较深的是双 11 前后，我当时为了参加 SF 黑客马拉松，就暂停了两周的读书会，黑客马拉松结束后赶上双11公司做活动，然后就一直拖，第三章看完用了三个月，虽然第三章的内容比较多，怎么也不至于三个月时间才看完。现在进行到第四章了，不管怎样，一定要把这本书坚持一下，什么东西开始都是靠激情，但是能把一件事情做好，除了激情外，肯定需要坚持，而且是长时间的坚持。我也相信古今中外那些让我们记住名字的人，他们的杰出贡献和他们几十年如一日的坚持是分不开的。<br>比较欣慰的是，自己的 <a href="https://github.com/jiacai2050/sicp" target="_blank" rel="noopener">SICP 笔记</a>截止到现在已经有 113 个 star，这也算是一种鼓励吧，同时自己也写了个 <a href="https://github.com/jiacai2050/JCScheme" target="_blank" rel="noopener">Scheme 方言</a>，算是真正领略到了编程语言的奥秘，SICP 虽然是个时间黑洞，但是绝对值得投入。<br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2gk15jpXXXXXxXpXXXXXXXXXX_!!581166664.png" alt="Github Contributions"></p><p>从上面 Github 的 Contributions 基本也可以看出来在，我在 5、6、7月份是比较活跃，这阶段应该也是看 SICP 最快的时间段，16 年争取让这个图更平均一些。</p><p>除了 SICP 之外，较完整看完的一本书是<a href="http://book.douban.com/subject/3628911/" target="_blank" rel="noopener">《Dive Into Python 3》</a>，我的书评在<a href="http://book.douban.com/review/7717953/" target="_blank" rel="noopener">这里</a>。这本书很大一部分是在坐 89 路公交车去公司的路上看完的，算是充分利用时间吧，这里不得不推荐一下 Kindle，真是看书神器。其他还在看的书有：</p><ul><li><a href="http://book.douban.com/subject/1494026/" target="_blank" rel="noopener">Code : The Hidden Language of Computer Hardware and Software</a></li><li><a href="http://book.douban.com/subject/25854634/" target="_blank" rel="noopener">公共问题经济学</a></li></ul><p>更多可以查阅我的<a href="http://book.douban.com/people/liujiacai/do" target="_blank" rel="noopener">豆瓣我读</a>页面。<br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2cImCjpXXXXcpXpXXXXXXXXXX_!!581166664.png" alt="2015 在看的书"></p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>我写博客遵循下面三个原则：</p><ul><li><code>原创</code>。我们不是知识的“搬运工”，我们是知识的创造者</li><li><code>干货</code>。探究知识的本质，并不仅仅是 how，重要的是 why</li><li><code>通俗易懂</code>。最好让你一个不学计算机的人也能懂</li></ul><p>15 年总共写出了 16 篇文章，数量不算多，但是我绝对可以说是我花费大量时间写出来的，除了一两篇是纪录生活轨迹的，绝大部分都是对一些知识的思考。<br>像年初写的关于 javascript 的两篇文章<a href="/blog/2015/02/24/javascript-datatype/">《javascript中的数据类型》</a>、<a href="/blog/2015/02/01/javascript-oop/">《javascript中的面向对象编程》</a>，基本把 javascript中的 good parts 写出来了，其中比较让人困惑的<code>__proto__</code>、<code>this</code>、面向对象的实现等都有比较详尽的解释，我相信可以胜过互联网上其他关于 javascript 的介绍。</p><p>然后是关于 Java 集合框架的一些文章，其中我觉得写的比较好的有<a href="/blog/2015/09/01/java-collection-overview/">《Java集合框架综述》</a>、<a href="/blog/2015/09/03/java-hashmap/">《Java HashMap 源码解析》</a>、<a href="/blog/2015/09/04/java-treemap/">《Java TreeMap 源码解析》</a>，看了 SICP 后，对数据结构的理解也更深刻了，语言提供的各种类库基本都是对数据的各种封装，只不过由于应用场景不一样，所以底层实现的方式不一样。</p><p>之后是关于 SICP 前三章的总结：<a href="/blog/2015/07/18/sicp-chapter1-summary/">《SICP 第一章总结》</a>、<a href="/blog/2015/09/20/sicp-chapter2-summary/">《SICP 第二章总结》</a>、<a href="/blog/2015/12/26/sicp-chapter3-summary/">《SICP 第三章总结》</a>。SICP 这本书给我带来太多太多关于编程上的认识了，希望对编程还有激情的同行们有机会一定要看一看。在看 SICP 之余，使用 Java 实现了个 Scheme 方言，<a href="/blog/2015/10/03/first-toy-scheme/">《我的第一个玩具语言 JCScheme 问世了》</a>这篇文章介绍了实现一个解释器的方方面面，感兴趣的可以参考。</p><p>年底最后一篇有份量的文章是<a href="/blog/2015/11/20/strings/">《字符串，那些你不知道的事》</a>，这部分内容是我在看《Dive into Python 3》时了解到的，真是大开眼界，我相信你应该也“小看”字符串了，抓紧去看看吧😊。</p><p>一直觉得能够写出一些通俗易懂但又有干货的文章不容易，我一直在努力。2016，希望为这世界贡献些美好的东西。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>今年五一期间，家里的姐姐结婚了，不过离我老家并不是很远。现在我的小外甥也已经四五个月了。倩姐也在15年12月30号嫁人了。<br>想想同龄人，大部分人都娶妻生子，只有一少部分人比较“另类”，还在坚持着不可预知的梦想。不过我觉得这也是正常的，大部分人注定平庸，只有那些不断坚持的人才有可能脱颖而出，当然我也不指望成为什么大老板，只是希望对得起自己的内心，记得小时候看过中央卫视的一个公益广告：<a href="http://v.youku.com/v_show/id_XNzQwODEyODQ=.html?from=s1.8-1-1.2" target="_blank" rel="noopener">心有多大，舞台就有多大</a>，还有一句话也挺触动我的：</p><blockquote><p>比你优秀的人不可怕，可怕的是比你优秀的人比你更努力</p></blockquote><p>是呀，什么东西都比不过坚持，《肖申克的救赎》中的男主角真是做到了十年如一日。我们每个人都很容易被生活磨平了棱角，当初刚毕业时的雄心壮志也不知道丢在了那里。想想我从初中到现在的求学之路，也算幸运，遇到了几个对我人生有重大启发的老师，虽然大学上的不是什么985、211，但是也看到了很多之前不了解的东西，明白了只有去努力，任何时间都不晚。走上编程这条路算是这辈子最幸运的一件事，高考后报专业对编程根本也没什么概念，稀里糊涂的就报了，现在回头看看，真是上天的眷顾。</p><p>感情状态还是单身，不过幸好还是有几个异性好朋友，工作之余和她们调侃一下生活也变的精彩了很多。下半年遇到了触动我心灵的姑娘，不过貌似时间并不是那么合适，有太多的不定因素了，缘分到底会不会来我也不知道，只能做好自己目前的事情。之前没怎么考虑过定居、今后的家庭之类的话题，和这个姑娘聊了半年多后，也意识到这些问题了，希望 16 年她回国后能有有更多的缘分❤️。</p><h2 id="展望-2016"><a href="#展望-2016" class="headerlink" title="展望 2016"></a>展望 2016</h2><p>以上罗列了 2015 年一些重要的事情，新的一年来临了，也要拥抱改变，给自己定一下新年目标。上面多次提到了坚持的意义，我觉得 2015 年我在这方面做的比之前的要好，虽然不是很完美，但是还时有了一些成果，今年一定要贯彻下去，毕竟太多事情需要做了。抓住主线，抵制诱惑，成为一个更好的自己。</p><h3 id="减肥"><a href="#减肥" class="headerlink" title="减肥"></a>减肥</h3><p>具体来说我觉得第一件事就是：<code>减肥</code>。减肥这两个字对现代人来说真是再熟悉不过了，我从小就胖些，以后也就养成了习惯，也不在乎别人怎么说了，其实这给我现在造成了挺大的苦恼，当然注意是找对象方面，都说女为悦己者容，男也可以为悦己者容呀，更重要的是肥胖对身体健康不好，程序员本来的运动量就少，如果天天加班身体肯定吃不消。</p><p>我也相信每个胖子都是潜力股，其实减肥也没想的那么困难，只要保证每天的摄入小于消耗的能量，更具体的说，就是管住嘴，这样减肥也不是什么难事，知乎上看到一个减肥成功的人说的一句话，甚是欣赏，这里与大家分享下：</p><blockquote><p>贪吃其实是人类贪念的一种，为了满足一时的快感，而不顾后果作出的一些行为。</p></blockquote><p>成功的人一定要抑制自己的贪欲，这样才能成为更好的自己，为了在减少摄入时不至于肚子饿，网上一般推荐吃燕麦片，这种食物比较容易有饱腹感，这样就能够愉快的写代码了。后面有什么心得会再来与大家分享。</p><h3 id="读书-1"><a href="#读书-1" class="headerlink" title="读书"></a>读书</h3><p>除了 2015 年一直在读的 SICP，我觉得算法导论可以提上日程了，至于 GEB，我觉得应该还不会涉及到，可以先放一放。<br>2016 的书单会包含下面这些：</p><ul><li><a href="http://book.douban.com/subject/1494026/" target="_blank" rel="noopener">Code : The Hidden Language of Computer Hardware and Software</a>，这本书主要是讲述计算机是如何一步步构造的。从最早的<a href="https://en.wikipedia.org/wiki/Morse_code" target="_blank" rel="noopener">摩斯电码</a>，到各种电路元件的实现原理，再到计算机中如何保存信息，对理解计算机如何工作非常有帮助。</li><li><a href="http://book.douban.com/subject/1230413/" target="_blank" rel="noopener">Computer Systems: A Programmer’s Perspective</a>。这本书主要是让我能够更好的理解操作系统。</li><li><a href="http://book.douban.com/subject/25854634/" target="_blank" rel="noopener">公共问题经济学</a>，主要是一些经济学知识，在现代社会，每个人都需要懂一些经济学，不是嘛</li><li><a href="http://book.douban.com/subject/1888733/" target="_blank" rel="noopener">Java Concurrency in Practice</a>。主要讲授多线程方面的知识，其实这块知识我一直挺欠缺多，hadoop 本身就是个非常复杂的多线程程序，如果不了解这方面的知识，查错非常不方便，另一方面现在并发的场景越来越多，多线程注定是个热门话题。</li><li><a href="http://book.douban.com/subject/1632977/" target="_blank" rel="noopener">The Little Schemer - 4th Edition</a>，这是一本小巧精炼的书，主要讲解 Scheme 方面的东西，对理解一些概念，像递归、lambda 很有帮助，是 SICP 很好的辅助书籍。</li><li><a href="http://book.douban.com/subject/1726083/" target="_blank" rel="noopener">The Seasoned Schemer</a>，TLS 的晋级篇，16年应该也会开始读这本书</li></ul><p>现在罗列的这些书籍 16 年很有可能看不完，后面也会补充这个书单。但是这里我想说的是：</p><blockquote><p>行动起来，不要停止探寻新知识的脚步，多去总结、回顾，做到举一反三。</p></blockquote><p>不是说看的书越多人就越厉害，这是错误的，准确的说应该是和人思考的多少成正比。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>16 年博客会照常写，还是遵循上面的三个原则。无意间发现可以用 Github 的 issue 来整理自己的 <a href="https://github.com/jiacai2050/ideas" target="_blank" rel="noopener">ideas</a>，觉得不错，以后可以利用起来。</p><p>项目上需要多去实践，反复推敲自己写过的代码，不要仅仅停留在能用级别，王垠的<a href="http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy/" target="_blank" rel="noopener">《编程的智慧》</a>这篇文章里面也反复提到了这一观点。<a href="/gooreplacer">gooreplacer</a> 也一直在不断更新中，希望新的一年能够开发出更多有趣实用的小项目。</p><p>有出国的想法，所以秉承坚持的原则，每天使用<a href="http://www.shanbay.com/" target="_blank" rel="noopener">扇贝网</a> APP 进行签到学习英文，用了一周发现还不错，文章内容比较新颖，就算人家做的再怎么不好，也不能成为自己放弃的借口。<a href="http://www.shanbay.com/checkin/user/calendar/37223251/201601" target="_blank" rel="noopener">这是</a>我在扇贝网的签到日历，如果你也想坚持学英语，我们可以加个好友。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>年年岁岁花相似，岁岁年年人不同。<br>2015 年已经过去了，让我们朝着 2016，大步向前。<br>生活会因你我的努力、坚持变得更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天，已经是 2016 年的第八天了。时间总是这样，当我们身处其中时觉得很漫长，但是过后看看，也没觉得什么。&lt;br&gt;2015 年是毕业后正式工作的第一年，地点从上海转到了杭州，&lt;a href=&quot;/blog/2014/12/29/review-2014/&quot;&gt;2014 年终总结
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>SICP 第三章总结</title>
    <link href="http://liujiacai.net/blog/2015/12/26/sicp-chapter3-summary/"/>
    <id>http://liujiacai.net/blog/2015/12/26/sicp-chapter3-summary/</id>
    <published>2015-12-26T04:53:33.000Z</published>
    <updated>2019-12-24T10:59:14.604Z</updated>
    
    <content type="html"><![CDATA[<p>历时三个月，终于把第三章看完了。这三月发生了太多的意外，本文不打算说了，后面在写 <a href="/blog/2016/01/08/review-2015/#读书">2015 年终总结</a>时再来谈谈这三个月的事情。如今回过头来看看第三章的内容，好像也不怎么难，只是内容涉及的面稍微广一些而已，下面来回顾总结一下第三章。</p><h2 id="主旨"><a href="#主旨" class="headerlink" title="主旨"></a>主旨</h2><p>第三章的标题为<code>模块化、对象和状态</code>，主要讨论与状态有关的编程问题。前面两章，讨论的问题主要是：</p><ol><li>如何组合基本过程和基本数据</li><li>如何构造各种复合对象(组合过程/数据)</li><li><strong>抽象</strong>在控制和处理程序复杂性中的重要作用</li></ol><p>但对于程序设计而言，上面这三种手段还不够用，有效设计大型系统，还需要一些组织系统的原则，这体现在下面两方面：</p><ol><li>只有一集高效算法，不足以构造出良好的大型系统</li><li>系统的功能分解，结构组织和管理与算法一样重要(或更甚之)</li></ol><p>为了系统化地完成设计，特别需要一些模块化策略。模块化就是把复杂系统分解为一些边界清晰、易于独立理解的部分；每个部分的内部成分之间关系较密切，内聚力强;不同部分具有良 好的功能分离，相互之间的交互清晰、容易认识和处理；良好模块化分解出的部分可以分别设计，分别开发和维护。</p><p>假设构造一个系统的目标是希望模拟一个真实世界的系统，一种有效策略就是<code>基于被模拟系统的结构</code>去设计程序的结构。这主要包括下面三个方面：</p><ol><li>针对实际物理系统中的每个对象，构造一个对应的程序对象</li><li>针对实际系统里的每种活动，在计算系统里实现一种对应操作</li><li>让所开发的系统的活动比较直接地反映被模拟系统的活动</li></ol><p>采用这种设计系统策略，有一个重要问题必须考虑：</p><blockquote><p>真实世界的系统是变化的（相应的，人的认识也不断深入）</p></blockquote><p>这些变化在人工系统里的反映，通常是需要在系统里增加新对象或新操作，或者需要修改已有对象和操作的行为。</p><p>为了有效完成模拟，我们希望构造出的模拟系统在遇到变化时，做到下面两点：</p><ol><li>在修改时只需要局部做，不需要大范围改变程序</li><li>在扩充时只需简单加入对象或操作，局部修改/加入相关操作</li></ol><h2 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h2><p>本章针对上述目标，将讨论两种系统的组织策略：</p><ol><li>把系统看成是由一批相互作用的对象组成<blockquote><p>真实系统中的对象随着时间的进展不断变化，模拟它们的系统对象也吸引相应地变化</p></blockquote></li><li>把系统看作一种信号处理系统<blockquote><p>关注流过系统的信息流</p></blockquote></li></ol><h2 id="基于对象的设计"><a href="#基于对象的设计" class="headerlink" title="基于对象的设计"></a>基于对象的设计</h2><p>基于对象，需要关注计算对象可以怎样变化而又同时保持其标识。这是一种新的计算模型，带来许多本质性变化，包括有关计算的基本观点，基本操作，抽象的计算模型及其实现。</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>为了说清楚让一个计算对象具有随时间变化状态，贯穿本章的例子是：银行账号。一个账号对于我们系统设计中的一个对象，对同一个对象调用同一方法，返回的结果缺不一致。例如，假设开始时账户有100元钱，在不断调用“取钱”过程时，得到结果是不一样的。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">withdraw</span> <span class="number">25</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line">(<span class="name">withdraw</span> <span class="number">25</span>)</span><br><span class="line"><span class="number">50</span></span><br><span class="line">(<span class="name">withdraw</span> <span class="number">60</span>)</span><br><span class="line"><span class="string">"Insufficient funds"</span></span><br></pre></td></tr></table></figure></p><p>这样的计算模型如果使用第一章介绍的<code>替换计算模型</code>，是不可能做到的，为此，本章引入了一新的计算模型，在该模型中，变量不在仅仅是某个值的名字，更准确的说，此时的变量标识了一个值的地址，这很像 C语言中的指针，面向对象中的值引用。</p><h3 id="环境计算模型"><a href="#环境计算模型" class="headerlink" title="环境计算模型"></a>环境计算模型</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-withdraw</span> balance)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (amount)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> amount balance)</span><br><span class="line">      <span class="string">"Insufficient"</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">begin</span></span></span><br><span class="line">        (<span class="name"><span class="builtin-name">set!</span></span> balance (<span class="name"><span class="builtin-name">-</span></span> balance amount))</span><br><span class="line">        balance))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> W1 (<span class="name">make-withdraw</span> <span class="number">100</span>))</span><br><span class="line">(<span class="name">W1</span> <span class="number">50</span>)</span><br></pre></td></tr></table></figure><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2WwebiVXXXXcxXXXXXXXXXXXX_!!581166664.png" alt="(define W1 (make-withdraw 100))的环境模型"><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2mo5iiVXXXXa.XXXXXXXXXXXX_!!581166664.png" alt="(W1 50)的环境模型"><br></center><p>关于环境计算模型，核心点就两个：</p><ol><li>过程声明时，其外围指针指向其运行时的环境</li><li>过程调用时，其外围指针指向声明时外围指针指向的那个环境</li></ol><p>我自己尝试着用 Java 实现了一个 <a href="https://github.com/jiacai2050/JCScheme" target="_blank" rel="noopener">Scheme 方言</a>，其中对这个环境模型也进行了模拟，大家不清楚的可以看看我<a href="/blog/2015/10/03/first-toy-scheme/#作用域">这篇文章</a>的介绍。</p><h2 id="用变动的数据做模拟"><a href="#用变动的数据做模拟" class="headerlink" title="用变动的数据做模拟"></a>用变动的数据做模拟</h2><p>在前两章中，没有赋值的概念，那时对于一种数据结构，我们只需明确其<code>构造函数</code>与<code>选择函数</code>即可使用该数据结构，在之前两章中，我们介绍了“表”、“树”这两种数据结构，引入了赋值后，一个数据结构多了一种函数，即<code>修改函数</code>，利用修改函数，3.3 小节介绍了“变动的表”、“队列”、“表格”三种新的数据结构。</p><h3 id="变动的表"><a href="#变动的表" class="headerlink" title="变动的表"></a>变动的表</h3><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2f4qciVXXXXcIXXXXXXXXXXXX_!!581166664.png" alt="(cons (list 'a 'b) (list 'a 'b)) 的盒模型"><br></center><p>变动的表这一数据结构，主要是借助<code>set!</code>，实现了<code>set-car!</code>与<code>set-cdr!</code>，进而可以实现变动的表，其中比较有意思的是<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/3.19.md" target="_blank" rel="noopener">习题3.19</a>，让我们在<code>O(1)</code>空间复杂度检查一个表中是否包含环，这也是面试题中经常出现的一道，大家一定要掌握。基本思路就是</p><blockquote><p>设置两个指针，一个一次走一步，另一个一次走两步，然后如果两个指针相等，那么就说明有环存在。</p></blockquote><p>更进一步，如果一个表中有环的存在，如何找出那个环的交叉点（即如何找出下图中的<code>m</code>点）。如果不清楚，可以参考我<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/3.19.md" target="_blank" rel="noopener">习题3.19</a> 的解答。</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2kxxRiVXXXXXmXFXXXXXXXXXX_!!581166664.png" alt="环交叉点检测"><br></center><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB27OhWiVXXXXcjXpXXXXXXXXXX_!!581166664.png" alt="带首尾指针的队列"><br></center><p>队列是一个“先进先出”的数据结构，这里主要是引入首尾指针的思想来加速对队列末端的访问。队列的实现可以参考我 Github 库的<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/lib/queue.scm" target="_blank" rel="noopener">/exercises/03/lib/queue.scm</a>。<br>其中<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/3.23.md" target="_blank" rel="noopener">习题3.23</a>让我们实现一双向链表，一种很实用的队列的变种，大家一定要自己做一下。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>这里的表格和我们Java中的Map、Python中的dict类型比较类似。</p><center><br>    <img src="https://img.alicdn.com/imgextra/i1/581166664/TB2G54UiVXXXXcNXpXXXXXXXXXX_!!581166664.png" alt="二维表"><br></center><p>其中比较有意思对是<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/3.25.md" target="_blank" rel="noopener">习题3.25</a>，让我们推广一维表格、二维表格的概念，实现任意多个关键码的表格，比较有趣。</p><h3 id="数字电路的模拟器"><a href="#数字电路的模拟器" class="headerlink" title="数字电路的模拟器"></a>数字电路的模拟器</h3><p>这是本章一个比较实际的例子，其背景是</p><blockquote><p>数字系统（像计算机）都是通过连接一些简单元件构造起来的，这些元件单独看起来功能都很简单，它们连接起来形成的网络就可能产生非常复杂的行为。</p></blockquote><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2O48ZiVXXXXcnXpXXXXXXXXXX_!!581166664.png" alt="半加器电路"><br></center><p>从上面这个半加器可以看出</p><blockquote><p>由于各个门部件延迟的存在，使得输出可能在不同的时间产生，有关数字电路的设计的许多困难都源于此。</p></blockquote><p>这里的模拟器主要包含下面两部分：</p><ol><li>构造电路的基本构件，像反门、与门、或门</li><li>传递数字信号的连线</li></ol><p>除了上面两部分，为了模拟门部件延时的效果，本系统引入待处理表。这三部分都是用Scheme的过程实现，用内部状态表示该对象的改变，具体代码可以参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/lib/simulator.scm" target="_blank" rel="noopener">simulator.scm</a>。</p><p>其中比较有意思的是<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/3.31.md" target="_blank" rel="noopener">习题3.31</a>，大家可以好好想想。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (accept-action-<span class="function"><span class="keyword">procedure</span>! <span class="title">proc</span>)</span></span><br><span class="line"><span class="function">  <span class="params">(<span class="keyword">set</span>! action-procedures (cons proc action-procedures)</span>)</span></span><br><span class="line"><span class="function">  ;</span> 这里将 proc 加入后，立即执行了 proc，为什么？ 见习题<span class="number">3.31</span></span><br><span class="line">  (proc))</span><br></pre></td></tr></table></figure></p><h3 id="约束的传播"><a href="#约束的传播" class="headerlink" title="约束的传播"></a>约束的传播</h3><p>本章另一个比较实用的例子，之前我们的过程都是单向，我们只能通过一个过程的输入获得其输出，但是这里给我们展示了如何构建一个约束系统，是的我们可以从任意方向求过程的未知数的值。</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2jEGbiVXXXXXDXpXXXXXXXXXX_!!581166664.png" alt="9C = 5(F-32) 形成的约束网络"><br></center><p>在讲解这个实例时，3.3.5小节引入一新语言的设计，这种语言将使我们可以基于各种关系进行工作。</p><p>我们在第一章里面就知道了，任何一门语言都必须提供三种机制：<code>基本表达形式</code>、<code>组合的方法</code>与<code>抽象的方法</code>。针对本系统的语言的基本元素就是各种<code>基本约束</code>，像<code>adder</code>、<code>multiplier</code>、<code>constant</code>。用 Scheme 过程来实现基本约束也就自动地为该新语言提供了一种复合对象的抽象方式。</p><p>整个约束系统，我个人觉得主要是理解<code>process-forget-value</code>过程中为什么要调用<code>process-new-value</code>，这是串联起整个约束系统很重要的一步。书上是这么解释的：</p><blockquote><p>只所以需要这一步，是因为还可能有些连接器仍然有自己的值（也就是说，某个连接器过去所拥有的值原来就不是由当前对象设置的）<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; adder 中 <span class="built_in">process</span>-forget-<span class="built_in">value</span> 的实现</span><br><span class="line">(define (<span class="built_in">process</span>-forget-<span class="built_in">value</span>)</span><br><span class="line">  (forget-<span class="built_in">value</span>! <span class="built_in">sum</span> me)</span><br><span class="line">  (forget-<span class="built_in">value</span>! a1 me)</span><br><span class="line">  (forget-<span class="built_in">value</span>! a2 me)</span><br><span class="line">  ; TODO 为什么需要理解执行 <span class="built_in">process</span>-<span class="built_in">new</span>-<span class="built_in">value</span></span><br><span class="line">  (<span class="built_in">process</span>-<span class="built_in">new</span>-<span class="built_in">value</span>))</span><br></pre></td></tr></table></figure></p></blockquote><p>整个约束系统的代码可以在<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/lib/propagation.scm" target="_blank" rel="noopener">propagation.scm</a>找到。</p><h2 id="并发，时间是一个本质问题"><a href="#并发，时间是一个本质问题" class="headerlink" title="并发，时间是一个本质问题"></a>并发，时间是一个本质问题</h2><p>这一小节主要讲解引入<code>赋值</code>这一行为后，并发程序可能出现的问题，其实这里的东西我们在平常的编程中多多少少有些了解，主要是如何保证操作的原子性。</p><p><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2lzajiVXXXXcHXXXXXXXXXXXX_!!581166664.png" alt="Peter与Paul同时取同一个账户的一种场景"><br></center><br>保证操作的原子性，这里解释了一种方式——串行化组（serializer），其实就是我们 Java 里面的 synchronized 的关键字的功能。<br>保证一个对象的原子性还比较好解决，但是保证多个对象间交互的原子性就比较麻烦了，书上用从一个账户向另一个账户转账这个例子说明了这种情况。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">serialized-exchange</span> account1 account2)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">serializer1</span> (<span class="name">account1</span> <span class="symbol">'serializer</span>))</span><br><span class="line">        (<span class="name">serializer2</span> (<span class="name">account2</span> <span class="symbol">'serializer</span>)))</span><br><span class="line">    ((<span class="name">serializer1</span> (<span class="name">serializer2</span> exchange)))</span><br><span class="line">      account1</span><br><span class="line">      account2))</span><br></pre></td></tr></table></figure></p><p>该例子完整代码可以参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/lib/serialized_exchange.scm" target="_blank" rel="noopener">serialized_exchange.scm</a>。</p><p>更进一步，如果保证 n 对象间交互的原子性呢？这应该就是现在比较热门的一领域：分布式系统中，如何保证数据的一致性，后面有精力可以看看看业界使用最广泛的 <a href="http://stackoverflow.com/questions/3662995/explaining-apache-zookeeper" target="_blank" rel="noopener">zookeeper 的实现原理</a>。</p><p>书上进一步扩展，讲述了并发问题与物理学的联系。有种发现一世界未解之谜的感觉，摘抄如下：</p><blockquote><p>从本质上看，在并发控制中，任何时间概念都必然与通信有内在的密切联系。有意思的是，时间与通信之间的这种联系也出现在相对论里，在那里的光速（可能用于同步事件的最快信号）是与时间和空间有关的基本常量。在处理时间和状态时，我们在计算模型领域所遭遇的复杂性，事实上，可能就是物理世界中最基本的复杂性的一种反映。</p></blockquote><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流是另一种模拟现实物理世界的设计策略，其核心思想就是用数学概念上的函数来表示一现实物体的改变，比如对象X，可以用<code>X(t)</code>来表示，如果我们想集中关心的是一个个时刻的x，那么就可以将它看作一个变化的量。如果关注的是这些值的整个时间史，那么就不需要强调其中的变化——这一函数本身是没有改变的。</p><p>这里流，较之前的表而言，主要是引入<code>force</code>、<code>delay</code>两个过程，将其延时求值。有了延时求值，我们就可以做很多之前不能做的事情，比如实现一个表示所有正整数的无穷流<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 第一种方式</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">integers-starting-from</span> n)</span><br><span class="line">  (<span class="name">cons-stream</span> n (<span class="name">integers-starting-from</span> (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">1</span>))))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</span><br><span class="line"><span class="comment">; 第二种方式，隐式定义</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> ones (<span class="name">cons-stream</span> <span class="number">1</span> ones))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-streams</span> s1 s2)</span><br><span class="line">  (<span class="name">stream-map</span> + s1 s2))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> integers2 (<span class="name">cons-stream</span> <span class="number">1</span> (<span class="name">add-streams</span> ones integers2)))</span><br></pre></td></tr></table></figure></p><h3 id="流计算模式的使用"><a href="#流计算模式的使用" class="headerlink" title="流计算模式的使用"></a>流计算模式的使用</h3><p>流方法极富有启发性，因为借助于它去构造系统时，所用的模块划分方式可以与采用赋值，围绕着状态变量组织系统的方式不同。例如，我们可以将整个的时间序列作为有关的目标，而不是去关注状态变量在各个时刻的值。这将使我们更方便地组合与比较来自不同时刻的状态的组合。</p><h4 id="将迭代操作表示为流操作"><a href="#将迭代操作表示为流操作" class="headerlink" title="将迭代操作表示为流操作"></a>将迭代操作表示为流操作</h4><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 求解一个数的平方</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-stream</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> guesses</span><br><span class="line">    (<span class="name">cons-stream</span> <span class="number">1.0</span></span><br><span class="line">                 (<span class="name">stream-map</span> (<span class="name"><span class="builtin-name">lambda</span></span> (guess) (<span class="name">sqrt-improve</span> guess x))</span><br><span class="line">                             guesses)))</span><br><span class="line">  guesses)</span><br><span class="line"><span class="comment">; 由 π/4 = 1- 1/3 + 1/5 - 1/7 + ..... 计算 π 的值</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">pi-summands</span> n)</span><br><span class="line">  (<span class="name">cons-stream</span> (<span class="name"><span class="builtin-name">/</span></span> <span class="number">1.0</span> n)</span><br><span class="line">               (<span class="name">stream-map</span> - (<span class="name">pi-summands</span> (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">2</span>)))))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">partial-sums</span> s)</span><br><span class="line">  (<span class="name">cons-stream</span> (<span class="name">stream-car</span> s)</span><br><span class="line">               (<span class="name">add-streams</span> (<span class="name">stream-cdr</span> s)</span><br><span class="line">                            (<span class="name">partial-sums</span> s))))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> pi-stream</span><br><span class="line">  (<span class="name">scale-stream</span> (<span class="name">partial-sums</span> (<span class="name">pi-summands</span> <span class="number">1</span>)) <span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="序对的无穷流"><a href="#序对的无穷流" class="headerlink" title="序对的无穷流"></a>序对的无穷流</h4><p><center><br>  <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2UTipiVXXXXa5XXXXXXXXXXXX_!!581166664.png" alt="序对(i,j)，并且i<=j"><br></center><br>这里主要是生产序对<code>(i,j)</code>，并且<code>i&lt;=j</code><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">pairs</span> s <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">cons-stream</span></span><br><span class="line">    (<span class="name">list</span> (<span class="name">stream-car</span> s) (<span class="name">stream-car</span> <span class="literal">t</span>))</span><br><span class="line">    (<span class="name">interleave</span></span><br><span class="line">      (<span class="name">stream-map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">list</span> (<span class="name">stream-car</span> s) x))</span><br><span class="line">                  (<span class="name">stream-cdr</span> <span class="literal">t</span>))</span><br><span class="line">      (<span class="name">pairs</span> (<span class="name">stream-cdr</span> s) (<span class="name">stream-cdr</span> <span class="literal">t</span>)))))</span><br></pre></td></tr></table></figure></p><p>这里比较有意思的是<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/03/3.66.md" target="_blank" rel="noopener">习题3.66</a>，让我们计算某序对在流中的位置，这题感觉需要将强的数学功底。</p><h4 id="将流作为信号"><a href="#将流作为信号" class="headerlink" title="将流作为信号"></a>将流作为信号</h4><p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2KcaeiVXXXXXtXpXXXXXXXXXX_!!581166664.png" alt="将积分过程看作信号处理系统"><br></center><br>这里充分利用流当作某系统的输入信号，使得这个系统不断运转下去。</p><h3 id="流的弊端"><a href="#流的弊端" class="headerlink" title="流的弊端"></a>流的弊端</h3><p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2o7KviVXXXXarXXXXXXXXXXXX_!!581166664.png" alt="一个合用账户，通过合并两个交易请求流的方式模拟"><br></center><br>这里还是用两个用户同时访问一个账户为例。处理的麻烦之处在于如何<strong>归并</strong>两个请求流。这里并不能简单交替地从两个请求流取一个地方式合并，因为两个用户访问账户的频率可能不一样。这正好是在并发中不得不去处理的同一个约束条件，在那里我们发现需要引进显式同步，以保证在并发处理具有状态的对象的过程中，各个事件时按照“正确”顺序发生的。这样，虽然这里试图支持函数式的风格，但在需要归并来自不同主体的输入时，又要重新引入函数式风格中致力于消除的同一个问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章一开始就提出了其目标，那就是构造一些计算模型，使其结构能够符合我们对于试图去模拟的真实世界的看法。我们学到了两种方式：</p><ol><li>将这一世界模拟为一集相互分离的、受时间约束的、具有状态的相互交流的对象</li><li>将它模拟为单一的、无时间也无状态的统一体</li></ol><p>每种方式都具有强有力的优势，但就其自身而言，有没有一种方式能够完全令人满意。如何整合这两个系统，是现在一重要难题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;历时三个月，终于把第三章看完了。这三月发生了太多的意外，本文不打算说了，后面在写 &lt;a href=&quot;/blog/2016/01/08/review-2015/#读书&quot;&gt;2015 年终总结&lt;/a&gt;时再来谈谈这三个月的事情。如今回过头来看看第三章的内容，好像也不怎么难，只是内容
      
    
    </summary>
    
      <category term="研习经典" scheme="http://liujiacai.net/categories/%E7%A0%94%E4%B9%A0%E7%BB%8F%E5%85%B8/"/>
    
    
      <category term="sicp" scheme="http://liujiacai.net/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>字符串，那些你不知道的事</title>
    <link href="http://liujiacai.net/blog/2015/11/20/strings/"/>
    <id>http://liujiacai.net/blog/2015/11/20/strings/</id>
    <published>2015-11-20T15:16:21.000Z</published>
    <updated>2019-12-24T10:59:14.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看<a href="http://www.diveintopython3.net/strings.html" target="_blank" rel="noopener">《Dive Into Python 3》</a>，第四章讲了字符串相关知识，看后才发现，字符串远比我们想象的要复杂多。就像该书所说的</p><blockquote><p>Everything you thought you knew about strings is wrong.</p></blockquote><p>是的，我之前对字符串的理解都是错的。</p><p>也许你会诧异，字符串有什么难的，即便遇到乱码的情况随便 Google 下就能找到解决方法，但是这样你不觉得有种被动的感觉嘛，我觉得和学习任何东西一样，学习编程首要是学习其思想，知道某事物为什么（why）要这么做，至于如何做（how）那只是前辈们提出的解决方案，我们可以参考，随便掌握下来。</p><p>本文下面首先讲解字符、字符串、编码、ASCII、Unicode、UTF-8 等一些基本概念，然后会介绍在使用计算机时是如何如编码打交道的，也就是实战部分。<br>希望大家在阅读完本文后，都能对 string 有一全新的认识。</p><h2 id="为什么需要字符编码"><a href="#为什么需要字符编码" class="headerlink" title="为什么需要字符编码"></a>为什么需要字符编码</h2><p>当我们谈到字符串（string或text）时，你可能会想到“计算机屏幕上的那些字符（characters）与符号（symbols）”，你正在阅读的文章，无非也是由一串字符组成的。但是你也许会发现，你无法给“字符串”一明确定义，但是我们就是知道，就像给你一个苹果，你能说出其名字，但是不能给出准确定义一样。这个问题先放一放，后面我再解释。</p><p>我们知道，计算机并不能直接处理操作字符与符号，它只认识 0、1 这两个数字，所以如果想让计算机显示各种各样的字符与符号，就必须定义它们与数字的一一映射关系，也就是我们所熟知的字符编码（character encoding）。你可简单的认为，字符编码为计算机屏幕上显示的字符与这些字符保存在内存或磁盘中的形式提供了一种映射关系。字符编码纷繁复杂，有些专门为特定语言优化，像针对简体中文的编码就有 <a href="https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN" target="_blank" rel="noopener">EUC-CN</a>，<a href="https://en.wikipedia.org/wiki/HZ_%28character_encoding%29" target="_blank" rel="noopener">HZ</a>；针对日文的<a href="https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-JP" target="_blank" rel="noopener">EUC-JP</a>，针对英文的 <a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a>；另一些专门用于多语言环境，像后面要讲到的 <a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>。</p><p>我们可以把<strong>字符编码</strong>看作一种解密密钥（decryption key），当我们收到一段字节流时，无论来自文件还是网络，如果我们知道它是“文本（text）”，那么我们就需要知道采用何种字符编码来<strong>解码</strong>这些字节流，否则，我们得到的只是一堆无意义的符号，像 ������。</p><h3 id="单字节编码"><a href="#单字节编码" class="headerlink" title="单字节编码"></a>单字节编码</h3><p>计算机最早起源于以英文为母语的美国，英文中的符号比较少，用七个二进制位就足以表示，现在最常见也是最流行的莫过于 ASCII 编码，该编码使用 0 到 127 之间的数字来存储字符（65表示“A”，97表示“a”）。</p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2uLAFhpXXXXXZXXXXXXXXXXXX_!!581166664.png_620x10000.jpg" alt=" ASCII_Code_Chart-Quick_ref_card"><br></center><br>我们知道一个字节是 8 位，ASCII 编码其实只使用了其中的低 7 位，还剩下 1 位。很多人就想着可以利用这最高的一位来表示更多的可见字符，由于 IBM 是那时最有名的 OEM，其制定的编码规则影响范围也最广。<br><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2acofhpXXXXbQXpXXXXXXXXXX_!!581166664.gif" alt="ascii-dos"><br></center><p>随着时间的推进，计算机的使用范围扩展到西方欧洲国家，像法国🇫🇷、西班牙🇪🇸，德国🇩🇪等，它们这些国家的字母比英文要多。所以为了表示这些国家的语言，也需要借助最高位扩展 ASCII 编码。但由于没有统一的标准，有些地方用 130 表示 <code>é</code>，有些地方表示为 Hebrew letter Gimel <code>ג</code>。在这些语言中，使用最广的是 <a href="https://en.wikipedia.org/wiki/Windows-1252" target="_blank" rel="noopener">CP-1252 编码</a>，也称为 Windows-1252 编码，因为在 <a href="https://en.wikipedia.org/wiki/Windows-1252#History" target="_blank" rel="noopener">Windows 在 1.0 时就使用了该编码</a>，随着 Windows 的普及，大家就沿用了 Windows-1252 的说法。</p><center><br>    <img src="https://img.alicdn.com/imgextra/i1/581166664/TB25E0xhVXXXXbtXXXXXXXXXXXX_!!581166664.png_310x310.jpg" alt=" Windows-1252"><br></center><h4 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO-8859-1"></a>ISO-8859-1</h4><p>既然说到了 Windows-1252，那么就不能不提它与 ISO-8859-1 的关系，我相信大家对 ISO-8859-1 这个编码肯定很熟悉，我还记得第一次用 Dreamweaver 写 HTML 时，其 HTML 模板中默认编码就是 ISO-8859-1，还有一个比较常见的场景是在 mysql 中，mysql 的默认编码为 latin-1，这其实是 ISO-8859-1 的一个别名而已。</p><p><a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1" target="_blank" rel="noopener">ISO-8859-1</a> 是早期 8 位编码方案的一种，是 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="noopener">ISO/IEC 8859</a> 编码系列的一种， 第一版发布于 1987 年。它主要是针对西欧国家设计，现在大多数流行的 8 位编码方案都以它为基础，这其中就包括 Windows-1252。</p><p>Windows-1252 与 ISO-8859-1 的主要不同在于 0x80 到 0x9F 之间的字符，在 ISO-8859-1 中为控制字符（control characters），在 Windows-1252 中为可打印字符（printable characters）。</p><p>在 HTTP 协议中，以<code>text/</code>开头的 MIME 类型的文件默认编码为 ISO-8859-1，但是由于控制字符在文件中用处不大，所以大多数客户端程序用 Windows-1252 来解码，这也就是它们之间经常混淆的主要原因。</p><h3 id="字符集-vs-字符编码"><a href="#字符集-vs-字符编码" class="headerlink" title="字符集 vs 字符编码"></a>字符集 vs 字符编码</h3><p>在介绍完 ASCII 之后，需要强调一个很重要但被大多数人都忽略的一个概念问题。</p><p>我们平时说的 ASCII 其实有两个含义，一个是 ASCII 字符集，另一个是 ASCII 编码。</p><blockquote><p>ASCII 字符集只是定义了字符与字符码（character code，也称 code point 代码点）的对应关系。也就是说这一层面只是规定了字符<code>A</code>用 65 表示，至于这个 65 在内存或硬盘中怎么表示，它不管，那是 ASCII 编码做的事。</p></blockquote><blockquote><p>ASCII 编码规定了用 7 个二进制位来保存 ASCII 字符码，即定义了字符集的<code>存储形式</code>。</p></blockquote><p>说到这里你也许会问，那既然用 7 个二进制位就能够表示所有 ASCII 字符码了，为什么现在一个字节是 8 位，而不是 7 位呢，这不是浪费吗？</p><p>其实这是早期设计者有意而为之：</p><blockquote><p>7 位表示 ASCII 字符码，剩下 1 位为 <a href="https://en.wikipedia.org/wiki/Parity_bit" target="_blank" rel="noopener">Parity bit</a>，也称为校验位，用以检查数据的正确性。</p></blockquote><p>关于数据校验，我这里不打算展开讲，感兴趣的可以参考 <a href="https://en.wikipedia.org/wiki/Error_detection_and_correction" target="_blank" rel="noopener">Error detection and correction</a>。</p><p>为了让大家更清楚的明白这两者以及相关概念的关系，我画了图，便于大家理解。</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2bda5iXXXXXbHXpXXXXXXXXXX_!!581166664.png" alt="字符、代码点、二进制字节关系图"><br></center><ul><li><code>Character 字符</code>。即我们看到的单个符号，像“A”、“啊”等</li><li><code>Code point 代码点</code>。一个无符号数字，通常用16进制表示。代码点与字符的一一对应关系称为字符集（Character Set），这种对应关系肯定不止一种，也就导致了不同字符集的出现，像 ASCII、ISO-8859-1、GB2312、GBK、Unicode 等。</li><li><code>Bytes 二进制字节</code>。其含义为代码点在内存或磁盘中的表示形式。代码点与二进制字节的一一对应关系称为编码（Encoding），当然这种对应关系也不是唯一的，所以编码也有很多种，像 ASCII、ISO-8859-1、ENC-CN、GBK、UTF-8等。</li></ul><blockquote><p>上面这个图基本把我们平时经常混淆的概念清晰地区分开了，大家一定要充分理解并牢记于心。</p></blockquote><h3 id="多字节编码"><a href="#多字节编码" class="headerlink" title="多字节编码"></a>多字节编码</h3><p>多字节编码主要用于我们亚洲国家，像中文（Chinese），日文（Japanese），韩文（Korean）（业界一般称为 CJK）等象形（表意）文字（ideograph-based language），字符数量比较多，1 个字节是放不下的，所以需要更多的字节来进行字符的编码。</p><p><a href="https://en.wikipedia.org/wiki/ISO/IEC_2022" target="_blank" rel="noopener">ISO/IEC 2022</a> 标准为多字节编码制定了一套标准，主要有下面两个方面：</p><ol><li>一个编码系统里面可以表示多种字符集</li><li>一个编码系统既可以在 7 位编码系统中表示所有字符集，也可以在 8 位编码系统表示所有字符集</li></ol><p>为了能够表示多种字符集 ISO/IEC 2022 引入了<a href="https://en.wikipedia.org/wiki/Escape_sequence" target="_blank" rel="noopener">escape sequences</a>，也就是我们中文里面说的“转义字符”的意思；为了能够兼容之前的 7 位编码系统，像 ASCII，实现 ISO/IEC 2022 标准的编码系统一般都是<strong>变长编码</strong>。</p><h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p><a href="https://en.wikipedia.org/wiki/GB_2312" target="_blank" rel="noopener">GB2312</a> 是我国国家标准总局在1980年发布一套遵循 ISO/IEC 2022 标准的<code>字符集</code>，在 GB2312 中，字符码一般称为区位码，由于该字符集需要兼容 ASCII 字符集，所以它只能一个字节中的 7 位，剩下 1 位用于区分，比如可以通过最高位为 1 表示 GB2312 字符集，为 0 表示 ASCII 字符集。</p><p>GB2312 使用两个字节来表示字符码，最多可以表示 94 * 94 个字符，但是 GB2312 并没有全部使用，留了一部分方便后面扩展用。</p><p>实现 GB2312 字符集的编码主要是 <a href="https://en.wikipedia.org/wiki/Extended_Unix_Code#EUC-CN" target="_blank" rel="noopener">EUC-CN</a>，该编码与 ASCII 编码兼容。</p><p>我们平时说的 GB2312 编码其实就是指的 EUC-CN 编码，这一点需要明白。</p><h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p><a href="https://en.wikipedia.org/wiki/GBK" target="_blank" rel="noopener">GBK</a> 字符集是对 GB2312 字符集的扩展，GBK 并没有一个官方标准，现在使用最广的标准是微软在 Windows 95 中实现的版本——<a href="https://en.wikipedia.org/wiki/Code_page_936" target="_blank" rel="noopener">CP936</a> 编码。</p><p>GBK 也使用两个字节来表示字符码，94 * 94 的区位码分布可以参考下面这个图，截自 <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/GBK_encoding.svg/1290px-GBK_encoding.svg.png" target="_blank" rel="noopener">Wikipedia</a></p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2wxevhVXXXXaUXpXXXXXXXXXX_!!581166664.png_310x310.jpg" alt="GBK_encoding"><br></center><p>同 GB2312 一样，我们平时说的 GBK 编码其实就是指的 CP936 编码。</p><p>除了我们中国的 GB* 系统字符集以外，日本、韩国各有各的字符集标准，虽然都是基于 ISO/IEC 2022，但是具体的表示方式千差万别，比如 1601 在 GB2312 中表示“啊”，但在日韩就不知道表示什么含义了。</p><p>所以，我们需要一种囊括世界上所有字符的一套字符集，在该字符集中，字符码与字符一一对应，比如字符码 0x41 表示英文字母<code>A</code>，在任何国家都表示<code>A</code>，即使该国家没有这个字符。解决这个问题的是现在最流行的一套字符集——Unicode。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 的全称是 universal character encoding，中文一般翻译为“统一码、万国码、单一码”。</p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2GcoghpXXXXc6XpXXXXXXXXXX_!!581166664.png_160x160.jpg" alt="Unicode_logo"><br></center><p>在 Unicode 中字符码称为 code point，用 4 个字节来表示，这么做主要是为了涵盖世界上所有的字符。写法一般为<code>U+XXXX</code>，XXXX 为用 16 进制表示的数字。比如，<code>U+0041</code>表示<code>A</code>。</p><h3 id="Unicode-的存储形式"><a href="#Unicode-的存储形式" class="headerlink" title="Unicode 的存储形式"></a>Unicode 的存储形式</h3><p>Unicode 的<strong>存储形式</strong>一般称为<code>UTF-*</code>编码，其中 UTF 全称为 <code>Unicode Transformation Format</code>，常见的有：</p><h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p><a href="https://en.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a> 编码是 Unicode 最直接的存储方式，用 4 个字节来分别表示 code point 中的 4 个字节，也是 <code>UTF-*</code>编码家族中唯一的一种<strong>定长编码（fixed-length encoding）</strong>。UTF-32 的好处是能够在<code>O(1)</code>时间内找到第 N 个字符，因为第 N 个字符的编码的起点是 N*4 个字节，当然，劣势更明显，四个字节表示一个字符，别说以英文为母语的人不干，我们中国人也不干了。</p><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p><a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a> 最少可以采用 2 个字节表示 code point，需要注意的是，UTF-16 是一种<strong>变长编码（variable-length encoding）</strong>，只不过对于 65535 之内的 code point，采用 2 个字节表示而已。如果想要表示 65535 之上的字符，需要一些 hack 的手段，具体可以参考<a href="https://en.wikipedia.org/wiki/UTF-16#U.2B10000_to_U.2B10FFFF" target="_blank" rel="noopener">wiki UTF-16#U.2B10000_to_U.2B10FFFF</a>。很明显，UTF-16 比 UTF-32 节约一半的存储空间，如果用不到 65535 之上的字符的话，也能够在<code>O(1)</code>时间内找到第 N 个字符。</p><blockquote><p>UTF-16 与 UTF-32 还有一个不明显的缺点。我们知道不同的计算机存储字节的顺序是不一样的，这也就意味着<code>U+4E2D</code> 在 UTF-16 可以保存为<code>4E 2D</code>，也可以保存成<code>2D 4E</code>，这取决于计算机是采用大端模式还是小端模式，UTF-32 的情况也类似。为了解决这个问题，引入了 <strong>BOM (Byte Order Mark)</strong>，它是一特殊的不可见字符，位于文件的起始位置，标示该文件的字节序。对于 UTF-16 来说，BOM 为<code>U+FEFF</code>（FF 比 FE 大 1），如果 UTF-16 编码的文件以<code>FF FE</code>开始，那么就意味着其字节序为<strong>小端模式</strong>，如果以<code>FE FF</code>开始，那么就是<strong>大端模式</strong>。<br>其他 UTF-* 编码的 BOM 可以参考 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#Representations_of_byte_order_marks_by_encoding" target="_blank" rel="noopener">Representations of byte order marks by encoding</a>。</p></blockquote><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-16 对于以英文为母语的人来说，还是有些浪费了，这时聪明的人们（准确说是<a href="https://en.wikipedia.org/wiki/Ken_Thompson_%28computer_programmer%29" target="_blank" rel="noopener">Ken Thompson</a>与<a href="https://en.wikipedia.org/wiki/Rob_Pike" target="_blank" rel="noopener">Rob Pike</a>）又<a href="http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt" target="_blank" rel="noopener">发明</a>了另一个编码——<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>。在 UTF-8 中，ASCII 字符采用单字节。其实，UTF-8 前 128 个字符与 ASCII 字符编码方式一致；扩展的拉丁字符像<code>ñ</code>、<code>ö</code>等采用2个字节存储；中文字符采用 3 个字符存储，使用频率极少字符采用 4 个字节存储。由此可见，UTF-8 也是一种<strong>变长编码（variable-length encoding）</strong>。</p><p>UTF-8 的编码规则很简单，只有二条：</p><ol><li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 code point。因此对于英语字母，UTF-8编码和ASCII码是相同的。</li><li>对于n字节的符号，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 code point。</li></ol><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB244crhpXXXXbKXpXXXXXXXXXX_!!581166664.png" alt=" UTF-8 编码规则"></p><p>通过上面这两个规则，UTF-8 就不存在字节顺序在大小端不同的情况，所以用 UTF-8 编码的文件在任何计算机中保存的字节流都是一致的，这是其很重要一优势；UTF-8 的另一大优势在于对 ASCII 字符超节省空间，存储扩展拉丁字符与 UTF-16 的情况一样，存储汉字字符比 UTF-32 更优。</p><p>UTF-8 的一劣势是查找第 N 个字符时需要<code>O(N)</code> 的时间，也就是说，字符串越长，就需要更长的时间来查找其中的每个字符。其次是在对字节流解码、字符编码时，需要遵循上面两条规则，比 UTF-16、UTF-32 略麻烦。</p><p>随着互联网的兴起，UTF-8 是逐渐成为使用范围最广的编码方案。下图为 Google 在 2010 年初做的<a href="http://googleblog.blogspot.com/2010/01/unicode-nearing-50-of-web.html" target="_blank" rel="noopener">统计</a>（链接需翻墙）</p><p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2PjtzhVXXXXbnXXXXXXXXXXXX_!!581166664.png_620x10000.jpg" alt=" Growth_of_Unicode_on_the_Web"><br></center><br>由于 Google 的爬虫遍布全世界，这个数据可信度比较高。</p><h3 id="UCS"><a href="#UCS" class="headerlink" title="UCS"></a>UCS</h3><p>我们在互联网上查找编码相关资料时，经常会看到<code>UCS-2</code>、<code>UCS-4</code>编码，它们和<code>UTF-*</code>编码家族是什么关系呢？要想理清它们之间的关系，需要先弄清楚，什么是 <strong>UCS</strong>。</p><p><a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="noopener">UCS</a> 全称是 <strong>Universal Coded Character Set</strong>，是由 <a href="https://en.wikipedia.org/wiki/ISO/IEC_10646" target="_blank" rel="noopener">ISO/IEC 10646</a>定义的一套标准字符集，是很多字符编码的基础，UCS 中大概包含 100,000 个抽象字符，每一个字符都有一唯一的数字编码，称为 code point。</p><p>在19世纪八十年代晚期，有两个组织同时在 UCS 的基础上开发一种与具体语言无关的统一的编码方案，这两个组织分别是 <a href="https://en.wikipedia.org/wiki/IEEE" target="_blank" rel="noopener">IEEE</a> 与 <a href="https://en.wikipedia.org/wiki/Unicode_Consortium" target="_blank" rel="noopener">Unicode Consortium</a>，为了保持这两个组织间编码方案的兼容性，两个组织尝试着合作。早期的两字节编码方案叫做“Unicode”，后来改名为“UCS-2”，在研发过程发，发现 16 位根本不能够囊括所有字符，于是 IEEE 引入了新的编码方案——UCS-4 编码，这种编码每个字符需要 4 个字节，这一行为立刻被 Unicode Consortium 制止了，因为这种编码太浪费空间了，又因为一些设备厂商已经对 2 字节编码技术投入大量成本，所以在 1996 年 7 月发布的 Unicode 2.0 中提出了 UTF-16 来打破 UCS-2 与 UCS-4 之间的僵局，UTF-16 在 2000 年被 <a href="https://en.wikipedia.org/wiki/IETF" target="_blank" rel="noopener">IEFE</a> 组织制定为<a href="https://tools.ietf.org/html/rfc2781" target="_blank" rel="noopener">RFC 2781</a>标准。更多可参考：</p><ul><li><a href="http://unicode.org/faq/utf_bom.html#utf16-11" target="_blank" rel="noopener">Q: What is the difference between UCS-2 and UTF-16?</a></li></ul><p>由此可见，<code>UCS-*</code> 编码是一历史产物，目前来说，统一编码方案最终的赢家是 <code>UTF-*</code> 编码。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>根据<a href="http://unicode.org/notes/tn12/#Software_16" target="_blank" rel="noopener">UTF-16 FOR PROCESSING</a>，现在流行的三大操作系统 Windows、Mac、Linux 均采用 UTF-16 编码方案，上面链接也指出，现代编程语言像 Java、ECMAScript、.Net 平台上所有语言等在内部也都使用 UTF-16 来表示字符。<br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2hdILhpXXXXbAXpXXXXXXXXXX_!!581166664.png" alt="Mac Finder 界面"><br>上图为 Mac 系统中文件浏览器 Finder 的界面，其中所有的字符，在内存中都是以 UTF-16 的编码方式存储的。</p><p>你也许会问，为什么操作系统都这么偏爱 UTF-16，Stack Exchange 上面有一个精彩的回答，感兴趣的可以去了解</p><ul><li><a href="http://programmers.stackexchange.com/questions/102205/should-utf-16-be-considered-harmful" target="_blank" rel="noopener">Should UTF-16 be considered harmful?</a></li><li><a href="http://utf8everywhere.org/" target="_blank" rel="noopener">UTF-8 Everywhere</a></li></ul><h4 id="Locale"><a href="#Locale" class="headerlink" title="Locale"></a>Locale</h4><p>为了适应多语言环境，Linux/Mac 系统通过 <a href="http://man7.org/linux/man-pages/man7/locale.7.html" target="_blank" rel="noopener">locale</a> 来设置系统的语言环境，下面是我在 Mac 终端输入<code>locale</code>得到的输出</p><pre><code>LANG=&quot;en_US.UTF-8&quot;         &lt;==主语言的环境LC_COLLATE=&quot;en_US.UTF-8&quot;   &lt;==字串的比较排序等LC_CTYPE=&quot;en_US.UTF-8&quot;     &lt;==语言符号及其分类LC_MESSAGES=&quot;en_US.UTF-8&quot;  &lt;==信息显示的内容，如功能表、错误信息等LC_MONETARY=&quot;en_US.UTF-8&quot;  &lt;==币值格式的显示等LC_NUMERIC=&quot;en_US.UTF-8&quot;   &lt;==数字系统的显示信息LC_TIME=&quot;en_US.UTF-8&quot;      &lt;==时间系统的显示资料LC_ALL=&quot;en_US.UTF-8&quot;       &lt;==语言环境的整体设定</code></pre><p>locale 按照所涉及到的文化传统的各个方面分成12个大类，上面的输出只显示了其中的 6 类。为了设置方便，我们可以通过设置<code>LC_ALL</code>、<code>LANG</code>来改变这 12 个分类熟悉。其优先级关系为</p><blockquote><p><code>LC_ALL</code> &gt; <code>LC_*</code> &gt; <code>LANG</code></p></blockquote><p>设置好 locale，操作系统在进行文本字节流解析时，如果没有明确制定其编码，就用 locale 设定的编码方案，当然现在的操作系统都比较聪明，在用默认编码方案解码不成功时，会尝试其他编码，现在比较成熟的编码测探技术有<a href="http://www-archive.mozilla.org/projects/intl/UniversalCharsetDetection.html" target="_blank" rel="noopener">Mozila 的 UniversalCharsetDetection</a> 与 <a href="http://userguide.icu-project.org/conversion/detection" target="_blank" rel="noopener">ICU 的 Character Set Detection</a> 。</p><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>一般来说，高级编程语言都提供都对字符的支持，像 Java 中的 <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html" target="_blank" rel="noopener">Character</a> 类就采用 UTF-16 编码方案。</p><p>这里有个文字游戏，一般我们说“某某字符串是XX编码”，其实这是不合理的，因为字符串压根就没有编码这一说法，只有<strong>字符</strong>才有，字符串只是字符的一串序列而已。<br>不过我们平时并没有这么严谨，不过你要明白，当我们说“某某字符串是XX编码”时，知道这其实指的是该字符串中字符的编码就可以了。<br>这也就回答了本文一开始提到问题，什么是字符串，这里用《Diving into Python 3》书上的一句话来总结这个问题：</p><blockquote><p>Bytes are not character, bytes are bytes. Characters are an abstraction. A string is a sequence of those abstraction.</p></blockquote><p>我们可以做个简单的实验来验证 Java 中确实使用 UTF-16 编码来存储字符：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> s  = <span class="string">"中国人a"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//线程睡眠，不要让线程退出</span></span><br><span class="line">            Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用 javac 编译这个类时，javac 会按照操作系统默认的编码去解析字节流，如果你保存的源文件编码与操作系统默认不一致，是可能出错的，可以在启动 javac 命令时，附加<code>-encoding &lt;encoding&gt;</code>选项来指明源代码文件所使用的编码。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译生成 .class 文件</span></span><br><span class="line"><span class="keyword">javac </span>-encoding utf<span class="number">-8</span> EncodingTest.<span class="keyword">java</span></span><br><span class="line"><span class="keyword"># </span>执行该类</span><br><span class="line"><span class="keyword">java </span>EncodingTest</span><br><span class="line"><span class="comment"># 使用 jps 查看其 pid，然后用 jmap 把程序运行时内存的内容 dump 下来</span></span><br><span class="line"><span class="keyword">jmap </span>-dump:live,format=<span class="keyword">b,file=encoding_test.bin </span>&lt;pid&gt;</span><br><span class="line"><span class="comment"># 在 Linux/Mac 系统上，使用 xxd 命令以十六进制查看该文件，我这里用管道传给了 vim</span></span><br><span class="line">xxd encoding_test.<span class="keyword">bin </span><span class="title">| vim -</span></span><br></pre></td></tr></table></figure></p><p>在 vim 中可以看到下图所示片段<br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2RigHhpXXXXb5XpXXXXXXXXXX_!!581166664.png" alt="以16进制显示的memory dump"><br>其中我用红框标注部分就是上面 EncodingTest 类中字符串<code>s</code>的内容，<code>4e2d</code>是“中”的 code point，<code>56fd</code>是“国”的 code point， <code>4eba</code>是“人”的 code point，<code>0061</code>是“a”的 code point。而在 UTF-16 编码中，0-66535之间的字符直接用两个字节存储，这也就证明了 Java 中的 <code>Character</code> 是使用 UTF-16 编码的。</p><p>关于 Java 支持的所有编码，可以在 Oracle 官方文档 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html" target="_blank" rel="noopener">Supported Encodings</a>中找到。</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><h5 id="Python-解释器"><a href="#Python-解释器" class="headerlink" title="Python 解释器"></a>Python 解释器</h5><p>首先说下 Python 解释器如何读取、解析 Python 源程序。</p><p>在 Python 2 中，Python 解析器默认用 ASCII 编码（而非系统默认编码）来读取源程序，当程序中包含非 ASCII 字符时，解释器会报错，下面实验在我 Mac 上用 python 2.7.6 进行：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat str.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">a</span> = <span class="string">"中国人"</span></span><br><span class="line"></span><br><span class="line">$ python str.py</span><br><span class="line">  File <span class="string">"str.py"</span>, <span class="built_in">line</span> <span class="number">2</span></span><br><span class="line">SyntaxError: Non-ASCII <span class="keyword">character</span> <span class="string">'\xe4'</span> <span class="keyword">in</span> <span class="built_in">file</span> str.py <span class="keyword">on</span> <span class="title">line</span> <span class="title">2</span>, <span class="title">but</span> <span class="title">no</span> <span class="title">encoding</span> <span class="title">declared</span>; <span class="title">see</span> <span class="title">http</span>://<span class="title">www</span>.<span class="title">python</span>.<span class="title">org</span>/<span class="title">peps</span>/<span class="title">pep-0263</span>.<span class="title">html</span> <span class="title">for</span> <span class="title">details</span></span><br></pre></td></tr></table></figure></p><p>我们可以通过在源程序起始处用<code>coding: name</code>或<code>coding=name</code>来声明源程序所用的编码。</p><p>Python 3 中改变了这一行为，解析器默认采用 UTF-8 解析源程序。</p><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>下面介绍 Python 2/3 中对字符的处理。</p><p>Python 2 中对字符的处理坑比较多，我这里单独写了篇文章介绍，感兴趣的可以参考：<a href="/blog/2016/06/30/python2-encoding/">《Python2 中的编码问题》</a>。 </p><p>Python 3 中改变了这一行为，字符字面量直接表示为 Unicode 字符，引入以“字节”类型表示 Python 2 中的 str 类型，根据<a href="https://www.python.org/dev/peps/pep-0393/#specification" target="_blank" rel="noopener">PEP-0393</a>，Python 3 内部采用多种编码方案，而不仅仅是单单一种（细节可以参考<a href="https://github.com/python/cpython/blob/1fe0fd9feb6a4472a9a1b186502eb9c0b2366326/Doc/c-api/unicode.rst" target="_blank" rel="noopener">c-api/unicode</a>），这么做是权衡字符存储空间与字符操作速度后的结果，下面给出 CPython 中相关的定义：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  PyObject_HEAD</span><br><span class="line">  Py_ssize_t length;</span><br><span class="line">  Py_hash_t hash;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      unsigned int <span class="symbol">interned:</span><span class="number">2</span>;</span><br><span class="line">      unsigned int <span class="symbol">kind:</span><span class="number">2</span>;</span><br><span class="line">      unsigned int <span class="symbol">compact:</span><span class="number">1</span>;</span><br><span class="line">      unsigned int <span class="symbol">ascii:</span><span class="number">1</span>;</span><br><span class="line">      unsigned int <span class="symbol">ready:</span><span class="number">1</span>;</span><br><span class="line">  &#125; state;</span><br><span class="line">  wchar_t *wstr;</span><br><span class="line">&#125; PyASCIIObject;</span><br><span class="line"></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  PyASCIIObject _base;</span><br><span class="line">  Py_ssize_t utf8_length;</span><br><span class="line">  char *utf8;</span><br><span class="line">  Py_ssize_t wstr_length;</span><br><span class="line">&#125; PyCompactUnicodeObject;</span><br><span class="line"></span><br><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  PyCompactUnicodeObject _base;</span><br><span class="line">  /<span class="regexp">/ 可以看到，这里用了 union 类型，实际中 data 的类型为四种中的一个</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 同时，这里的 ucs2 相当于 utf-16；ucs4 相当于 utf-32</span></span><br><span class="line"><span class="regexp">  union &#123;</span></span><br><span class="line"><span class="regexp">      void *any;</span></span><br><span class="line"><span class="regexp">      Py_UCS1 *latin1;</span></span><br><span class="line"><span class="regexp">      Py_UCS2 *ucs2;</span></span><br><span class="line"><span class="regexp">      Py_UCS4 *ucs4;</span></span><br><span class="line"><span class="regexp">  &#125; data;</span></span><br><span class="line"><span class="regexp">&#125; PyUnicodeObject;</span></span><br></pre></td></tr></table></figure></p><p>我们也可以做个实验验证 Python 中 Unicode 的存储方案：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python <span class="number">3.5</span>.<span class="number">0</span> (v3.<span class="number">5.0</span>:<span class="number">374</span>f501f4567, Sep <span class="number">12</span> <span class="number">2015</span>, <span class="number">11</span>:<span class="number">00</span>:<span class="number">19</span>)</span><br><span class="line">[GCC <span class="number">4.2</span>.<span class="number">1</span> (Apple Inc. build <span class="number">5666</span>) (dot <span class="number">3</span>)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> for more information.</span><br><span class="line">&gt;&gt;&gt; a  = <span class="string">"中国人"</span></span><br><span class="line">&gt;&gt;&gt; import ctypes</span><br><span class="line">&gt;&gt;&gt; import binascii</span><br><span class="line">&gt;&gt;&gt; binascii.hexlify(ctypes.string_at(id(a), a.__sizeof__()))</span><br><span class="line">b'<span class="number">01000000000000</span><span class="number">0020</span>c<span class="number">52200010000000</span><span class="number">30000000000000</span>0cfb<span class="number">7326</span>4f62ba107a81c<span class="number">22000100000000</span><span class="number">00000000000000</span><span class="number">00000000000000</span><span class="number">0000000000</span>0</span><br><span class="line"><span class="number">00000000000000</span><span class="number">0000000002</span>d4efd56ba4e<span class="number">0000</span>'</span><br><span class="line">&gt;&gt;&gt; binascii.hexlify(a.encode('utf-16'))</span><br><span class="line">b'fffe2d4efd56ba4e'</span><br></pre></td></tr></table></figure></p><p><code>fffe</code>是 UTF-16 的 BOM，表明我的Mac是小端模式。随后的<code>2d4e</code>表示<code>中</code>；<code>fd56</code>表示<code>国</code>；<code>ba4e</code>表示<code>人</code>，最后的<code>0000</code>表明 Python 中的字符串和 C 语言中的一样，用<code>\0</code>标明字符的结尾。<br>如果你比较细心，可能会发现 CPython 中字符相关的结构体中包含了<code>length</code>这一字段了，为什么这里又多此一举，加个尾标呢？其实这主要是为了Python 与 C 的交互，有了<code>\0</code>，Python 就可以直接读取 C 中的字符，也可以直接将 Python 中的字符直接传给 C 了。</p><p>参考：</p><ul><li><a href="http://lucumr.pocoo.org/2014/1/5/unicode-in-2-and-3/" target="_blank" rel="noopener">More About Unicode in Python 2 and 3</a></li><li><a href="http://v2ex.com/t/247821" target="_blank" rel="noopener"> Python3 的 str 底层是用什么编码储存的？</a></li></ul><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>JavaScript 遵循 ECMAScript 规范，在 <a href="http://es5.github.io/x2.html#x2" target="_blank" rel="noopener">ECMAScript 5.1</a> 中有下面的定义：</p><blockquote><p>A conforming implementation of this International standard shall interpret characters in conformance with the Unicode Standard, Version 3.0 or later and ISO/IEC 10646-1 with either UCS-2 or UTF-16 as the adopted encoding form, implementation level 3. If the adopted ISO/IEC 10646-1 subset is not otherwise specified, it is presumed to be the BMP subset, collection 300. If the adopted encoding form is not otherwise specified, it is presumed to be the UTF-16 encoding form.</p></blockquote><p>也就是说 JavaScript 解释器的实现，即可以用 UCS-2 也可以用 UTF-16，但是考虑到 UTF-16 是 UCS-2 的超集，所以现在浏览器中的 JavaScript 引擎都用 UTF-16 存储字符串。<br>我这里做了个实验验证 Nodejs 中字符的存储方案：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 1. 安装这个模块</span></span><br><span class="line">npm install heapdump</span><br><span class="line"><span class="meta"># 2. 写个简单的程序</span></span><br><span class="line"><span class="keyword">var</span> heapdump = require(<span class="string">'heapdump'</span>);</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"中国人"</span>;</span><br><span class="line">heapdump.writeSnapshot(<span class="string">'str_test.heapsnapshot'</span>);</span><br><span class="line"><span class="meta"># 3. 执行上面的程序后，找个二进制编辑器，打开生成的内存快照文件。我这里用了 xxd</span></span><br><span class="line">xxd str_test.heapsnapshot | vim -</span><br></pre></td></tr></table></figure></p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2yyi9jXXXXXauXXXXXXXXXXXX_!!581166664.png" alt="Nodejs 字符内存快照"></p><p>上图中的<code>\u4E2D</code>即为“中”，在内存中的字节序为<code>5c75 3445 3244</code>，这一串数字是<code>\u4E2D</code>的 ASCII 码。</p><p>参考：</p><ul><li><a href="https://mathiasbynens.be/notes/javascript-encoding" target="_blank" rel="noopener">JavaScript’s internal character encoding: UCS-2 or UTF-16?</a></li></ul><h3 id="HTML-XML"><a href="#HTML-XML" class="headerlink" title="HTML/XML"></a>HTML/XML</h3><p>在我们的 Web 浏览器接收到来自世界各地的 HTML/XML 时，也需要正确的编码方案才能够正常显示网页，在现代的 HTML5 页面，一般通过下面的代码指定<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">charset</span>=<span class="string">"UTF-8"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>4.0.1 之前的 HTML 页面使用下面的代码<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attribute">content</span>=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>XML 使用属性标注其编码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br></pre></td></tr></table></figure></p><p>仔细想想，这里有个矛盾的地方，因为我们需要事先知道某字节流的编码才能正确解析该字节流，而这个字节流的编码是保存在这段字节流中的，和“鸡生蛋，蛋生鸡”的问题有点像，其实这并不是一个问题，因为大部分的编码都是兼容 ASCII 编码的，而这些 HTML/XML 开始处基本都是 ASCII 字符，所以采用浏览器默认的编码方案即可解析出该字节流所声明的编码，在解析出该字节流所用编码后，使用该编码重新解析该字节流。</p><h3 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h3><ul><li><a href="http://edyfox.codecarver.org/html/vim_fileencodings_detection.html" target="_blank" rel="noopener">vim_fileencodings_detection</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章第一次写用了周末 2 天时间才完成，在后面陆陆续续又增删了不少，我只能说真是长见识了。在 wiki 上搜索的资料时，需要消耗较大精力去整理，因为各个编码都不是孤立存在的，要想完整了解某编码，需要从起发展历史开始，在不同编码条目间来回切换，才能对其有深入理解。这是我意料之外的。</p><p>字符串，这个既熟悉又陌生的东西，相信大家在看本文后，大家都能够对其有一全新的认识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></li><li><a href="http://programmers.stackexchange.com/questions/291950/are-data-type-declarators-like-int-and-char-stored-in-ram-when-a-c-program-e" target="_blank" rel="noopener">Are data type declarators like “int” and “char” stored in RAM when a C program executes?</a></li><li><a href="http://www.utf8everywhere.org" target="_blank" rel="noopener">UTF-8 Everywhere</a></li><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode和UTF-8</a></li><li><a href="http://illegalargumentexception.blogspot.hk/2009/05/java-rough-guide-to-character-encoding.html" target="_blank" rel="noopener">Java: a rough guide to character encoding</a></li><li><a href="https://docs.python.org/2/howto/unicode.html" target="_blank" rel="noopener">Python Unicode HOWTO</a></li><li><a href="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/core-formats.html" target="_blank" rel="noopener">How does my computer store things in memory?</a></li><li><a href="http://www.fmddlmyy.cn/text6.html" target="_blank" rel="noopener">谈谈Unicode编码，简要解释UCS、UTF、BMP、BOM等名词</a></li><li><a href="https://docs.python.org/2.7/reference/datamodel.html#the-standard-type-hierarchy" target="_blank" rel="noopener">The Python Language Reference: Data model</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看&lt;a href=&quot;http://www.diveintopython3.net/strings.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Dive Into Python 3》&lt;/a&gt;，第四章讲了字符串相关知识，看后才发现，字符串远
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="string" scheme="http://liujiacai.net/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>SF 黑客马拉松赛后回顾</title>
    <link href="http://liujiacai.net/blog/2015/10/27/sf-hackathon/"/>
    <id>http://liujiacai.net/blog/2015/10/27/sf-hackathon/</id>
    <published>2015-10-27T13:05:30.000Z</published>
    <updated>2019-12-24T10:59:14.603Z</updated>
    
    <content type="html"><![CDATA[<p>上个周末，也就是10月24、25号，参加了人生中第一次<a href="http://segmentfault.com/hackathon-2015" target="_blank" rel="noopener">黑客马拉松</a>（hackathon），虽然最终没有获奖，但是这个比赛过程中还是 hack 的挺爽，趁现在还有余热，纪录下比赛时的一些心得与收获。</p><h2 id="为什么参加-hackathon"><a href="#为什么参加-hackathon" class="headerlink" title="为什么参加 hackathon"></a>为什么参加 hackathon</h2><p>当在公司得知有黑客马拉松之后，我就立即报名了，觉得这件事本身就很酷，虽然身边一些同事说此类比赛没意思，大部分人都是奔着投资去的，但我还是觉得要你怎么看了，你如果去是为了那奖品、钱，我觉得那失去了 hackathon 的意义了，hackathon 我理解的就是</p><blockquote><p>做一些很酷的事情，而这些事情在平时的工作中“用不到”，但是完成这些事能够让我们有很强的满足感。</p></blockquote><p>也就是玩，虽然当知道自己的作品没有获奖时会有些许失落，但那是一时的，最起码那一天一夜 coding，让我确实很 high。</p><h2 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h2><p>编程语言我毫无疑问的选择了 javascript，一来 javascript 与 Scheme 有<a href="https://en.wikipedia.org/wiki/JavaScript#JavaScript_and_Java" target="_blank" rel="noopener">很深的渊源</a>，其次我也一直想好好系统学习下 nodejs，所以就是它了。参加比赛前的一周，我停止了 <a href="https://github.com/jiacai2050/sicp" target="_blank" rel="noopener">SICP</a> 的阅读，转而进攻<a href="http://book.douban.com/subject/25870705/" target="_blank" rel="noopener">《Node.js实战》</a>，这本书之前断断续续翻过前两章，这次基本把这本书看完了，主要是学习了下如何系统的开发一个完整的 node 应用，包括常用模块、通用架构等，之前写的 node 都是玩具，没有错误处理，没有单元测试（这次比赛虽然也没用上，但是知道了如何使用相应工具去测了）。</p><p>书上最后一章介绍了 node 中较为底层的知识，像<code>net</code>库，node 的定位就是提供小而美的核心类库，常用的模块都是基于这些核心类库构建。下面纪录两个书中比较有趣的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">"net"</span>);</span><br><span class="line"><span class="keyword">var</span> socket = net.connect(&#123;<span class="attr">host</span>: <span class="string">"github.com"</span>, <span class="attr">port</span>: <span class="number">22</span>&#125;);</span><br><span class="line">socket.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk.toString());</span><br><span class="line">    socket.end();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动后，会输出 SSH-2.0-libssh-0.7.0</span></span><br></pre></td></tr></table></figure></p><p>下面的代码片段实现了类似于 Linux 上 <a href="http://linux.die.net/man/1/nc" target="_blank" rel="noopener">nc</a> 命令的功能：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var net = require(<span class="string">"net"</span>);</span><br><span class="line">var socket = net.connect(&#123;host: process.argv[<span class="number">2</span>], port: process.argv[<span class="number">3</span>]&#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="keyword">on</span><span class="params">(<span class="string">"connect"</span>, function<span class="params">()</span> &#123;</span></span><br><span class="line"><span class="params">    process.stdin.pipe<span class="params">(socket)</span>;</span></span><br><span class="line"><span class="params">    socket.pipe<span class="params">(process.stdout)</span>;</span></span><br><span class="line"><span class="params">    process.stdin.resume<span class="params">()</span>;</span></span><br><span class="line"><span class="params">&#125;)</span>;</span><br><span class="line">socket.<span class="keyword">on</span><span class="params">(<span class="string">"close"</span>, function<span class="params">()</span> &#123;</span></span><br><span class="line"><span class="params">    console.log<span class="params">(<span class="string">"bye..."</span>)</span>;</span></span><br><span class="line"><span class="params">&#125;)</span>;</span><br></pre></td></tr></table></figure></p><p>其次在看 expressjs 时，无意间发现其作者 <a href="https://github.com/tj" target="_blank" rel="noopener">tj</a> 早在 2014年4月份，就已经<a href="https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b" target="_blank" rel="noopener">抛弃 nodejs，投向 go 的怀抱</a>，心中难免有些忧伤，大牛总是这样，在我们还在学习某东西时，人家已经发现其缺点，转向更高深的地方……</p><h2 id="比赛开始了"><a href="#比赛开始了" class="headerlink" title="比赛开始了"></a>比赛开始了</h2><p>这次的比赛是命题制——技术改变生活，这基本上是没有限制，经过有赞小伙伴的一番讨论，最终定了3个题目，然后就开始组队做了，我和劲风一组，做的是一个超市扫码购物的微信应用，想要解决的基本问题是——超市排长队付款。对于我来说，主要是想做一些有难度的技术，挑战自己，也没想为什么现在超市为什么不推行扫码购物，当然这也是后来评委问我们的问题。<br>这个题目主要的技术难点有：</p><h3 id="微信公众号开发"><a href="#微信公众号开发" class="headerlink" title="微信公众号开发"></a>微信公众号开发</h3><p>如何扫码是我们遇到的第一个问题，是借助微信还是自己做原生应用，由于我俩都不会 Android 与 IOS 开发，所以微信成了唯一选择。<br>微信开发需要有公众号，如果调用 <a href="http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="noopener">JS-SDK</a>，需要有备过案的域名，我们都没有，这时我想到了<a href="http://sundabao.com/" target="_blank" rel="noopener">大宝</a>兄，他很慷慨的给我提供云主机、mysql、nginx，加上宝贵的域名，很是感谢。（后面知道了可以用<a href="http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">测试号</a>）。</p><p>这里必须吐槽下微信的开发文档，真是烂：排版烂、个别语句不通顺、经常有死链接，希望微信团队好好维护下。</p><p>比如这里的<a href="http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html" target="_blank" rel="noopener">签名算法</a>，由于微信的人不知道<a href="http://www.w3school.com.cn/html/html_links.asp" target="_blank" rel="noopener">命名锚（named anchors）</a>，所以你在打开上面的链接后，需要用<code>Ctrl + F</code> 来搜索 “签名算法” 才能找到我这里所指的签名算法，最最坑人的是，由于签名是针对网页 URL 的，所以一个网页需要签名一个，而这个 URL 必须是以<code>/</code>结尾，比如，如果用<code>http://1024.sundabao.com</code>这个 URL 来签名是不对的，必须是<code>http://1024.sundabao.com/</code>，这个真的好坑。</p><p>相比之下，Github的<a href="https://developer.github.com/v3" target="_blank" rel="noopener">开发者文档</a>，看起来就很让人舒服，希望微信团队好好学学。</p><h3 id="订单系统"><a href="#订单系统" class="headerlink" title="订单系统"></a>订单系统</h3><p>扫码问题解决了，剩下的就是一个集成购物车的订单系统，之前在公司虽然也是在数据部，但是报表做的不多，真是没想到这订单系统是多么麻烦，我当时遇到问题就是，购物车选好后，点击提交，这时，按理说应该生成订单的，但是生成订单的同时是否需要把购物车的商品删除呢，第一感觉是需要，但是后来发现不是这样的，如果顾客发现还有商品没有购买，这时他会返回上一页继续购买，所以正确的做法是在确认支付订单后，再去把购物车的商品删掉。但是这样也会有问题，因为顾客确认支付方式后，有可能支付失败了，这时按理说购物车里的东西还是应该有的，但是我们这里比较简单，只要用户点击支付，就认为成功了。可见，要做一个完整的订单＋交易系统，是多么不容易的事。</p><h3 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a>callback hell</h3><p>由于订单系统的逻辑比较多，涉及很多数据库的操作，而我们使用 nodejs 也没用什么 ORM 系统，只是用原生的 sql 来做，这时就陷入了 <a href="http://callbackhell.com/" target="_blank" rel="noopener">callback hell</a>，之前写 node 程序一般都不怎么关注错误处理， 所以一直没怎么发现这个问题，这次在做这个订单系统，真是暴露无疑，太难维护了。</p><p>下面代码片段的功能是：扫描一个商品，向购物车列表中增加一个商品的 <code>callback hell</code><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">exports.add = <span class="function"><span class="keyword">function</span><span class="params">(userId, goodsId, goodsNum, cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> dbPool = db.getPool();</span><br><span class="line">    <span class="keyword">var</span> sql = <span class="string">"insert into 1024_cart values (?,?,?) ON DUPLICATE KEY UPDATE goods_num=goods_num+1"</span>;</span><br><span class="line">    sql = db.formatSQL(sql, [userId, goodsId, goodsNum]);</span><br><span class="line">    dbPool.query(sql, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            logger.error(<span class="string">"exec:"</span> + sql + <span class="string">" error:"</span> + err);</span><br><span class="line">            cb(&#123;code:<span class="number">-2</span>, msg: <span class="string">"服务器内部错误！"</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(result.affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            goodsDAO.select(goodsId, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                    logger.error(<span class="string">"exec:goodsDAO.select. error:"</span> + err);</span><br><span class="line">                    cb(&#123;code:<span class="number">-2</span>, msg: <span class="string">"服务器内部错误！"</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(result.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    that.delete(userId, goodsId);</span><br><span class="line">                    cb(&#123;code:<span class="number">-1</span>, msg: <span class="string">"数据库中没有该商品！"</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> goods = result[<span class="number">0</span>];</span><br><span class="line">                    getGoodsNum(userId, goodsId, <span class="function"><span class="keyword">function</span><span class="params">(err, result)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                            cb(&#123;code:<span class="number">-2</span>, msg: <span class="string">"服务器内部错误！"</span>&#125;);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            goods[<span class="string">"num"</span>] = result[<span class="number">0</span>][<span class="string">"goods_num"</span>];</span><br><span class="line">                            cb(&#123;code:<span class="number">0</span>, data: goods&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cb(&#123;code:<span class="number">-3</span>, msg: <span class="string">"修改失败！"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编码与生活"><a href="#编码与生活" class="headerlink" title="编码与生活"></a>编码与生活</h2><p>在整个比赛过程中（大概20个小时），我睡了不到4个小时，大脑一直处于兴奋状态，一直在解决问题，从动态获取微信签名，到解决订单系统的 bug，到最后的测试，都是极度兴奋的，coding 的比较 high。</p><blockquote><p><strong>我觉得我会编码到老</strong>。</p></blockquote><p>记得在学生时代就不断听到有人说，程序员是青春饭，做几年后要转向管理岗，真不知道说这些话的人是出于什么心理，当然有部分人是把编码当成为一份养家糊口的工作，但是我相信更多人是因为热爱编码而编码的，从编码中能汲取无限快乐。</p><p>如果你身边在有人 balabala 的说诸如此类的话，我劝你最好离这种人远些，道不同不相为谋，世界这么大，为什么不去做自己喜欢的事呢？</p><h2 id="精彩瞬间"><a href="#精彩瞬间" class="headerlink" title="精彩瞬间"></a>精彩瞬间</h2><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB29QBpgFXXXXcOXXXXXXXXXXXX_!!581166664.jpg" alt="美丽的互联网小镇"></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2bstCgFXXXXXSXXXXXXXXXXXX_!!581166664.jpg" alt="午餐时刻"></p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2pBXCgFXXXXanXXXXXXXXXXXX_!!581166664.jpg" alt="比赛开始了"></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2dNhogFXXXXXmXpXXXXXXXXXX_!!581166664.jpg" alt="休息，休息一会♨️"><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2ZDFngFXXXXXvXpXXXXXXXXXX_!!581166664.jpg" alt="大家都睡了，但我们还在继续..."></p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2QsppgFXXXXXQXpXXXXXXXXXX_!!581166664.jpg" alt="凌晨3点的互联网小镇"></p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2w8xkgFXXXXX5XpXXXXXXXXXX_!!581166664.jpg" alt="圆满结束，感谢 sf 组办方"></p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB212BEgFXXXXX0XXXXXXXXXXXX_!!581166664.jpg" alt="有赞小伙伴"></p><p>注：图片均来自 sf 官方，如涉及个人隐私请告知。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次参加比赛，玩的很开心，没什么遗憾。至于代码就不开源了，写的比较烂，后面等功力提升了在说这事。感兴趣可以看看我们作品<a href="http://note.youdao.com/share/web/file.html?id=134b727dc48180570c66408da03116d4&amp;type=note" target="_blank" rel="noopener">易购 EasyGo</a>的简介。</p><p>这里我想回答当时评委问我们组的问题——<strong>为什么现在的超市不推广扫码支付</strong>：</p><ol><li>二维码识别后，一般会包含商品的生产日期这个信息，而对于超市某些产品，像海鲜，是不想让顾客知道这个的…</li><li>同一商品不同超市买的价格可能不一样，这样卖的贵的超市是不愿意用这套系统的…</li></ol><p>对于这些，我只能说，经济基础决定上层建筑，商家还是以盈利为目的的。</p><p>比赛是结束了，但生活的挑战还在继续，<a href="https://github.com/jiacai2050/sicp" target="_blank" rel="noopener">SICP</a> 要继续搞起了，这次停了有两个多星期了，真要多下功夫了。</p><p>希望大家都能够 happy hacking ！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上个周末，也就是10月24、25号，参加了人生中第一次&lt;a href=&quot;http://segmentfault.com/hackathon-2015&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黑客马拉松&lt;/a&gt;（hackathon），虽然最终没有获奖，
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
      <category term="nodejs" scheme="http://liujiacai.net/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>转载『非科班出身的人学习编程不负责任指南』</title>
    <link href="http://liujiacai.net/blog/2015/10/21/programming-guide/"/>
    <id>http://liujiacai.net/blog/2015/10/21/programming-guide/</id>
    <published>2015-10-21T13:50:18.000Z</published>
    <updated>2019-12-24T10:59:14.603Z</updated>
    
    <content type="html"><![CDATA[<p>来我们这个实验室里读研的学生可能自从来到这里的第一天就觉得自己的命运很苦逼。他们读本科时主修的是机械设计、制造以及自动化之类的专业，毕业时的简历上也顶多是写写擅长 MS Word、PowerPoint、UGNX、AutoCAD 之类的应用软件。他们有限的学习生涯里，怎么也不会想到来到这里竟然要首先重新学习 C 语言，然后还要学 C++，接下来还要学习 Python 或 Lua 什么的，而且竟然还不让用 Windows，只能用连个 QQ 都没有并且经常出故障的 Linux……</p><p>在他们心里，编程似乎并不是多么有趣的事，所以他们就觉得编程很难。对此我有同感，大家都会玩的 Windows 里的挖雷与纸牌那样的小游戏，还有很多人会打的麻将，还有围棋，这些事我觉得也挺难的。</p><p>我曾经告诉他们，如果不会编程，那么他们就很难解决自己的研究方向上的那些问题，因此也就不可能写出有价值的论文，不可能顺利的毕业拿到学位，不可能找到很好的工作……这种功利性的『威胁』，对于有些人会有点效用，但是如果没有能力让他们自发的对编程产生足够的兴趣，这对于任何一个『好为人师』的人而言都是一种莫名其妙的羞辱。</p><p>现在我试着去告诉他们，编程不仅不难，而且会很有趣，其中充满着值得深思的东西，而这些深思对于我们人生也会产生许多增益。于是，就有了这篇文章。</p><h2 id="编程是什么"><a href="#编程是什么" class="headerlink" title="编程是什么"></a>编程是什么</h2><p>无论你是不是程序猿，每一天你都在编程，每一天你都被编程。编程，就是设计一些步骤，组织这些步骤，让这些步骤在当前环境中正确的运行，最终得出自己想要的结果。</p><p>你的每一天都是在起床、喝水、吃饭、工作、上厕所、娱乐、睡觉等步骤的有序组织下运转的，你活在这个程序中，同时你在这个程序中为改善自己的生活而制定各种计划并努力去实现。</p><p>机械设计，其实比编程还要编程。所谓的机械零件，就是数据结构。所谓的传动机制，就是应用程序接口（API）。所谓发动机，就是程序的内核。你将零件装配好，通过传动机制将它们接驳到发动机上，于是你就创造出来一部机器，通上电或者打着火，就可以让它运转起来。</p><p>编程比机械设计来的更为简单，你不需要经常给自己所编写的程序添加润滑油，也不需要去对每个数据结构进行复杂的力学分析，更不需要关注这些数据结构是否严丝合缝的相互配合，至少目前的计算机软件工程是这个样子的，它不像机械工程学科那样以坚实的物理定律为基础。机械的结构与运行规律总是可计算、可分析的，而软件的结构与运行过程却充满着太多不严格的环节。这种不严格，却给我们营造了一个可以发挥天赋或工科实践经验的空间。显然，即使软件工程存在着各种不严格，但是我们却能够通过编程模拟出机械工程的一切。事实上也是如此，现代的机械工程领域，软件已经无处不在。</p><p>机械设计有很多精妙的『算法』，像缝纫机、枪械、发动机之类的机构，设计它们其实要比计算机世界里的算法设计难得多，而且这些机构对人类文明的发展往往能够产生巨大的推动作用。希望你不要因此爱上机械设计……学会编程，你会对机械设计的理解更为深刻。因为编程是将『设计』本身作为一种智力活动而对待的。<strong>你可以将机械工程领域的那些智力活动应用于编程，也可以将编程中的智力活动应用到任何设计之中。</strong></p><p><img src="http://segmentfault.com/img/bVqpCM" alt></p><p>正如 SICP 一书的序言所言，教育者、将军、营养学家、心理学家以及父母们，他们做规划，而士兵、学生以及某些社群则被规划。克服大型的问题，要经过一系列的规划，其中大部分规划会运作于现实之中，因为这些规划总是与迫切处理的问题息息相关。若将规划这件事情本身作为一项智力活动来欣赏或研究，那么就必须转到计算机编程上面来。你需要阅读与编写计算机程序，而且要大量的做。程序是怎样的，它们的功能是什么，这些不太重要，重要的是它们的性能如何，它们之间能否精巧的相互配合从而构造更大规模的程序。</p><h2 id="入门书"><a href="#入门书" class="headerlink" title="入门书"></a>入门书</h2><p>学习编程之前，应该先问自己一个问题：我为什么要学习编程？不要打我……我知道你们是被逼着去学习编程的，那就不妨被逼着思考『我为什么要学习编程？』。</p><p>如果不知道答案，也没有关系。反正这个问题与学习编程也没有太大关系。其实，我们已经做了非常多的不需要回答为什么的事了。我们连『我们为何而存在』这样的问题都不知道答案，却依然糊里糊涂的活到了现在。</p><p>先推荐几本入门书以及阅读它们的方法，因为学习编程最不需要的方法就是将一本讲编程的书从头读到尾……编程不是考试，它是基于现实生活的创造。这种创造是渐进的，你在创造之初可能也无法预料到结果会是如何，这是任何创造性活动的基本属性。</p><p>我推荐的第一本书是《计算机程序的构造和解释》，英文名是《Structure and Interpretation of Computer Programs》，简称 SICP。英语阅读能力好的同学，可以看英文版。中文阅读能力好的同学，可以看中文译本，裘宗燕老师的文字素养与翻译的严谨程度是可赞的。这本书的阅读，建议分以下三个阶段：</p><ol><li>阅读前两章，第一章是讲计算过程的抽象方法，第二章是将基本的数据的抽象方法。这两章的内容涵盖了软件世界的『九年制义务教育』的全部内容，所用的教学语言也是非常成熟且设计精巧的 Scheme 语言的一个很小的子集。学习这两章内容的过程中，可以穿插着阅读《Teach Yourself Scheme in Fixnum Days》的前 10 章，这份 Scheme 教程也有一份中文译本。SICP 的习题，即使不去做，也应该把题目看一下，动脑子想一想，判断一下能不能做得出来。这些习题，在网络上很容易找到答案。</li><li>复习 C 语言，教材用 Kernighan 与 C 语言之父 Ritchie 合写的那本《C 程序设计语言》即可。这个阶段的设置，主要是面向我们实验室内部。因为我们实验室里的同学在本科阶段通常是要修 C 语言这门课的，但是当时他们可能并未真正从学习编程的角度去学习，现在可以通过第一阶段基于 Scheme 语言建立的编程观念去重新认识一下 C 语言，只有这样方能理解 C 语言的优点与缺点，并且去思考如何充分发挥 C 的优势，然后用 Scheme 来弥补 C 的不足。借助 GNU Guile 2，很容易实现 C 与 Scheme 复合编程。这个过程可以穿插阅读 Kernighan 写的《程序设计实践》。</li><li>阅读 SICP 的第 3 章，然后再找一本讲 C++ 的书，比如 C++ 世界中非常有名但我不以为然的砖书《C++ Primer》，只学习基于类的数据抽象以及面向对象编程部分即可。这个阶段，SICP 的第三章阐述了面向对象编程与函数式编程两种方法。从 SICP 中获得的面向对象编程，可以在 C++ 的学习中得到进一步一些强化，至于函数式编程方法，可以假装自己已经知悉，留待日后需要时再作打算。最后，记得将《Teach Yourself Scheme in Fixnum Days》剩下的内容看完。</li></ol><blockquote><p>C++ 的入门书，我更推荐《C++ Without Fear》，中文译本叫《好学的 C++》，现在应该是第 2 版。之所以不推荐大家认为是 C++ 四书五经之一的《C++ Primer》，是因为我总觉得它像一本事无巨细的案头手册，比较适合那些已经有了编程经验甚至 C++ 经验的程序猿阅读。我心目中真正好的教材应该像小说那样，由一条或多条逻辑主线延展而成，这种教材对于非科班出身的人尤为重要。</p></blockquote><p>对于大部分编程任务而言，上述书所涉及的知识已经足够用了，而且上面的这几本书也是非常耐读的书，只要你不是那么着急的将它们读完，它们总是很有趣。我很喜欢 SICP 与《程序设计实践》这两本书，因为太喜欢了，所以一直都不舍得把它们读完。</p><h2 id="让实践有些难度"><a href="#让实践有些难度" class="headerlink" title="让实践有些难度"></a>让实践有些难度</h2><p>书是要看的，但是看书的过程中最好开动你的双手。所以，你不应该停下来问自己：为何要学习编程？</p><p>我希望总有一天，你能给自己找到一个答案，那就是你想写一个 XXX 程序。这个程序至少应该对你是有用，亦即它的主要功能不与你的系统里的其他程序存在着重复。如果你能明确这一点，那么你所创造的程序就有了意义，你的学习就有了意义。</p><p>为何要学习编程？因为你要创造一些从来没有的软件，而且它能够帮助你做一些你认为是很重要的事！凡是你认为重要的事，对于很多人而言，很有可能也是很重要的，因此你所创造的东西就可以帮助更多的人，这意味着会有一些你可能不认识的人需要你，这就是你的价值所在。</p><p>编程的实践，应该将它作为探索未知世界的智力活动，应该从书中跳出来，将自己从那些示例中获得的经验用于解决现实中的问题。如果你觉得，现实中根本不存在什么问题需要你去解决。那么……请你回答一下『你为何而存在』这个问题吧。</p><p>看书，是从前人正确的经验中学习。实践，是从自己的失败中学习。既然决定要实践了，所以还是给自己找一些比较难走的路走走看吧，让失败多一些，让失败早一些。</p><p>以我个人比较感兴趣的几个东西为例，可以写一个基于 <a href="http://segmentfault.com/a/1190000003779240" target="_blank" rel="noopener">TeX</a> 的现代<a href="http://garfileo.is-programmer.com/2012/7/7/cweb-none-definitive-tutorial-for-chinese.34433.html" target="_blank" rel="noopener">文学编程</a>语言，通过它不仅可以历练编程能力，也会对编译原理中的语法分析环节有一些实际的认识。也可以尝试去写一个三维几何库，能够完成凸包、Delaunay剖分以及 Voronoi 图等计算，不求大而全，只求小而精，以后漫长的时间里可以慢慢的去改进它。还可以去找一个自己喜欢的开源项目，去阅读它的源代码，了解它所用的项目构建系统，分析项目结构，试着去修改它的代码……我现在最感兴趣的是 LuaTeX。</p><h2 id="问题是最重要的"><a href="#问题是最重要的" class="headerlink" title="问题是最重要的"></a>问题是最重要的</h2><p>假如你已经有了非常多次的实践上的失败，并且你已经大致掌握了 Scheme 与 C/C++ 这样的语言，那么每年学一门新的语言，这并非难事。可能你会对网络上经常发生的语言之战觉得奇怪。</p><p>是问题决定了语言，是问题决定了编程范式，是问题决定了信仰。如果你能很明确的认识到这些，那么你就不会陷入某种语言宗教的泥淖之中。对于许多事都是如此……搞机械的人，也经常信仰 UGNX，CATIA，PROE 这些『宗教』的……</p><p>如果非要给自己找一种信仰，那么<strong>我信仰我的存在就是为了解决问题的。</strong></p><p>如果在我用的 Linux 系统上做一些自动化程度高一些的维护任务，我不会厌憎佶屈聱牙的 Bash 脚本，而是非常欣赏它像胶水一样快速的将几个本来是独立运行的程序连接起来替我完成复杂的任务。</p><p>如果我要临时的做一些文本处理工作，我可以用 python 3，因为它对 UTF-8 支持的挺好，而且字符串库功能齐备。如果只是进行一些文本的替换，emacs 或 sed 之类现成的工具也够用了。</p><p>如果我要写一个严肃的程序，严肃到了它的生命可能要很久，那我会选择一门成熟稳定的语言来实现它，即使用 C，我也不会烦弃它的繁琐的代码，我会尽力凝练程序中要实现的功能。</p><p>人生中本来就面临着许多选择，但是非常多的人在选择之前并未认真的去考察自己面对的问题。</p><p>不过，对问题本身的考察，需要一套基本的工具集。没有听诊器、手术刀或 X 光，再厉害的医生也无法分析人体的内部发生了什么。对于编程而言，我认为上述我推荐的书中所涉及的知识已经足够用来洞察软件世界的各种问题了，以此为基础，我们只需再保持心态的开放，随时汲取所需的知识就可以了。例如，虽然上述几本书没有一本是讲 Web 开发的，但是如果你熟悉 Scheme，就可以发现 JavaScript、HTML 5、CSS 3 之类的语言并没有超出 Scheme 的范畴，你可以很快的就掌握它们。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>解决问题需要算法。既然编程无处不在，那么算法也是无处不在的。但是，如果随便拿起一本讲算法的书，随便一本，可能都会让你觉得头昏脑胀。也许你会担心，连算法的书都看不懂，还怎么写程序？</p><p>当初我刚学习编程的时候，写过二十四点、汉诺塔、八皇后、俄罗斯方块之类的小程序。后来，在现实的项目里，也写过堆排序、快速排序、矩阵的 LU 与 SVD 分解、无向连通图的最小生成树及最短路径之类的程序。但是现在，随便拿一个让我去实现，我还是不得不去翻书看懂算法，然后再去写程序……</p><p>我想说的是，如果你正在阅读一本讲算法的书，书里有些算法或它的示例是你一时无法看懂的，可以跳过去。很多专门讲算法的书里，充斥着心智游戏。如果你无法将自己代入到这些游戏的情境中，这个游戏的玩法自然就是不明了的。现在看起来，这是很自然的事，然而当初我却一遍又一遍的怀疑自己的智商，特别是看到网络上很多人像喝白开水一样的谈论着这些心智游戏，我一度怀疑，我不适合做编程方面的事。</p><p>幸好，这个世界足够稳定，以至于我们不需要了解相对论与量子力学也能够很好的生活下去。大部分人，连牛顿力学都不需要了解……算法也是这样，特别是现在已经存在了相当多的实现，例如几乎任何一种编程语言的标准库中都提供一维数据的快速排序算法的实现。基本上，只要是对现实中的问题非常重要的算法，你总是能够找到它们的既有实现，取而用之。</p><p>当你走在街上，那些高高矗立恢宏建筑，建筑工人建造它们的过程中可曾用了极高心智的技术？编程，本质上也是如此，工程经验的重要性大于心智。甚至在编程中，过多的运用心智，反而会适得其反。</p><p>我不是说学习算法没有必要，我只是强调不要被一时难以理解的算法挡住你。你天生就拥有一些无比强大的算法，它们是穷举、贪婪与分治，还有最强大的『演化』与『神经网络』。那些专门讲算法的书，只不过是是了很蹩脚的语言、符号以及示例将你天生的直觉刻画出来而已。只要你在现实中遇到问题，你总是能够找到求解这个问题的方法，而不是只有读懂了某本讲算法的书你才能解决这个问题。</p><p>很多算法书，都是我看不懂的。它们的第一章就是让我复习数学归纳法，第二章就是让我学习算法的时间与空间复杂度分析……而我属于对数学缺乏直觉的人，对我而言，这些书的唯一价值就是故意不让我去读它。即使是我心目中的大神 Knuth 的传世之作《计算机编程艺术》，它唯一的目的似乎就是让我觉得我不是搞艺术的。</p><p>很久之后，我在学校图书馆闲逛的时候，发现了<a href="http://book.douban.com/subject/1232071/" target="_blank" rel="noopener">《如何求解问题：现代启发式方法》</a>这本书，翻了翻，就开始叹息，为什么一开始不知道这本书？</p><h2 id="增强对计算机的理解"><a href="#增强对计算机的理解" class="headerlink" title="增强对计算机的理解"></a>增强对计算机的理解</h2><p>有时间与精力可以阅读一些专业性强一些的计算机理论的书籍，譬如操作系统原理、编译原理、算法与数据结构之类。看不懂太专业的书，或者没那么多时间和精力，可以看看计算机科学的一些科普著作。有本《通灵芯片》值得一看，薄薄的小册子，三五天的业余时间就可以看完。有本《编码：隐匿在计算机软硬件背后的语言》，算是《通灵芯片》的加强版，也值得一看。有一本《深入理解计算机系统》，以程序员的视角来看计算机的软硬件系统，也是一本很好的书，不过就是要读完它，需要一些耐心与时间，所以没必要一次性看完。也可以继续将 SICP 的第四、五章看完。</p><p>虽然你的编程技能不会因为读了这些讲述计算机原理的书而突飞猛进，但是这些书可以让你理解你的程序是在一个什么样的世界里运行的。虽然你不知道自己为何而存在，但是你知道这个程序为何而存在。你不仅知道它为何而存在，还知道它怎样存在，并且也知道怎样让它更好的存在。这样，也就没必要在那些所谓的『XXX 箴言』、『XXX 之道』、『XXX 之禅』的书籍上浪费你有限的生命。</p><p>有时间，也可以复习一下《黑客帝国》，它的导演虽然不是程序猿，但胜似程序猿。看完黑客帝国，也可以看看 Steven Levy 写的《黑客：计算机革命的英雄》。从技术层面跃迁到人文层面，也许那时你会对自己的人生有着更为深刻的认识。计算机，是人类为自己创造出来的最好的一面镜子。我们现在没有能力了解自身，但是我们可以制造与发展计算机来逐步了解自己。</p><h2 id="思考生命"><a href="#思考生命" class="headerlink" title="思考生命"></a>思考生命</h2><p>懂编程就像懂其他任何一门技艺一样，没什么了不起，因为任何技艺都不会比你的生命更复杂，它甚至不如路边已经被你视而不见的野草复杂。生命，本身就是一个非常奇妙的东西，它的诞生即偶然又必然。整个生命体系只要略微有一点点误差，我可能就不会诞生于世。当我确认我已经存在于这个世上了，但是我又不知道我为何而存在。</p><p>如果每个人都思考过『我为何而存在』这个问题，那么就意味着对于这个问题的思考，我们不是自发的，而是被迫的。这个问题，自我们诞生以来就像烙印一样存在于每个人的思想里。这个问题是人类的终极问题，我们所解决的一切问题最终都会指向它。我们为这个问题而生。不仅仅是为了自己去回答这个问题而生，还要为他人回答这个问题而创造生存条件。他人，包括我们的家人，也包括我们的朋友以及那些我们并不不认识的人。</p><p>我们努力赚钱，是为了过更好的生活么？似乎并非如此，生活条件的富足，似乎仅仅是为了我们去思考『我们为何而存在』而创造一个更好的环境。即使是世界上最穷的人，也会自问，我为何而存在，上苍为何如此待我之类的问题。在这个问题面前，富人与穷人是绝对平等的。我们看见美女，可能会怦然心动，追而娶之，是为了一段美好的爱情么？也许美色是一种诱惑，用于保证人类能够继续繁衍生息，以便继续思考那个终极问题；即使是出于爱情，也极有可能是因为你爱的人对于你回答『我为何而存在』这个问题具有增益作用。</p><p>一切的生物，皆为命而生，这就是生命。生，是一种可变并且可自我繁衍的状态。只要有一种事物，它的状态是可变的，而且这种状态在保持自身变化的过程中能够产生新的可变且可繁衍的状态，那么它就有『生』。那么命是什么？汉字的『命』，字形上有点儿『一个人一生都在叩问』的意思……我们在叩问什么，或许正是『我为何而存在』这个问题。</p><p>苏格拉底说他的存在是为了『认识自己』，但这似乎不是答案，只是一个过程。在<a href="http://segmentfault.com/a/1190000003869521" target="_blank" rel="noopener">『泛型与闭包』</a>，我之所以感慨『每一个人，都像是一个闭包』，是觉得如果我们是程序里的一个函数，我们自身似乎永远也无法知道自己的运行结果是什么。这种想法有点宿命论的意味，但是每个人的诞生又充满着偶然，我们的生存活动似乎并不受创造者的影响，或者创造者无意于去干扰我们的活动，因此在生活中我们经常觉得自己有自由意志。</p><p>如果我们即是被创造的，又有一定的自由意志，那么苏格拉底或许就是对的，创造者试图创造我们的目的就是让我们去『认识自己』。我们虽然并不知道我们的生命终止之时会产生什么样的『计算结果』，但是兴许创造者可以理解这些结果。同时，我们有积极生活的自由，也有消极颓废的自由，我们可以将认识自己作为终极问题去探索的自由，也有完全不配合这位创造者而自杀的自由。还有一种可能，创造者已经不存在，整个宇宙系统也许只是一个被遗弃的废墟，或者他只是在机器之前打了个盹……</p><p>很容易发现，将问题上溯到原点，再从原点演化到现在，不难得出苏格拉底式的结论。既然我们还活着，既然我们在问自己存在的意义，那么答案就自然指向了『认识自己』。生命对我而言只是个过程。在这个过程中，我唯一能观测的并非世界的变化，而是我自身的变化。至于我自身的状态的变化是已经发生过了，现在只是回放，还是正在发生，这显得非常的不重要，因为我们无法跳出这种状态的变化。这可能也是为什么 OOP 比 FP 更容易理解的根本原因。</p><p>这个世界有许许多多的工作，似乎没有任何一种工作能像编程这样激发我对生命开始思考。</p><h2 id="从其他领域寻找答案"><a href="#从其他领域寻找答案" class="headerlink" title="从其他领域寻找答案"></a>从其他领域寻找答案</h2><p>为了寻找终极问题的答案，有必要阅读一些哲学、物理、生物之类的书籍。人类数千年的文明，『我为何而存在』这个问题也已经被思考了数千年。既然我们此刻所处的系统还在运行着，那就说明答案并未真正出现。但是，在决定自己去思考这个问题之前，看看过去的时代里的有智慧的人是如何思考的，这是一个必须的过程。人类对这个问题的所有思考过程是伴随着自身的繁衍生息不断的传递下去的。</p><p>也许你该看点哲学类的书。如果从未想过去看哲学的书，我推荐一本 14 岁的少男少女就应该阅读的《苏菲的世界》，你不要打我。罗素的那本《西方哲学史》虽然出自他个人的视角，但是显然我们对哲学的理解也很难达到他那样的高度，鉴于我们也不是打算去在哲学上有所成就，《西方哲学史》足够我们看的了。我不认为这个世界上真正存在『正确』的哲学。</p><p>复习物理。《费恩曼物理学讲义》第一卷就很好，人类所能感知到的这个世界，费恩曼像讲故事一样的差不多一网打尽了。如果连费曼的书都看不懂，不妨看看《时间的形状》+《量子物理史话》，它们是近年来在相对论及其之后的物理学方面中国人写的非常优秀的科普书。还有一本是我大学时经常看的《从一到无穷大》，虽然年代已颇为久远，但依然不失为极好的物理科普著作。</p><p>生物学，这门课在中学时是我最讨厌的课程之一。因为我实在是看不懂书里的插图，乡村中学连个显微镜与真实的标本都没有，所以长期以来，我一直都是个生物盲。很多常见的花草树木鸟兽虫鱼，我连它们的名字都叫不上来，更不要说它们具体属于哪个门纲目科属种了。但是有一本生物学的书我还是能看懂的——《漫画玩转遗传学》，这是本非常好的遗传学科普书。当时我是因为学习遗传算法而买来的，结果从它从第一页开始就把我的眼睛抓住了。</p><p>但是，很诚恳的说，这些书都读完，我还是不知道『我为何而存在』这个问题的答案，但是我对编程有了更多的思考。特别是最近，量子力学将基本粒子的运动归结为概率问题的思想，这对于我一直致力去解决的一个问题有很大的启发。</p><h2 id="这些书你都看过么？"><a href="#这些书你都看过么？" class="headerlink" title="这些书你都看过么？"></a>这些书你都看过么？</h2><p>都看过，但是有一些没有看完。有些书是看完了，但是时间久了，有些遗忘，一直想找点时间再重读一遍。</p><p>有些书是因为实在太好，不忍心一下都看完。这样说，有些矫情，但事实就是如此。像《费恩曼物理学讲义》，虽然有着物理学界小飞侠之称的费恩曼已经将深邃的物理学变成了我能够读懂的人类语言，但是一方面我不是专业研究物理学的人，我没有必要赶进度似的将他的书彻底读完，另一方面是一旦读完了，我就会惋惜，它不会再有第二季……我打算将费恩曼的这三卷物理学讲义留给我今后的时间里慢慢的去看，我也可以把这些知识讲给我的儿子听。</p><p>有些书对我而言是因为太难，即使我觉得已经看完了，但过一段时间发现，跟没看过是一样的。这些书，我也只能归类为没有看完的书。</p><p>凡是我看的书，都是我认为在书中所涉及的方向上，作者比我走的更为深远。但是我也不会自卑，因为他们现在已经没法走了……</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文写于一个深秋又寂寞的下午，目的只是为我的小伙伴们学习编程指出一条道路。从 SICP 开始，可能有许多人觉得不靠谱，但是考虑到这些小伙伴一个一个都是研究生，考研期间经过了高数、线代、概率以及英语的『洗礼』，研一也会修数值分析与矩阵分析这两门数学课。即使他们以前从未接触过编程，但是他们的情况，SICP 还是挺适合他们的。如果他们连 SICP 的前三章都搞不定，这只能说明他们连 MIT 大一的学生都不如了……这或许不是他们的悲哀，而是这个国家的悲哀。</p><p>对于我不知道底细又打算学编程的同学，这篇文章可能不会太靠谱，所以我只能在题目中写上『不负责任』。不过，文章中出现的这些书，我觉得还都是挺不错的，有时间看一下，应该不是浪费时间。</p><h2 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h2><ul><li><a href="http://segmentfault.com/a/1190000003873192" target="_blank" rel="noopener">http://segmentfault.com/a/1190000003873192</a> by <a href="http://segmentfault.com/u/garfileo" target="_blank" rel="noopener">garfileo</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来我们这个实验室里读研的学生可能自从来到这里的第一天就觉得自己的命运很苦逼。他们读本科时主修的是机械设计、制造以及自动化之类的专业，毕业时的简历上也顶多是写写擅长 MS Word、PowerPoint、UGNX、AutoCAD 之类的应用软件。他们有限的学习生涯里，怎么也不
      
    
    </summary>
    
      <category term="他山之石" scheme="http://liujiacai.net/categories/reproduce/"/>
    
    
      <category term="sicp" scheme="http://liujiacai.net/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个玩具语言 JCScheme 问世了</title>
    <link href="http://liujiacai.net/blog/2015/10/03/first-toy-scheme/"/>
    <id>http://liujiacai.net/blog/2015/10/03/first-toy-scheme/</id>
    <published>2015-10-03T09:13:49.000Z</published>
    <updated>2019-12-24T10:59:14.603Z</updated>
    
    <content type="html"><![CDATA[<p>记得在上大学那会，就想着能够实现个自己的编程语言。由于之前技能不足，一直没敢去尝试。现赶上国庆七天假期，SICP 看的也正起劲，终于鼓起勇气，把这个坑给填上了。甚是开心。<br>实现 JCScheme 这个语言前后大概用了一天时间，功能虽然简单，但是“麻雀虽小，五脏俱全”，编程语言中最基本的类型、作用域、函数都涵盖了，以后在扩展时也很方便。<br>如果你和之前的我一样，想实现一门语言但又苦于无从下手，那么你应该花半个小时看看本文，相信你肯定会有所收获。<br>本文没有复杂难懂的编译原理知识，没有学过编译原理的人不要害怕。</p><p>JCScheme 完整代码托管到我的 <a href="https://github.com/jiacai2050/JCScheme" target="_blank" rel="noopener">Github</a>，并且以后会持续更新，如果你先从无到有实现个语言可以关注这个项目。由于 JCScheme 一直在更新中，下面某些设计或链接可以会失效，所以还是建议你关注  Github 上的项目。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><p>由于 JCScheme 极其简单，所以你不需要什么背景知识即可看懂本文，不过你最好了解点 Scheme 语言，如果不了解也没关系，你只需要知道 JCScheme 中的语句使用<a href="https://zh.wikipedia.org/zh/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener">前缀表达式（也称为波兰表示法）</a>，如果你之前没了解过，需要适应下。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是我们常用的中缀表达式</span></span><br><span class="line"><span class="string">(5</span> <span class="string">−</span> <span class="number">6</span><span class="string">)</span> <span class="string">*</span> <span class="number">7</span></span><br><span class="line"><span class="comment"># 这就是前缀表达式</span></span><br><span class="line"><span class="string">*</span> <span class="string">(−</span> <span class="number">5</span> <span class="number">6</span><span class="string">)</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>前缀表达式最明显的一个好处是其操作符的参数可以有不定个，像<code>(+ 1 2 3 4)</code>。</p><h3 id="编程语言分类"><a href="#编程语言分类" class="headerlink" title="编程语言分类"></a>编程语言分类</h3><p>现在编程语言大致可以分为两种：</p><ol><li>编译型，该类型语言源代码经由编译器（compiler）转化为机器语言，再由机器运行机器码。像C/C++ 即属于这个范畴。更详细的可以参考<a href="http://segmentfault.com/a/1190000003814221" target="_blank" rel="noopener">深入理解计算机之hello world背后的故事</a></li><li>解释型，该类型语言不转化为最终的机器语言，而是由解释器（interpreter）逐行解释执行，像 Python、JavaScript 属于这个范畴， JCScheme 也是这种类型。</li></ol><p>由于我这里采用 Java 来实现 JCScheme 的解释器，所以 JCScheme 源代码的执行逻辑是这样的：</p><center><br>    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB2548UfVXXXXXiXXXXXXXXXXXX_!!581166664.png" alt="JCScheme 源程序执行逻辑"><br></center><p>可以看到，JCScheme 解释器的主要工作就是将按照自定义语法规则书写的源程序，转化为 Java 代码，之后的事情就由 JVM 来处理了。</p><h3 id="JCScheme-解释器"><a href="#JCScheme-解释器" class="headerlink" title="JCScheme 解释器"></a>JCScheme 解释器</h3><p>JCScheme解释器主要分为两部分，解析（Parse）和求值（Evaluation）：</p><ul><li>解析：解析源程序，并生成解释器可以理解的中间（Intermediate）结构。这部分包含词法分析，语法分析，语义分析，生成语法树。</li><li>求值：执行解析阶段得到的中介结构然后得到运行结果。这部分包含作用域，类型系统设计和语法树遍历。</li></ul><p>明确了解释的工作后，我们第一步是制定语言的语法，然后进行解析、求值即可。</p><h2 id="JCScheme-语法"><a href="#JCScheme-语法" class="headerlink" title="JCScheme 语法"></a>JCScheme 语法</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rlwrap java -jar target/JCScheme-*.jar</span><br><span class="line"><span class="meta">&gt;&gt;</span> (* <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;</span> (<span class="function"><span class="keyword">def</span> <span class="title">a</span> 4)</span></span><br><span class="line">null</span><br><span class="line"><span class="meta">&gt;&gt;</span> (<span class="function"><span class="keyword">def</span> <span class="title">b</span> 5)</span></span><br><span class="line">null</span><br><span class="line"><span class="meta">&gt;&gt;</span> (if (&gt; a b) a b)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;</span> (<span class="function"><span class="keyword">def</span> <span class="title">max</span> <span class="params">(lambda (a b)</span></span> (if (&gt; a b) a b)))</span><br><span class="line">null</span><br><span class="line"><span class="meta">&gt;&gt;</span> (<span class="function"><span class="keyword">def</span> <span class="title">c</span> <span class="params">(max a b)</span></span>)</span><br><span class="line">null</span><br><span class="line"><span class="meta">&gt;&gt;</span> c</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>从上面可以看出，JCScheme 有以下基本特性：</p><ol><li>支持整数（Java int实现）与布尔（Java bool实现）、函数三种类型</li><li>提供<code>def</code>进行变量定义、<code>if</code>进行逻辑判断、<code>lambda</code>进行函数声明</li><li>支持整数的<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>四种基本算术操作，<code>&gt;</code>、<code>&lt;</code>、<code>=</code>三种比较操作。参数可以为多个</li><li>更多的特性可以参考<a href="https://github.com/jiacai2050/JCScheme#ChangeLog" target="_blank" rel="noopener">ChangeLog</a></li></ol><h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p><code>解析过程</code>的一般顺序为</p><blockquote><p>词法分析 —-&gt; 语法分析 —-&gt; 语义分析</p></blockquote><p>解析过程最主要的是得到语法树，之后，就可以由后面的<code>求值过程</code>进行求值了。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析（lexical analysis）就是将源程序中的字符分割为一个个单词（token，构成源代码最小的单位）。<br>由于 JCScheme 中使用前缀表示，所以词法解析很简单，两行代码：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src = src.replaceAll(<span class="string">"<span class="subst">\\</span>("</span>, <span class="string">"( "</span>).replaceAll(<span class="string">"<span class="subst">\\</span>)"</span>, <span class="string">" )"</span>);</span><br><span class="line">String[] tokens = src.split(<span class="string">"<span class="subst">\\</span>s+"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析（Syntactic analysis，也叫Parsing）也就是把词法分析得到的token序列转化为<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">语法树（AST）</a>，语法树是程序的中间表示形式，与具体语言无关。JCScheme 采用 Lisp 中经典的<a href="https://en.wikipedia.org/wiki/S-expression" target="_blank" rel="noopener">S表达式（S-expression）</a>来表示语法树。</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2MKQ2fFXXXXX1XpXXXXXXXXXX_!!581166664.png" alt="(* 2 (+ 3 4)) 的语法树"><br></center><p>AST 本质是一种树，大家可以先想想数据结构中一般都是怎么设计树的存储结构。（其实只要设计的数据结构能够保证获取到当前节点的父节点与子节点就可以了）。下面看看我的实现：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SExpression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">private</span> SExpression parent;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SExpression&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SExpression</span>(<span class="params">String <span class="keyword">value</span>, SExpression parent</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">addChild</span>(<span class="params">SExpression child</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.children.<span class="keyword">add</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3个 getter 函数省略</span></span><br><span class="line">    <span class="comment">// 进行求值的 eval 函数省略，这是重点，后面会单独介绍</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == children.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuffer displayBuffer = <span class="keyword">new</span> StringBuffer(<span class="keyword">value</span> + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (SExpression child : children) &#123;</span><br><span class="line">                displayBuffer.append(child.toString() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> displayBuffer.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解析token序列生产AST的函数是<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">String</span> START_TOKEN = <span class="string">"("</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">String</span> END_TOKEN = <span class="string">")"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SExpression parse(<span class="keyword">String</span>[] tokens) &#123;</span><br><span class="line">    SExpression root = <span class="keyword">new</span> <span class="type">SExpression</span>(<span class="string">""</span>, <span class="literal">null</span>);</span><br><span class="line">    SExpression parent = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> token : <span class="type">tokens</span>) &#123;</span><br><span class="line">        SExpression <span class="keyword">new</span><span class="type">Node</span> = <span class="keyword">new</span> <span class="type">SExpression</span>(token, parent);</span><br><span class="line">        parent.addChild(<span class="keyword">new</span><span class="type">Node</span>);</span><br><span class="line">        <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">        <span class="keyword">case</span> Constants.START_TOKEN:<span class="type"></span></span><br><span class="line"><span class="type">            parent </span>= <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Constants.END_TOKEN:<span class="type"></span></span><br><span class="line"><span class="type">            parent </span>= parent.getParent();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，每个 AST 根节点是token为空，父节点为 null 的一节点。<br>这里解析的方法是：</p><ol><li>每一个token为AST上的一节点，父节点为 parent（初始为root）</li><li>遇到<code>(</code> token时，开始创建该节点的子树（通过让这个节点成为 parent 实现）</li><li>遇到<code>)</code> token时，进行回溯（通过把 parent 赋值为 parent.getParent() 实现）</li></ol><p>下面看下<code>(+ 1 2 (* 3 4))</code>生成怎样的 <code>SExpression</code>：</p><p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2l9NefVXXXXbeXXXXXXXXXXXX_!!581166664.png" alt="(+ 1 2 (* 3 4)) AST 示意图"><br></center><br>上图最主要的一点就是</p><blockquote><p>与左括号相匹配的右括号位于左括号的最后一个孩子节点上（从左到右）。</p></blockquote><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析（Semantic analysis，也叫context sensitive analysis）根据上一步生成的AST，收集源代码的信息，这包括类型校验、变量在使用前是否声明等一系列操作。</p><p>因为 JCScheme 中类型比较简单，而且去做语义分析，需要做很多异常处理，有些繁琐，我这里为了简单都忽略了。所以如果你输入的语法有误（比如括号不匹配），那么解释器就会报错，在后面的迭代中会逐步改善这块。</p><h2 id="求值过程"><a href="#求值过程" class="headerlink" title="求值过程"></a>求值过程</h2><p>经过<code>解析过程</code>，我们已经得到了与具体语言无关的 AST，那么如何进行求值呢，SICP 书中给出答案：<code>eval-apply cycle</code>，如下图</p><p><center><br>    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB2KjMVfFXXXXbOXpXXXXXXXXXX_!!581166664.png" alt="SICP-eval-apply"><br></center><br>eval、apply 这两个规则描述了求值过程的核心部分，也就是它的基本循环。在这一循环中</p><blockquote><p>表达式在环境中的求值被规约到过程对实际参数的应用，而这种应用又被规约到新的表达式在新的环境中的求值，如此下去，直到下降到符号（其值可以在环境中找到）或者基本过程（它们可以直接应用）。</p></blockquote><p>在<a href="http://stackoverflow.com/a/6269132/2163429" target="_blank" rel="noopener">StackOverflow</a>上找到一比较好理解的解释：</p><ul><li>the one that eval is doing, is dealing with the syntactic translation of code to its meaning – but it’s doing almost nothing except dispatching over the expression type</li><li>apply is to call function with values.</li><li>A major enlightenment moment here is to realize that there is a major difference between this eval and apply – the former inherently deals with syntax, but the latter deals with values.</li></ul><p>如果你也在读 SICP，可以参考下面的<code>eval</code>、与<code>apply</code>的具体实现，对 Scheme 不了解的可以直接略过。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">eval</span></span> exp env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">self-evaluating?</span> exp) exp)</span><br><span class="line">        ((<span class="name">variable?</span> exp) (<span class="name">lookup-variable-value</span> exp env))</span><br><span class="line">        ((<span class="name">quoted?</span> exp) (<span class="name">text-of-quotation</span> exp))</span><br><span class="line">        ((<span class="name">assignment?</span> exp) (<span class="name">eval-assignment</span> exp env))</span><br><span class="line">        ((<span class="name">definition?</span> exp) (<span class="name">eval-definition</span> exp env))</span><br><span class="line">        ((<span class="name">if?</span> exp) (<span class="name">eval-if</span> exp env))</span><br><span class="line">        ((<span class="name">lambda?</span> <span class="name"><span class="builtin-name">exp</span></span>)</span><br><span class="line">         (<span class="name">make-procedure</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>)</span><br><span class="line">                         (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>)</span><br><span class="line">                         env))</span><br><span class="line">        ((<span class="name">begin?</span> exp)</span><br><span class="line">         (<span class="name">eval-sequence</span> (<span class="name">begin-actions</span> exp) env))</span><br><span class="line">        ((<span class="name">cond?</span> exp) (<span class="name"><span class="builtin-name">eval</span></span> (<span class="name">cond-&gt;if</span> exp) env))</span><br><span class="line">        ((<span class="name">application?</span> exp)</span><br><span class="line">         (<span class="name"><span class="builtin-name">apply</span></span> (<span class="name"><span class="builtin-name">eval</span></span> (<span class="name">operator</span> exp) env)</span><br><span class="line">                (<span class="name">list-of-values</span> (<span class="name">operands</span> exp) env)))</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">         (<span class="name">error</span> <span class="string">"Unknown expression type -- EVAL"</span> exp))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">apply</span></span> procedure arguments)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">primitive-procedure?</span> procedure)</span><br><span class="line">         (<span class="name">apply-primitive-procedure</span> procedure arguments))</span><br><span class="line">        ((<span class="name">compound-procedure?</span> procedure)</span><br><span class="line">         (<span class="name">eval-sequence</span></span><br><span class="line">           (<span class="name">procedure-body</span> procedure)</span><br><span class="line">           (<span class="name">extend-environment</span></span><br><span class="line">             (<span class="name">procedure-parameters</span> procedure)</span><br><span class="line">             arguments</span><br><span class="line">             (<span class="name">procedure-environment</span> procedure))))</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">         (<span class="name">error</span></span><br><span class="line">          <span class="string">"Unknown procedure type -- APPLY"</span> procedure))))</span><br></pre></td></tr></table></figure></p><p>简单来说，<code>eval</code>的主要作用就是理解 AST 的含义，根据其含义进行相应处理，比如赋值语句有其独特的处理方式，if 语句有其独特的处理方式等等。<br>为了能够让<code>apply</code>进行函数调用求值，需要把 AST 解释为 JCScheme 中内置的类型，而这就是 JCScheme 中<code>eval</code>的主要作用。</p><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p>定义一个基类<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是整数类型与布尔类型<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SNumber</span> <span class="title">extends</span> <span class="title">SObject</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SNumber</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SBool</span> <span class="title">extends</span> <span class="title">SObject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> boolean <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">getValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SBool</span>(<span class="params">boolean <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个类比较简单，并且注意到没有为其成员变量提供<code>setter</code>函数，这说明这些类型是不可变的。<br>最后一个比较重要的是函数类型<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SFunction</span> <span class="title">extends</span> <span class="title">SObject</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    List&lt;<span class="keyword">String</span>&gt; param;</span><br><span class="line">    SExpression body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SFunction</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; param, SExpression body)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.param = param;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SObject <span class="title">apply</span><span class="params">(SObject... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; args.length; i ++) &#123;</span><br><span class="line">            SScope.env.<span class="built_in">put</span>(param.<span class="built_in">get</span>(i), args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        SObject ret = body.eval();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; args.length; i ++) &#123;</span><br><span class="line">            SScope.env.<span class="built_in">remove</span>(param.<span class="built_in">get</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuffer <span class="built_in">buffer</span> = <span class="keyword">new</span> StringBuffer(<span class="string">"Function : args ["</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> p : param) &#123;</span><br><span class="line">            <span class="built_in">buffer</span>.append(p + <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">buffer</span>.append(<span class="string">"]\n"</span>);</span><br><span class="line">        <span class="built_in">buffer</span>.append(<span class="string">"Body :\n"</span>);</span><br><span class="line">        <span class="built_in">buffer</span>.append(body.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buffer</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>SFunction</code>内部有两个成员变量，用来表示其<code>参数列表</code>与<code>函数体</code>。其中的<code>apply</code>表示函数调用，可以看到无非就是把形式参数与实际参数进行捆绑（现在放到全局环境中，按理说这时应该生成一新环境，后面讲求值过程时会介绍改进版的SFunction），之后调用<code>SExpression</code>的<code>eval</code>方法，得到用内置类型表示的结果。</p><p>可以看到，这里的重点又回到<code>eval</code>方法上去了。 JCScheme 的主要复杂点也就算在<code>SExpression</code>的<code>eval</code>方法上，因为它涉及到把<code>SExpression</code>转为内置类型，所以按理说也应该是复杂的。</p><p><code>eval</code>的工作原理最直接的方式就是看源码<a href="https://github.com/jiacai2050/JCScheme/blob/master/src/main/java/net/liujiacai/jcscheme/JCExpression.java#L41" target="_blank" rel="noopener">JCScheme/SExpression.java</a>，这个方法后面会不断完善。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域也可以理解为环境，里面是一系列的 binding，用以保存变量名与其对应值。<br>在现代编程语言中，作用域一般分为两种：</p><ul><li>静态作用域（static/lexical scope），环境在声明时指定。JCScheme、C、Java、Python 等现在大部分语言都属于此类。</li><li>动态作用域（dynamic scope），环境在运行时指定。最常见的就是各种 Shell，像Bash、Ksh等，其次还有 emacs-lisp。更多可参考 <a href="http://stackoverflow.com/questions/1473111/besides-logo-and-emacs-lisp-what-are-other-pure-dynamically-scoped-languages" target="_blank" rel="noopener">what are other pure dynamically scoped languages?</a></li></ul><p>为了解决在 JCScheme 中函数调用时，新创建环境的父环境应该指向运行时的环境还是声明时的这个问题，我去 Stackoverflow 上提了个<a href="http://stackoverflow.com/questions/33056236/scheme-environment-model-closure-issue" target="_blank" rel="noopener">问题</a>，对作用域不清楚的可以去看看。</p><p> JCScheme 中，一开始只有一个全局作用域，后面我逐渐把这快给完善了，主要是 <a href="https://github.com/jiacai2050/JCScheme/blob/master/src/main/java/net/liujiacai/jcscheme/SScope.java" target="_blank" rel="noopener">SScope</a> 类 与 <a href="https://github.com/jiacai2050/JCScheme/blob/master/src/main/java/net/liujiacai/jcscheme/type/SFunction.java" target="_blank" rel="noopener">SFunction</a> 类。<br> <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SScope</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个环境都指向一个父环境，全局环境父环境为 null</span></span><br><span class="line">    <span class="keyword">private</span> SScope parent;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, SObject&gt; env;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SScope getParent() &#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;<span class="keyword">String</span>, SObject&gt; getEnv() &#123;</span><br><span class="line">        <span class="keyword">return</span> env;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在查找变量时，如何当前 scope 中没有，会沿着环境链，一直找到全局环境中</span></span><br><span class="line">    <span class="keyword">public</span> SObject findVariable(<span class="keyword">String</span> <span class="keyword">var</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (env.containsKey(<span class="keyword">var</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> env.<span class="keyword">get</span>(<span class="keyword">var</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SScope p = <span class="built_in">this</span>.getParent();</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">                Map&lt;<span class="keyword">String</span>, SObject&gt; subEnv = p.getEnv();</span><br><span class="line">                <span class="keyword">if</span> (subEnv.containsKey(<span class="keyword">var</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> subEnv.<span class="keyword">get</span>(<span class="keyword">var</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.getParent();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前的环境</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SScope current = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; builtinFuncs = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; builtinKeywords = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();</span><br><span class="line">    <span class="comment">// 省略一个内置函数、关键字的初始化</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SFunction</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">SObject</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">String</span>&gt; param;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SExpression&gt; body;</span><br><span class="line">    <span class="keyword">private</span> SScope scope;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; getParam() &#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在声明函数时，传入当前的环境</span></span><br><span class="line">    <span class="keyword">public</span> SFunction(List&lt;<span class="keyword">String</span>&gt; param, List&lt;SExpression&gt; body, SScope scope) &#123;</span><br><span class="line">        <span class="built_in">this</span>.param = param;</span><br><span class="line">        <span class="built_in">this</span>.body = body;</span><br><span class="line">        <span class="built_in">this</span>.scope = scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SObject apply(SObject... args) &#123;</span><br><span class="line">        <span class="comment">// 保存函数调用之前的环境，相当于入栈</span></span><br><span class="line">        SScope originScope = SScope.current;</span><br><span class="line">        <span class="comment">// 创建一个指向函数声明传入的环境的新环境，保存形参与实参的绑定关系。</span></span><br><span class="line">        <span class="comment">// 这里构造新环境时用到了声明函数时传入的环境，这点说明了 JCScheme 是静态作用域的</span></span><br><span class="line">        SScope funcScope = <span class="keyword">new</span> <span class="type">SScope</span>(<span class="built_in">this</span>.scope);</span><br><span class="line">        <span class="comment">// 设置当前环境为 新创建的环境，这时所有的求值，都是在其中进行</span></span><br><span class="line">        SScope.current = funcScope;</span><br><span class="line">        SObject ret = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            SScope.current.getEnv().put(param.<span class="keyword">get</span>(i), args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; param.size()) &#123;</span><br><span class="line">            <span class="comment">// 实现函数部分调用， currying</span></span><br><span class="line">            List&lt;<span class="keyword">String</span>&gt; subParam = param.subList(args.length, param.size());</span><br><span class="line">            ret = <span class="keyword">new</span> <span class="type">SFunction</span>(subParam, body, funcScope);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int bodySize = body.size();</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; bodySize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                body.<span class="keyword">get</span>(i).eval();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// only return last exp</span></span><br><span class="line">            ret = body.<span class="keyword">get</span>(bodySize - <span class="number">1</span>).eval();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// GC will clean unused scope</span></span><br><span class="line">        <span class="comment">// 恢复函数调用之前的环境，相当于出栈</span></span><br><span class="line">        SScope.current = originScope;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>经过上面这些工作，JCScheme 已经大功告成了（希望没有bug😊）。但是下面这些点都没有涉及</p><ol><li>函数的递归调用</li><li><del>匿名函数的直接调用，如<code>((lambda (a b) (+ a b)) 1 2)</code>，现在这样的方式是不支持的， 需要先定义个变量，然后在调用</del>，已经支持。</li><li><del>函数的部分调用，也就是<code>currying</code></del>，已经支持<br>……</li></ol><p>后面会逐步添坑，大家可以查看 JCScheme 的 <a href="https://github.com/jiacai2050/JCScheme#ChangeLog" target="_blank" rel="noopener">ChangeLog</a> 获取最新进展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“纸上得来终觉浅，绝知此事要躬行”，最开始时，觉得像 Scheme 语法这么简单的语言实现起来应该不难，做了后才发现眼高手低。比如，我第一次设计<code>SExpression</code>时没有<code>parent</code>这个属性导致了无法正确实现<code>parse</code>函数。以及后面在设计作用域时，分不清楚到底是声明时创建环境还是运行时创建，环境的父环境应该怎么指向，应该指向声明时的环境还是运行时的环境。<br>不过感触最深应该是这点：动手。在之前学习编程语言，被各种语法类库虐的死去活来，虽然想尝试去实现个自己的语言，但是一直觉得自己能力不够，没敢去尝试，随着不断完善 JCScheme 的功能，对编程语言有了更深刻的认识，真是有种“不入虎穴,焉得虎子”的感觉。</p><p>当然，JCScheme 语言只是刚开始，还比较简陋，高手请不要见笑，后面随着学习的深入我会逐步完善。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>王垠的<a href="http://www.yinwang.org/blog-cn/2015/09/19/parser/" target="_blank" rel="noopener">谈谈Parser</a></li><li><a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/" target="_blank" rel="noopener">90分钟实现一门编程语言——极简解释器教程</a></li><li>Wiki <a href="https://en.wikipedia.org/wiki/Scope_%28computer_science%29" target="_blank" rel="noopener">Scope (computer science)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记得在上大学那会，就想着能够实现个自己的编程语言。由于之前技能不足，一直没敢去尝试。现赶上国庆七天假期，SICP 看的也正起劲，终于鼓起勇气，把这个坑给填上了。甚是开心。&lt;br&gt;实现 JCScheme 这个语言前后大概用了一天时间，功能虽然简单，但是“麻雀虽小，五脏俱全”，
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Scheme" scheme="http://liujiacai.net/tags/scheme/"/>
    
  </entry>
  
  <entry>
    <title>Java WeakHashMap 源码解析</title>
    <link href="http://liujiacai.net/blog/2015/09/27/java-weakhashmap/"/>
    <id>http://liujiacai.net/blog/2015/09/27/java-weakhashmap/</id>
    <published>2015-09-27T06:10:24.000Z</published>
    <updated>2020-02-02T03:27:59.321Z</updated>
    
    <content type="html"><![CDATA[<p>前面把基于特定数据结构的Map介绍完了，它们分别利用了相应数据结构的特点来实现特殊的目的，像HashMap利用哈希表的快速插入、查找实现<code>O(1)</code>的增删改查，TreeMap则利用了红黑树来保证key的有序性的同时，使得增删改查的时间复杂度为<code>O(log(n))</code>。</p><p>今天要介绍的<a href="http://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html" target="_blank" rel="noopener">WeakHashMap</a>并没有基于某种特殊的数据结构，它的主要目的是为了优化JVM，使JVM中的垃圾回收器（garbage collector，后面简写为 GC）更智能的回收“无用”的对象。</p><blockquote><p>本文源码分析基于<a href="http://www.oracle.com/technetwork/java/javase/7u71-relnotes-2296187.html" target="_blank" rel="noopener">Oracle JDK 1.7.0_71</a>，请知悉。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.7.0_71"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_71-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 24.71-b01, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p><code>WeakHashMap</code>与其他 Map 最主要的不同之处在于其 key 是弱引用类型，其他 Map 的 key 均为强引用类型，说到这里，必须强调下：Java 中，引用有四种类型，分别为：强（strong）引用、软（soft）引用、弱（weak）引用、虚（phantom，本意为幽灵👻）引用。我相信对于 Java 初学者来说，不一定听过这几种引用类似，下面先介绍下这几种类型。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>这是最常用的引用类型，在执行下面的语句时，变量 <code>o</code> 即为一个强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><blockquote><p>强引用指向的对象无论在何时，都不会被GC 清理掉。</p></blockquote><p>一般来说，对于常驻类应用（比如server），随着时间的增加，所占用的内存往往会持续上升，如果程序中全部使用强引用，那么很容易造成内存泄漏，最终导致<code>Out Of Memory (OOM)</code>，所以 Java 中提供了除强引用之外的其他三种引用，它们全部位于<code>java.lang.ref</code>包中，下面一一介绍。</p><h3 id="java-lang-ref-Reference"><a href="#java-lang-ref-Reference" class="headerlink" title="java.lang.ref.Reference"></a>java.lang.ref.Reference</h3><p><code>java.lang.ref.Reference</code> 为 软（soft）引用、弱（weak）引用、虚（phantom）引用的父类。</p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2FuyqfFXXXXcjXpXXXXXXXXXX_!!581166664.png" alt="Reference类继承关系"><br></center><p>下面分析下<code>Reference</code>的源码（其他三种引用都是其子类，区分不是很大）。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//referent 为引用指向的对象</span></span><br><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ReferenceQueue对象，可以简单理解为一个队列</span></span><br><span class="line"><span class="comment">//GC 在检测到appropriate reachability changes之后，</span></span><br><span class="line"><span class="comment">//会把引用对象本身添加到这个queue中，便于清理引用对象本身</span></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在创建一个引用对象时，指定了<code>ReferenceQueue</code>，那么当引用对象指向的对象达到合适的状态（根据引用类型不同而不同）时，GC 会把引用对象本身添加到这个队列中，方便我们处理它，因为</p><blockquote><p>引用对象指向的对象 GC 会自动清理，但是引用对象本身也是对象（是对象就占用一定资源），所以需要我们自己清理。</p></blockquote><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(o , queue);</span><br></pre></td></tr></table></figure><p><code>sr</code> 为软引用，指向 <code>o</code> 这个对象，<code>o</code> 会在一定时机被 GC 自动清理，但是 <code>sr</code> 对象本身的清理工作依赖于 <code>queue</code>，当 <code>sr</code> 出现在<code>queue</code>中时，说明其指向的对象已经无效，可以放心清理了。</p><p>从上面的分析大家应该对<code>Reference</code>类有了基本的认识，但是上面也提到了，不同的引用，添加到<code>ReferenceQueue</code>的时机是不一样。下面介绍具体引用时再进行说明。<br>这里有个问题，如果创建引用对象是没有指定<code>ReferenceQueue</code>，引用对象会怎么样呢？这里需要了解<code>Reference</code>类内部的四种状态。</p><h4 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h4><p>每一时刻，<code>Reference</code>对象都处于下面四种状态中。这四种状态用<code>Reference</code>的成员变量<code>queue</code>与<code>next</code>（类似于单链表中的next）来标示。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;? super T&gt; queue;</span><br><span class="line">Reference next;</span><br></pre></td></tr></table></figure><ul><li><p>Active。新创建的引用对象都是这个状态，在 GC 检测到引用对象已经到达合适的reachability时，GC 会根据引用对象是否在创建时制定<code>ReferenceQueue</code>参数进行状态转移，如果指定了，那么转移到<code>Pending</code>，如果没指定，转移到<code>Inactive</code>。在这个状态中</p>  <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//如果构造参数中没指定queue，那么queue为ReferenceQueue.<span class="literal">NULL</span>，否则为构造参数中传递过来的queue</span><br><span class="line">queue = ReferenceQueue || ReferenceQueue.<span class="literal">NULL</span></span><br><span class="line"><span class="keyword">next</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></li><li><p>Pending。pending-Reference列表中的引用都是这个状态，它们等着被内部线程<code>ReferenceHandler</code>处理（会调用<code>ReferenceQueue.enqueue</code>方法）。没有注册的实例不会进入这个状态。在这个状态中</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造参数参数中传递过来的queue</span></span><br><span class="line"><span class="built_in">queue</span> = ReferenceQueue</span><br><span class="line">next = 该<span class="built_in">queue</span>中的下一个引用，如果是该队列中的最后一个，那么为<span class="keyword">this</span></span><br></pre></td></tr></table></figure></li><li><p>Enqueued。调用<code>ReferenceQueue.enqueued</code>方法后的引用处于这个状态中。没有注册的实例不会进入这个状态。在这个状态中</p>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">queue</span> = ReferenceQueue.ENQUEUED</span><br><span class="line"><span class="attr">next</span> = 该queue中的下一个引用，如果是该队列中的最后一个，那么为this</span><br></pre></td></tr></table></figure></li><li><p>Inactive。最终状态，处于这个状态的引用对象，状态不会在改变。在这个状态中</p>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">queue</span> = ReferenceQueue.NULL</span><br><span class="line"><span class="attr">next</span> = this</span><br></pre></td></tr></table></figure></li></ul><p>有了这些约束，GC 只需要检测<code>next</code>字段就可以知道是否需要对该引用对象采取特殊处理</p><ul><li>如果<code>next</code>为<code>null</code>，那么说明该引用为<code>Active</code>状态</li><li>如果<code>next</code>不为<code>null</code>，那么 GC 应该按其正常逻辑处理该引用。</li></ul><p>我自己根据<code>Reference.ReferenceHandler.run</code>与<code>ReferenceQueue.enqueue</code>这两个方法，画出了这四种状态的转移图，供大家参考：</p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2CCSNfFXXXXceXXXXXXXXXXXX_!!581166664.png" alt="Reference状态转移图"><br></center><p>要理解这个状态 GC 到底做了什么事，需要看 JVM 的代码，我这里时间、能力都不够，就不献丑了，后面有机会再来填坑。<br>对于一般程序员来说，这四种状态完全可以不用管。最后简单两句话总结上面的四种状态：</p><ol><li>如果构造函数中指定了<code>ReferenceQueue</code>，那么事后程序员可以通过该队列清理引用</li><li>如果构造函数中没有指定了<code>ReferenceQueue</code>，那么 GC 会自动清理引用</li></ol><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>调用<code>Reference.get</code>方法可以得到该引用指向的对象，但是由于指向的对象随时可能被 GC 清理，所以即使在同一个线程中，不同时刻的调用可能返回不一样的值。</p><h3 id="软引用（soft-reference）"><a href="#软引用（soft-reference）" class="headerlink" title="软引用（soft reference）"></a>软引用（soft reference）</h3><p>软引用“保存”对象的能力稍逊于强引用，但是高于弱引用，一般用来实现memory-sensitive caches。</p><blockquote><p>软引用指向的对象会在程序即将触发<code>OOM</code>时被GC 清理掉，之后，引用对象会被放到<code>ReferenceQueue</code>中。</p></blockquote><h3 id="弱引用（weak-reference）"><a href="#弱引用（weak-reference）" class="headerlink" title="弱引用（weak reference）"></a>弱引用（weak reference）</h3><p>软引用“保存”对象的能力稍逊于弱引用，但是高于虚引用，一般用来实现canonicalizing mapping，也就是本文要讲的<code>WeakHashMap</code>😊。</p><blockquote><p>当弱引用指向的对象只能通过弱引用（没有强引用或弱引用）访问时，GC会清理掉该对象，之后，引用对象会被放到<code>ReferenceQueue</code>中。</p></blockquote><h3 id="虚引用（phantom-reference）"><a href="#虚引用（phantom-reference）" class="headerlink" title="虚引用（phantom reference）"></a>虚引用（phantom reference）</h3><p>虚引用是“保存”对象能力最弱的引用，一般用来实现scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism</p><blockquote><p>调用虚引用的<code>get</code>方法，总会返回<code>null</code>，与软引用和弱引用不同的是，虚引用被<code>enqueued</code>时，GC 并不会自动清理虚引用指向的对象，只有当指向该对象的所有虚引用全部被清理（enqueued后）后或其本身不可达时，该对象才会被清理。</p></blockquote><h2 id="WeakHashMap-Entry"><a href="#WeakHashMap-Entry" class="headerlink" title="WeakHashMap.Entry"></a>WeakHashMap.Entry</h2><p>上面介绍了很多引用的知识点，其实<code>WeakHashMap</code>本身没什么好说的，只要是把引用的作用与使用场景搞清楚了，再来分析基于这些引用的对象就会很简单了。<br><code>WeakHashMap</code>与<code>HashMap</code>的签名与构造函数一样，这里就不介绍了，这里重点介绍下<code>Entry</code>这个内部对象，因为其保存具体key-value对，所以把它弄清楚了，其他的就问题不大了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The entries in this hash table extend WeakReference, using its main ref</span></span><br><span class="line"><span class="comment">  * field as the key.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     V value;</span><br><span class="line">     <span class="keyword">int</span> hash;</span><br><span class="line">     Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Creates new entry.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     Entry(Object key, V value,</span><br><span class="line">           ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">           <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">         <span class="comment">//这里把key传给了父类WeakReference，说明key为弱引用（没有显式的 this.key = key）</span></span><br><span class="line">         <span class="comment">//所有如果key只有通过弱引用访问时，key会被 GC 清理掉</span></span><br><span class="line">         <span class="comment">//同时该key所代表的Entry会进入queue中，等待被处理</span></span><br><span class="line">         <span class="comment">//还可以看到value为强引用（有显式的 this.value = value ），但这并不影响</span></span><br><span class="line">         <span class="comment">//后面可以看到WeakHashMap.expungeStaleEntries方法是如何清理value的</span></span><br><span class="line">         <span class="keyword">super</span>(key, queue);</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">         <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">         <span class="keyword">this</span>.next  = next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     <span class="comment">//在获取key时需要unmaskNull，因为对于null的key，是用WeakHashMap的内部成员属性来表示的</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (K) WeakHashMap.unmaskNull(get());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">         V oldValue = value;</span><br><span class="line">         value = newValue;</span><br><span class="line">         <span class="keyword">return</span> oldValue;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">         K k1 = getKey();</span><br><span class="line">         Object k2 = e.getKey();</span><br><span class="line">         <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">             V v1 = getValue();</span><br><span class="line">             Object v2 = e.getValue();</span><br><span class="line">             <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         K k = getKey();</span><br><span class="line">         V v = getValue();</span><br><span class="line">         <span class="keyword">return</span> ((k==<span class="keyword">null</span> ? <span class="number">0</span> : k.hashCode()) ^</span><br><span class="line">                 (v==<span class="keyword">null</span> ? <span class="number">0</span> : v.hashCode()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="WeakHashMap-expungeStaleEntries"><a href="#WeakHashMap-expungeStaleEntries" class="headerlink" title="WeakHashMap.expungeStaleEntries"></a>WeakHashMap.expungeStaleEntries</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reference queue for cleared WeakEntries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 所有Entry在构造时都传入该queue</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expunges stale entries from the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="comment">// e 为要清理的对象</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="comment">// while 循环遍历冲突链</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    <span class="comment">// 可以看到这里把value赋值为null，来帮助 GC 回收强引用的value</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了<code>expungeStaleEntries</code>方法的作用，下面看看它是何时被调用的</p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2nMe3fFXXXXaFXXXXXXXXXXXX_!!581166664.png" alt="expungeStaleEntries调用链"><br></center><p>可以看到，在对<code>WeakHashMap</code>进行增删改查时，都调用了<code>expungeStaleEntries</code>方法。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>上面说了，下面来个具体的例子帮助大家消化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyHolder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am over from key"</span>);</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueHolder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am over from value"</span>);</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakHashMap&lt;KeyHolder, ValueHolder&gt; weakMap = <span class="keyword">new</span> WeakHashMap&lt;KeyHolder, ValueHolder&gt;();</span><br><span class="line"></span><br><span class="line">        KeyHolder kh = <span class="keyword">new</span> KeyHolder();    </span><br><span class="line">        ValueHolder vh = <span class="keyword">new</span> ValueHolder();</span><br><span class="line"></span><br><span class="line">        weakMap.put(kh, vh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (KeyHolder key : weakMap.keySet()) &#123;</span><br><span class="line">                System.out.println(key + <span class="string">" : "</span> + weakMap.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"here..."</span>);</span><br><span class="line">            <span class="comment">//这里把kh设为null，这样一来就只有弱引用指向kh指向的对象</span></span><br><span class="line">            kh = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KeyHolder@a15670a : ValueHolder@<span class="number">20e1</span>ed5b</span><br><span class="line"><span class="function"><span class="title">here</span></span>...</span><br><span class="line">I am over from key   <span class="comment">//输出这句话说明，该key对应的Entry已经被 GC 清理</span></span><br><span class="line"><span class="function"><span class="title">here</span></span>...</span><br><span class="line"><span class="function"><span class="title">here</span></span>...</span><br><span class="line"><span class="function"><span class="title">here</span></span>...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说实话，之前我是没怎么了解过引用，更是没有用过<code>WeakHashMap</code>这个类，这次算是把这个坑给填上了。引用的使用场景应该是在常驻类或消耗内存较大应用中才用得上，我自己确实没怎么经历过这种类型的项目，只能现在打好基础，以后有机会在尝试。</p><p>其实关于引用，本文重点介绍了弱引用的使用场景，其他的没怎么介绍，感兴趣的可以阅读参考中给出的链接。😊</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://weblogs.java.net/blog/2006/05/04/understanding-weak-references" target="_blank" rel="noopener">https://weblogs.java.net/blog/2006/05/04/understanding-weak-references</a></li><li><a href="http://www.onjava.com/pub/a/onjava/2001/07/09/optimization.html?page=1" target="_blank" rel="noopener">http://www.onjava.com/pub/a/onjava/2001/07/09/optimization.html?page=1</a></li><li><a href="http://stackoverflow.com/questions/5585694/whats-the-state-of-a-weak-reference-that-has-been-manually-enqueued" target="_blank" rel="noopener">whats-the-state-of-a-weak-reference-that-has-been-manually-enqueued</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面把基于特定数据结构的Map介绍完了，它们分别利用了相应数据结构的特点来实现特殊的目的，像HashMap利用哈希表的快速插入、查找实现&lt;code&gt;O(1)&lt;/code&gt;的增删改查，TreeMap则利用了红黑树来保证key的有序性的同时，使得增删改查的时间复杂度为&lt;code
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SICP 第二章总结</title>
    <link href="http://liujiacai.net/blog/2015/09/20/sicp-chapter2-summary/"/>
    <id>http://liujiacai.net/blog/2015/09/20/sicp-chapter2-summary/</id>
    <published>2015-09-20T09:48:17.000Z</published>
    <updated>2019-12-24T10:59:14.602Z</updated>
    
    <content type="html"><![CDATA[<p>到今天为止终于把第二章看完了，相比于第一章，感觉难点少了些，这章主要是通过大量例子（主要有图形语言、区间运算、符号求导、集合的表示、通用型算术运算）来熟悉构造数据抽象的相关技能。下面来回顾总结一下第二章。</p><h2 id="数据抽象的意义"><a href="#数据抽象的意义" class="headerlink" title="数据抽象的意义"></a>数据抽象的意义</h2><p>在第一章中，只是进行了一些数值演算，这是比较简单的数据，并没有体现出数据抽象的意义，本章一开始就通过有理数的运算这个例子引出了数据抽象的意义。<br>数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们可以像操作数值等简单数据类型一样操作“抽象数据”。通过构造复合数据（与构造复合过程类似）可以达到下面的效果：</p><ol><li>降低程序间的耦合度</li><li>提高设计的模块性</li><li>增强语言表达能力，为处理计算问题提供更多手段和方法。</li></ol><p>第二章主要围绕下面两个部分展开：</p><ol><li>如何构造复合数据对象（通过数据组合）</li><li>如何处理复合数据对象</li></ol><p>其他一些细节点还包括：</p><ol><li>复合数据如何支持以“匹配和组合”方式工作的编程接口</li><li>通过定义数据抽象,进一步模糊“过程”和“数据”的差异</li><li>符号表达式的处理,这种表达式的基本部分是符号而不是数 通用型(泛型)操作,使同样操作可能用于不同的数据</li><li>数据制导（导向/驱动）的程序设计,方便新数据类的加入</li></ol><h3 id="过程抽象与数据抽象"><a href="#过程抽象与数据抽象" class="headerlink" title="过程抽象与数据抽象"></a>过程抽象与数据抽象</h3><p>一个过程描述了一类计算的模式,又可以作为元素用于实现其他(更复 杂的)过程。因此过程是一种抽象——过程抽象。过程抽象的优势在于：</p><ol><li>屏蔽计算的实现细节,可以用任何功能/使用形式合适的过程取代</li><li>规定了使用方式,使用方只依赖于抽象的使用方式约定</li></ol><p>数据抽象的情况类似。<br>一个数据抽象实现一类数据所需的所有功能,又像基本数据元素一样可以作为其他数据抽象的元素。主要优势：</p><ol><li>屏蔽一种复合数据的实现细节</li><li>提供一套抽象操作,使用组合数据的就像是使用基本数据</li><li>数据抽象的接口(界面)包括两类操作:构造函数和选择函数。构造函数基于一些参数构造这类数据,选择函数提取其内容</li></ol><p>后面将说明（在第三章😊）,如果需要支持基于状态的程序设计，那么就需要增加另外 一类变动操作（mutation，修改操作）。</p><h2 id="数据抽象的语言支持"><a href="#数据抽象的语言支持" class="headerlink" title="数据抽象的语言支持"></a>数据抽象的语言支持</h2><p>一般来说，实现数据抽象，编程语言需要提供下面三种机:</p><ol><li>粘合机制，支持把一组数据对象组合成一个整体（通过闭包实现）</li><li>操作定义机制，定义针对组合数据的操作（通过scheme内置的define实现）</li><li>抽象机制，屏蔽实现细节，使组合数据能像简单数据一样使用（通过数据导向的程序设计风格实现）</li></ol><p>处理复合数据的一个关键概念是<code>闭包</code>，这里的闭包概念来自<a href="https://en.wikipedia.org/wiki/Abstract_algebra" target="_blank" rel="noopener">抽象代数</a>，指的是</p><blockquote><p>通过数据对象组合起来得到的结果，还可以通过同样的操作再进行再次组合。</p></blockquote><p>这个概念和我们在JavaScript等现代编程语言中的概念（一种为表示带有自由变量的过程而用的实现技术）不一样，要注意区分。</p><h3 id="序对pair"><a href="#序对pair" class="headerlink" title="序对pair"></a>序对pair</h3><p>Scheme的基本复合结构称为“序对”，序对本身也是数据对象,可以用于构造更复杂的数据对象（也就是表，list）。例如<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> y (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">5</span> <span class="number">6</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> z (<span class="name"><span class="builtin-name">cons</span></span> x y))</span><br><span class="line"><span class="comment">; 注意理解序对pair 与表list 的区别</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> y (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">cdr</span></span> x)  <span class="comment">; 2</span></span><br><span class="line">(<span class="name"><span class="builtin-name">cdr</span></span> y)  <span class="comment">; (2)</span></span><br></pre></td></tr></table></figure></p><p>常规过程性语言都没有内部的表数据类型，但是我们在算法与数据结构课上，一般都用C语言实现过各种表（单向双向链表，环形链表等）结构，C++的标准STL库的list，Java集合框架中的List。</p><p>表及其相关概念是从 Lisp 开始开发，现已经成为很多技术的基础：</p><ol><li>动态存储管理已经成为日常编程工作的基本支持</li><li>链表的定义和使用是常用技术（想想Java 中你用了多少次ArrayList吧）</li><li>有关表的使用和操作,以及各种操作的设计和实现,都可以从Lisp的表结构学习许多东西</li><li>基于map、reduce的hadoop</li><li>高阶表操作对分解程序复杂性很有意义</li></ol><h3 id="序对的操作"><a href="#序对的操作" class="headerlink" title="序对的操作"></a>序对的操作</h3><p>由于序对是构造复杂数据对象的基础，所有掌握序对的操作也就显得尤为重要，在学习这些操作时，我们可以感受到函数式编程的奇妙。<br>废话不多说，直接看代码<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/lib/list.scm" target="_blank" rel="noopener">list.scm</a>看代码吧。</p><h2 id="数据导向-vs-消息传递"><a href="#数据导向-vs-消息传递" class="headerlink" title="数据导向 vs. 消息传递"></a>数据导向 vs. 消息传递</h2><p>这两种方式是本章着重接受的两种数据抽象方式，分别对象函数式编程（数据导向）与面向对象编程（消息传递），具体辨析可参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.76.md" target="_blank" rel="noopener">习题2.76</a>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>由于本章大部分内容都是用具体例子来讲解，下面我就再一一回顾遍。大部分内容都在我Github的读书笔记中，这里相当于个索引，具体例子可参考给出的相应链接😊。</p><h3 id="有理数运算"><a href="#有理数运算" class="headerlink" title="有理数运算"></a>有理数运算</h3><p>通过这里例子，引入数据抽象的意义。具体代码见<a href="https://github.com/jiacai2050/sicp/tree/master/exercises/02/lib/rational.scm" target="_blank" rel="noopener">rational.scm</a>。</p><p>介绍完这个例子后，书上提出了一个重要的问题，“什么是数据”，在有理数运算这个例子，中我们能看到的就是一个构造函数<code>make-rat</code>，两个选择函数<code>numer</code>与<code>demon</code>。首先我们要明确，并不是任意三个过程都能构成有理数的实现，需要满足<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">make-rat</span> (<span class="name">numer</span> x) (<span class="name">denom</span> x)) = x</span><br></pre></td></tr></table></figure></p><p>任意满足这一条件的三个函数，都能作为有理数表示的基础。<br>一般来说，一种数据对象的构造函数和选择函数都要满足一定条件。scheme中底层的数据结构序对也满足这一特点。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">car</span> (<span class="name">cons</span> a b)) = a</span><br><span class="line">(<span class="name">cdr</span> (<span class="name">cons</span> a b)) = b</span><br><span class="line">(<span class="name">cons</span> (<span class="name">car</span> x)(<span class="name">cdr</span> x)) = x  <span class="comment">;有前提,x 必须是序对</span></span><br></pre></td></tr></table></figure></p><h4 id="Church数"><a href="#Church数" class="headerlink" title="Church数"></a>Church数</h4><p><a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.06.scm" target="_blank" rel="noopener">习题2.06</a>引出Church数，完全用过程实现整数算术系统，关于这一点，推荐大家看我之前写的<a href="/blog/2014/10/12/lambda-calculus-introduction/">编程语言的基石——Lambda calculus</a>，绝对能够颠覆你的思维。</p><h3 id="区间运算"><a href="#区间运算" class="headerlink" title="区间运算"></a>区间运算</h3><p>见相应的习题解答，推荐看<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.14_2.16.md" target="_blank" rel="noopener">习题2.14_2.16</a></p><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB23LNQfFXXXXckXXXXXXXXXXXX_!!581166664.png" alt="八皇后示意图"><br></center><p>经典的问题，参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.42_2.43.md" target="_blank" rel="noopener">习题2.42</a>。</p><h3 id="图形语言"><a href="#图形语言" class="headerlink" title="图形语言"></a>图形语言</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i3/581166664/TB2lhtEfFXXXXaRXpXXXXXXXXXX_!!581166664.png" alt="图形语言"><br></center><br>这个示例比较好玩，设计了一个图形语言，基本的元素painter用一过程表示，进一步模糊过程与数据的区别。参考相关习题，推荐<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.44_2.45.md" target="_blank" rel="noopener">2.44</a>、<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.49.md" target="_blank" rel="noopener">2.49</a>。<br>你可以看到，把painter用过程实现后，相关操作（flip-vert、besides等）变得何其简单。</p><h3 id="Huffman编码树🌲"><a href="#Huffman编码树🌲" class="headerlink" title="Huffman编码树🌲"></a>Huffman编码树🌲</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2Uy8RfFXXXXcEXXXXXXXXXXXX_!!581166664.png" alt="一个Huffman的例子"><br></center><br>又一经典算法，一定要看，推荐<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.69.scm" target="_blank" rel="noopener">练习2.69</a>，学习如果构造一个Huffman编码树。</p><h3 id="复数的表示"><a href="#复数的表示" class="headerlink" title="复数的表示"></a>复数的表示</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB213J7fFXXXXXOXXXXXXXXXXXX_!!581166664.png" alt="复数的表示"><br></center><br>这种主要是用直角坐标与极坐标两种形式表示复数，用带标志的数据，实现了数据导向的设计风格。</p><p>两种坐标的实现，参考代码<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/lib/generic_arithmetic.scm" target="_blank" rel="noopener">lib/generic_arithmetic.scm</a></p><h3 id="通用型算术包的实现"><a href="#通用型算术包的实现" class="headerlink" title="通用型算术包的实现"></a>通用型算术包的实现</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2GYJSfFXXXXcFXXXXXXXXXXXX_!!581166664.png" alt="通用型算术包"><br></center><br>这一示例基本在前面有理数与复数的基础上，定义了统一的接口（add、sub等）来操作<code>scheme-number</code>、<code>rational</code>与<code>complex</code>三种类型的数据。</p><p>参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/lib/complex_number.scm" target="_blank" rel="noopener">lib/complex_number.scm</a></p><h3 id="符号代数——多项式算术"><a href="#符号代数——多项式算术" class="headerlink" title="符号代数——多项式算术"></a>符号代数——多项式算术</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i3/581166664/TB2_HRVfFXXXXbzXXXXXXXXXXXX_!!581166664.png" alt="多边形的继承性（强制的难点）"><br></center><br>本章最后一个例子，难度比之前通用型算术包要大，因为不同类型的数据间操作需要“强制（coercion）”，而强制就需要一定的规则，实际编程中这种规则可能很复杂，所有这里需要注意的细节点比较多。</p><p>从“强制”引出的问题可以看出强类型语言的劣势，现在像python、javascript等弱类型的语言这么火，很大程序上就是由于弱类型语言的编译器把“强制”的工作给做了，程序员根本不用去关心。当然，如果所有“强制”工作都让编译器去做，也是不合适的，具体如何选择，就需要综合多种因素了。<br>我本身经验还不是很丰富，就不乱说了，如果你有这方面的亲身体会，可以留言，我会及时更新😊。</p><p>代码实现参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/lib/poly.scm" target="_blank" rel="noopener">lib/poly.scm</a>与<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.92.md" target="_blank" rel="noopener">习题2.92</a>。</p><h3 id="扩充练习：有理函数"><a href="#扩充练习：有理函数" class="headerlink" title="扩充练习：有理函数"></a>扩充练习：有理函数</h3><p>经过前面多项式算术的习题，我基本已经败下阵来了，实在是吸收消化不了了，改日再战😂。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一次看第二章，陆陆续续用了2个月，基本上耗费平时下班＋周末双休的时间，收获还是挺大的。<br>不过由于本章习题量有些大，而且一开始像一些基础的过程<code>put</code>、<code>get</code>都没有，所以自己只是随便写写，没法运行，所以前面看的不好，这章习题之简的联系很紧密，前面没做好，后面只能呵呵了。</p><p>有一段时间让这些题弄的很烦，一点不想做，还好我这时候分散了下注意力，看了些其他的东西，像java集合框架的一些代码、the little schemer第九章的Y算子推导（虽然还没看懂），由于带着放松心情看的，遇到不懂的地方我就跳过去，没有深究，基本上达到了放松的目的。之后在网上把那些基础的过程都实现出来，再去做那些习题就顺多了。</p><p>这一章的内容，我之前多多少少了解过，所以大部分内容看起来还是比较顺畅的，就是习题多了点，由于当初给自己定的目标，所以还是慢慢的把所有习题（有理函数的除外）做了一遍。还是一点就是做后面的题时，忘了前面的知识点，需要平时没事多去翻翻，毕竟现在还达不到烂熟于心的地步。</p><p>下周一小组内再过一遍，向着第三章进军了。⛽️</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;到今天为止终于把第二章看完了，相比于第一章，感觉难点少了些，这章主要是通过大量例子（主要有图形语言、区间运算、符号求导、集合的表示、通用型算术运算）来熟悉构造数据抽象的相关技能。下面来回顾总结一下第二章。&lt;/p&gt;
&lt;h2 id=&quot;数据抽象的意义&quot;&gt;&lt;a href=&quot;#数据抽
      
    
    </summary>
    
      <category term="研习经典" scheme="http://liujiacai.net/categories/%E7%A0%94%E4%B9%A0%E7%BB%8F%E5%85%B8/"/>
    
    
      <category term="sicp" scheme="http://liujiacai.net/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>Java LinkedHashMap源码解析</title>
    <link href="http://liujiacai.net/blog/2015/09/12/java-linkedhashmap/"/>
    <id>http://liujiacai.net/blog/2015/09/12/java-linkedhashmap/</id>
    <published>2015-09-12T10:31:12.000Z</published>
    <updated>2019-12-24T10:59:14.602Z</updated>
    
    <content type="html"><![CDATA[<p>上周把<a href="/blog/2015/09/03/java-hashmap/">HashMap</a>、<a href="/blog/2015/09/04/java-treemap/">TreeMap</a>这两个Map体系中比较有代表性的类介绍完了，大家应该也能体会到，如果该类所对应的数据结构与算法掌握好了，再看这些类的源码真是太简单不过了。</p><p>其次，我希望大家能够触类旁通，比如我们已经掌握了HashMap的原理，我们可以推知<a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html" target="_blank" rel="noopener">HashSet</a>的内部实现</p><blockquote><p>HashSet 内部用一个HashMap对象存储数据，更具体些，只用到了key，value全部为一dummy对象。</p></blockquote><p>HashSet这个类太简单了，我不打算单独写文章介绍。今天介绍个比较实用的类——<a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener">LinkedHashMap</a>。</p><blockquote><p>本文源码分析基于<a href="http://www.oracle.com/technetwork/java/javase/7u71-relnotes-2296187.html" target="_blank" rel="noopener">Oracle JDK 1.7.0_71</a>，请知悉。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.7.0_71"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_71-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 24.71-b01, mixed mode)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，LinkedHashMap是HashMap的一子类，它根据自身的特性修改了HashMap的内部某些方法的实现，要想知道LinkedHashMap具体修改了哪些方法，就需要了解LinkedHashMap的设计原理了。</p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>LinkedHashMap是key键有序的HashMap的一种实现。它除了使用哈希表这个数据结构，使用双向链表来保证key的顺序</p><p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2WFoafXXXXXaUXXXXXXXXXXXX_!!581166664.gif" alt="双向链表"><br></center><br>双向链表算是个很常见的数据结构，上图中的头节点的prev、尾节点的next指向null，双向链表还有一种变种，见下图</p><p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB27MP7fXXXXXb6XXXXXXXXXXXX_!!581166664.png" alt="环型双向链表"><br></center><br>可以看到，这种链表把首尾节点相连，形成一个环。</p><p>LinkedHashMap中采用的这种<code>环型双向链表</code>，环型双向链表的用途比较多，感兴趣可以看这里：</p><ul><li><a href="http://stackoverflow.com/questions/3589772/why-exactly-do-we-need-a-circular-linked-list-singly-or-doubly-data-structur" target="_blank" rel="noopener">http://stackoverflow.com/questions/3589772/why-exactly-do-we-need-a-circular-linked-list-singly-or-doubly-data-structur</a></li></ul><p>双向链表这种数据结构，最关键的是保证在增加节点、删除节点时不要断链，后面在分析LinkedHashMap具体代码时会具体介绍，这里就不赘述了。</p><h3 id="LinkedHashMap-特点"><a href="#LinkedHashMap-特点" class="headerlink" title="LinkedHashMap 特点"></a>LinkedHashMap 特点</h3><p>一般来说，如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。<br>但是选择TreeMap就会有性能问题，因为TreeMap的get操作的时间复杂度是<code>O(log(n))</code>的，相比于HashMap的<code>O(1)</code>还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得</p><blockquote><p>能够以<code>O(1)</code>时间复杂度增加查找元素，又能够保证key的有序性</p></blockquote><p>此外，LinkedHashMap提供了两种key的顺序：</p><ul><li>访问顺序（access order）。非常实用，可以使用这种顺序实现LRU（Least Recently Used）缓存</li><li>插入顺序（insertion orde）。同一key的多次插入，并不会影响其顺序</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先打开eclipse的outline面版看看LinkedHashMap里面有那些成员</p><p><center><br>    <img src="https://img.alicdn.com/imgextra/i1/581166664/TB25aL6fXXXXXcGXXXXXXXXXXXX_!!581166664.png" alt="LinkedHashMap结构"><br></center><br>可以看到，由于LinkedHashMap继承自HashMap，所以大部分的方法都是根据<code>key的有序性</code>而重写了HashMap中的部分方法。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//accessOrder为true表示该LinkedHashMap的key为访问顺序</span></span><br><span class="line"><span class="comment">//accessOrder为false表示该LinkedHashMap的key为插入顺序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="comment">//默认为false，也就是插入顺序</span></span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(m);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called by superclass constructors and pseudoconstructors (clone,</span></span><br><span class="line"><span class="comment"> * readObject) before any entries are inserted into the map.  Initializes</span></span><br><span class="line"><span class="comment"> * the chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//通过这里可以看出，LinkedHashMap采用的是环型的双向链表</span></span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedHashMap-Entry"><a href="#LinkedHashMap-Entry" class="headerlink" title="LinkedHashMap.Entry"></a>LinkedHashMap.Entry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">    <span class="comment">//每个节点包含两个指针，指向前继节点与后继节点</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes this entry from the linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//删除一个节点时，需要把</span></span><br><span class="line">    <span class="comment">//1. 前继节点的后继指针 指向 要删除节点的后继节点</span></span><br><span class="line">    <span class="comment">//2. 后继节点的前继指针 指向 要删除节点的前继节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts this entry before the specified existing entry in the list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//在某节点前插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">        after  = existingEntry;</span><br><span class="line">        before = existingEntry.before;</span><br><span class="line">        before.after = <span class="keyword">this</span>;</span><br><span class="line">        after.before = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked by the superclass whenever the value</span></span><br><span class="line"><span class="comment">     * of a pre-existing entry is read by Map.get or modified by Map.set.</span></span><br><span class="line"><span class="comment">     * If the enclosing Map is access-ordered, it moves the entry</span></span><br><span class="line"><span class="comment">     * to the end of the list; otherwise, it does nothing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">        <span class="comment">// 如果需要key的访问顺序，需要把</span></span><br><span class="line">        <span class="comment">// 当前访问的节点删除，并把它插入到双向链表的起始位置</span></span><br><span class="line">        <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">            lm.modCount++;</span><br><span class="line">            remove();</span><br><span class="line">            addBefore(lm.header);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更形象表示双向链表是如何删除、增加节点，下面用代码加图示的方式</p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2cA__fXXXXXbQXXXXXXXXXXXX_!!581166664.jpg" alt="删除节点"><br></center><br>上图中，删除的是b节点<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">before</span>.<span class="keyword">after</span> = <span class="keyword">after</span>;  //相当于上图中的操作 1</span><br><span class="line">    <span class="keyword">after</span>.<span class="keyword">before</span> = <span class="keyword">before</span>; //相当于上图中的操作 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h4><p><center><br>    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB2lqv0fXXXXXaeXpXXXXXXXXXX_!!581166664.jpg" alt="增加节点"><br></center><br>上图中的c节点相当于下面代码中的existingEntry，要插入的是x节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;         <span class="comment">//相当于上图中的操作 1</span></span><br><span class="line">    before = existingEntry.before;  <span class="comment">//相当于上图中的操作 3</span></span><br><span class="line">    before.after = <span class="keyword">this</span>;            <span class="comment">//相当于上图中的操作 4</span></span><br><span class="line">    after.before = <span class="keyword">this</span>;            <span class="comment">//相当于上图中的操作 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了增加节点的原理，下面看看LinkedHashMap的代码是怎么实现put方法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This override alters behavior of superclass put method. It causes newly</span></span><br><span class="line"><span class="comment"> * allocated entry to get inserted at the end of the linked list and</span></span><br><span class="line"><span class="comment"> * removes the eldest entry if appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove eldest entry if instructed</span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    <span class="comment">//如果有必要移除最老的节点，那么就移除。LinkedHashMap默认removeEldestEntry总是返回false</span></span><br><span class="line">    <span class="comment">//也就是这里if里面的语句永远不会执行</span></span><br><span class="line">    <span class="comment">//这里removeEldestEntry主要是给LinkedHashMap的子类留下的一个钩子</span></span><br><span class="line">    <span class="comment">//子类完全可以根据自己的需要重写removeEldestEntry，后面我会举个现实中的例子🌰</span></span><br><span class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class="line">        removeEntryForKey(eldest.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This override differs from addEntry in that it doesn't resize the</span></span><br><span class="line"><span class="comment"> * table or remove the eldest entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">//这里把新增的Entry加到了双向链表的header的前面，成为新的header</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this map should remove its eldest entry.</span></span><br><span class="line"><span class="comment"> * This method is invoked by &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;putAll&lt;/tt&gt; after</span></span><br><span class="line"><span class="comment"> * inserting a new entry into the map.  It provides the implementor</span></span><br><span class="line"><span class="comment"> * with the opportunity to remove the eldest entry each time a new one</span></span><br><span class="line"><span class="comment"> * is added.  This is useful if the map represents a cache: it allows</span></span><br><span class="line"><span class="comment"> * the map to reduce memory consumption by deleting stale entries.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Sample use: this override will allow the map to grow up to 100</span></span><br><span class="line"><span class="comment"> * entries and then delete the eldest entry each time a new entry is</span></span><br><span class="line"><span class="comment"> * added, maintaining a steady state of 100 entries.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     private static final int MAX_ENTRIES = 100;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span></span><br><span class="line"><span class="comment"> *        return size() &gt; MAX_ENTRIES;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method typically does not modify the map in any way,</span></span><br><span class="line"><span class="comment"> * instead allowing the map to modify itself as directed by its</span></span><br><span class="line"><span class="comment"> * return value.  It &lt;i&gt;is&lt;/i&gt; permitted for this method to modify</span></span><br><span class="line"><span class="comment"> * the map directly, but if it does so, it &lt;i&gt;must&lt;/i&gt; return</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;false&lt;/tt&gt; (indicating that the map should not attempt any</span></span><br><span class="line"><span class="comment"> * further modification).  The effects of returning &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * after modifying the map from within this method are unspecified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation merely returns &lt;tt&gt;false&lt;/tt&gt; (so that this</span></span><br><span class="line"><span class="comment"> * map acts like a normal map - the eldest element is never removed).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>    eldest The least recently inserted entry in the map, or if</span></span><br><span class="line"><span class="comment"> *           this is an access-ordered map, the least recently accessed</span></span><br><span class="line"><span class="comment"> *           entry.  This is the entry that will be removed it this</span></span><br><span class="line"><span class="comment"> *           method returns &lt;tt&gt;true&lt;/tt&gt;.  If the map was empty prior</span></span><br><span class="line"><span class="comment"> *           to the &lt;tt&gt;put&lt;/tt&gt; or &lt;tt&gt;putAll&lt;/tt&gt; invocation resulting</span></span><br><span class="line"><span class="comment"> *           in this invocation, this will be the entry that was just</span></span><br><span class="line"><span class="comment"> *           inserted; in other words, if the map contains a single</span></span><br><span class="line"><span class="comment"> *           entry, the eldest entry is also the newest.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   &lt;tt&gt;true&lt;/tt&gt; if the eldest entry should be removed</span></span><br><span class="line"><span class="comment"> *           from the map; &lt;tt&gt;false&lt;/tt&gt; if it should be retained.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是LinkedHashMap中重写了HashMap的两个方法，当调用put时添加Entry（新增Entry之前不存在）整个方法调用链是这样的：</p><blockquote><p><code>LinkedHashMap.put</code> -&gt; <code>LinkedHashMap.addEntry</code> -&gt;<br><code>HashMap.addEntry</code> -&gt; <code>LinkedHashMap.createEntry</code></p></blockquote><p>有了这个调用链，再结合上面createEntry方法中的注释，就可以明白如何在添加Entry保证双向链表不断链的了。</p><h4 id="实战：LRU缓存"><a href="#实战：LRU缓存" class="headerlink" title="实战：LRU缓存"></a>实战：LRU缓存</h4><p>上面已经介绍了，利用访问顺序这种方式可以实现LRU缓存，正好最近在用flume向hadoop传数据，发现里面hdfs sink里面就用到了这种思想。</p><p>如果你不了解flume、hdfs、sink等这些概念，也不要紧，也不会影响阅读下面的代码，相信我😊。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Extended Java LinkedHashMap for open file handle LRU queue.</span></span><br><span class="line"><span class="comment"> * We want to clear the oldest file handle if there are too many open ones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterLinkedHashMap</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">String</span>, <span class="title">BucketWriter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxOpenFiles;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WriterLinkedHashMap</span><span class="params">(<span class="keyword">int</span> maxOpenFiles)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里的第三个参数为true，表示key默认的顺序为访问顺序，而不是插入顺序</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>); <span class="comment">// stock initial capacity/load, access ordering</span></span><br><span class="line">    <span class="keyword">this</span>.maxOpenFiles = maxOpenFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Entry&lt;String, BucketWriter&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size() &gt; maxOpenFiles) &#123;</span><br><span class="line">      <span class="comment">// If we have more that max open files, then close the last one and</span></span><br><span class="line">      <span class="comment">// return true</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        eldest.getValue().close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        LOG.warn(eldest.getKey().toString(), e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        LOG.warn(eldest.getKey().toString(), e);</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里的<code>WriterLinkedHashMap</code>主要是重写了removeEldestEntry方法，我们上面介绍了，在LinkedHashMap中，这个方法总是返回false，在这里设定了一个阈值maxOpenFiles，如果打开的文件数超过了这个阈值，就返回true，即把之前最不经常访问的节点给删除掉，达到释放资源的效果。</p><h3 id="更高效的LinkedHashIterator"><a href="#更高效的LinkedHashIterator" class="headerlink" title="更高效的LinkedHashIterator"></a>更高效的LinkedHashIterator</h3><p>由于元素之间用双向链表连接起来了，所以在遍历元素时只需遍历双向链表即可，这比HashMap中的遍历方式要高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; nextEntry    = header.after;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The modCount value that the iterator believes that the backing</span></span><br><span class="line"><span class="comment">     * List should have.  If this expectation is violated, the iterator</span></span><br><span class="line"><span class="comment">     * has detected concurrent modification.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">//由于采用环型双向链表，所以可以用header.after == header 来判断双向链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry != header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">        LinkedHashMap.<span class="keyword">this</span>.remove(lastReturned.key);</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (nextEntry == header)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Entry&lt;K,V&gt; e = lastReturned = nextEntry;</span><br><span class="line">        <span class="comment">//在访问下一个节点时，直接使用当前节点的后继指针即可</span></span><br><span class="line">        nextEntry = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了LinkedHashIterator利用了双向链表遍历的优势外，下面的两个方法也利用这个优势加速执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries to new table array.  This method is called</span></span><br><span class="line"><span class="comment"> * by superclass resize.  It is overridden for performance, as it is</span></span><br><span class="line"><span class="comment"> * faster to iterate using our linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(HashMap.Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = header.after; e != header; e = e.after) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rehash)</span><br><span class="line">            e.hash = (e.key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">        <span class="keyword">int</span> index = indexFor(e.hash, newCapacity);</span><br><span class="line">        e.next = newTable[index];</span><br><span class="line">        newTable[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment"> * specified value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment"> *         specified value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Overridden to take advantage of faster iterator</span></span><br><span class="line">    <span class="keyword">if</span> (value==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class="line">            <span class="keyword">if</span> (e.value==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次分析LinkedHashMap，我发现JDK里面的类设计确实巧妙，父类中很多为空的方法，看似无用，其实是为子类留的一个钩子，子类可以根据需要重写这个方法，像LinkedHashMap就重写了<code>init</code>方法，这个方法在HashMap中的实现为空。</p><p>其次我还想强调下一些基础数据结构与算法的重要性，语言现在很多，火的也多，我们不可能一一去学习，语法说白了就是一系列规则（也可以说是语法糖衣），不同的语言创建者所定的规则可能千差万别，但是他们所基于的数据结构与算法肯定是统一的。去伪存真，算法与数据结构才是我们真正需要学习的。</p><p>最近在看<a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus" target="_blank" rel="noopener">Y_combinator</a>，函数式编程中最迷人的地方，希望自己完全理解后再与大家分享。Stay Tuned！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周把&lt;a href=&quot;/blog/2015/09/03/java-hashmap/&quot;&gt;HashMap&lt;/a&gt;、&lt;a href=&quot;/blog/2015/09/04/java-treemap/&quot;&gt;TreeMap&lt;/a&gt;这两个Map体系中比较有代表性的类介绍完了，大家应该也能体
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java TreeMap 源码解析</title>
    <link href="http://liujiacai.net/blog/2015/09/04/java-treemap/"/>
    <id>http://liujiacai.net/blog/2015/09/04/java-treemap/</id>
    <published>2015-09-04T11:54:55.000Z</published>
    <updated>2019-12-24T10:59:14.601Z</updated>
    
    <content type="html"><![CDATA[<p>继<a href="/blog/2015/09/03/java-hashmap/">上篇文章</a>介绍完了HashMap，这篇文章开始介绍Map系列另一个比较重要的类<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/TreeMap.html" target="_blank" rel="noopener">TreeMap</a>。<br>大家也许能感觉到，网络上介绍HashMap的文章比较多，但是介绍TreeMap反而不那么多，这里面是有原因：一方面HashMap的使用场景比较多；二是相对于HashMap来说，TreeMap所用到的数据结构更为复杂。</p><blockquote><p>本文源码分析基于<a href="http://www.oracle.com/technetwork/java/javase/7u71-relnotes-2296187.html" target="_blank" rel="noopener">Oracle JDK 1.7.0_71</a>，请知悉。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.7.0_71"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_71-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 24.71-b01, mixed mode)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="签名（signature）"><a href="#签名（signature）" class="headerlink" title="签名（signature）"></a>签名（signature）</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到，相比HashMap来说，TreeMap多继承了一个接口<a href="http://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html" target="_blank" rel="noopener">NavigableMap</a>，也就是这个接口，决定了TreeMap与HashMap的不同：</p><blockquote><p>HashMap的key是无序的，TreeMap的key是有序的</p></blockquote><h3 id="接口NavigableMap"><a href="#接口NavigableMap" class="headerlink" title="接口NavigableMap"></a>接口NavigableMap</h3><p>首先看下NavigableMap的签名<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt;</span><br></pre></td></tr></table></figure></p><p>发现NavigableMap继承了SortedMap，再看SortedMap的签名</p><h4 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a><code>SortedMap</code></h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p><code>SortedMap</code>就像其名字那样，说明这个Map是有序的。这个顺序一般是指由<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener">Comparable接口</a>提供的keys的自然序（natural ordering），或者也可以在创建SortedMap实例时，指定一个<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html" target="_blank" rel="noopener">Comparator</a>来决定。<br>当我们在用集合视角（collection views，与HashMap一样，也是由entrySet、keySet与values方法提供）来迭代（iterate）一个SortedMap实例时会体现出key的顺序。</p><p>这里引申下关于Comparable与Comparator的区别（参考<a href="http://stackoverflow.com/a/4108616/2163429" target="_blank" rel="noopener">这里</a>）：</p><ul><li>Comparable一般表示类的自然序，比如定义一个Student类，学号为默认排序</li><li>Comparator一般表示类在某种场合下的特殊分类，需要定制化排序。比如现在想按照Student类的age来排序</li></ul><p>插入SortedMap中的key的类类都必须继承Comparable类（或指定一个comparator），这样才能确定如何比较（通过<code>k1.compareTo(k2)</code>或<code>comparator.compare(k1, k2)</code>）两个key，否则，在插入时，会报<code>ClassCastException</code>的异常。</p><p>此为，SortedMap中key的顺序性应该与<code>equals</code>方法保持一致。也就是说<code>k1.compareTo(k2)</code>或<code>comparator.compare(k1, k2)</code>为true时，<code>k1.equals(k2)</code>也应该为true。</p><p>介绍完了SortedMap，再来回到我们的NavigableMap上面来。<br>NavigableMap是JDK1.6新增的，在SortedMap的基础上，增加了一些“导航方法”（navigation methods）来返回与搜索目标最近的元素。例如下面这些方法：</p><ul><li>lowerEntry，返回所有比给定Map.Entry小的元素</li><li>floorEntry，返回所有比给定Map.Entry小或相等的元素</li><li>ceilingEntry，返回所有比给定Map.Entry大或相等的元素</li><li>higherEntry，返回所有比给定Map.Entry大的元素</li></ul><h2 id="设计理念（design-concept）"><a href="#设计理念（design-concept）" class="headerlink" title="设计理念（design concept）"></a>设计理念（design concept）</h2><h3 id="红黑树（Red–black-tree）"><a href="#红黑树（Red–black-tree）" class="headerlink" title="红黑树（Red–black tree）"></a><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">红黑树（Red–black tree）</a></h3><p>TreeMap是用红黑树作为基础实现的，红黑树是一种<a href="https://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">二叉搜索树</a>，让我们在一起回忆下二叉搜索树的一些性质</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>先看看二叉搜索树（binary search tree，BST）长什么样呢？</p><p><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2R1QoeVXXXXaBXpXXXXXXXXXX_!!581166664.png" alt="二叉搜索树"><br></center><br>相信大家对这个图都不陌生，关键点是：</p><blockquote><p>左子树的值小于根节点，右子树的值大于根节点。</p></blockquote><p>二叉搜索树的优势在于每进行一次判断就是能将问题的规模减少一半，所以如果二叉搜索树是平衡的话，查找元素的时间复杂度为<code>log(n)</code>，也就是树的高度。</p><p>我这里想到一个比较严肃的问题，如果说二叉搜索树将问题规模减少了一半，那么三叉搜索树不就将问题规模减少了三分之二，这不是更好嘛，以此类推，我们还可以有四叉搜索树，五叉搜索树……对于更一般的情况：</p><blockquote><p>n个元素，K叉树搜索树的K为多少时效率是最好的？K＝2时吗？</p></blockquote><h4 id="K-叉搜索树"><a href="#K-叉搜索树" class="headerlink" title="K 叉搜索树"></a>K 叉搜索树</h4><p>如果大家按照我上面分析，很可能也陷入一个误区，就是</p><blockquote><p>三叉搜索树在将问题规模减少三分之二时，所需比较操作的次数是两次（二叉搜索树再将问题规模减少一半时，只需要一次比较操作）</p></blockquote><p>我们不能把这两次给忽略了，对于更一般的情况：</p><blockquote><p>n个元素，K叉树搜索树需要的平均比较次数为<code>k*log(n/k)</code>。</p></blockquote><p>对于极端情况k＝n时，K叉树就转化为了线性表了，复杂度也就是<code>O(n)</code>了，如果用数学角度来解这个问题，相当于：</p><blockquote><p>n为固定值时，k取何值时，<code>k*log(n/k)</code>的取值最小？</p></blockquote><p><code>k*log(n/k)</code>根据对数的运算规则可以转化为<code>ln(n)*k/ln(k)</code>，<code>ln(n)</code>为常数，所以相当于取<code>k/ln(k)</code>的极小值。这个问题对于大一刚学高数的人来说再简单不过了，我们这里直接看结果😊</p><blockquote><p>当k＝e时，<code>k/ln(k)</code>取最小值。</p></blockquote><p>自然数e的取值大约为2.718左右，可以看到二叉树基本上就是这样最优解了。在Nodejs的REPL中进行下面的操作<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo(k) &#123;return k/Math.log(k);&#125;</span><br><span class="line">&gt; foo(<span class="number">2</span>)</span><br><span class="line"><span class="number">2.8853900817779268</span></span><br><span class="line">&gt; foo(<span class="number">3</span>)</span><br><span class="line"><span class="number">2.730717679880512</span></span><br><span class="line">&gt; foo(<span class="number">4</span>)</span><br><span class="line"><span class="number">2.8853900817779268</span></span><br><span class="line">&gt; foo(<span class="number">5</span>)</span><br><span class="line"><span class="number">3.1066746727980594</span></span><br></pre></td></tr></table></figure></p><p>貌似k＝3时比k＝2时得到的结果还要小，那也就是说三叉搜索树应该比二叉搜索树更好些呀，但是为什么二叉树更流行呢？后来在万能的stackoverflow上找到了<a href="http://stackoverflow.com/questions/3498382/why-use-binary-search-if-theres-ternary-search/3525695#3525695" target="_blank" rel="noopener">答案</a>，主旨如下：</p><blockquote><p>现在的CPU可以针对二重逻辑（binary logic）的代码做优化，三重逻辑会被分解为多个二重逻辑。</p></blockquote><p>这样也就大概能理解为什么二叉树这么流行了，就是因为进行一次比较操作，我们最多可以将问题规模减少一半。</p><p>好了这里扯的有点远了😊，我们再回到红黑树上来。</p><h4 id="红黑树性质"><a href="#红黑树性质" class="headerlink" title="红黑树性质"></a>红黑树性质</h4><p>先看看红黑树的样子：</p><p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2HIUMeVXXXXXzXXXXXXXXXXXX_!!581166664.png" alt="红黑树示例"><br></center><br>上图是从wiki截来的，需要说明的一点是：</p><blockquote><p>叶子节点为上图中的NIL节点，国内一些教材中没有这个NIL节点，我们在画图时有时也会省略这些NIL节点，但是我们需要明确，当我们说叶子节点时，指的就是这些NIL节点。</p></blockquote><p>红黑树通过下面5条规则，保证了树是平衡的：</p><ol><li>树的节点只有红与黑两种颜色</li><li>根节点为黑色的</li><li>叶子节点为黑色的</li><li>红色节点的字节点必定是黑色的</li><li>从任意一节点出发，到其后继的叶子节点的路径中，黑色节点的数目相同</li></ol><p>满足了上面5个条件后，就能够保证：<code>根节点到叶子节点的最长路径不会大于根节点到叶子最短路径的2倍</code>。<br>其实这个很好理解，主要是用了性质4与5，这里简单说下：</p><blockquote><p>假设根节点到叶子节点最短的路径中，黑色节点数目为B，那么根据性质5，根节点到叶子节点的最长路径中，黑色节点数目也是B，最长的情况就是每两个黑色节点中间有个红色节点（也就是红黑相间的情况），所以红色节点最多为B－1个。这样就能证明上面的结论了。</p></blockquote><h4 id="红黑树操作"><a href="#红黑树操作" class="headerlink" title="红黑树操作"></a>红黑树操作</h4><p><center><br>    <img src="https://img.alicdn.com/imgextra/i1/581166664/TB2AkEOeVXXXXXvXXXXXXXXXXXX_!!581166664.png" alt="红黑树旋转示例（没有画出NIL节点）"><br></center><br>关于红黑树的插入、删除、左旋、右旋这些操作，我觉得最好可以做到可视化，文字表达比较繁琐，我这里就不在献丑了，网上能找到的也比较多，像<a href="http://blog.csdn.net/v_JULY_v/article/details/6105630" target="_blank" rel="noopener">v_July_v的《教你透彻了解红黑树》</a>。我这里推荐个<a href="http://www.csanimated.com/animation.php?t=Red-black_tree" target="_blank" rel="noopener">swf教学视频</a>（视频为英文，大家不要害怕，重点是看图😊），7分钟左右，大家可以参考。</p><p>这里还有个交互式<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="noopener">红黑树的可视化</a>网页，大家可以上去自己操作操作，插入几个节点，删除几个节点玩玩，看看左旋右旋是怎么玩的。</p><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>由于红黑树的操作我这里不说了，所以这里基本上也就没什么源码可以讲了，因为这里面重要的算法都是<code>From CLR</code>，这里的CLR是指Cormen, Leiserson, Rivest，他们是算法导论的作者，也就是说TreeMap里面算法都是参照算法导论的伪代码。</p><p>因为红黑树是平衡的二叉搜索树，所以其put（包含update操作）、get、remove的时间复杂度都为<code>log(n)</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到目前为止，TreeMap与HashMap的的实现算是都介绍完了，可以看到它们实现的不同，决定了它们应用场景的不同：</p><ul><li>TreeMap的key是有序的，增删改查操作的时间复杂度为<code>O(log(n))</code>，为了保证红黑树平衡，在必要时会进行旋转</li><li>HashMap的key是无序的，增删改查操作的时间复杂度为<code>O(1)</code>，为了做到动态扩容，在必要时会进行resize。</li></ul><p>另外，我这里没有解释具体代码，难免有些标题党了，请大家见谅，后面理解的更深刻了再来填坑。😂</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://stackoverflow.com/questions/21329662/explanation-of-red-black-tree-based-implementation-of-treemap-in-java" target="_blank" rel="noopener">http://stackoverflow.com/questions/21329662/explanation-of-red-black-tree-based-implementation-of-treemap-in-java</a></li><li><a href="http://javahungry.blogspot.com/2014/04/fail-fast-iterator-vs-fail-safe-iterator-difference-with-example-in-java.html" target="_blank" rel="noopener">http://javahungry.blogspot.com/2014/04/fail-fast-iterator-vs-fail-safe-iterator-difference-with-example-in-java.html</a></li><li><a href="https://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Binary_search_tree</a></li><li><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Red%E2%80%93black_tree</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继&lt;a href=&quot;/blog/2015/09/03/java-hashmap/&quot;&gt;上篇文章&lt;/a&gt;介绍完了HashMap，这篇文章开始介绍Map系列另一个比较重要的类&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/ind
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java HashMap 源码解析</title>
    <link href="http://liujiacai.net/blog/2015/09/03/java-hashmap/"/>
    <id>http://liujiacai.net/blog/2015/09/03/java-hashmap/</id>
    <published>2015-09-03T03:51:12.000Z</published>
    <updated>2019-12-24T10:59:14.601Z</updated>
    
    <content type="html"><![CDATA[<p>继上一篇文章<a href="/blog/2015/09/01/java-collection-overview">Java集合框架综述</a>后，今天正式开始分析具体集合类的代码，首先以既熟悉又陌生的<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/HashMap.html" target="_blank" rel="noopener">HashMap</a>开始。</p><blockquote><p>本文源码分析基于<a href="http://www.oracle.com/technetwork/java/javase/7u71-relnotes-2296187.html" target="_blank" rel="noopener">Oracle JDK 1.7.0_71</a>，请知悉。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.7.0_71"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_71-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 24.71-b01, mixed mode)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="签名（signature）"><a href="#签名（signature）" class="headerlink" title="签名（signature）"></a>签名（signature）</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到<code>HashMap</code>继承了</p><ul><li>标记接口<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Cloneable.html" target="_blank" rel="noopener">Cloneable</a>，用于表明<code>HashMap</code>对象会重写<code>java.lang.Object#clone()</code>方法，HashMap实现的是浅拷贝（shallow copy）。</li><li>标记接口<a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/io/Serializable.html" target="_blank" rel="noopener">Serializable</a>，用于表明<code>HashMap</code>对象可以被序列化</li></ul><p>比较有意思的是，<code>HashMap</code>同时继承了抽象类<code>AbstractMap</code>与接口<code>Map</code>，因为抽象类<code>AbstractMap</code>的签名为<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">AbstractMap</span>&lt;K,<span class="title">V</span>&gt; <span class="title">implements</span> <span class="title">Map</span>&lt;K,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><a href="http://stackoverflow.com/questions/14062286/java-why-does-weakhashmap-implement-map-whereas-it-is-already-implemented-by-ab" target="_blank" rel="noopener">Stack Overfloooow</a>上解释到：</p><blockquote><p>在语法层面继承接口<code>Map</code>是多余的，这么做仅仅是为了让阅读代码的人明确知道<code>HashMap</code>是属于<code>Map</code>体系的，起到了文档的作用</p></blockquote><p><code>AbstractMap</code>相当于个辅助类，<code>Map</code>的一些操作这里面已经提供了默认实现，后面具体的子类如果没有特殊行为，可直接使用<code>AbstractMap</code>提供的实现。</p><h3 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a><a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Cloneable.html" target="_blank" rel="noopener">Cloneable</a>接口</h3><pre><code>It&apos;s evil, don&apos;t use it.</code></pre><p><code>Cloneable</code>这个接口设计的非常不好，最致命的一点是它里面竟然没有<code>clone</code>方法，也就是说我们自己写的类完全可以实现这个接口的同时不重写<code>clone</code>方法。</p><p>关于<code>Cloneable</code>的不足，大家可以去看看《Effective Java》一书的作者<a href="http://www.artima.com/intv/bloch13.html" target="_blank" rel="noopener">给出的理由</a>，在所给链接的文章里，Josh Bloch也会讲如何实现深拷贝比较好，我这里就不在赘述了。</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a><a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/Map.html" target="_blank" rel="noopener">Map</a>接口</h3><p>在eclipse中的outline面板可以看到<code>Map</code>接口里面包含以下成员方法与内部类：</p><center><br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2Pt6LeVXXXXboXpXXXXXXXXXX_!!581166664.png" width="400" height="400" alt="Map_field_method"><br></center><p>可以看到，这里的成员方法不外乎是“增删改查”，这也反映了我们编写程序时，一定是以“数据”为导向的。</p><p>在<a href="/blog/2015/09/01/java-collection-overview/#Map">上篇文章</a>讲了<code>Map</code>虽然并不是<code>Collection</code>，但是它提供了三种“集合视角”（collection views），与下面三个方法一一对应：</p><ul><li><code>Set&lt;K&gt; keySet()</code>，提供key的集合视角</li><li><code>Collection&lt;V&gt; values()</code>，提供value的集合视角</li><li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>，提供key-value序对的集合视角，这里用内部类<code>Map.Entry</code>表示序对</li></ul><h3 id="AbstractMap抽象类"><a href="#AbstractMap抽象类" class="headerlink" title="AbstractMap抽象类"></a><a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/AbstractMap.html" target="_blank" rel="noopener">AbstractMap</a>抽象类</h3><p><code>AbstractMap</code>对<code>Map</code>中的方法提供了一个基本实现，减少了实现<code>Map</code>接口的工作量。<br>举例来说：</p><blockquote><p>如果要实现个不可变（unmodifiable）的map，那么只需继承<code>AbstractMap</code>，然后实现其<code>entrySet</code>方法，这个方法返回的set不支持add与remove，同时这个set的迭代器（iterator）不支持remove操作即可。</p><p>相反，如果要实现个可变（modifiable）的map，首先继承<code>AbstractMap</code>，然后重写（override）<code>AbstractMap</code>的put方法，同时实现<code>entrySet</code>所返回set的迭代器的remove方法即可。</p></blockquote><h2 id="设计理念（design-concept）"><a href="#设计理念（design-concept）" class="headerlink" title="设计理念（design concept）"></a>设计理念（design concept）</h2><h3 id="哈希表（hash-table）"><a href="#哈希表（hash-table）" class="headerlink" title="哈希表（hash table）"></a>哈希表（hash table）</h3><p><code>HashMap</code>是一种基于<a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">哈希表（hash table）</a>实现的map，哈希表（也叫关联数组）一种通用的数据结构，大多数的现代语言都原生支持，其概念也比较简单：<code>key经过hash函数作用后得到一个槽（buckets或slots）的索引（index），槽中保存着我们想要获取的值</code>，如下图所示</p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2ZGZbeVXXXXXtXXXXXXXXXXXX_!!581166664.png" alt="hash table demo" width="300" height="300"><br></center><p>很容易想到，一些不同的key经过同一hash函数后可能产生相同的索引，也就是产生了冲突，这是在所难免的。<br>所以利用哈希表这种数据结构实现具体类时，需要：</p><ul><li>设计个好的hash函数，使冲突尽可能的减少</li><li>其次是需要解决发生冲突后如何处理。</li></ul><p>后面会重点介绍<code>HashMap</code>是如何解决这两个问题的。</p><h3 id="HashMap的一些特点"><a href="#HashMap的一些特点" class="headerlink" title="HashMap的一些特点"></a>HashMap的一些特点</h3><ul><li>线程非安全，并且允许key与value都为null值，<code>HashTable</code>与之相反，为线程安全，key与value都不允许null值。</li><li>不保证其内部元素的顺序，而且随着时间的推移，同一元素的位置也可能改变（resize的情况）</li><li>put、get操作的时间复杂度为O(1)。</li><li>遍历其集合视角的时间复杂度与其容量（capacity，槽的个数）和现有元素的大小（entry的个数）成正比，所以如果遍历的性能要求很高，不要把capactiy设置的过高或把平衡因子（load factor，当entry数大于capacity*loadFactor时，会进行resize，reside会导致key进行rehash）设置的过低。</li><li>由于HashMap是线程非安全的，这也就是意味着如果多个线程同时对一hashmap的集合试图做迭代时有结构的上改变（添加、删除entry，只改变entry的value的值不算结构改变），那么会报<a href="http://docs.oracle.com/javase/7/docs/api/java/util/ConcurrentModificationException.html" target="_blank" rel="noopener">ConcurrentModificationException</a>，专业术语叫<code>fail-fast</code>，尽早报错对于多线程程序来说是很有必要的。</li><li><code>Map m = Collections.synchronizedMap(new HashMap(...));</code> 通过这种方式可以得到一个线程安全的map。</li></ul><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>首先从构造函数开始讲，<code>HashMap</code>遵循<a href="/blog/2015/09/01/java-collection-overview/#两大基类Collection与Map">集合框架的约束</a>，提供了一个参数为空的构造函数与有一个参数且参数类型为Map的构造函数。除此之外，还提供了两个构造函数，用于设置<code>HashMap</code>的容量（capacity）与平衡因子（loadFactor）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上可以看到，容量与平衡因子都有个默认值，并且容量有个最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>可以看到，默认的平衡因子为0.75，这是权衡了时间复杂度与空间复杂度之后的最好取值（JDK说是最好的😂），过高的因子会降低存储空间但是查找（lookup，包括HashMap中的put与get方法）的时间就会增加。</p><p>这里比较奇怪的是问题：容量必须为2的指数倍（默认为16），这是为什么呢？解答这个问题，需要了解HashMap中哈希函数的设计原理。</p><h3 id="哈希函数的设计原理"><a href="#哈希函数的设计原理" class="headerlink" title="哈希函数的设计原理"></a>哈希函数的设计原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Retrieve object hash code and applies a supplemental hash function to the</span></span><br><span class="line"><span class="comment">  * result hash, which defends against poor quality hash functions.  This is</span></span><br><span class="line"><span class="comment">  * critical because HashMap uses power-of-two length hash tables, that</span></span><br><span class="line"><span class="comment">  * otherwise encounter collisions for hashCodes that do not differ</span></span><br><span class="line"><span class="comment">  * in lower bits. Note: Null keys always map to hash 0, thus index 0.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">         <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">     <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">     <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">     h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">     <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>看到这么多位操作，是不是觉得晕头转向了呢，还是搞清楚原理就行了，毕竟位操作速度是很快的，不能因为不好理解就不用了😊。<br>网上说这个问题的也比较多，我这里根据自己的理解，尽量做到通俗易懂。</p><p>在哈希表容量（也就是buckets或slots大小）为length的情况下，为了使每个key都能在冲突最小的情况下映射到<code>[0,length)</code>（注意是左闭右开区间）的索引（index）内，一般有两种做法：</p><ol><li>让length为素数，然后用<code>hashCode(key) mod length</code>的方法得到索引</li><li>让length为2的指数倍，然后用<code>hashCode(key) &amp; (length-1)</code>的方法得到索引</li></ol><p><a href="http://docs.oracle.com/javase/7/docs/api/index.html?java/util/Hashtable.html" target="_blank" rel="noopener">HashTable</a>用的是方法1，<code>HashMap</code>用的是方法2。</p><p>因为本篇主题讲的是HashMap，所以关于方法1为什么要用素数，我这里不想过多介绍，大家可以看<a href="http://math.stackexchange.com/questions/183909/why-choose-a-prime-number-as-the-number-of-slots-for-hashing-function-that-uses" target="_blank" rel="noopener">这里</a>。</p><p>重点说说方法2的情况，方法2其实也比较好理解：</p><blockquote><p>因为length为2的指数倍，所以<code>length-1</code>所对应的二进制位都为1，然后在与<code>hashCode(key)</code>做与运算，即可得到<code>[0,length)</code>内的索引</p></blockquote><p>但是这里有个问题，如果<code>hashCode(key)</code>的大于<code>length</code>的值，而且<code>hashCode(key)</code>的二进制位的低位变化不大，那么冲突就会很多，举个例子：</p><blockquote><p>Java中对象的哈希值都32位整数，而HashMap默认大小为16，那么有两个对象那么的哈希值分别为：<code>0xABAB0000</code>与<code>0xBABA0000</code>，它们的后几位都是一样，那么与16异或后得到结果应该也是一样的，也就是产生了冲突。</p></blockquote><p>造成冲突的原因关键在于16限制了只能用低位来计算，高位直接舍弃了，所以我们需要额外的哈希函数而不只是简单的对象的<code>hashCode</code>方法了。<br>具体来说，就是HashMap中<code>hash</code>函数干的事了</p><blockquote><p>首先有个随机的hashSeed，来降低冲突发生的几率</p><p>然后如果是字符串，用了<code>sun.misc.Hashing.stringHash32((String) k);</code>来获取索引值</p><p>最后，通过一系列无符号右移操作，来把高位与低位进行异或操作，来降低冲突发生的几率</p></blockquote><p>右移的偏移量20，12，7，4是怎么来的呢？因为Java中对象的哈希值都是32位的，所以这几个数应该就是把高位与低位做异或运算，至于这几个数是如何选取的，就不清楚了，网上搜了半天也没统一且让人信服的说法，大家可以参考下面几个链接：</p><ul><li><a href="http://stackoverflow.com/questions/7922019/openjdks-rehashing-mechanism/7922219#7922219" target="_blank" rel="noopener">http://stackoverflow.com/questions/7922019/openjdks-rehashing-mechanism/7922219#7922219</a></li><li><a href="http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function/9336103#9336103" target="_blank" rel="noopener">http://stackoverflow.com/questions/9335169/understanding-strange-java-hash-function/9336103#9336103</a></li><li><a href="http://stackoverflow.com/questions/14453163/can-anybody-explain-how-java-design-hashmaps-hash-function/14479945#14479945" target="_blank" rel="noopener">http://stackoverflow.com/questions/14453163/can-anybody-explain-how-java-design-hashmaps-hash-function/14479945#14479945</a></li></ul><h3 id="HashMap-Entry"><a href="#HashMap-Entry" class="headerlink" title="HashMap.Entry"></a>HashMap.Entry</h3><p>HashMap中存放的是HashMap.Entry对象，它继承自Map.Entry，其比较重要的是构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// setter, getter, equals, toString 方法省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用key的hash值与上value的hash值作为Entry的hash值</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">     * overwritten by an invocation of put(k,v) for a key k that's already</span></span><br><span class="line"><span class="comment">     * in the HashMap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">     * removed from the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Entry实现了单向链表的功能，用<code>next</code>成员变量来级连起来。</p><p>介绍完Entry对象，下面要说一个比较重要的成员变量<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">//HashMap内部维护了一个为数组类型的<span class="meta">Entry</span>变量table，用来保存添加进来的<span class="meta">Entry</span>对象</span><br><span class="line"><span class="symbol">transient</span> <span class="meta">Entry</span>&lt;K,V&gt;[] table = (<span class="meta">Entry</span>&lt;K,V&gt;[]) EMPTY_TABLE<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>你也许会疑问，Entry不是单向链表嘛，怎么这里又需要个数组类型的table呢？<br>我翻了下之前的算法书，其实这是解决冲突的一个方式：<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining" target="_blank" rel="noopener">链地址法（开散列法）</a>，效果如下：</p><p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2rlT0eVXXXXazXpXXXXXXXXXX_!!581166664.gif" alt="链地址法处理冲突得到的散列表"><br></center><br>就是相同索引值的Entry，会以单向链表的形式存在</p><h4 id="链地址法的可视化"><a href="#链地址法的可视化" class="headerlink" title="链地址法的可视化"></a>链地址法的可视化</h4><p>网上找到个很好的网站，用来可视化各种常见的算法，很棒。瞬间觉得国外大学比国内的强不知多少倍。<br>下面的链接可以模仿哈希表采用链地址法解决冲突，大家可以自己去玩玩😊</p><ul><li><a href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/OpenHash.html</a></li></ul><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>get操作相比put操作简单，所以先介绍get操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//单独处理key为null的情况</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//key为null的Entry用于放在table[0]中，但是在table[0]冲突链中的Entry的key不一定为null</span></span><br><span class="line">    <span class="comment">//所以需要遍历冲突链，查找key是否存在</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">//首先定位到索引在table中的位置</span></span><br><span class="line">    <span class="comment">//然后遍历冲突链，查找key是否存在</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put操作（含update操作）"><a href="#put操作（含update操作）" class="headerlink" title="put操作（含update操作）"></a>put操作（含update操作）</h3><p>因为put操作有可能需要对HashMap进行resize，所以实现略复杂些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//辅助函数，用于填充HashMap到指定的capacity</span></span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">//threshold为resize的阈值，超过后HashMap会进行resize，内容的entry会进行rehash</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//这里的循环是关键</span></span><br><span class="line">    <span class="comment">//当新增的key所对应的索引i，对应table[i]中已经有值时，进入循环体</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//判断是否存在本次插入的key，如果存在用本次的value替换之前oldValue，相当于update操作</span></span><br><span class="line">        <span class="comment">//并返回之前的oldValue</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果本次新增key之前不存在于HashMap中，modCount加1，说明结构改变了</span></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果增加一个元素会后，HashMap的大小超过阈值，需要resize</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//增加的幅度是之前的1倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先得到该索引处的冲突链Entries，第一次插入bucketIndex位置时冲突链为null，也就是e为null</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//然后把新的Entry添加到冲突链的开头，也就是说，后插入的反而在前面（第一次还真没看明白）</span></span><br><span class="line">    <span class="comment">//table[bucketIndex]为新加入的Entry，是bucketIndex位置的冲突链的第一个元素</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面看看HashMap是如何进行resize，庐山真面目就要揭晓了😊</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//如果已经达到最大容量，那么就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//initHashSeedAsNeeded(newCapacity)的返回值决定了是否需要重新计算Entry的hash值</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历当前的table，将里面的元素添加到新的newTable中</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            <span class="comment">//最后这两句用了与put放过相同的技巧</span></span><br><span class="line">            <span class="comment">//将后插入的反而在前面</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the hashing mask value. We defer initialization until we</span></span><br><span class="line"><span class="comment"> * really need it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="comment">//这里说明了，在hashSeed不为0或满足useAltHash时，会重算Entry的hash值</span></span><br><span class="line">    <span class="comment">//至于useAltHashing的作用可以参考下面的链接</span></span><br><span class="line">    <span class="comment">// http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap</span></span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">    <span class="comment">//可以看到删除的key如果存在，就返回其所对应的value</span></span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//这里用了两个Entry对象，相当于两个指针，为的是防治冲突链发生断裂的情况</span></span><br><span class="line">    <span class="comment">//这里的思路就是一般的单向链表的删除思路</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当table[i]中存在冲突链时，开始遍历里面的元素</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e) <span class="comment">//当冲突链只有一个Entry时</span></span><br><span class="line">                table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到现在为止，HashMap的增删改查都介绍完了。<br>一般而言，认为HashMap的这四种操作时间复杂度为O(1)，因为它hash函数性质较好，保证了冲突发生的几率较小。</p></blockquote><h3 id="fast-fail的HashIterator"><a href="#fast-fail的HashIterator" class="headerlink" title="fast-fail的HashIterator"></a>fast-fail的HashIterator</h3><p>集合类用<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">Iterator</a>类来遍历其包含的元素，<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener">接口Enumeration</a>已经不推荐使用。相比Enumeration，Iterator有下面两个优势：</p><ol><li>Iterator允许调用者在遍历集合类时删除集合类中包含的元素（相比Enumeration增加了remove方法）</li><li>比Enumeration的命名更简短</li></ol><p>HashMap中提供的三种集合视角，底层都是用HashIterator实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    <span class="comment">//在初始化Iterator实例时，纪录下当前的修改次数</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;   <span class="comment">// For fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">// current slot</span></span><br><span class="line">    Entry&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            Entry[] t = table;</span><br><span class="line">            <span class="comment">//遍历HashMap的table，依次查找元素</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在访问下一个Entry时，判断是否有其他线程有对集合的修改</span></span><br><span class="line">        <span class="comment">//说明HashMap是线程非安全的</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        Entry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry[] t = table;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">        current = e;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        Object k = current.key;</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry().getKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>介绍到这里，基本上算是把HashMap中一些核心的点讲完了，但还有个比较严重的问题：保存Entry的table数组为transient的，也就是说在进行序列化时，并不会包含该成员，这是为什么呢？<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Entry<span class="variable">&lt;K,V&gt;</span>[] <span class="built_in">table</span> = (Entry<span class="variable">&lt;K,V&gt;</span>[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure></p><p>为了解答这个问题，我们需要明确下面事实：</p><ul><li>Object.hashCode方法对于一个类的两个实例返回的是不同的哈希值</li></ul><p>我们可以试想下面的场景：</p><blockquote><p>我们在机器A上算出对象A的哈希值与索引，然后把它插入到HashMap中，然后把该HashMap序列化后，在机器B上重新算对象的哈希值与索引，这与机器A上算出的是不一样的，所以我们在机器B上get对象A时，会得到错误的结果。</p><p>所以说，当序列化一个HashMap对象时，保存Entry的table是不需要序列化进来的，因为它在另一台机器上是错误的。</p></blockquote><p>因为这个原因，HashMap重写了<code>writeObject</code>与<code>readObject</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out number of buckets</span></span><br><span class="line">    <span class="keyword">if</span> (table==EMPTY_TABLE) &#123;</span><br><span class="line">        s.writeInt(roundUpToPowerOf2(threshold));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       s.writeInt(table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;K,V&gt; e : entrySet0()) &#123;</span><br><span class="line">            s.writeObject(e.getKey());</span><br><span class="line">            s.writeObject(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set other fields that need values</span></span><br><span class="line">    table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in number of buckets</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read number of mappings</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt();</span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                           mappings);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity chosen by number of mappings and desired load (if &gt;= 0.25)</span></span><br><span class="line">    <span class="keyword">int</span> capacity = (<span class="keyword">int</span>) Math.min(</span><br><span class="line">                mappings * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</span><br><span class="line">                <span class="comment">// we have limits...</span></span><br><span class="line">                HashMap.MAXIMUM_CAPACITY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate the bucket array;</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inflateTable(capacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        threshold = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();  <span class="comment">// Give subclass a chance to do its thing.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">        K key = (K) s.readObject();</span><br><span class="line">        V value = (V) s.readObject();</span><br><span class="line">        putForCreate(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="keyword">null</span> == key ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Look for preexisting entry for key.  This will never happen for</span></span><br><span class="line"><span class="comment">     * clone or deserialize.  It will only happen for construction if the</span></span><br><span class="line"><span class="comment">     * input Map is a sorted map whose ordering is inconsistent w/ equals.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，在序列化时，针对Entry的key与value分别单独序列化，当反序列化时，再单独处理即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在总结完HashMap后，发现这里面一些核心的东西，像哈希表的冲突解决，都是算法课上学到，不过由于“年代久远”，已经忘得差不多了，我觉得忘</p><ul><li>一方面是由于时间久不用</li><li>另一方面是由于本身没理解好</li></ul><p>平时多去思考，这样在遇到一些性能问题时也好排查。</p><p>还有一点就是我们在分析某些具体类或方法时，不要花太多时间一些细枝末节的边界条件上，这样很得不偿失，倒不是说这么边界条件不重要，程序的bug往往就是边界条件没考虑周全导致的。<br>只是说我们可以在理解了这个类或方法的总体思路后，再来分析这些边界条件。<br>如果一开始就分析，那真是丈二和尚——摸不着头脑了，随着对它工作原理的加深，才有可能理解这些边界条件的场景。</p><p>今天到此为止，下次打算分析<a href="/blog/2015/09/04/java-treemap/">TreeMap</a>。<del>Stay Tuned！🍺</del>。我已经写完了，两篇文章对比看，效果更好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://supercoderz.in/understanding-transient-variables-in-java-and-how-they-are-practically-used-in-hashmap/" target="_blank" rel="noopener">http://supercoderz.in/understanding-transient-variables-in-java-and-how-they-are-practically-used-in-hashmap/</a></li><li><a href="http://stackoverflow.com/questions/9144472/why-is-the-hash-table-of-hashmap-marked-as-transient-although-the-class-is-seria" target="_blank" rel="noopener">http://stackoverflow.com/questions/9144472/why-is-the-hash-table-of-hashmap-marked-as-transient-although-the-class-is-seria</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继上一篇文章&lt;a href=&quot;/blog/2015/09/01/java-collection-overview&quot;&gt;Java集合框架综述&lt;/a&gt;后，今天正式开始分析具体集合类的代码，首先以既熟悉又陌生的&lt;a href=&quot;http://docs.oracle.com/java
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架综述</title>
    <link href="http://liujiacai.net/blog/2015/09/01/java-collection-overview/"/>
    <id>http://liujiacai.net/blog/2015/09/01/java-collection-overview/</id>
    <published>2015-09-01T13:18:05.000Z</published>
    <updated>2019-12-24T10:59:14.601Z</updated>
    
    <content type="html"><![CDATA[<p>最近被陆陆续续问了几遍HashMap的实现，回答的不好，打算复习复习JDK中的<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/collections/overview.html" target="_blank" rel="noopener">集合框架</a>，并尝试分析其源码，这么做一方面是这些类非常实用，掌握其实现能更好的优化我们的程序；另一方面是学习借鉴JDK是如何实现了这么一套优雅高效的类库，提升编程能力。</p><p>在介绍具体适合类之前，本篇文章对Java中的集合框架做一个大致描述，从一个高的角度俯视这个框架，了解了这个框架的一些理念与约定，会大大帮助后面分析某个具体类，让我们开始吧。</p><h2 id="集合框架（collections-framework）"><a href="#集合框架（collections-framework）" class="headerlink" title="集合框架（collections framework）"></a>集合框架（collections framework）</h2><p>首先要明确，集合代表了一组对象（和数组一样，但数组长度不能变，而集合能）。Java中的集合框架定义了一套规范，用来表示、操作集合，使具体操作与实现细节解耦。</p><p>其实说白了，可以把一个集合看成一个微型数据库，操作不外乎“增删改查”四种操作，我们在学习使用一个具体的集合类时，需要把这四个操作的<code>时空复杂度</code>弄清楚了，基本上就可以说掌握这个类了。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>主要理念用一句话概括就是：提供一套“小而美”的API。API需要对程序员友好，增加新功能时能让程序员们快速上手。<br>为了保证核心接口足够小，最顶层的接口（也就是Collection与Map接口）并不会区分该集合是否可变（mutability）,是否可更改（modifiability）,是否可改变大小（resizability）这些细微的差别。相反，一些操作是可选的，在实现时抛出<code>UnsupportedOperationException</code>即可表示集合不支持该操作。集合的实现者必须在文档中声明那些操作是不支持的。</p><p>为了保证最顶层的核心接口足够小，它们只能包含下面情况下的方法：</p><ol><li>基本操作，像之前说的“增删改查”</li><li>There is a compelling performance reason why an important implementation would want to override it.</li></ol><p>此外，所有的集合类都必须能提供友好的交互操作，这包括没有继承<code>Collection</code>类的数组对象。因此，框架提供一套方法，让集合类与数组可以相互转化，并且可以把<code>Map</code>看作成集合。</p><h2 id="两大基类Collection与Map"><a href="#两大基类Collection与Map" class="headerlink" title="两大基类Collection与Map"></a>两大基类Collection与Map</h2><p>在集合框架的类继承体系中，最顶层有两个接口：</p><ul><li><code>Collection</code>表示一组纯数据</li><li><code>Map</code>表示一组key-value对</li></ul><p>一般继承自<code>Collection</code>或<code>Map</code>的集合类，会提供两个“标准”的构造函数：</p><ul><li>没有参数的构造函数，创建一个空的集合类</li><li>有一个类型与基类（<code>Collection</code>或<code>Map</code>）相同的构造函数，创建一个与给定参数具有相同元素的新集合类</li></ul><p>因为接口中不能包含构造函数，所以上面这两个构造函数的约定并不是强制性的，但是在目前的集合框架中，所有继承自<code>Collection</code>或<code>Map</code>的子类都遵循这一约定。</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB21HYoeVXXXXaLXXXXXXXXXXXX_!!581166664.jpeg" alt="java-collection-hierarchy"></p><p>如上图所示，<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html" target="_blank" rel="noopener">Collection</a>类主要有三个接口：</p><ul><li><code>Set</code>表示不允许有重复元素的集合（A collection that contains no duplicate elements）</li><li><code>List</code>表示允许有重复元素的集合（An ordered collection (also known as a sequence)）</li><li><code>Queue</code> JDK1.5新增，与上面两个集合类主要是的区分在于<code>Queue</code>主要用于存储数据，而不是处理数据。（A collection designed for holding elements prior to processing.）</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2JzW7eVXXXXbRXpXXXXXXXXXX_!!581166664.jpg" alt="MapClassHierarchy"></p><p><a href="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html" target="_blank" rel="noopener">Map</a>并不是一个真正意义上的集合（are not true collections），但是这个接口提供了三种“集合视角”（collection views ），使得可以像操作集合一样操作它们，具体如下：</p><ul><li>把map的内容看作key的集合（map’s contents to be viewed as a set of keys）</li><li>把map的内容看作value的集合（map’s contents to be viewed as a collection of values）</li><li>把map的内容看作key-value映射的集合（map’s contents to be viewed as a set of key-value mappings）</li></ul><h2 id="集合的实现（Collection-Implementations）"><a href="#集合的实现（Collection-Implementations）" class="headerlink" title="集合的实现（Collection Implementations）"></a>集合的实现（Collection Implementations）</h2><p>实现集合接口的类一般遵循<code>&lt;实现方式&gt;+&lt;接口&gt;</code>的命名方式，通用的集合实现类如下表：</p><table><thead><tr><th style="text-align:center">Interface</th><th style="text-align:center">Hash Table</th><th style="text-align:center">Resizable Array</th><th style="text-align:center">Balanced Tree</th><th style="text-align:center">Linked List</th><th style="text-align:center">Hash Table + Linked List</th></tr></thead><tbody><tr><td style="text-align:center">Set</td><td style="text-align:center">HashSet</td><td style="text-align:center">&nbsp;</td><td style="text-align:center">TreeSet</td><td style="text-align:center">&nbsp;</td><td style="text-align:center">LinkedHashSet</td></tr><tr><td style="text-align:center">List</td><td style="text-align:center">&nbsp;</td><td style="text-align:center">ArrayList</td><td style="text-align:center">&nbsp;</td><td style="text-align:center">LinkedList</td><td style="text-align:center">&nbsp;</td></tr><tr><td style="text-align:center">Deque</td><td style="text-align:center">&nbsp;</td><td style="text-align:center">ArrayDeque</td><td style="text-align:center">&nbsp;</td><td style="text-align:center">LinkedList</td><td style="text-align:center">&nbsp;</td></tr><tr><td style="text-align:center">Map</td><td style="text-align:center"><a href="/blog/2015/09/03/java-hashmap/">HashMap</a></td><td style="text-align:center">&nbsp;</td><td style="text-align:center"><a href="/blog/2015/09/04/java-treemap/">TreeMap</a></td><td style="text-align:center">&nbsp;</td><td style="text-align:center"><a href="/blog/2015/09/12/java-linkedhashmap/">LinkedHashMap</a></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天先开个头，后面会陆陆续续来一系列干货，Stay Tuned。</p><p>需要说明一点，今后所有源码分析都将基于<a href="http://www.oracle.com/technetwork/java/javase/7u71-relnotes-2296187.html" target="_blank" rel="noopener">Oracle JDK 1.7.0_71</a>，请知悉。</p><pre><code>$ java -versionjava version &quot;1.7.0_71&quot;Java(TM) SE Runtime Environment (build 1.7.0_71-b14)Java HotSpot(TM) 64-Bit Server VM (build 24.71-b01, mixed mode)</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/collections/overview.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/technotes/guides/collections/overview.html</a></li><li><a href="https://en.wikipedia.org/wiki/Java_collections_framework" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Java_collections_framework</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近被陆陆续续问了几遍HashMap的实现，回答的不好，打算复习复习JDK中的&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/guides/collections/overview.html&quot; target=&quot;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SICP 第一章总结</title>
    <link href="http://liujiacai.net/blog/2015/07/18/sicp-chapter1-summary/"/>
    <id>http://liujiacai.net/blog/2015/07/18/sicp-chapter1-summary/</id>
    <published>2015-07-18T04:51:44.000Z</published>
    <updated>2019-12-24T10:59:14.600Z</updated>
    
    <content type="html"><![CDATA[<p>最近两个月除了工作之外，业余时间一直在研习sicp这本经典书。关于这本书的讨论有<a href="https://www.google.com/?gws_rd=ssl#newwindow=1&amp;safe=active&amp;q=must+read+book+sicp" target="_blank" rel="noopener">很多</a>，像老赵写过SICP的<a href="http://blog.zhaojie.me/2009/07/recommended-reading-2-sicp.html" target="_blank" rel="noopener">书托</a>，我觉得与其讨论这本书有没有读的价值，不如花上些，随手翻翻，如果感兴趣，就读下去；否则直接忽略即可。计算机理论发展到了现在，有<a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read" target="_blank" rel="noopener">太多太多经典</a>需要我们去读了，恐怕我们这一辈子都无法读完，为什么不找你感兴趣的来读呢？</p><p>我这次建了个<a href="https://github.com/jiacai2050/sicp" target="_blank" rel="noopener">Github库</a>来记录课后每一道习题与平时的所感所悟，希望对后面阅读sicp的同胞们有所帮助。</p><p>废话不多说了，趁着上周刚看完第一章，现在进行一下总结。</p><h2 id="本章主旨–构造过程抽象"><a href="#本章主旨–构造过程抽象" class="headerlink" title="本章主旨–构造过程抽象"></a>本章主旨–构造过程抽象</h2><p>我们在进行程序设计时，接触到的无非就是两类东西：<code>数据</code>与<code>操作数据的过程</code>。本章只处理简单的数值数据，将注意力集中在过程的构造。本书采用lisp方言scheme进行教学，之所以选择lisp，是因为：</p><blockquote><p>计算过程的lisp描述（称为过程）本身又可以作为lisp的数据来表示和操作。</p></blockquote><p>现在许多威力强大的程序设计技术，都依赖于填平在“被动的”数据和“主动的”过程之间的传统划分。鉴于lisp可以将过程作为数据进行处理的灵活性，使它成为探索这些技术最方便的现存语言之一。</p><h2 id="程序设计的基本要素"><a href="#程序设计的基本要素" class="headerlink" title="程序设计的基本要素"></a>程序设计的基本要素</h2><p>一个强有力的编程语言，应该提供下面三种机制，编程者利用它们来组织自己有关计算过程的思想：</p><ol><li>基本表达式形式</li><li>组合机制</li><li>抽象机制</li></ol><p>scheme使用前缀表示法，这和我们平常的编程语言不一样，需要适应。</p><p>本小节依此讲解了下面知识：</p><ul><li>基本的表达式，环境和变量</li><li>组合式的求值</li><li>过程的定义</li><li>复合过程求值的替换模型（应用序与正则序）</li><li>条件表达式和谓词</li><li>过程抽象</li></ul><p>概念本身比较简单，我们需要明确下面几个点：</p><ol><li>表达式求值过程就是表达式语义的实现</li><li>代换模型给出了过程定义和过程应用的一种语义<blockquote><p>很多 Scheme 过程的行为可以用这个模型描述<br>后面会看到,更复杂的过程需要用扩充的语义模型（像一些语法糖衣）</p></blockquote></li><li>代换模型只是为了帮助直观理解过程应用的行为<blockquote><p>它并没有反映解释器的实际工作过程<br>实际解释器的情况后面讨论，基于环境实现  </p></blockquote></li><li>本课程要研究解释器工作过程的一组模型<blockquote><p>代换模型最简单,容易理解,但不足以解释所有的实际程序<br>其局限性是不能解释带有可变数据的程序<br>后面将介绍更精细的模型</p></blockquote></li></ol><p>无论是 C 还是 Scheme,都没规定运算对象的求值顺序。这意味着 假定它们采用某种特殊顺序都是不正确且不可靠的。所以我们不要写只有按特定求值顺序才能得到所需结果的表达式!<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//C 语言里依赖于求值顺序的表达式，这里的输出依赖于编译器的实现，与语言本身无关</span><br><span class="line">m = <span class="built_in">n</span>++ + ++<span class="built_in">n</span>;</span><br><span class="line">printf(<span class="string">"%d, %d"</span>, <span class="built_in">n</span>, <span class="built_in">n</span>++);</span><br></pre></td></tr></table></figure></p><p>本小节以牛顿法求平方根展示了如何通过简单的过程构造复杂的过程。关于牛顿法的代码及优化方案我<a href="https://github.com/jiacai2050/sicp/blob/master/05/2015-05-19.md" target="_blank" rel="noopener">git笔记</a>中找到。</p><h2 id="过程与它们所产生的问题"><a href="#过程与它们所产生的问题" class="headerlink" title="过程与它们所产生的问题"></a>过程与它们所产生的问题</h2><p>本小节主要讲解了下面几个概念：</p><ul><li>过程的内部定义与块结构（上面的牛顿法我已经使用）</li><li>分析过程（静态、动态）产生的计算过程（动态，行为）</li><li>计算过程的类型<blockquote><p>线性递归<br>线性迭代<br>树形递归</p></blockquote></li><li>计算的代价</li></ul><p>本小节主要是熟悉过程，知道常见过程的分类，以及能够明确各种过程所占用的资源。</p><p>这里有意思的是<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/01/1.19.md" target="_blank" rel="noopener">习题1.19</a>，通过矩阵相乘的方式来算斐波那契数，大家可以去了解下。</p><p>###找零钱</p><p>关于这个题目我在git库上的笔记已经有了比较详细的介绍，这里不再赘述。</p><ul><li><a href="https://github.com/jiacai2050/sicp/blob/master/05/2015-05-21-count-change-recurisve.md" target="_blank" rel="noopener">题目描述与递归的解法</a></li><li><a href="https://github.com/jiacai2050/sicp/blob/master/05/2015-05-24-count-change-iterative.md" target="_blank" rel="noopener">迭代解法的讨论</a></li><li>时空复杂度分析可参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/01/1.14.md" target="_blank" rel="noopener">习题1.14</a></li></ul><h3 id="求素数"><a href="#求素数" class="headerlink" title="求素数"></a>求素数</h3><p>这里求素数有两种解法，分别是：</p><ol><li>寻找因子，代码参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/01/1.22.scm" target="_blank" rel="noopener">习题1.22</a></li><li>费马检查，代码参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/01/1.24.scm" target="_blank" rel="noopener">习题1.24</a></li></ol><p>这里比较有意思的是<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/01/1.28.scm" target="_blank" rel="noopener">习题1.28</a>，这道题介绍了一种费马检测的不会被欺骗的变形，称为Miller-Rabin检查。<br>到现在我还不知道为什么MR检查不会被欺骗，感觉应该是和费马定量等价的，无非就是等式两边同时除以了a而已。后面想明白后，我会再即时更新。</p><p>除了上面两个外，本章还用了下面两个例子：</p><ul><li><a href="https://github.com/jiacai2050/sicp/blob/master/05/2015-05-28.md" target="_blank" rel="noopener">求幂</a></li><li>最大公约数<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">definee</span> (<span class="name"><span class="builtin-name">gcd</span></span> a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> b <span class="number">0</span>)</span><br><span class="line">    a</span><br><span class="line">    (<span class="name"><span class="builtin-name">gcd</span></span> b (<span class="name"><span class="builtin-name">remainder</span></span> a b))))</span><br></pre></td></tr></table></figure></li></ul><h2 id="用高阶函数过抽象"><a href="#用高阶函数过抽象" class="headerlink" title="用高阶函数过抽象"></a>用高阶函数过抽象</h2><p>这一小节可算是第一章的重点，在这小节里，过程既可以作为参数传给过程，又可以作为过程的返回值，通过不断抽象，得到一系列高阶过程，前面的牛顿法，<a href="https://github.com/jiacai2050/sicp/blob/master/07/2015-07-06.md" target="_blank" rel="noopener">不定点</a>都可以轻松用高阶过程来实现。</p><p>这里主要是做相应的习题来巩固自己的理解，如果你是第一次接触高阶函数，我相信你一定会大喊：“还能这么玩呀”!</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过2个月的时间陆陆续续把这第一章看完，现在过了2周再来写这篇总结，效果还是蛮好的，很多东西一下就能够回想起来，不过也发现之前的漏洞，一些点当时没深究，放下了也就没有然后了。这次总结发现了些，这个周末一定补充上。</p><p>如果你也在读sicp，希望你能坚持下去，让我们一起享受编程的奥妙。</p><p>PS：在写这篇总结时，在简书上我找到这么一篇文章<a href="http://www.jianshu.com/p/fe89c4b6bd28" target="_blank" rel="noopener">仍距遥远，知易行难</a>，不知该作者的功力有多深厚才能有这么深的见解。<br>世界这么大， 让我们抓紧从SICP开始行动起来吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近两个月除了工作之外，业余时间一直在研习sicp这本经典书。关于这本书的讨论有&lt;a href=&quot;https://www.google.com/?gws_rd=ssl#newwindow=1&amp;amp;safe=active&amp;amp;q=must+read+book+sicp
      
    
    </summary>
    
      <category term="研习经典" scheme="http://liujiacai.net/categories/%E7%A0%94%E4%B9%A0%E7%BB%8F%E5%85%B8/"/>
    
    
      <category term="sicp" scheme="http://liujiacai.net/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>回顾来有赞的这三个月</title>
    <link href="http://liujiacai.net/blog/2015/07/11/review-3-month-life-in-youzan/"/>
    <id>http://liujiacai.net/blog/2015/07/11/review-3-month-life-in-youzan/</id>
    <published>2015-07-11T06:36:17.000Z</published>
    <updated>2019-12-24T10:59:14.600Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写博客了，上一篇还是写在三个月前，当时应该是在有赞客满毕业后，现在转正也将近半个多月了。本来想的是每个月至少一篇原创技术文章的，没想到坚持还没一年就“食言”了。</p><h2 id="时间都去哪了"><a href="#时间都去哪了" class="headerlink" title="时间都去哪了"></a>时间都去哪了</h2><p><div></div></p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=28126661&auto=0&height=66"></iframe><br><br>没坚持写博客最直接也最根本的原因就是：懒。</p><p>最近几天杭州有<a href="http://nb.ifeng.com/zjxw/detail_2015_07/10/4093975_0.shtml" target="_blank" rel="noopener">台风登陆</a>，周六不用去公司了，公司领导层也决定今后实行双休，我今天也趁此机会好好反思一下最近三个月做的事情，看看时间都去哪了。</p><h2 id="回顾反思"><a href="#回顾反思" class="headerlink" title="回顾反思"></a>回顾反思</h2><h3 id="忙工作"><a href="#忙工作" class="headerlink" title="忙工作"></a>忙工作</h3><p>新到一家公司，从熟悉业务到最终能够干活，成本还是不小的，尤其是一家创业型公司，一般都是身兼数职，而且我自身定位一开始也不是很清晰，有种忙这忙那的感觉，最后的成果不是很大。用得到知识基本上还是在ucloud学的，翻翻之前的日报（公司要求新人写日报的效果还是大大有益的，最起码我现在回顾的时候有据可循），觉得下面这些东西算是新学到的：</p><ol><li>通过调研hadoop streaming任务慢，学习strace命令查看进程到底在做什么。</li><li>为了开发hive服务，学习hive权限验证，可以具体到某个表。</li><li>为优化hive任务，学习研究hiveQL如何转为mapreduce，尝试explain 一些语句。</li><li>为了搭建日志收集系统，学习flume使用方式，不过到目前为止也还是没用的。</li><li>日常Hadoop维护，这个包含的东西比较杂乱，因为一个分布式的环境，出了一个问题，可能的原因实在是太多了，从服务本身的问题到机器的问题。其次就是编写各种shell脚本，说实话到现在我觉得写shell也不是十分得心应手，对于一些命令如sed、awk、ps、iftop、find、date等还只是简单的入门级别，写一个脚本有时需要较多的时间。</li><li>熟悉python</li></ol><p>最近日报不怎么写了，开始写半周报。现在想想一天能干的事好有限，我最近早上醒来的时候，会想一下：我到底想要什么？我的人生目标是什么？今天我该如何去做才能离目标越来越近？张爱玲好像有句话：“出名要趁早”，我不知道是不是我太急功近利了，以至于乱了手脚。我一直能想着为Hadoop社区贡献patch，但是我觉得现在我对他的了解，和之前也差不多，三个月的时间，在这方面貌似只是原地打转。记得之前看过耗子叔写的文章，说他在职业生涯早期通过不断面试来提高自己，我也效仿了下，现在还记得当时人家问我，我回答的不好的问题：</p><ol><li>你在日常运维Hadoop时，出现过哪些问题？如何解决的？现在系统的瓶颈是什么？如何解决？</li><li>在运行Hadoop任务时，如何出行某些问题特别慢？你会如何排查问题？</li><li>有没有遇到过这样的场景：当正在上传一个文件到hdfs上时，另一个程序开始读这个文件，这时会有什么问题？</li><li>hdfs文件是怎么存储的？有没有用过Arvo？</li></ol><p>对于前两个问题，应该属于考察解决问题的思路的，看看你在遇到问题时，能不能保持大脑清晰，有个清晰的方案来排查解决问题。当时我回答道，CPU是系统瓶颈，IO不是，但是当人家在顺着问下去时，我就不能够很好的回答了。其实这个问题就说明了我分析问题的能力不够，遇到问题后没有打破沙锅问到底的精神，经常性就不了了之了。想想前两天出现的resourcemanager假死的情况，我好像也是没什么定论。<br>第三个问题应该算是看看Hadoop使用经验丰富与否，是否处理过一些不太正常的情况。<br>最后一个问题应该算是对Hadoop生态系统的考察，也可以说是系统架构的考虑。说实话这个我是真不清楚，之前Hadoop集群只是搭着玩玩，从来没想过如何一个集群保证一年7*24不间断正常运行，如何发挥系统的最佳性能，经过这个问题还是有帮助，最起码现在开始考虑如何处理小文件问题？以什么格式存储文件，文本、二进制还是压缩格式？集群在什么情况下可能崩溃？</p><h3 id="SICP"><a href="#SICP" class="headerlink" title="SICP"></a><a href="https://github.com/jiacai2050/sicp" target="_blank" rel="noopener">SICP</a></h3><p>当时我能来有赞，也是因为这本书。花了两个月时间算是把第一章给结束了。想想工作之余能够把这本书坚持下来，确实没想的那么简单，这次我们组内四个人，成立了个小组，周末能够讨论上几次，习题一道道过，遇到一些可以扩展的知识点，我们也是尽量发散思维，比如讲找零钱问题，我们扯到了动态规划、尾递归优化、过程执行轨迹的可视化等等，为了找出找零钱的迭代算法，我们讨论了好几次，正好这个周五把第一章所有内容＋习题都过完一遍了，我会抽时间把第一章的内容在总结次，到时候再好好说说找零钱问题，这里就不细说了。</p><p>我们这个学习小组看完第一章也是磕磕绊绊，中间还停了两周，刚开始几小节还可以，后来逐渐聚不齐了，要不就是谁有事或者工作忙，总之就是没能够进行下去，想想我今年年初的目标，看完三本书，这样算下来，能够完完整整的把SICP看完，也是不容易了。</p><p>后面再接再厉，把进度顶上去。</p><h3 id="亲情、友情、爱情"><a href="#亲情、友情、爱情" class="headerlink" title="亲情、友情、爱情"></a>亲情、友情、爱情</h3><p>这三个月家里发生的事也是蛮多的，五一的时候我姐姐结婚了。怎么说呢，觉得自从上中学后，和姐姐的交流就不多了，我们之间从来没问过各自的理想。姐姐大学毕业后，考过了老师、公务员、事业编，结果也不怎么顺利，一直在家里和我爸爸一起干，开了个淘宝店，最近年逼婚问题也是愈演愈烈，我记得妈妈给我说过姐姐因为这个还哭过，作为一个没什么经验的我，完全不能理解姐姐的心情。这次结婚了，算是对大家最好的交代，端午那天我姐生了个小男孩，在我看来好快，刚结婚没几个月就有小孩了，不过这也好，感觉一下子把好几年要干的事一下解决了。希望我姐姐等家庭稳定后再好好考，以我姐的实力，考个高中老师，绝对没有问题。</p><p>至于我自己，我也只能说是随缘了，感情这东西，太深奥。想想现在的处境，也确实不适合找，有个老同学还能谈谈，要是说从头开始的，我觉得就别浪费大家的时间了。这东西也挺耽误时间的，在看网上一些暖文的时候，也挺像有个人能一起谈人生、谈理想，一起奋斗的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>革命尚未胜利，同志仍需努力。</p><p>我觉得现在的问题一方面是把零碎时间利用好，不要小看这些时间，想想有时候看个10分钟视频，刷会微博，再因为某某好玩的东西，东点点西看看的，时间就这么溜走了。</p><p>另一方面就是控制好自己欲望，什么事情都不是一步就能够成功的，慢慢来，稳扎稳打，夯实基础。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没写博客了，上一篇还是写在三个月前，当时应该是在有赞客满毕业后，现在转正也将近半个多月了。本来想的是每个月至少一篇原创技术文章的，没想到坚持还没一年就“食言”了。&lt;/p&gt;
&lt;h2 id=&quot;时间都去哪了&quot;&gt;&lt;a href=&quot;#时间都去哪了&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>我来有赞了</title>
    <link href="http://liujiacai.net/blog/2015/04/03/leave-ucloud-to-youzan/"/>
    <id>http://liujiacai.net/blog/2015/04/03/leave-ucloud-to-youzan/</id>
    <published>2015-04-03T15:10:49.000Z</published>
    <updated>2019-12-24T10:59:14.600Z</updated>
    
    <content type="html"><![CDATA[<p>今天晚上终于有时间来写写博客了，想想决定从ucloud离职到现在，差不多一个多月了。关于离职的原因，一句话两句话也说不清楚，离职这事也纠结了好久，正好顺着年后跳槽高峰期，从上海跳到了美丽大杭州。</p><p>跳槽是件折腾的事。从投简历，再到搬家，都是耗时耗力的事。找合适的工作，真是好比找个女朋友，两方都看顺眼才行。不过，我觉得，还是比较幸运的，找到了<a href="http://youzan.com/" target="_blank" rel="noopener">有赞</a>——一家做<code>微电商</code>的创业公司。</p><p>##客满轮岗<br>有赞的新人需要在客满（客户满意部，也就是客服）轮岗，目的很明确——熟悉业务。轮岗时间为两周，在这期间，学到的电商知识真是太多太多，什么B2C了，O2O了，我也能张口即来了。当然，熟悉这些名词只是第一步，我觉得更重要的是对现在电商生态的分析，大家估计也都很清楚，现在想在淘宝开店有多难，刷单这早是过时的行为了，效果好的还是通过购买广告位，争取在商品搜索页面的第一页就能出现。</p><p>客满结束有个ppt分享，我是用 <a href="https://github.com/impress/impress.js/" target="_blank" rel="noopener">impress.js</a> 做的，<a href="http://youzan.liujiacai.net/" target="_blank" rel="noopener">在线地址</a>，大家感兴趣可以参考。<br>下面我将简单说说最近两周内收获到的东西。</p><p>###微商<br>其实大家不难发现，淘宝、京东之类的电商平台的短板，就是它能够展现的店家、商品是有限的，不管你再怎么设计，一个页面能够承载的信息量是一定的，记得之前在北京听过<a href="http://102.alibaba.com/competition/etao.htm" target="_blank" rel="noopener">阿里搜索引擎专场</a>的分享，当时就说到了，淘宝现在搜索的痛点，不是什么个性化搜索，而是如何在有限的页面里尽可能多的展示店铺、商品。<br>那么如何展示更多的店铺、商品呢？如果只限于淘宝这一个点，可以说目前是无解的（如果，你能想到，马上联系马云吧），究其原因，就是因为淘宝是个中心，所有的店铺、商品都需要经由淘宝这个平台来呈现，所以一个简单的解决方式，把这个中心点拿掉，这样不就解决这个问题了嘛。<br>但是如果没有淘宝这个统一入口了，顾客怎么买东西呢？在提出这个问题的时候，我们的问题从“<strong>如何在有限的页面布局中尽可能多的展现店铺、商品？</strong>”转化到“<strong>如何在没有平台的前提下，提供一种方式，让顾客能够快速找到自己想要的商品？</strong>”，白鸦在“逛”创业失败后，也遇到了这个问题，微信的崛起让白鸦看到了解决这个问题办法——微商。</p><p>###去中心化</p><p>微商现在没有一个统一定义，是伴随着微信而崛起的一种<code>社交化移动社交电商</code>，不过微信只是微商的一种载体，其他的社交平台，像微博、人人都可以。微商与传统电商的区别是：</p><pre><code>传统电商以商品为中心，微商则是以人为中心。</code></pre><p>传统电商就以淘宝为例，在淘宝购物的大致流程为：</p><blockquote><p>输入商品关键字–&gt;多角度比较（价格、销量、评论）–&gt;下单</p></blockquote><p>当然，你也可能是通过别人分享的链接去购买的，但我觉得这种购买方式相比于上面的可以忽略不计。这里可以顺便插一句，为什么淘宝把像蘑菇街、美丽说之类的导购网站给封杀了？原因其实很简单：</p><blockquote><p>如果淘宝大部分顾客是通过第三分导购网站过来了，对淘宝有两个威胁：一是淘宝的广告位对商家来说不是很有竞争力了；二是如果那天这些导购网站不把链接指向淘宝了，那淘宝不就被架空了嘛。</p></blockquote><p>所以淘宝在很早的时候就掐断了来自第三方导购网站的链接。</p><p>回到正题，因为<code>淘宝需要提供广告位，所以就必须以商品为中心</code>。以商品为中心，就意味着需要个统一的入口，让顾客可以进行商品搜索，而这又会导致出现“<strong>如何在有限的页面布局中尽可能多的展现店铺、商品？</strong>”这个问题。</p><p>以人为中心就不一样了。首先，我们知道人都有群体性，都是需要朋友的。我们通过朋友介绍，购买商品往往也是比较放心的，尤其是朋友是某方面的高手时。我相信，如果你身边有个懂电脑的朋友，你买电脑时，一定会参考他的意见。</p><p>朋友之间有下面两个特征：</p><ol><li>信任度高、黏性强</li><li>有共同的喜好</li></ol><p>如果把社交结合到购物上，就是现在的“微商”了。想想为什么淘宝会入股新浪微博，目的不正是如此嘛。</p><p>不过相对于微信，微博的黏性不够，因为大部分人在微博上只有很少的关注，只有大V才有可能有一大批脑残粉。相比之下，腾讯的微信，完胜，这也从侧面应证了腾讯在社交方面的强势。随着公众号的推出，使每个人都可能成为中心。比如，你很懂电脑，并且开了个订阅号，天天推送电脑方面的维修知识，相信肯定能在你的社交圈内成为个中心。</p><p>每个人都有自己的特长，也就意味着每个人都有可能成为自己社交圈中某一方面的中心。如果把这一特点放到电商上，不正好解决了去中心化问题嘛，而且还有可能顺便解决假货问题。说明一下，解决假货问题不是说没有假货了，而是说，顾客能够区分出真货假货了，因为在中国大环境内，假货还是很有必要的。</p><p>微商就是借助于微信这个平台，解决了中心化问题，但是同时也引入了新的问题：</p><ol><li>刷屏，相信大家都很反感这个。如果你的朋友圈内天天都是商品推广链接，那你的朋友很有可能就把你屏蔽了。其实这个问题属于营销，就是说如何经营你的朋友（潜在顾客，微信粉丝）。</li><li>囤货，这是开店首要的。如果你买手机，手上没有个几十部，你怎么开店，但是囤货需要大量资金，大部分人是无法承担的。</li></ol><p>这时候就需要有赞了。</p><h3 id="有赞"><a href="#有赞" class="headerlink" title="有赞"></a>有赞</h3><p>有赞前名口袋通，目标是为微电商提供完整的解决方案。下面重点说说有赞是如何解决上面两个问题的：</p><ol><li>有赞与微信打通，提供基于微信粉丝的管理后台。粉丝经验不再是广告投放，需要服务、需要互动，顾客面对的不再是一个品牌商标，而是某个销售员。</li><li>通过引入<a href="http://fx.youzan.com/" target="_blank" rel="noopener">分销平台</a>，解决货源问题</li></ol><p>此外，有赞还免费的提供CRM系统、服务商平台，解决开店难问题。下图给出一个我理解的有赞产品架构，不一定准确，仅供参考。</p><center><br>    <img src="http://img02.taobaocdn.com/imgextra/i2/581166664/TB2u20XcpXXXXcPXXXXXXXXXXXX_!!581166664.png" alt="有赞产品架构"><br></center><p>我是从“商家－商品－顾客”的角度来把各个产品串联起来的。从上图右侧可以看出，商品的流传主要靠的是顾客口碑相传。</p><p>其实仅仅通过上图的描述，并不能看出有赞的优势来，别人完全可以复制出来。在客满期间，一些创始人也给我们分析了有赞的生态，我觉得这块理解的不好，这里就不写了，今后有了更深入的理解再补上。<br>iDoNews上有篇文章，大家可以参考：<a href="http://www.donews.com/idonews/article/5449.shtm" target="_blank" rel="noopener">以“有赞”为例，谈谈免费模式背后的微商经济</a></p><p>##新的起点</p><p>从今年开始决定换工作，到现在客满两周结束，也算是完成了一次转变。这期间说实话，没怎么看书、写程序。早先计划着手gooreplacer的Safari版的，也一直被搁置了；一些jvm、sed的博文素材也没老整理，现在业务也熟悉完了，下面该继续做技术了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天晚上终于有时间来写写博客了，想想决定从ucloud离职到现在，差不多一个多月了。关于离职的原因，一句话两句话也说不清楚，离职这事也纠结了好久，正好顺着年后跳槽高峰期，从上海跳到了美丽大杭州。&lt;/p&gt;
&lt;p&gt;跳槽是件折腾的事。从投简历，再到搬家，都是耗时耗力的事。找合适的
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript中的数据类型</title>
    <link href="http://liujiacai.net/blog/2015/02/24/javascript-datatype/"/>
    <id>http://liujiacai.net/blog/2015/02/24/javascript-datatype/</id>
    <published>2015-02-24T13:09:45.000Z</published>
    <updated>2019-12-24T10:59:14.599Z</updated>
    
    <content type="html"><![CDATA[<p>学一门编程语言，无非两方面：一是语法，二是数据类型。类C语言的语法不外乎if、while、for、函数、算术运算等，面向对象的语言再加上object。<br>语法只是语言设计者预先做的一套规则，不同语言语法不尽相同，但都有一些共通点，对于熟悉一两门编程语言的人，学其他的编程语言时，语法往往不是问题（当然，如果你一直学的是类C语言，那么首次接触lisp时肯定也要花些时间），学习的重点往往是数据类型及其相关操作上，不是有句老话：“数据结构＋算法＝程序”！其次，有些语言的语法本身就存在设计问题（javascript更甚），我们没必要深究这些点，当然，如果你自诩geek，可以把玩把玩。</p><p>本文将对javascript中的数据类型做一个详尽的介绍。</p><h2 id="弱类型-vs-强类型"><a href="#弱类型-vs-强类型" class="headerlink" title="弱类型 vs 强类型"></a>弱类型 vs 强类型</h2><p>鉴于javascript的<a href="/blog/2015/02/01/javascript-oop/#设计理念">设计理念</a>，javascript被设计成一种弱类型的语言。<br>说到这里，难免要说一下，弱类型与强类型的区别。<br>一些人会误以为这两者的差别就是“强类型的语言在声明一个变量时需要指明它的类型，而弱类型的则不用”。其实这种观点是错误的。比如下面这个Java代码片段：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">String s</span> = <span class="string">"hello"</span>;</span><br><span class="line"><span class="attribute">int l</span> = s.getBytes().length;</span><br></pre></td></tr></table></figure></p><p>编译器是怎么知道<code>.length</code>是合法的表达式呢？这是因为编译器知道<code>s</code>的数据类型为<code>String</code>，当调用<code>String</code>的<code>getBytes</code>方法时，返回值的数据类型为<code>byte[]</code>，所以<code>.length</code>是合法的表达式。<br>这两者真正的区别是：  </p><blockquote><p>在强类型的语言，每个表达式的类型都能够在编译时确定，并且只允许适用于该类型的操作；<br>弱类型的语言允许对任意类型施加任何操作，只是这个操作有可能在运行时报错。</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>根据<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8" target="_blank" rel="noopener">ECMAScript 5.1</a>的规范，javascript中共有六种数据类型，分别为：<code>Undefined</code>, <code>Null</code>, <code>Boolean</code>, <code>Number</code>, <code>String</code>、<code>Object</code>。前五种属于基本类型，最后一种属于对象类型。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li><code>Undefined</code>类型只有一个值，为<code>undefined</code>，意味着“空值(no value)”，适用于所有数据类型。</li><li><code>Null</code>类型只有一个值，为<code>null</code>，意味着“空对象(no object)”，只适用于对象类型。</li><li><code>Boolean</code>类型有两个值，为<code>true</code>与<code>false</code></li><li><code>Number</code>类型的值是遵循IEEE 754标准的64位浮点数的集合，类似于Java的double。没有整型数据结构。此外还包含三个特殊的值：<code>NaN</code>、<code>Infinity</code>、<code>-Infinity</code></li><li><code>String</code>类型的值是有穷个Unicode字符的集合。必须用<code>&#39;</code>或<code>&quot;</code>括起来。</li></ul><h4 id="基本类型的string与对象类型的string区别"><a href="#基本类型的string与对象类型的string区别" class="headerlink" title="基本类型的string与对象类型的string区别"></a>基本类型的string与对象类型的string区别</h4><p>在javascript是区分基本类型的string与对象类型的string（Number、Boolean与之类似）。</p><ul><li>使用字面量方式创建的字符串，为基本类型的string</li><li>使用<code>String()</code>创建的字符串，为基本类型的string</li><li>使用<code>new String()</code>的方式创建的字符串，为对象类型的string<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">str1 </span>= <span class="string">"javascript"</span></span><br><span class="line"><span class="keyword">str2 </span>= <span class="keyword">String("javascript")</span></span><br><span class="line"><span class="keyword">str3 </span>= new <span class="keyword">String("javascript")</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">&gt; </span>typeof <span class="keyword">str1</span></span><br><span class="line"><span class="keyword">"string"</span></span><br><span class="line"><span class="keyword">&gt; </span>typeof <span class="keyword">str2</span></span><br><span class="line"><span class="keyword">"string"</span></span><br><span class="line"><span class="keyword">&gt; </span>typeof <span class="keyword">str3</span></span><br><span class="line"><span class="keyword">"object"</span></span><br></pre></td></tr></table></figure></li></ul><p>javascript会在合适的时候自动把基本类型的string转为对象类型的string，也就是说我们可以对基本类型string使用<code>String.prototype</code>中的方法。这两者也可以进行显式转化。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型-----&gt;对象类型</span><br><span class="line"><span class="keyword">str1 </span>= <span class="string">"javascript"</span></span><br><span class="line"><span class="keyword">str1 </span>= new <span class="keyword">String(str1)</span></span><br><span class="line"><span class="keyword">&gt; </span>typeof <span class="keyword">str1</span></span><br><span class="line"><span class="keyword">"object"</span></span><br><span class="line"><span class="keyword">// </span>对象类型-----&gt;基本类型</span><br><span class="line"><span class="keyword">str1 </span>= new <span class="keyword">String("javascript")</span></span><br><span class="line"><span class="keyword">str1 </span>= <span class="keyword">str1.valueOf()</span></span><br><span class="line"><span class="keyword">&gt; </span>typeof <span class="keyword">str1</span></span><br><span class="line"><span class="keyword">"string"</span></span><br></pre></td></tr></table></figure></p><p>这两者用在<code>eval</code>函数中时，结果有所区别：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'2 + 2'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'2 + 2'</span>);</span><br><span class="line">&gt; <span class="built_in">eval</span>(s1)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt; <span class="built_in">eval</span>(s2)</span><br><span class="line">[<span class="built_in">String</span>: <span class="string">'2 + 2'</span>]   <span class="comment">//这里还是返回的string对象</span></span><br></pre></td></tr></table></figure></p><h4 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h4><p><code>null</code>与<code>undefined</code>都表示“没有值(non-value)”的概念，如果严格区分：</p><ul><li><code>null</code>表示空</li><li><code>undefined</code>表示不存在。没有初始化的变量、函数中缺失的参数、函数没有显式return值时都为此值</li></ul><p>在其他语言中，一般只用一个null来表示空值，javascript中为什么多了个undefined呢？这是历史原因造成的：</p><blockquote><p>javascript采用了Java的语法，把类型分为了基本类型与对象类型，Java中用null来表示空对象，javascript想当然的继承了过来；在C语言中，null在转为数字时为0，javascript也采取同样的方式：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt;</span> <span class="string">Number(null)</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">&gt;</span> <span class="number">5</span> <span class="string">+</span> <span class="literal">null</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在javascript1.0时，还没有异常处理(exception handling)，对于一些异常情况（没有初始化的变量、调用函数时缺失的参数等），需要标明为一种特殊的值，<code>null</code>本来是个很好的选择，但是Brendan Eich同时想避免下面两件事：</p><ul><li>这个特殊值不应该有引用的特性，因为那是对象特有的</li><li>这个特殊值不应该能转为0，因为这样不容易发现程序中的错误</li></ul></blockquote><blockquote><p>基于这两个原因，Brendan Eich选择了<code>undefined</code>，它可以被强转为<code>NaN</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Number</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line">&gt; <span class="number">5</span> + <span class="literal">undefined</span></span><br><span class="line"><span class="literal">NaN</span></span><br></pre></td></tr></table></figure></p></blockquote><p>两者在于JSON对象打交道时，结果也迥然不同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">JSON</span>.parse(<span class="literal">null</span>)</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">&gt; <span class="built_in">JSON</span>.parse(<span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">//Firfox SyntaxError: JSON.parse: unexpected character at line 1 column 1 of the JSON data</span></span><br><span class="line"><span class="comment">//Chrome SyntaxError: Unexpected token u</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">JSON</span>.stringify(<span class="literal">null</span>)</span><br><span class="line"><span class="string">"null"</span></span><br><span class="line">&gt; <span class="built_in">JSON</span>.stringify(<span class="literal">undefined</span>)</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>javascript作为一门<a href="http://en.wikipedia.org/wiki/Scripting_language" target="_blank" rel="noopener">脚本语言</a>，本身功能十分精简，很多功能（文件读写、网络等）都是由宿主环境提供。宿主环境与javascript语言的桥梁是对象，宿主环境通过提供一系列符合javascript语法的对象，提供各种各样的功能。</p><p>在<a href="/blog/2015/02/01/javascript-oop">javascript面向对象编程</a>这篇文章（如果你不知道prototype是什么，强烈建议看看这篇文章）里，我多次强调了<code>对象在javascript中就是一系列的键值对</code>，就像Java中的HashMap一样，不过，javascript中对象的属性可以有一些描述符(property descriptor)，这在HashMap中是没有的。</p><h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>属性描述符分为两类：</p><ul><li>数据描述符(data descriptor)，包含一系列boolean值，用以说明该属性是否允许修改、删除。</li><li>访问描述符(accessor descriptor)，包含get与set函数。</li></ul><p>这两种描述符都是对象，它们都拥有下面两个boolean属性：</p><ul><li>configurable 用以指定该描述符是否允许修改、删除。默认为false。</li><li>enumerable 用以指定在遍历对象（使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener">for…in循环</a>或<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener">Object.keys方法</a>）的属性时，是否访问该属性。默认为false。</li></ul><p>除了上面这两个共有属性外，数据描述符还有下面两个属性：</p><ul><li>value 用以指定该属性的值，默认为undefined</li><li>writable 用以指定该属性的值是否允许改变该属性的值，默认为false</li></ul><p>访问描述符还有下面两个属性：</p><ul><li>get 用以指定访问该属性时的访问器(getter，本质是个函数)，该访问器的返回值为该属性的值。默认为undefined</li><li>set 用以指定访问该属性时的赋值器(setter，本质是个函数)，该赋值器的接受一个参数。默认为undefined</li></ul><p>我们可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a>来设置对象的属性描述符。例如：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using __proto__</span></span><br><span class="line">Object.defineProperty(obj, <span class="string">'key'</span>, &#123;</span><br><span class="line">  __proto__: <span class="literal">null</span>, <span class="comment">// no inherited properties</span></span><br><span class="line">  <span class="keyword">value</span>: <span class="string">'static'</span>  <span class="comment">// not enumerable</span></span><br><span class="line">                   <span class="comment">// not configurable</span></span><br><span class="line">                   <span class="comment">// not writable</span></span><br><span class="line">                   <span class="comment">// as defaults</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>通过上面这个例子可以看出，描述符具有继承的特点，我们这里显式的把描述符对象的<code>__proto__</code>设为<code>null</code>，就避免了从<code>Object.prototype</code>中继承相应属性。当然我们也可以显式地设置描述符的所有属性：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">being</span> <span class="string">explicit</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,</span> <span class="string">'key'</span><span class="string">,</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">enumerable:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">  <span class="attr">configurable:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">  <span class="attr">writable:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">'static'</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure></p><p>这样的效果和第一段代码的效果是一样的。</p><p>下面再举一个访问描述符的例子：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of an object property added with defineProperty with an accessor property descriptor</span></span><br><span class="line"><span class="keyword">var</span> bValue = <span class="number">38</span>;</span><br><span class="line">Object.defineProperty(obj, <span class="string">'key'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bValue; &#125;,</span><br><span class="line">  <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span> </span>&#123; bValue = newValue; &#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，不能混淆了访问描述器与数据描述器。下面这样写是错误的：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You cannot try to mix both:</span></span><br><span class="line">Object.defineProperty(obj, <span class="string">'conflict'</span>, &#123;</span><br><span class="line">  value: <span class="number">0x9f91102</span>,</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0xdeadbeef</span>; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// throws a TypeError: property descriptors must not specify a value</span></span><br><span class="line"><span class="comment">// or be writable when a getter or setter has been specified</span></span><br></pre></td></tr></table></figure></p><p>##typeof</p><p>如果想在运行时获知某变量的类型，可以使用typeof操作符。typeof的返回值如下表：</p><center><br><img src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB2WufjbVXXXXX1XpXXXXXXXXXX_!!581166664.png" alt="typeof-values"><br></center><p>其中有一处需要注意，那就是<code>typeof null == &quot;object&quot;</code>，按照<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.2" target="_blank" rel="noopener">ECMAScript 5.1</a>标准，<code>Null</code>类型应该是个基本类型，为什么这里返回<code>object</code>呢？原因是这样的：</p><blockquote><p>在javascript 1.0中，javascript中的值是用一个类型标志（type tag）和一个实际值这样的结构表示的，对象的类型标志为0，null在C语言中表示NULL指针（0x00），所以null的类型标志就为0了。</p></blockquote><p>##参考</p><ul><li><a href="http://speakingjs.com/es5/ch08.html#undefined_null" target="_blank" rel="noopener">《Speaking JavaScript》 Chapter 8. Values</a></li><li><a href="http://javascript.crockford.com/survey.html" target="_blank" rel="noopener">A Survey of the JavaScript Programming Language</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noopener">Standard built-in objects String</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">typeof</a></li><li><a href="http://www.2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener">The history of “typeof null”</a> （需翻墙）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学一门编程语言，无非两方面：一是语法，二是数据类型。类C语言的语法不外乎if、while、for、函数、算术运算等，面向对象的语言再加上object。&lt;br&gt;语法只是语言设计者预先做的一套规则，不同语言语法不尽相同，但都有一些共通点，对于熟悉一两门编程语言的人，学其他的编程
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="JavaScript" scheme="http://liujiacai.net/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript中的面向对象编程</title>
    <link href="http://liujiacai.net/blog/2015/02/01/javascript-oop/"/>
    <id>http://liujiacai.net/blog/2015/02/01/javascript-oop/</id>
    <published>2015-02-01T04:53:18.000Z</published>
    <updated>2019-12-24T10:59:14.599Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作一直在用nodejs做开发，有了nodejs，前端、后端、脚本全都可以用javascript搞定，很是方便。但是javascript的很多语法，比如对象，就和我们常用的面向对象(object oriented programming)的编程语言不同；看某个javascript开源项目，也经常会看到使用this关键字，而这个this关键字在javascript中因上下文不同而意义不同；还有让人奇怪的原型链。这些零零碎碎的东西加起来就很容易让人不知所措，所以，有必要对javascript这门语言进行一下深入了解。</p><p>我这篇文章主要想说说如何在javascript中进行面向对象的编程，同时会讲一些javascript这门语言在设计之初的理念。下面让我们开始吧。<br>首先强调一下，我们现在广泛使用的javascript都是遵循了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources" target="_blank" rel="noopener">ECMAScript 5.1</a>标准的，正在制定中的版本为6.0，这个版本变化很大，增加了很多新的语法与函数，大家可以去<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="noopener">Mozilla Developer Network</a>上查看。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>javascript1.0 最初是由网景公司的<a href="http://en.wikipedia.org/wiki/Brendan_Eich" target="_blank" rel="noopener">Brendan Eich</a>在1995年5月花了<a href="http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.pdf" target="_blank" rel="noopener">十天搞出来的</a>，Eich的目标是设计出一种即轻量又强大的语言，所以Eich充分借鉴了其他编程语言的特性，比如Java的语法(syntax)、Scheme的函数(function)、Self的原型继承(prototypal inheritance)、Perl的正则表达式等。<br>其中值得一提的是，为什么继承借鉴了Self语言的原型机制而不是Java的类机制？首先我们要知道：</p><ul><li>Self的原型机制是靠运行时的语义</li><li>Java的类机制是靠编译时的类语法</li></ul><p>Javascript1.0的功能相对简单，为了在今后不断丰富javascript本身功能的同时保持旧代码的兼容性，javascript通过改变运行时的支持来增加新功能，而不是通过修改javascript的语法，这就保证了旧代码的兼容性。这也就是javascript选择基于运行时的原型机制的原因。<br>wikipedia这样描述到：JavaScript is classified as a <a href="http://en.wikipedia.org/wiki/Prototype-based_programming" target="_blank" rel="noopener">prototype-based</a> scripting language with <a href="http://en.wikipedia.org/wiki/Dynamic_language" target="_blank" rel="noopener">dynamic typing</a> and <a href="http://en.wikipedia.org/wiki/First-class_functions" target="_blank" rel="noopener">first-class functions</a>。这些特性使得javascript是一种<a href="http://en.wikipedia.org/wiki/Multi-paradigm" target="_blank" rel="noopener">多范式</a>的<a href="http://en.wikipedia.org/wiki/Interpreter_%28computing%29" target="_blank" rel="noopener">解释性</a>编程语言，支持<a href="http://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">面向对象</a>,<a href="http://en.wikipedia.org/wiki/Imperative_programming" target="_blank" rel="noopener">命令式(imperative)</a>, <a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">函数式(functional)</a>编程风格。</p><p>##对象<br>在javascript中，除了<code>Undefined</code>, <code>Null</code>, <code>Boolean</code>, <code>Number</code>, <code>String</code>这几个简单类型外，其他的都是对象。<br>数字、字符串、布尔值这些简单类型都是不可变量，对象是可变的键值对的集合(mutable keyed conllections)，对象包括数组<code>Array</code>、正则表达式<code>RegExp</code>、函数<code>Function</code>，当然对象<code>Object</code>也是对象。<br>对象在javascript中说白了就是<code>一系列的键值对</code>。键可以是任意字符串，包括空串；值可以是任何值。在javascript中是没有类的概念(class-free)的，但是它有一个原型链(prototype linkage)。javascript对象通过这个链来实现继承关系。</p><p>javascript中有一些<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">预定义对象</a>，像是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">Object</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">Function</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">Date</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number" target="_blank" rel="noopener">Number</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noopener">String</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array</a>等。</p><p>###字面量(literal)<br>javascript中的每种类型的对象都可以采用<code>字面量(literal)</code>的方式创建。<br>对于Object对象，可以使用<code>对象字面量(Object literal)</code>来创建，例如：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty_object = &#123;&#125;;<span class="comment">//创建了一个空对象</span></span><br><span class="line"><span class="comment">//创建了一个有两个属性的对象</span></span><br><span class="line"><span class="keyword">var</span> stooge = &#123;</span><br><span class="line">    <span class="string">"first-name"</span>: <span class="string">"Jerome"</span>,</span><br><span class="line">    <span class="string">"last-name"</span>: <span class="string">"Howard"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当然，也可以用<code>new Object()</code>或<code>Object.create()</code>的方式来创建对象。<br>对于<code>Function</code>、<code>Array</code>对象都有其相应的字面量形式，后面会讲到，这里不再赘述。</p><p>###原型链(prototype linkage)<br>javascript中的每个对象都隐式含有一个<code>[[prototype]]</code>属性，这是ECMAScript中的记法，目前各大浏览器厂商在实现自己的javascript解释器时，采用的记法是<code>__proto__</code>，也就是说每个对象都隐式包含一个<code>__proto__</code>属性。举个例子：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">foo</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">x:</span> <span class="number">10</span><span class="string">,</span></span><br><span class="line">    <span class="attr">y:</span> <span class="number">20</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure></p><p>foo这个对象在内存中的存储结构大致是这样的：</p><center><br><br><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2vFhwbVXXXXc7XpXXXXXXXXXX_!!581166664.png" alt="basic-object"><br></center><p>当有多个对象时，通过<code>__proto__</code>属性就能够形成一条原型链。看下面的例子：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    x: <span class="number">10</span>,</span><br><span class="line">    calculate: <span class="function"><span class="keyword">function</span> <span class="params">(z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y + z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    y: <span class="number">20</span>,</span><br><span class="line">    __proto__: a</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">    y: <span class="number">30</span>,</span><br><span class="line">    __proto__: a</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// call the inherited method</span></span><br><span class="line">b.calculate(<span class="number">30</span>); <span class="comment">// 60</span></span><br><span class="line">c.calculate(<span class="number">40</span>); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure></p><p>上面的代码在声明对象b、c时，指明了它们的原型为对象a（a的原型默认指向Object.prototype，Object.prototype这个对象的原型指向null），这几个对象在内存中的结构大致是这样的：</p><center><br><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2RwVEbVXXXXaCXpXXXXXXXXXX_!!581166664.png" alt="prototype-chain"><br></center><p>这里需要说明一点，<code>__proto__</code>不是ECMAScript的规定，而是由于在javascript早期，ECMAScript没有明确的说明如何访问一个对象的原型，所以各大实现商采用了约定俗成的<code>__proto__</code>记法。<br>在ECMAScript 3.1及以后的版本中，为内置对象<code>Object</code>添加了访问设置、对象原型的方法：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener">getPropertyOf()</a>，用于获取对象的原型</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">create()</a>，在创建对象时设置对象的原型。</li></ul><p>####__proto__ vs prototype<br>除了我们这里说的<code>__proto__</code>属性，相信大家平常更常见的是<code>prototype</code>属性。比如，Date对象中没有加几天的函数，那么我们可以这么做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.addDays = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setDate(<span class="keyword">this</span>.getDate() + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么所有通过<code>new Date()</code>得到的对象就拥有<code>addDays</code>方法了（后面讲解继承是会解释原因）。那么<code>__proto__</code>属性与<code>prototype</code>属性有什么区别呢？</p><blockquote><p>javascript的每个对象都有<code>__proto__</code>属性，但是只有<code>函数对象</code>有<code>prototype</code>属性。</p></blockquote><p>那么在函数对象中， 这两个属性的有什么区别呢？</p><ol><li><code>__proto__</code>表示该函数对象的原型</li><li><code>prototype</code>表示使用new来执行该函数时（这种函数一般成为构造函数，后面会讲解），新创建的对象的原型。例如：<pre><code>var d = new Date();d.__proto__ === Date.prototype; //这里为trueDate.__proto__ === Object.__proto__  //这里为true</code></pre></li></ol><p>看到这里，希望大家能够理解这两个属性的区别了。</p><p>####instanceof</p><p>instanceof在javascript中是个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords" target="_blank" rel="noopener">关键字</a>，用法如下：</p><pre><code>obj instanceof constructorFunction</code></pre><p>用于检测<code>constructorFunction.prototype</code>对象是否在<code>obj</code>的<code>原型链</code>中。<br>如果我们自己实现类似于<code>instanceof</code>的函数，可以这么做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">obj, constructorFunction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj === constructorFunction.prototype)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        obj = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面看一个使用<code>instanceof</code>的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mycar = <span class="keyword">new</span> Car(<span class="string">"Honda"</span>, <span class="string">"Accord"</span>, <span class="number">1998</span>);</span><br><span class="line">mycar <span class="keyword">instanceof</span> Car;    <span class="comment">// true，因为mycar.__proto__ === Car.prototype</span></span><br><span class="line">mycar <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true，因为mycar.__proto__.__proto__ === Object.prototype</span></span><br></pre></td></tr></table></figure></p><p>在javascript，原型和函数是最重要的两个概念，上面说完了原型，下面说说函数对象。</p><p>###函数对象Function</p><p>首先，函数在javascript中无非也是个对象，可以作为value赋值给某个变量，唯一不同的是函数能够被执行。</p><ul><li>使用对象字面量方式创建的对象的<code>__proto__</code>属性指向<code>Object.prototype</code>(<code>Object.prototype</code>的<code>__proto__</code>属性指向<code>null</code>)；</li><li>使用函数字面量创建的对象的<code>__proto__</code>属性指向<code>Function.prototype</code>(<code>Function.prototype</code>对象的<code>__proto__</code>属性指向<code>Object.prototype</code>)。<br>函数对象除了<code>__proto__</code>这个隐式属性外，还有两个隐式的属性：</li></ul><ol><li>函数的上下文(function’s context)</li><li>实现函数的代码(the code that implements the function’s behavior)</li></ol><p>和对象字面量一样，我们可以使用<code>函数字面量(function literal)</code>来创建函数。类似于下面的方式：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字面量方式创建一个函数，并赋值给add变量</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">add</span> = <span class="function"><span class="keyword">function</span> <span class="params">(a, b)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    return a + b;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br></pre></td></tr></table></figure></p><p>一个函数字面量有四个部分：</p><ol><li>function关键字，必选项。</li><li>函数名，可选项。上面的示例中就省略了函数名。</li><li>由圆括号括起来的一系列参数，必选项。</li><li>由花括号括起来的一系列语句，必选项。该函数执行时将会执行这些语句。</li></ol><p>####函数调用与this<br>一个函数在被调用时，除了声明的参数外，还会隐式传递两个额外的参数：<code>this</code>与<code>arguments</code>。<br>this在OOP中很重要，this的值随着调用方式的不同而不同。javascript中共有四种调用方式：</p><ol><li>method invocation pattern。当函数作为某对象一个属性调用时，this指向这个对象。this赋值过程发生在函数调用时（也就是运行时），这叫做late binding</li><li><p>function invocation pattern。当函数不作为属性调用时，this指向全局对象（这里的全局对象依宿舍环境而异，在浏览器中，是window对象），这是个设计上的错误，正确的话，内部函数的this应该指向外部函数。可以通过在函数中定义一个变量来解决这个问题。</p><pre><code>var add = function(a, b) {return a+b;}var obj = {    value: 3,    double: function() {        var self = this;//把this赋值给了self        this.value = add(self.value, self.value);    }}obj.double(); //obj.value现在为6</code></pre></li><li><p>construct invocation pattern。javascript是一门原型继承语言，这也就意味着对象可以直接从其他对象中继承属性，没有类的概念。这和java中的继承不一样。但是javascript提供了一种类似与java创建对象的语法。当一个函数用new来调用时，this指向新创建的对象。这时的函数通常称为构造函数。</p></li><li>apply invocation pattern。使用函数对象的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">apply方法</a>来执行时，this指向apply的第一个参数。</li></ol><p>除了this外，函数在调用是额外传入的另一个参数是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">arguments</a>。它是函数内部的一个变量，包含函数调用处的所有参数，甚至包含函数定义时没有的参数。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">sum</span> = <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    var i, <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arguments.<span class="built_in">length</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sum</span> += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sum</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>); <span class="comment">// 108</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，这里的arguments不是一个数组，它只是一个有length属性的类数组对象(Array-like)，它并不拥有数组的其他方法。<br>关于对象，最后说一下数组，javascript中的数组和平常编程中的数组不大一样。</p><p>###数组对象Array<br>数组是一种在内存中线性分配的数据结构，通过下标计算出元素偏移量，从而取出元素。数组应该是一个快速存取的数据结构，但是在javascript中，数组不具备这种特性。<br>数组在javascript中一个具有传统数组特性的对象，这种对象能够把数组下标转为字符串，然后把这个字符串作为对象的key，最后对取出对应该key的value（这又一次说明了对象在javascript中就是一系列键值对）。</p><p>虽然javascript中的数组没有传统语言中的数组那么快，但是由于javascript是弱类型的语言，所以javascript中的数组可以存放任何值。此外Array有很多实用的方法，大家可以去<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">MDN Array</a>查看。<br>javascript也为数组提供了很方便的<code>字面量(Array Literal)</code>定义方式：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>通过数组字面量创建的数组对象的<code>__proto__</code>指向Array.prototype。</p><p>##继承Inheritance</p><p>在Java中，对象是某个类的实例，一个类可以从另一个类中继承。但是在基于原型链的javascript中，对象可以直接从另一个对象创建。</p><p>在上面讲解对象时，我们知道了在创建一个对象时，该对象会自动赋予一个<code>__proto__</code>属性，使用对象<code>字面量(Literal)</code>来创建对象时，javascript解释器自动为<code>__proto__</code>赋值。当我们在javascript使用new操作符创建对象时，javascript解释器在调用构造函数时，会执行类似于下面的语句<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.__proto__ = &#123;<span class="keyword">constructor</span>: <span class="keyword">this</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>新创建的对象都会有一个<code>__proto__</code>属性，这个属性有一个<code>constructor</code>属性，并且这个属性指向这个新对象。举个例子：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = new Date()</span><br><span class="line">d.__proto__<span class="function">.<span class="keyword">constructor</span> === <span class="title">Date</span> <span class="comment">//这里为true</span></span></span><br></pre></td></tr></table></figure></p><p>如果new不是一个操作符，而是一个函数的话，它的实现类似于下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.new =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new object that inherits from the constructor's prototype.</span></span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</span><br><span class="line">    <span class="comment">// Invoke the constructor, binding –this- to the new object.</span></span><br><span class="line">    <span class="keyword">var</span> other = <span class="keyword">this</span>.apply(that, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// If its return value isn't an object, substitute the new object.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> other === <span class="string">'object'</span> &amp;&amp; other) || that;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>之前也说了，基于原型的继承机制是根据运行时的语义决定的，这就给我们提供了很大的便利。比如，我们想为所有的Array添加一个map函数，那么我们可以这么做：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span></span>(f) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Arr</span> = [];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Arr</span>.push(f(<span class="built_in">this</span>[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Arr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为所有的数组对象的<code>__proto__</code>都指向Array.prototype对象，所以我们为这个对象增加方法，那么所有的数组对象就都拥有了这个方法。<br>javascript解释器会顺着原型链查看某个方法或属性。如果想查看某对象的是否有某个属性，可以使用<code>Object.prototype.hasOwnProperty</code>方法。</p><p>##总结</p><p>通过上面多次讲解，希望大家对<code>对象在javascript中就是一系列的键值对</code>、<code>原型</code>与<code>函数</code>这三个概念有更加深刻的认识，使用javascript来写前端、后端与脚本。在<a href="http://conf.reactjs.com/" target="_blank" rel="noopener">React.js 2015大会</a>上，Facebook公布了即将开源的<a href="https://github.com/facebook/react" target="_blank" rel="noopener">React Native</a>，这意味着今后我们可以用javascript来写IOS、Android的原生应用了，这可真是<code>learn-once, write-anywhere</code>。相信随着ECMAScript 6的发布，javascript这门语言还会有一系列翻天覆地的变化，Stay Tuned。:-)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" target="_blank" rel="noopener">JavaScript. The core</a></li><li><a href="http://book.douban.com/subject/2994925/" target="_blank" rel="noopener">Javascript: The Good Parts</a></li><li>JQuery作者的 <a href="http://ejohn.org/blog/objectgetprototypeof/" target="_blank" rel="noopener">Object.getPrototypeOf</a></li><li>JS 之父的 <a href="https://brendaneich.com/2011/06/new-javascript-engine-module-owner/" target="_blank" rel="noopener">New JavaScript Engine Module Owner</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近工作一直在用nodejs做开发，有了nodejs，前端、后端、脚本全都可以用javascript搞定，很是方便。但是javascript的很多语法，比如对象，就和我们常用的面向对象(object oriented programming)的编程语言不同；看某个javas
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="mozilla" scheme="http://liujiacai.net/tags/mozilla/"/>
    
      <category term="JavaScript" scheme="http://liujiacai.net/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>2014 年终总结</title>
    <link href="http://liujiacai.net/blog/2014/12/29/review-2014/"/>
    <id>http://liujiacai.net/blog/2014/12/29/review-2014/</id>
    <published>2014-12-29T14:06:16.000Z</published>
    <updated>2019-12-24T10:59:14.599Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉间，又到一年尾，想想自己这正式工作也有大半年了，加上之前的实习，也算是有一年半多“工作经验”的人了。在今年的六月份，大学也划上了圆满的句号，还记得当初大一刚去学校报道时的一个标语——“今天我以烟大为荣，明天烟大以我为荣”，我肯定是不达标了。</p><p>“年年岁岁花相似，岁岁年年人不同。”这首诗我记得每年的寒假作业上都会有吧。想想这一年经历，很多事，酸甜苦辣，应有尽有。下面简单整理下，不仅仅是为了记住这些事，更重要的是能够在这些事中吸取经验，克服自身的缺点。</p><h2 id="再见，北京（2014-1～2014-3）"><a href="#再见，北京（2014-1～2014-3）" class="headerlink" title="再见，北京（2014.1～2014.3）"></a>再见，北京（2014.1～2014.3）</h2><p>年初时，我还在果壳网实习，这份实习从13年暑假开始，我还记得是和刘晓丽一起坐着火车去的，当时觉得出来了就要混出个样子，没想到我干了不到一年就呵呵了。在果壳网的实习收获主要有两点：</p><ol><li>学习clojure，接触函数式编程</li><li>完成<a href="https://github.com/jiacai2050/hebo" target="_blank" rel="noopener">hebo项目</a></li></ol><p>其实当初找工作想法挺简单的，能有个地方安心的学习就够了，果壳应该算是完成了我这个初衷，果壳的工作氛围比较松，加班的情况很少，当然也可能是因为我是实习生，没接触生产环境。是<a href="http://cn.linkedin.com/pub/%E6%98%8E%E7%90%86-%E8%8B%91/0/1a1/153/zh-cn" target="_blank" rel="noopener">明理</a>把我招进去，我当时在果壳话比较少，没怎么和明理深入交流，想想也挺遗憾的。<br>离职应该是在3月25号，当时租房子的中介跑了，房东来赶我们，想想一起住的几个人，行色匆匆，到现在也不知道人家叫什么。每个在北京漂过的人都应该知道一个人是什么滋味。<br>当时也去参加过阿里校招，被刷，投简历，被刷。在北京这么个名校云集的地方，烟大的，有些自卑。所以我给自己找了个借口——我要考研。辞职后，回家看书考研去了。</p><h2 id="考研之路（2014-4～2014-5）"><a href="#考研之路（2014-4～2014-5）" class="headerlink" title="考研之路（2014.4～2014.5）"></a>考研之路（2014.4～2014.5）</h2><p>从北京回家，想着从头开始，但是往往事与愿违。刚开始考研的激情还比较浓，看书什么的也还好，但是慢慢的就开始看不进去了，还记得当时买了那本《SICP》，每天就看几页，做做习题，也没怎么运动，天天就是吃、吃、睡、睡，家里环境好呀，也没人。浑浑噩噩的，很快就到了要回学校做毕业设计的时间了。回学校后就断了考研的想法。</p><p>其实就像每个毕业生都会经历的那样，就业与考研在那段时间也一直困扰着我，一直到今天（2015-1-10）回头再看看，也不知道这条路选的是否正确。</p><h2 id="毕业设计（2014-5～2014-6）"><a href="#毕业设计（2014-5～2014-6）" class="headerlink" title="毕业设计（2014.5～2014.6）"></a>毕业设计（2014.5～2014.6）</h2><p>从家里回到学校做毕业设计应该是在5月11号左右。从大三暑假就开始出来实习，到这次重新回来，算算也是有半年的时间了，重新回到学校，感觉一切是那么熟悉又那么陌生，熟悉的是相同的教学楼，陌生的是不同的心情，仿佛我已经不属于这个地方了。毕业设计是用的我在果壳做的hebo项目，鉴于前期代码基本已经完成了，这次回学校主要是文档的编写，导师我找的是张老师，合作挺愉快的，经过几次修改后，最后我的论文被评为了优秀，作为奖励，发了¥500RMB。</p><p>我在所有实习的同学中回来的算是早的，随着大家陆陆续续的回来，相互寒碜几句，问问都找了什么样的公司，待遇多少，刚开始也想着在学校找个自习室什么的上个自习考研的来，但是还是觉得自己太浮躁了，现在在看书，根本静不下心来了，这期间也投了几个简历，当时应该是投了蘑菇街，还因此去了趟杭州，不过还是败下阵了，当时让我写一个算法，应该是<a href="http://blog.csdn.net/v_july_v/article/details/6444021" target="_blank" rel="noopener">求连续子数组的最大和</a>，我当时大概用了半个小时才把这个算法写出来吧，面试官印象是个很“短小精湛”的小伙子，个子不高，瘦瘦的，但是通过交流就知道是个算法狂人，他也给我指出了我的“硬伤”，基本功不行，我简历上写了会lucene、hadoop，猛地一看很唬人，其实自己就是调用API级别的菜鸟，内部原理不甚了解，以前也写过一篇<a href="/blog/2014/05/19/go-into-java-world/">文章</a>总结，事过半年了，貌似还是菜鸟。</p><h2 id="杭州找工作（2014-6～2014-7）"><a href="#杭州找工作（2014-6～2014-7）" class="headerlink" title="杭州找工作（2014.6～2014.7）"></a>杭州找工作（2014.6～2014.7）</h2><p>在学校昨晚毕业设计答辩后，就觉得应该去杭州，阿里巴巴对于像我这样的应届生还是有莫大的吸引力的。从上次面试蘑菇街，这次算是第二次来了，这次我主要是在内推网上投的简历，来之前投了的又拍云，这次来主要是先是面试它，现在还记得，当时我应该是租的文一路的布丁旅馆，又拍云面试很顺利，整个过程下来没问什么具体的技术，就是泛泛谈谈，之后就让回去等通知了，我还记得当时面试出来后，我就给学坤打了个电话，说应该问题不大了，又了这个保底的，就没什么特别担心的了，但是又拍云一直没给我最终结果，导致时间越长，就越担心，收到offer应该是在一个星期后了，最后给我工资和我预期差距较大，几经纠结后，还是决定在找找看，当时在内推看到ucloud的招聘，投递简历后，先是让他们那边安排了次电话面试，我还记得当时第一次约的时间他们那边没给我打，得知又拍云的薪资后，我又尝试主动联系他们，简单电话聊过之后，让我去他们公司试试，之后就是来上海面，那天一早从杭州出发，公交到杭州城站，动车到浦东站，地铁到ucloud，面试一下午，之后原路线返回，回到杭州已经晚上11点了。</p><p>到当前写作时间（2015-1-10），已经过去大半年了，一直在ucloud。</p><p>##ucloud（2014.7～2014.12）</p><p>确定在上海工作后，就开始租房，上海租房比北京好些，黑中介少些。</p><p>到现在，回想这半年的工作，正好前几天公司的KPI自评，发现自己还是不行，一直没找到感觉，还是浮躁，没找到点上。感觉工作内容也一直在变，什么感觉说不出来，就是没找到兴奋点上。部门领导也看出来了，主动和我交流，指出我有如下两个缺点：</p><ol><li>空想，没有实际行动</li><li>责任心不强</li></ol><p>这两点很好理解，第一点，每个人都想成功，但是怎么做呢，具体到这个月需要达到什么效果，这周需要完成什么呢，没想过。第二点，自己只顾自己的一亩三分地了，不去管应该由用户抛出来的问题，觉得别人可以解决或者这块不属于我管，我不用关心。</p><p>通过这次KPI自评，还是找到一些需要解决的问题，下面半年争取有个质的突破。</p><h2 id="2015-你好"><a href="#2015-你好" class="headerlink" title="2015 你好"></a>2015 你好</h2><p>上面简单梳理了下2014年发生的事情，下面罗列一下在2015年需要干的事情。</p><ol><li>工作态度要端正，KPI时指出的缺点要克服，工作用心，多思考，多实践；作为衡量指标，每周的周报一定要有干货，每个月自己在进行一次总结。</li><li>看书<blockquote><p>这是个很容易拖延的话题，毕竟现在看书太“难”了。但还是要罗列下15年必须看完的书了。</p></blockquote></li></ol><ul><li><a href="http://book.douban.com/subject/1148282/" target="_blank" rel="noopener">SICP</a></li><li><a href="http://book.douban.com/subject/1885170/" target="_blank" rel="noopener">算法导论</a></li><li><a href="http://book.douban.com/subject/1291204/" target="_blank" rel="noopener">哥德尔、艾舍尔、巴赫</a></li></ul><p>这三本书实体版都已经买来了，不管工作多重，也要抽业余时间看完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉间，又到一年尾，想想自己这正式工作也有大半年了，加上之前的实习，也算是有一年半多“工作经验”的人了。在今年的六月份，大学也划上了圆满的句号，还记得当初大一刚去学校报道时的一个标语——“今天我以烟大为荣，明天烟大以我为荣”，我肯定是不达标了。&lt;/p&gt;
&lt;p&gt;“年年岁岁
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式“派别”简述</title>
    <link href="http://liujiacai.net/blog/2014/12/07/regexp-favors/"/>
    <id>http://liujiacai.net/blog/2014/12/07/regexp-favors/</id>
    <published>2014-12-07T11:07:48.000Z</published>
    <updated>2019-12-24T10:59:14.599Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家对于正则表达式都不陌生，在文本处理中或多或少的都会使用到它。但是，我们在使用linux下的文本处理工具如awk、sed等时，正则表达式的语法貌似还不一样，在awk中能正常工作的正则，在sed中总是不起作用，这是为什么呢？</p><p>这个问题产生的缘由是因为正则表达式不断演变的结果，为了弄清楚这些工具使用的正则语法的不同，我们有必要去简单了解下正则的演变过程，做到知己知彼。当然这个过程本身也是很精彩的，我这里抛砖引玉，希望对大家正确使用正则表达式有所帮助。</p><h2 id="诞生期"><a href="#诞生期" class="headerlink" title="诞生期"></a>诞生期</h2><p>正则表示式这一概念最早可以追溯到20世纪40年代的两个神经物理学家Warren McCulloch与Walter Pitts，他们将神经系统中的神经元描述成小而简单的自动控制元；紧接着，在50年代，数学家1950年代，数学家<a href="http://en.wikipedia.org/wiki/Stephen_Cole_Kleene" target="_blank" rel="noopener">Stephen Kleene</a>利用称之为“正则集合”的数学符号来描述此模型，并且建议使用一个简单的概念来表示，于是regular expressions就正式登上历史舞台了。插播一下，这个Kleene可不是凡人，大家都知道图灵是现代人工智能之父，那图灵的博导是<a href="http://en.wikipedia.org/wiki/Alonzo_Church" target="_blank" rel="noopener">Alonzo Church</a>，提出了lambda表达式，而Church的老师，就是Kleene了。关于lambda，之前也写过一篇文章，大家可以参考<a href="/blog/2014/10/12/lambda-calculus-introduction/">编程语言的基石——Lambda calculus</a>。</p><p>在接下来的时间里，一直到60年代的这二十年里，正则表示式在<a href="http://en.wikipedia.org/wiki/Pure_mathematics" target="_blank" rel="noopener">理论数学领略</a>得到了长足的发展，<a href="http://www.cs.cornell.edu/home/rc/" target="_blank" rel="noopener">Robert Constable</a>为数学发烧友们写了一篇总结性文章<a href="http://www.sciencedirect.com/science/article/pii/S0049237X08712539" target="_blank" rel="noopener">The Role of Finite Automata in the Development of Modern Computing Theory</a>，由于版权问题，我在网上没找到这篇文章，大家有兴趣的可以参考<a href="http://cs.stanford.edu/people/eroberts/courses/soco/projects/2004-05/automata-theory/basics.html" target="_blank" rel="noopener">Basics of Automata Theory</a>。</p><p>Ken Thompson大牛在1968年发表了<a href="http://www.fing.edu.uy/inco/cursos/intropln/material/p419-thompson.pdf" target="_blank" rel="noopener">Regular Expression Search Algorithm</a>论文，紧接着Thompson根据这篇论文的算法实现了<a href="http://en.wikipedia.org/wiki/QED_%28text_editor%29" target="_blank" rel="noopener">qed</a>，qed是unix上编辑器ed的前身。ed所支持的正则表示式并不比qed的高级，但是ed是第一个在非技术圈广泛传播的工具，ed有一个命令可以展示文本中符合给定正则表达式的行，这个命令是<code>g/Regular Expression/p</code>，在英文中读作“Global Regular Expression Print”，由于这个命令非常实用，所以后来有了grep、egrep这两个命令。</p><h2 id="成长期"><a href="#成长期" class="headerlink" title="成长期"></a>成长期</h2><p>相比egrep，grep只支持很少的元符号，<code>＊</code>是支持的（但不能用于分组中），但是<code>+</code>、<code>|</code>与<code>?</code>是不支持的；而且，分组时需要加上反斜线转义，像<code>\( ...\)</code>这样才行，由于grep的缺陷性日渐明显，AT&amp;T的<a href="http://en.wikipedia.org/wiki/Alfred_Aho" target="_blank" rel="noopener">Alfred Aho</a>实在受不了了，于是egrep诞生了，这里的e表示extended，加强版的意思，支持了<code>+</code>、<code>|</code>与<code>?</code>这三个元符号，并且可以在分组中使用<code>*</code>，分组可以直接写成<code>(...)</code>，同时用<code>\1,\2...</code>来引用分组。</p><p>在grep、egrep发展的同时，awk、lex、sed等程序也开始发展起来，而且每个程序所支持的正则表达式都或多或少的和其他的不一样，这应该算是正则表达式发展的混乱期，因为这些程序在不断的发展过程中，有时新增加的功能因为bug原因，在后期的版本中取消了该功能，例如，如果让grep支持元符号<code>+</code>的话，那么grep就不能表示字符<code>+</code>了，而且grep的老用户会对这很反感。</p><h2 id="成熟期"><a href="#成熟期" class="headerlink" title="成熟期"></a>成熟期</h2><p>这种混乱度情况一直持续到了1986年。在1986年，POSIX（Portable Operating System Interface）标准公诸于世，POSIX制定了不同的操作系统都需要遵守的一套规则，当然，正则表达式也包括其中。</p><p>当然，除了POSIX标准外，还有一个Perl分支，也就是我们现在熟知的PCRE，随着Perl语言的发展，Perl语言中的正则表达式功能越来越强悍，为了把Perl语言中正则的功能移植到其他语言中，PCRE就诞生了。现在的编程语言中的正则表达式，大部分都属于PCRE这个分支。</p><p>下面分别所说这两个分支。</p><h3 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h3><p>POSIX把正则表达式分为两种（favor）：BRE（Basic Regular Expressions）与ERE（Extended Regular Expressions ）。所有的POSIX程序可以选择支持其中的一种。具体规范如下表：<br><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2uVx6bpXXXXaDXpXXXXXXXXXX_!!581166664.png" alt=" posix-regexp-favor"></p><p>从上图可以看出，有三个空白栏，那么是不是就意味这无法使用该功能了呢？答案是否定的，因为我们现在使用的linux发行版，都是集成GNU套件的，GNU是Gnu’s Not Unix的缩写，GNU在实现了POXIS标准的同时，做了一定的扩展，所以上面空白栏中的功能也能使用。下面一一讲解：</p><ol><li>BRE如何使用<code>+</code>、<code>?</code>呢？需要用<code>\+</code>、<code>\?</code></li><li>BRE如何使用<code>|</code>呢？需要用<code>\|</code></li><li>ERE如何使用<code>\1</code>、<code>\2</code>…<code>\9</code>这样的反引用？和BRE一样，就是<code>\1</code>、<code>\2</code>…<code>\9</code></li></ol><p>通过上面总结，可以发现：GNU中的ERE与BRE的功能相同，只是语法不同（BRE需要用<code>\</code>进行转义，才能表示特殊含义）。例如<code>a{1,2}</code>，在ERE表示的是<code>a</code>或<code>aa</code>，在BRE中表示的是<code>a{1,2}</code>这个字符串。为了能够在Linux下熟练使用文本处理工具，我们必须知道这些命令支持那种正则表达式。现对常见的命令总结如下：</p><p>－ 使用BRE语法的命令有：grep、ed、sed、vim<br>－ 使用ERE语法的命令有：egrep、awk、emacs</p><p>当然，这也不是绝对的，比如 sed 通过-r选项就可以使用ERE了，大家到时自己man一下就可以了。</p><p>还值得一提的是POSIX还定义了一些shorthand，具体如下：</p><ul><li>[:alnum:]</li><li>[:alpha:]</li><li>[:cntrl:]</li><li>[:digit:]</li><li>[:graph:]</li><li>[:lower:]</li><li>[:print:]</li><li>[:punct:]</li><li>[:space:]</li><li>[:upper:]</li><li>[:xdigit:]</li></ul><p>在使用这些shorthand时有一个约束：必须在<code>[]</code>中使用，也就是说如果像匹配0-9的数字，需要这么写<code>[[:alnum:]]</code>，取反就是<code>[^[:alnum:]]</code>。shorhand 在BRE与EBE中的用法相同。</p><p>如果你对sed、awk比较熟悉，你会发现我们平常在变成语言中用的<code>\d</code>、<code>\w</code>在这些命令中不能用，原因很简单，因为POSIX规范根本没有定义这些shorthand，这些是由下面将要说的PCRE中定义的。</p><h3 id="PCRE标准"><a href="#PCRE标准" class="headerlink" title="PCRE标准"></a>PCRE标准</h3><p>Perl语言第一版是由<a href="http://en.wikipedia.org/wiki/Larry_Wall" target="_blank" rel="noopener">Larry Wall</a>发布于1987年12月，Perl在发布之初，就因其强大的功能而一票走红，Perl的定位目标就是“天天要使用的工具”。Perl比较显诸特征之一是与sed与awk兼容，这造就了Perl成为第一个通用性脚本语言。</p><p>随着Perl的不断发展，其支持的正则表达式的功能也越来越强大。其中影响较大的是于1994年10月发布的Perl 5，其增加了很多特性，比如non-capturing parentheses、lazy quantifiers、look-ahead、元符号\G等等。</p><p>正好这时也是WWW兴起的时候，而Perl就是为了文本处理而发明的，所以Perl基本上成了web开发的首选语言。Perl语言应用是如此广泛，以至于其他语言开始移植Perl，最终Perl compatible（兼容）的PCRE诞生了，这其中包括了Tcl, Python, Microsoft’s .NET , Ruby, PHP, C/C++, Java等等。</p><p>前面说了shorthand在POSIX与PCRE是不同的，PCRE中我们常用的有如下这些：</p><ul><li><code>\w</code> 表示<code>[a-zA-Z]</code></li><li><code>\W</code> 表示<code>[^a-zA-Z]</code></li><li><code>\s</code> 表示<code>[ \t\r\n\f]</code></li><li><code>\S</code> 表示<code>[^ \t\r\n\f]</code></li><li><code>\d</code> 表示<code>[1-9]</code></li><li><code>\D</code> 表示<code>[^1-9]</code></li><li><code>\&lt;</code> 表示一个单词的起始</li><li><code>\&gt;</code> 表示一个单词的结尾</li></ul><p>关于shorthand在两种标准的比较，更多可参考<a href="http://en.wikipedia.org/wiki/Regular_expression#Character_classes" target="_blank" rel="noopener">Wikipedia</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我相信大家最初接触正则表达式（RE）这东西，都是在某个语言中，像 Java、Python等，其实这些语言的正则表达式都是基于PCRE标准的。<br>而Linux下使用各种处理文本的命令，是继承自POSIX标准，不过是由GNU扩展后的而已。</p><p>大家如果对 sed、awk命令不熟悉，可以参考耗子叔下面的两篇文章：</p><ul><li><a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">sed 简明教程</a></li><li><a href="http://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">awk 简明教程</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.regular-expressions.info/gnu.html" target="_blank" rel="noopener">GNU Regular Expression Extensions</a></li><li><a href="http://www.regular-expressions.info/posixbrackets.html" target="_blank" rel="noopener">POSIX Bracket Expressions</a></li><li><a href="https://www.gnu.org/software/gnulib/manual/html_node/Regular-expression-syntaxes.html" target="_blank" rel="noopener">Different types of regular expressions Gnulib supports</a></li><li><a href="http://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="noopener">Regular_expression</a></li><li><a href="http://www.infoq.com/cn/news/2011/07/regular-expressions-6-POSIX" target="_blank" rel="noopener">Linux/Unix工具与正则表达式的POSIX规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信大家对于正则表达式都不陌生，在文本处理中或多或少的都会使用到它。但是，我们在使用linux下的文本处理工具如awk、sed等时，正则表达式的语法貌似还不一样，在awk中能正常工作的正则，在sed中总是不起作用，这是为什么呢？&lt;/p&gt;
&lt;p&gt;这个问题产生的缘由是因为正则表
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="Linux" scheme="http://liujiacai.net/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>MacBook 最佳实践</title>
    <link href="http://liujiacai.net/blog/2014/11/23/first-taste-of-macbook/"/>
    <id>http://liujiacai.net/blog/2014/11/23/first-taste-of-macbook/</id>
    <published>2014-11-23T12:40:07.000Z</published>
    <updated>2019-12-24T10:59:14.598Z</updated>
    
    <content type="html"><![CDATA[<p>MacBook 兼具命令行的高效与图形界面的酷炫，实在是程序员必备利器。本文主要介绍我在两年的使用过程中总结出的一些最佳实践，供大家参考、借鉴。</p><p><img src="https://dn-mhke0kuv.qbox.me/cb49a18efb421a9624c5.png" alt="MacBook 你值得拥有"></p><h2 id="Mac-OS-简介"><a href="#Mac-OS-简介" class="headerlink" title="Mac OS 简介"></a>Mac OS 简介</h2><p>Mac OS可以被分成操作系统的两个系列：</p><ul><li>一个是老旧且已不被支持的“Classic”Mac OS（系统搭载在1984年销售的首部Mac与其后代上，终极版本是Mac OS 9）。采用Mach作为內核，在Mac OS 7.6.1以前用“System vX.X”来称呼。</li><li>新的OS X结合<a href="http://zh.wikipedia.org/wiki/BSD" target="_blank" rel="noopener">BSD Unix</a>、OpenStep和Mac OS 9的元素。它的最底层建基于Unix基础，其代码被称为Darwin，实行的是部分开放源代码。</li></ul><p>关于为什么Mac系统没有采用Linux内核，而是采用了BSD还有个小故事，感兴趣的大家可以看<a href="https://zhuanlan.zhihu.com/p/20263877" target="_blank" rel="noopener">Mac OS X 背后的故事（二）——Linus Torvalds的短视</a>这篇文章。</p><p>尽管 Mac 的文件系统目录和 Linux 差不多，但还是有些差距，可参考下面的表格：</p><p><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2SgzpbXXXXXbSXpXXXXXXXXXX_!!581166664.png" alt="Mac-FileSystem"></p><h2 id="Mac-开发环境部署"><a href="#Mac-开发环境部署" class="headerlink" title="Mac 开发环境部署"></a>Mac 开发环境部署</h2><h3 id="包管理器-Homebrew"><a href="#包管理器-Homebrew" class="headerlink" title="包管理器 Homebrew"></a>包管理器 <a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a></h3><blockquote><p>The missing package manager for macOS</p></blockquote><p><code>brew</code>相当于<code>Ubuntu</code>下的<code>apt-get</code>，<code>CentOS</code>中的<code>yum</code>。非常方便实用，一条命令即可安装：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/<span class="keyword">install</span>/<span class="keyword">master</span>/<span class="keyword">install</span>)<span class="string">"</span></span><br></pre></td></tr></table></figure><ul><li><code>brew install &lt;cli-program&gt;</code>，安装命令行工具</li><li><code>brew cask install &lt;gui-program&gt;</code>，安装图形界面软件，这得益于<a href="https://github.com/caskroom/homebrew-cask" target="_blank" rel="noopener">Homebrew-Cask</a>扩展</li></ul><p>可以根据需要，配置国内源：</p><ul><li>中科大，<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/brew.git</a></li><li>清华，<a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/</a></li></ul><h3 id="文本编辑器-VSCode"><a href="#文本编辑器-VSCode" class="headerlink" title="文本编辑器 VSCode"></a>文本编辑器 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>visual-studio-code</span><br></pre></td></tr></table></figure><p>新时代的文本编辑器，功能和 Atom/Sublime 差不多，但是不会出现卡顿现象，而且官方提供了 <a href="https://github.com/Microsoft/vscode-sublime-keybindings" target="_blank" rel="noopener">Sublime Text Keymap</a> 插件，如果之前熟悉 Sublime，推荐安装。下面是我非常依赖的快捷键：</p><ul><li>Multiple Selection: <code>Control+Command+G</code>（在 Linux/Windows 下，是 Alt+F3）</li><li>选中多行 <code>Shift+Command+L</code></li><li>多行合并为一行<code>Command+J</code></li></ul><h3 id="神之编辑器-Emacs"><a href="#神之编辑器-Emacs" class="headerlink" title="神之编辑器 Emacs"></a>神之编辑器 <a href="https://www.emacswiki.org/emacs?interface=en" target="_blank" rel="noopener">Emacs</a></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>--with-cocoa --srgb emacs</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span><span class="keyword">sbcl </span><span class="comment"># 顺便把 common lisp 也装上</span></span><br></pre></td></tr></table></figure><p>其实 Mac 是有自带 Emacs 的，位置是<code>/usr/bin/emacs</code>，只是版本非常旧，通过<code>brew</code>安装的位置在<code>/usr/local/bin/emacs</code>，可以通过下面的命令删除 Mac 自带的 Emacs：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm <span class="meta-keyword">/usr/</span>bin/emacs</span><br><span class="line">sudo rm -rf <span class="meta-keyword">/usr/</span>share/emacs</span><br></pre></td></tr></table></figure></p><p>为了能在 git，终端中默认使用 Emacs，需要做以下配置：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">EDITOR</span>=<span class="string">"emacsclient -t -a=\"\""</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ALTERNATE_EDITOR</span>=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~/.gitconfig</span></span><br><span class="line">[core]</span><br><span class="line">    editor = emacsclient -t <span class="attribute">-a</span>=\\\"\\\"</span><br></pre></td></tr></table></figure></p><p>上面的配置会调用 <code>emacsclient</code> 去连接 <code>emacs daemon</code>服务，如果服务没启，就先启动服务再去连接。</p><h3 id="API-查阅工具Dash"><a href="#API-查阅工具Dash" class="headerlink" title="API 查阅工具Dash"></a>API 查阅工具<a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>dash</span><br></pre></td></tr></table></figure><blockquote><p>Dash gives your Mac instant offline access to 150+ API documentation sets.</p></blockquote><p>安装 Dash 后，就可以离线查各种语言/框架的 API 文档了。🍺</p><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2x_3QcNdkpuFjy0FbXXaNnpXa_!!581166664.png" alt></p><h3 id="抓包工具-Wireshark"><a href="#抓包工具-Wireshark" class="headerlink" title="抓包工具 Wireshark"></a>抓包工具 <a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>wireshark</span><br></pre></td></tr></table></figure><p>也许是最强大的抓包工具，从其名字上就能体现出：wire（线路）+ shark（鲨鱼）。但这个软件初次使用时有些难度，最重要的是区分两个概念：</p><ul><li><code>capture filter</code>，在抓包开始时指定。<br><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2dcIUcHXlpuFjSszfXXcSGXXa_!!581166664.png" alt="capture filter"><br>常见表达式</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Capture only traffic to or from IP address 172.18.5.4:</span></span><br><span class="line">host 172.18.5.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Capture traffic to or from a range of IP addresses:</span></span><br><span class="line">net 192.168.0.0/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># Capture non-HTTP and non-SMTP traffic on your server (both are equivalent):</span></span><br><span class="line">host www.example.com <span class="keyword">and</span> <span class="keyword">not</span> (port 80 <span class="keyword">or</span><span class="built_in"> port </span>25)</span><br><span class="line">host www.example.com <span class="keyword">and</span> <span class="keyword">not</span><span class="built_in"> port </span>80 <span class="keyword">and</span> <span class="keyword">not</span><span class="built_in"> port </span>25</span><br><span class="line"></span><br><span class="line"><span class="comment"># Capture traffic within a range of ports  with newer versions of libpcap (0.9.1 and later):</span></span><br><span class="line">tcp portrange 1501-1549</span><br><span class="line"></span><br><span class="line"><span class="comment">#Capture only IPv4 traffic - the shortest filter, but sometimes very useful to get rid of lower layer protocols like ARP and STP:</span></span><br><span class="line">ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Capture only unicast traffic - useful to get rid of noise on the network if you only want to see traffic to and from your machine, not, for example, broadcast and multicast announcements:</span></span><br><span class="line"><span class="keyword">not</span> broadcast <span class="keyword">and</span> <span class="keyword">not</span> multicast</span><br></pre></td></tr></table></figure><ul><li><code>display filter</code>，在抓取一定包后进行过滤。<br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2L5U0cHJkpuFjy1zcXXa5FFXa_!!581166664.png" alt="display filter"><br>常见表达式</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ip.dst_host</span> <span class="string">==</span> <span class="number">192.168</span><span class="number">.30</span><span class="number">.103</span> <span class="string">and</span> <span class="string">tcp.dstport</span> <span class="string">==</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="string">ip.addr</span> <span class="string">==</span> <span class="number">10.43</span><span class="number">.54</span><span class="number">.65</span></span><br><span class="line"><span class="comment"># is equivalent to</span></span><br><span class="line"><span class="string">ip.src</span> <span class="string">==</span> <span class="number">10.43</span><span class="number">.54</span><span class="number">.65</span> <span class="string">or</span> <span class="string">ip.dst</span> <span class="string">==</span> <span class="number">10.43</span><span class="number">.54</span><span class="number">.65</span></span><br></pre></td></tr></table></figure><h3 id="终端-iTerm-2"><a href="#终端-iTerm-2" class="headerlink" title="终端 iTerm 2"></a>终端 <a href="http://iterm2.com/" target="_blank" rel="noopener">iTerm 2</a></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>iterm2</span><br></pre></td></tr></table></figure><p>Mac自带的终端不是很强，程序员们需要一个强劲的终端来工作，于是有了 iTerm2。需要设置一项：Left Option act as +Esc（Preferences–&gt;Profiles–&gt;Keys），这样 Option 就可以用作 Meta 键了。</p><ul><li><code>Cmd + D</code> 垂直分屏 </li><li><code>Cmd + Shift + D</code> 水平分屏 </li><li><code>Cmd + T</code> 开多个Tab </li><li><code>Cmd + 数字</code> 在多个Tab之间进行切换 </li><li><code>Option + F/B（向前、向后）</code> 按字移动。Bash Shell 光标默认按照 Emacs 风格移动，也可改为 VIM，可参考<a href="http://www.hypexr.org/bash_tutorial.php#set" target="_blank" rel="noopener">Modifying the Bash Shell with the set Command</a>。 </li><li><code>Ctrl + r</code> 搜索历史命令</li><li><code>!!</code> 执行上条命令</li><li><code>Ctrl+x Ctrl+e</code> 调用<a href="http://www.commandlinefu.com/commands/view/1446/rapidly-invoke-an-editor-to-write-a-long-complex-or-tricky-command" target="_blank" rel="noopener">默认编辑器去编辑一个特别长的命令</a></li></ul><p>当然，说到了 iTerm2，不得不提到终端复用软件 <a href="https://tmux.github.io/" target="_blank" rel="noopener">tmux</a>，tmux 默认配置文件在 Mac 上很别扭，你可以参考我这里的<a href="https://github.com/jiacai2050/conf/blob/master/.tmux.conf" target="_blank" rel="noopener">配置文件</a>，这样 tmux 就可以像 vim 一样实现各种分屏的效果了。如果你还不知道 tmux 为何物，强烈推荐你看这个13分钟的<a href="http://pan.baidu.com/s/1gdLZzB9" target="_blank" rel="noopener">视频</a>，绝对物超所值，感谢 <a href="http://haoduoshipin.com/u/happypeter" target="_blank" rel="noopener">happypeter</a> 的分享。</p><p>我现在用的主题是：<a href="https://github.com/chriskempson/tomorrow-theme/blob/master/iTerm2/Tomorrow%20Night.itermcolors" target="_blank" rel="noopener">Tomorrow Night</a>。</p><h3 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h3><p>Linux 一般通过<code>~/.bashrc</code>进行环境变量的配置，但是在 Mac 下配置后，发现根本没有效果，这是为什么呢？<br>其实这是个比较基础的问题，shell有两种：登录式shell与非登录式shell，直观理解，登录(login)式shell就是在你打开shell要求你输入用户名与密码的shell，我们在使用桌面Linux时一般只在登录时接触到这种shell，等我们进入系统后，再打开的Terminal就是非登录式shell了。这两种 shell 读取配置的文件是不同的：</p><ul><li>登录式Shell启动时会去读取<code>~/.profile</code>文件（Redhat、Mac上为 <code>~/.bash_profile</code>）</li><li>非登录式Shell会去读取<code>~/.bashrc</code>文件</li></ul><p>这也就解释了为什么在 Linux 系统上只需要修改 <code>~/.bashrc</code> 后即可生效的原因。但在 Mac 上有些不同，开机后再通过 Terminal.app（或iTerm.app） 打开终端时，这时的 shell 是登录式shell，因为Terminal.app（或iTerm.app）这个应用程序是通过<code>/usr/bin/login</code>这个命令打开终端的，所以不会去<code>source ~/.bashrc</code>了。<br>解决方法也很简单，在~/.bash_profile加上下面一句代码就ok了<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -r ~<span class="string">/.bashrc</span> ] &amp;&amp; source ~<span class="string">/.bashrc</span></span><br></pre></td></tr></table></figure></p><p>Mac下<code>ls</code>命令默认是没有颜色的，不是很直观，可以自己设置一个alias，参考<a href="http://apple.stackexchange.com/questions/33677/how-can-i-configure-mac-terminal-to-have-color-ls-output" target="_blank" rel="noopener">链接</a><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">LSCOLORS</span>=gxBxhxDxfxhxhxhxhxcxcx</span><br><span class="line">alias <span class="attribute">ls</span>=<span class="string">'ls -FG'</span></span><br><span class="line">alias <span class="attribute">ll</span>=<span class="string">'ls -l'</span></span><br></pre></td></tr></table></figure></p><p>为了在命令行提示符中显示时间，可以设置<code>PS1</code>变量<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PS1="<span class="symbol">\n</span><span class="symbol">\e</span>[1;37m[<span class="symbol">\e</span>[m<span class="symbol">\e</span>[1;35m<span class="symbol">\u</span><span class="symbol">\e</span>[m<span class="symbol">\e</span>[1;36m@<span class="symbol">\e</span>[m<span class="symbol">\e</span>[1;37m<span class="symbol">\h</span><span class="symbol">\e</span>[m <span class="symbol">\e</span>[1;33m<span class="symbol">\t</span><span class="symbol">\e</span>[m <span class="symbol">\w</span><span class="symbol">\e</span>[m<span class="symbol">\e</span>[1;37m]<span class="symbol">\e</span>[m<span class="symbol">\e</span>[1;36m<span class="symbol">\e</span>[m<span class="symbol">\n</span><span class="symbol">\$</span> "</span><br><span class="line"></span><br><span class="line"># 效果如下</span><br><span class="line">[liujiacai@macbook 22:02:13 ~]</span><br></pre></td></tr></table></figure></p><h3 id="ssh-config"><a href="#ssh-config" class="headerlink" title="~/.ssh/config"></a>~/.ssh/config</h3><p>在 macOS/OS X 截止到 Yosemite，ssh-agent 会一直记住 <code>ssh-add -K</code> 添加的 key，即使重启 keychain，ssh-agent 也会自动去读取保存在 keychain 中的密码（passphrase）。但在 Sierra 中，重启 keychain 后，ssh-agent 就不会去读取了。Apple 开发者也对这一现象作出<a href="https://openradar.appspot.com/27348363" target="_blank" rel="noopener">回应</a>：</p><blockquote><p>That’s expected. We re-aligned our behavior with the mainstream OpenSSH in this area. </p></blockquote><p>解决办法也很简单，将<code>ssh-add -A</code> 放到 <code>~/.bashrc</code> 里面就可以了。除了这种方式，还可以在<code>~/.ssh/config</code>里面加入如下配置：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host * (<span class="name">asterisk</span> for all hosts or add specific host)</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  IdentityFile &lt;key&gt; (<span class="name">e</span>.g. ~/.ssh/userKey)</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://github.com/jirsbek/SSH-keys-in-macOS-Sierra-keychain" target="_blank" rel="noopener">Saving SSH keys in macOS Sierra keychain</a></li></ul><p>除此之外，对于 OpenSSH 4.0 以及之后的版本，引入一新功能 ControlMaster，可以复用之前已经登录的连接，建议开启：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  ControlMaster auto</span><br><span class="line">  ControlPath ~/.ssh/master-<span class="built_in">%r</span>@<span class="built_in">%h</span>:<span class="built_in">%p</span></span><br><span class="line">  ControlPersist <span class="number">60</span>m</span><br></pre></td></tr></table></figure></p><p>参考：</p><ul><li><a href="https://www.linux.com/news/accelerating-openssh-connections-controlmaster" target="_blank" rel="noopener">Accelerating OpenSSH connections with ControlMaster</a></li><li><a href="OpenSSH/Cookbook/Multiplexing">https://en.wikibooks.org/wiki/OpenSSH/Cookbook/Multiplexing</a></li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span><span class="keyword">java</span></span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>maven</span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>intellij-idea-ce  <span class="comment"># IDE，不要告诉我你还在用 eclipse</span></span><br></pre></td></tr></table></figure><p>通过<code>brew cask</code>安装后，可以通过执行<code>/usr/libexec/java_home</code>这个命令来获取JAVA_HOME<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=<span class="string">"<span class="variable">$(/usr/libexec/java_home)</span>"</span></span><br></pre></td></tr></table></figure></p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>docker</span><br></pre></td></tr></table></figure><p>国内访问 Docker Hub 有时会遇到困难，最好可以配置<a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" target="_blank" rel="noopener">镜像加速器</a>。</p><h3 id="数据库-GUI-客户端"><a href="#数据库-GUI-客户端" class="headerlink" title="数据库 GUI 客户端"></a>数据库 GUI 客户端</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>sequel-pro <span class="comment"># mysql</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>robo<span class="number">-3</span>t    <span class="comment"># mongodb</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>rdm        <span class="comment"># redis</span></span><br></pre></td></tr></table></figure><h3 id="科学上网-Shadowsocks"><a href="#科学上网-Shadowsocks" class="headerlink" title="科学上网 Shadowsocks"></a>科学上网 Shadowsocks</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span><span class="keyword">shadowsocks-libev</span></span><br></pre></td></tr></table></figure><p>Mac 下不推荐安装 GUI 版本，已经很久没人维护了。安装之后编辑<code>/usr/local/etc/shadowsocks-libev.json</code>，填入 server 地址即可。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">ss-<span class="built_in">local</span> -v -c /usr/<span class="built_in">local</span>/etc/shadowsocks-libev.json</span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">brew services <span class="built_in">start</span> shadowsocks-libev</span><br></pre></td></tr></table></figure></p><p>为了让终端可以使用代理，需要将 http(s) 转为 socks 流量。ss 官方推荐的是 <a href="https://github.com/shadowsocks/shadowsocks/wiki/Using-Shadowsocks-with-Command-Line-Tools" target="_blank" rel="noopener">proxychains</a>，但是在OS X 10.11 以后引入了 <a href="https://developer.apple.com/library/content/releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_11.html" target="_blank" rel="noopener">SIP安全机制</a>，导致无法直接使用，关闭 SIP 貌似也不可取，可以选用 <a href="https://www.privoxy.org/" target="_blank" rel="noopener">privoxy</a> 来替代 proxychains。（<a href="https://tech.jandou.com/to-accelerate-the-terminal.html" target="_blank" rel="noopener">参考</a>）<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew install privoxy</span><br><span class="line"><span class="comment"># privoxy 使用 8118 端口， ss 使用 1080</span></span><br><span class="line">echo <span class="string">'listen-address 0.0.0.0:8118\nforward-socks5 / localhost:1080 .'</span> &gt;&gt; /usr/local/etc/privoxy/config</span><br><span class="line"><span class="comment"># 测试，查看 8118 有没有在监听， netstat -an | grep 8118</span></span><br><span class="line">/usr/local/sbin/privoxy /usr/local/etc/privoxy/config</span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">brew services start privoxy</span><br></pre></td></tr></table></figure></p><p>经过上面这几步 <code>http(s)-&gt;socks5</code> 就完成，下面只需要让终端走这个代理即可：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=<span class="string">'http://localhost:8118'</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">https_proxy</span>=<span class="string">'http://localhost:8118'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将以下函数放入 ~/.bashrc 中，方便开启/关闭代理</span></span><br><span class="line">function proxy_off()&#123;</span><br><span class="line">    unset http_proxy</span><br><span class="line">    unset https_proxy</span><br><span class="line">    echo -e <span class="string">"已关闭代理"</span></span><br><span class="line">&#125;</span><br><span class="line">function proxy_on() &#123;</span><br><span class="line">    <span class="builtin-name">export</span> <span class="attribute">no_proxy</span>=<span class="string">"localhost,127.0.0.1,localaddress,.localdomain.com"</span></span><br><span class="line">    <span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=<span class="string">"http://127.0.0.1:8118"</span></span><br><span class="line">    <span class="builtin-name">export</span> <span class="attribute">https_proxy</span>=<span class="variable">$http_proxy</span></span><br><span class="line">    echo -e <span class="string">"已开启代理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="虚拟机-Virtualbox"><a href="#虚拟机-Virtualbox" class="headerlink" title="虚拟机 Virtualbox"></a>虚拟机 <a href="https://www.virtualbox.org/" target="_blank" rel="noopener">Virtualbox</a></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>virtualbox</span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>vagrant   <span class="comment"># 虚拟机管理工具，方便命令行操作</span></span><br></pre></td></tr></table></figure><p>在天朝，很多网站是只支持 IE 的，Mac 下的 Firefox, Chrome, Safari 这时候都显得心有力而不足了，而且很多软件也只有 Windows 版，所以装个虚拟机是非常有必要的。 Virtualbox 是我自用 Ubuntu 以来一直用的虚拟机，开源免费。</p><p><a href="https://github.com/hashicorp/vagrant" target="_blank" rel="noopener">vagrant</a> 是一款非常简单且使用的虚拟机命令行工具，支持市面上主流虚拟机，当然包括 VBox，通过下面的命令即可安装一个干净的 Ubuntu 环境：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant <span class="keyword">init</span> hashicorp/precise32</span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure></p><p>为了方便今后操作，我自己制作了一个基于 debian8 的 box，安装上了 <a href="https://app.vagrantup.com/jiacai2050/boxes/debian8" target="_blank" rel="noopener">Clojure 开发环境</a>，一键即可安装。</p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2aVGdcNlmpuFjSZPfXXc9iXXa_!!581166664.png" alt="Virtualbox"></p><h3 id="系统快捷键"><a href="#系统快捷键" class="headerlink" title="系统快捷键"></a>系统快捷键</h3><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>查看桌面</td><td><code>F11</code></td></tr><tr><td>查看Dashboard</td><td><code>F12</code></td></tr><tr><td>HOME</td><td><code>Command + &lt;-</code></td></tr><tr><td>END</td><td><code>Command + -&gt;</code></td></tr><tr><td>锁屏</td><td><code>Shift + Control + 电源键</code> （Windows 下为<code>Win+L</code>）</td></tr><tr><td>强制关闭程序</td><td><code>Command + Option + esc</code>（Windows 下为<code>Ctrl+Alt+Delete</code>）</td></tr><tr><td><a href="https://apple.stackexchange.com/questions/193937/shortcut-for-toggling-between-different-windows-of-same-app" target="_blank" rel="noopener">在同一应用不同窗口切换</a></td><td><code>Command + ~</code></td></tr><tr><td><a href="http://apple.stackexchange.com/questions/12391/why-is-it-not-possible-to-use-the-cut-command-to-manipulate-a-file-in-the-find" target="_blank" rel="noopener">Finder 里面剪切</a></td><td><code>Cmd + Option + V</code></td></tr></tbody></table><h3 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 修改hostname</span></span><br><span class="line">sudo scutil --<span class="keyword">set</span> HostName &lt;name&gt;</span><br><span class="line"><span class="meta"># 查看USB设备</span></span><br><span class="line">system_profiler SPUSBDataType</span><br></pre></td></tr></table></figure><p>下面的命令需要通过<code>brew</code>进行安装后在使用<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络请求</span></span><br><span class="line">brew install httpstat</span><br><span class="line">$ httpstat baidu.com</span><br><span class="line">Connected <span class="keyword">to</span> 180.149.132.47:80 <span class="keyword">from</span> 172.17.10.80:54727</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 14 Jan 2017 13:49:16 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">ETag: <span class="string">"51-47cf7e6ee8400"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 81</span><br><span class="line">Cache-Control: <span class="attribute">max-age</span>=86400</span><br><span class="line">Expires: Sun, 15 Jan 2017 13:49:16 GMT</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">Body stored <span class="keyword">in</span>: /var/folders/2g/fxz_98ks0lgc79sjp5vn5cxc0000gn/T/tmpsawHq4</span><br><span class="line"></span><br><span class="line"> <span class="built_in"> DNS </span>Lookup   TCP<span class="built_in"> Connection </span> <span class="built_in"> Server </span>Processing   Content Transfer</span><br><span class="line">[    69ms    |      37ms      |       33ms        |        0ms       ]</span><br><span class="line">             |                |                   |                  |</span><br><span class="line">    namelookup:69ms           |                   |                  |</span><br><span class="line">                        connect:106ms             |                  |</span><br><span class="line">                                      starttransfer:139ms            |</span><br><span class="line">                                                                 total:139ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># Swiss Army Knife for macOS !</span></span><br><span class="line">brew install m-cli</span><br><span class="line">$ m trash status</span><br><span class="line">Size:  51G</span><br><span class="line">Number of files: 252172</span><br></pre></td></tr></table></figure></p><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><p>日常使用的软件首选通过<code>App Store</code>进行安装，默认安装在<code>/Applications</code>下，个人从互联网上单独下载的软件放在这里面即可出现在<code>Launchpad</code>中找到。<br>对于通过<code>App Store</code>安装的软件，在<code>Launchpad</code>界面，按住<code>Option</code>键可进行删除。但是需要注意一点的时，应用程序一般都会有些历史文件，存放的位置有如下三处</p><ul><li><code>~/Library/Application Support/&lt;Application name&gt;</code></li><li><code>~/Library/Cache/&lt;Application name&gt;</code></li><li><code>~/Library/Preferences/&lt;Application name&gt;.plist</code></li></ul><p>使用<code>find + grep</code>的方式就能轻松找出来了。网上也有诸如<a href="http://appcleaner.en.softonic.com/mac" target="_blank" rel="noopener">AppCleaner</a>、<a href="http://www.appzapper.com/" target="_blank" rel="noopener">AppZapper</a>的小软件，大家可以根据需要自取之。</p><p>下面介绍下我日常使用的一些免费软件，供大家参考。</p><blockquote><p>PS: Mac 下有很多非常实用的收费软件，我个人用的并不多，这里就不在列举了。<br>大家可以参考知乎上的 <a href="https://www.zhihu.com/question/19550256" target="_blank" rel="noopener">macOS (OS X) 平台上有哪些值得推荐的常用软件？</a></p></blockquote><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>Mac 上自带的 Safari 比较轻量，虽然比较省电，但扩展性远不如 Chrome、Firefox，所以这两个是必须的。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>firefox</span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>google-chrome</span><br></pre></td></tr></table></figure></p><p>Chrome 默认会按照一个 Update 程序，在 <code>~/Library/Google/GoogleSoftwareUpdate</code>，可以执行<a href="https://superuser.com/a/1077420" target="_blank" rel="noopener">下面命令删除</a>：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/Users/</span>liujiacai<span class="regexp">/Library/</span>Google<span class="regexp">/GoogleSoftwareUpdate/</span>GoogleSoftwareUpdate.bundle<span class="regexp">/Contents/</span>Resources<span class="regexp">/GoogleSoftwareUpdateAgent.app/</span>Contents/Resources</span><br><span class="line"></span><br><span class="line">./ksinstall --nuke</span><br></pre></td></tr></table></figure></p><h3 id="图片截屏、合并"><a href="#图片截屏、合并" class="headerlink" title="图片截屏、合并"></a>图片截屏、合并</h3><p>Mac上的截图工具已经很好了，<code>Cmd + Shift + 3/4</code>就够用了，但是如果想在图片上写些文字，马赛克某部分，就不行了，推荐用 Snip，才 2M 大小，虽说是腾讯开发的，但是不流氓。可以设置快捷键，我设定的是<code>Cmd + Shift + 6</code>。<br>更重要的一点是，<a href="http://snip.qq.com/" target="_blank" rel="noopener">Snip</a> 可以解决Retina下截屏2x问题（就是截出来的图超大），就光这个特点就足以让你使用snip。</p><center><br><img width="500px" src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB2UXoxbFXXXXXnXXXXXXXXXXXX_!!581166664.png" alt="我的snip配置"><br></center><br>Mac自带的 Preview 可以对图片进行旋转、调整大小、添加文字，不需要在额外安装软件。<br><center><br><img src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB2KtMobFXXXXXkXpXXXXXXXXXX_!!581166664.png" alt="Preview工具栏"><br></center><p>此外，如果要对两张图片进行合并，需要通过安装 <a href="https://www.imagemagick.org" target="_blank" rel="noopener">ImageMagick</a>，并且通过以下命令操作：<a href="http://apple.stackexchange.com/a/52882/103966" target="_blank" rel="noopener">出处</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">brew</span> <span class="selector-tag">install</span> <span class="selector-tag">ImageMagick</span></span><br><span class="line"></span><br><span class="line"># 下面两条命令都会把 <span class="selector-tag">left</span><span class="selector-class">.png</span> <span class="selector-tag">right</span><span class="selector-class">.png</span> 合并到 <span class="selector-tag">merged</span><span class="selector-class">.png</span> 里面</span><br><span class="line"><span class="selector-tag">convert</span> +<span class="selector-tag">append</span> <span class="selector-tag">left</span><span class="selector-class">.png</span> <span class="selector-tag">right</span><span class="selector-class">.png</span> <span class="selector-tag">merged</span><span class="selector-class">.png</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">montage</span> <span class="selector-tag">-geometry</span> 100% <span class="selector-tag">left</span><span class="selector-class">.jpg</span> <span class="selector-tag">right</span><span class="selector-class">.jpg</span> <span class="selector-tag">merged</span><span class="selector-class">.jpg</span></span><br></pre></td></tr></table></figure><p>如果你依赖于Evernote，可以试试<a href="https://www.yinxiang.com/skitch/" target="_blank" rel="noopener">圈点</a>，洋名skitch，同样很好很强大。</p><h3 id="录屏-gif"><a href="#录屏-gif" class="headerlink" title="录屏 gif"></a>录屏 gif</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>licecap</span><br></pre></td></tr></table></figure><p>很多时候我们需要把自己的操作展示给别人看，比较好的做法是通过录屏软件将自己的操作保存成 gif 格式的图片。<br><a href="https://github.com/lepht/licecap" target="_blank" rel="noopener">开源免费</a>的<a href="http://www.cockos.com/licecap/" target="_blank" rel="noopener">licecap</a> 很好的解决了这个问题。</p><p><img src="http://ww3.sinaimg.cn/mw690/5fee18eegw1f17799uiz1g20ci0cijs2.gif" alt="使用 licecap 制作的例子"></p><h3 id="流程图制作工具"><a href="#流程图制作工具" class="headerlink" title="流程图制作工具"></a>流程图制作工具</h3><p>对于程序员来说，流程图应该是再亲切不过的了，一张图胜过千言万语。之前我都是用 Keynote 来画，但是实在是不好用，<del>后来在<a href="https://www.zhihu.com/question/19588698" target="_blank" rel="noopener">知乎</a>上发现了在线版的<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>，大大减少了我画流程图的时间，上手也比较快。</del>现在 ProcessOn 有了限制，只能保留 9 张流程图。我又找到了新的工具，<a href="https://www.draw.io" target="_blank" rel="noopener">draw.io</a>，时序图、状态图统统不在话下。</p><p>其次，国外很多项目的图是用纯文本画的，比较好用的在线工具是：<a href="http://asciiflow.com/" target="_blank" rel="noopener">asciiflow</a>。</p><h3 id="Calibre-mobi-转化器"><a href="#Calibre-mobi-转化器" class="headerlink" title="Calibre mobi 转化器"></a>Calibre mobi 转化器</h3><p>如果你有 Kinder 阅读器，那么这个应该适合你！<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 安装命令</span><br><span class="line">brew cask install calibre</span><br><span class="line"></span><br><span class="line">=<span class="ruby">=&gt; Installing Cask calibre</span></span><br><span class="line"><span class="ruby">==&gt; Moving App <span class="string">'calibre.app'</span> to <span class="string">'/Applications/calibre.app'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'calibre'</span> to <span class="string">'/usr/local/bin/calibre'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'calibre-complete'</span> to <span class="string">'/usr/local/bin/calibre-complete'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'calibre-customize'</span> to <span class="string">'/usr/local/bin/calibre-customize'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'calibre-debug'</span> to <span class="string">'/usr/local/bin/calibre-debug'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'calibre-parallel'</span> to <span class="string">'/usr/local/bin/calibre-parallel'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'calibre-server'</span> to <span class="string">'/usr/local/bin/calibre-server'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'calibre-smtp'</span> to <span class="string">'/usr/local/bin/calibre-smtp'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'calibredb'</span> to <span class="string">'/usr/local/bin/calibredb'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'ebook-convert'</span> to <span class="string">'/usr/local/bin/ebook-convert'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'ebook-device'</span> to <span class="string">'/usr/local/bin/ebook-device'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'ebook-edit'</span> to <span class="string">'/usr/local/bin/ebook-edit'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'ebook-meta'</span> to <span class="string">'/usr/local/bin/ebook-meta'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'ebook-polish'</span> to <span class="string">'/usr/local/bin/ebook-polish'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'ebook-viewer'</span> to <span class="string">'/usr/local/bin/ebook-viewer'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'fetch-ebook-metadata'</span> to <span class="string">'/usr/local/bin/fetch-ebook-metadata'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'lrf2lrs'</span> to <span class="string">'/usr/local/bin/lrf2lrs'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'lrfviewer'</span> to <span class="string">'/usr/local/bin/lrfviewer'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'lrs2lrf'</span> to <span class="string">'/usr/local/bin/lrs2lrf'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'markdown-calibre'</span> to <span class="string">'/usr/local/bin/markdown-calibre'</span>.</span></span><br><span class="line"><span class="ruby">==&gt; Linking Binary <span class="string">'web2disk'</span> to <span class="string">'/usr/local/bin/web2disk'</span>.</span></span><br></pre></td></tr></table></figure></p><h3 id="视频播放器、截取"><a href="#视频播放器、截取" class="headerlink" title="视频播放器、截取"></a>视频播放器、截取</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>vlc</span><br></pre></td></tr></table></figure><p>Mac下的自带的播放器QuickTime，功能实在是太弱了，支持的格式既少又难用，快进什么的貌似都没快捷键，只能手动点击进度条，试用了一段时间的<a href="http://mplayerosx.ch/" target="_blank" rel="noopener">Mplayer</a>，发现效果也不好，会有视频卡顿的现象，最终选择了 <a href="http://www.videolan.org/vlc/download-macosx.html" target="_blank" rel="noopener">VLC</a>，一直用的还不错。<br>此外， 有网友补充道 <a href="https://mpv.io/" target="_blank" rel="noopener">mpv</a> 才是程序员最佳播放器，大家也可以尝试下。</p><p>很多时候，我们只需要截取视频中的某一段视频，或者简单的进行格式转换，这时候就需要 ffmpeg 出马了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 安装命令</span><br><span class="line"><span class="selector-tag">brew</span>  <span class="selector-tag">install</span> <span class="selector-tag">ffmpeg</span></span><br><span class="line"></span><br><span class="line"># 将 <span class="selector-tag">mov</span> 格式的视频转为 <span class="selector-tag">mp4</span>，<span class="selector-tag">ffmpeg</span> 能根据文件后缀名自动识别</span><br><span class="line"><span class="selector-tag">ffmpeg</span>  <span class="selector-tag">-i</span> <span class="selector-tag">foo</span><span class="selector-class">.mov</span> <span class="selector-tag">foo</span><span class="selector-class">.mp4</span></span><br><span class="line"># 从第 6 秒开始，截取10<span class="selector-tag">s</span> 视频，并且转为 <span class="selector-tag">mp4</span> 格式</span><br><span class="line"><span class="selector-tag">ffmpeg</span> <span class="selector-tag">-t</span> 10 <span class="selector-tag">-ss</span> 00<span class="selector-pseudo">:00</span><span class="selector-pseudo">:06</span> <span class="selector-tag">-i</span> <span class="selector-tag">foo</span><span class="selector-class">.mov</span> <span class="selector-tag">smaller</span><span class="selector-class">.mp4</span></span><br></pre></td></tr></table></figure></p><h3 id="音乐频播放器"><a href="#音乐频播放器" class="headerlink" title="音乐频播放器"></a>音乐频播放器</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>vox</span><br></pre></td></tr></table></figure><p>官方的 iTunes 实在是不适应，喜欢简洁清爽的朋友可以试试 <a href="http://coppertino.com/" target="_blank" rel="noopener">VOX</a></p><h3 id="webarchive"><a href="#webarchive" class="headerlink" title="*.webarchive"></a>*.webarchive</h3><p>在windows下保存网页时，如果想把网页上的资源，比如css、js、image等一起下载下来，会单独生成个文件夹，但是用 Mac 上的 Safari 保存整个网页时，是以<code>webarchive</code>为后缀名的文件进行保存的，如何把打开这种文件呢？推荐：</p><p><a href="http://sourceforge.net/projects/webarchivext/" target="_blank" rel="noopener">http://sourceforge.net/projects/webarchivext/</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="不能写-NTFS"><a href="#不能写-NTFS" class="headerlink" title="不能写 NTFS"></a>不能写 NTFS</h3><p>用惯了 Windows 的大家都习惯用 NTFS 文件系统格式，但是很遗憾，这个文件系统是微软自己搞得，不是开放的，所以 Mac 是不支持的，如果你以前的 NTFS 格式的硬盘放到 Mac 上，会发现只能进行读操作，不能写入，这属于正常现象，不要惊慌。</p><p>解决的方法也很简单，把移动硬盘格式化成FAT32(单个文件大小不能超过4G)或FAText 格式都可以，Mac 自带的磁盘工具就可以进行格式转化，当然你需要先把移动硬盘上的数据拷贝出来。</p><h3 id="Wi-Fi-时常中断"><a href="#Wi-Fi-时常中断" class="headerlink" title="Wi-Fi 时常中断"></a>Wi-Fi 时常中断</h3><p>Mac 生于乔帮主之手时，为了凸显尊贵，接口与一般的电脑有很大不同。常见的网线没办法直接连接 Mac 电脑，需要单独购买一个<a href="http://www.apple.com/cn/shop/product/MC704FE/A/apple-usb-ethernet-adapter" target="_blank" rel="noopener">以太网转接器</a>，所以大部分同学都是使用无线连接，但 Mac 这里应该是有个 bug，而且是很久的 bug，我用 Mac 两年了，偶尔会遇到几次，网上解决的方法有如下几种：</p><ol><li>修改网络位置，不是其默认的“自动”就好</li><li>修改路由器，把无线信道改为6或9</li><li>关闭蓝牙，Mac 中，同时打开蓝牙与 Wi-Fi 会冲突。<a href="http://apple.stackexchange.com/a/162406/103966" target="_blank" rel="noopener">详情</a></li></ol><p>如果你的 Mac 也遇到了 Wi-Fi 问题，可以试试上面三个解决方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>Once you get Mac, you never come back!</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://havee.me/mac/2014-01/os-x-tips-and-tricks.html" target="_blank" rel="noopener">OS X 的一些技巧汇总</a></li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul><li>2017/01/14，增加 emacs、dash、<code>brew cask</code>、<code>httpstat</code>、<code>m-cli</code></li><li>2017/06/03，增加 ffmpeg、asciiflow</li><li>2017/07/06，修改 iTerm2 部分，增加 docker</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MacBook 兼具命令行的高效与图形界面的酷炫，实在是程序员必备利器。本文主要介绍我在两年的使用过程中总结出的一些最佳实践，供大家参考、借鉴。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-mhke0kuv.qbox.me/cb49a18efb421a9624c
      
    
    </summary>
    
    
      <category term="最佳实践" scheme="http://liujiacai.net/tags/best-practice/"/>
    
  </entry>
  
  <entry>
    <title>让firefox与chrome一样快</title>
    <link href="http://liujiacai.net/blog/2014/11/08/secret-of-firefox-prefs/"/>
    <id>http://liujiacai.net/blog/2014/11/08/secret-of-firefox-prefs/</id>
    <published>2014-11-08T12:23:53.000Z</published>
    <updated>2019-12-24T10:59:14.598Z</updated>
    
    <content type="html"><![CDATA[<p>在如今这个Web时代，浏览器可以说是仅次于操作系统的软件了，各种应用都可以放到云端、移动端随时随地的使用，<a href="http://www.w3.org/TR/html5/" target="_blank" rel="noopener">HTML5标准</a>的最终版正式<a href="http://www.w3.org/blog/news/archives/4167" target="_blank" rel="noopener">发布</a>， 再次为使用Web技术开发跨平台应用奠定了基石。</p><p>HTML5现在是有统一标准了，但用户使用的浏览器可是五花八门了，身为程序员，IE可以忽略，一般linux下就是chrome与firefox，chrome快是快，就是太吃内存，所以在一些”老机器“上不敢用，下面就剩下firefox了，其实我自从看了《Code Rush》这个记录片以后，十分崇拜上个世纪有那么一群极客聚在一起，开发了很多促进了互联网发展的技术，以前我也写的文章<a href="/blog/2014/09/14/mozilla-history/">《Mozilla前世今生》</a>说过，这里就不在多说了。</p><p>但是不得不说的是firefox确实比chrome慢，有时候感觉chrome只需要一眨眼就能打开的网页，而firefox却要等上那么3、4秒，我真是无法忍受了。趁着这几天开发<a href="/gooreplacer/">gooreplacer</a>这个插件，又深入了解了下firefox一些工作机制，发现我们可以在不升级内存的情况下加速firefox打开网页的时间，我自己亲自实验了下，速度确实提了不少，现与大家分享之。</p><p>firefox的配置我们一般可以在”工具 -&gt; 选项“菜单中找到，但是还有一些配置项并不在这里，在firefox中地址栏输入about:config，回车，进入时应该会有个警告，忽略之，之后就应该能看到很多如下的配置项了。</p><p><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2L8ImaVXXXXcqXpXXXXXXXXXX_!!581166664.png" alt=" about-config截图"></p><p>这些配置项定义了很多浏览器的的默认参数，但不是全部，我们可以根据实际情况自己添加。使用上方的搜索输入框我们能够很容易地找到感兴趣的配置项。这里的配置项类型分三种：integer、boolean、string。这些配置项保存在本地一个叫prefs.js的文件中，prefs.js根据操作系统不同位置不同：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linxu</span></span><br><span class="line">~<span class="regexp">/.mozilla/firefox/</span>&lt;profile ID&gt;.<span class="keyword">default</span>/</span><br><span class="line"><span class="comment"># WinXP</span></span><br><span class="line">C:<span class="string">\Documents</span> <span class="keyword">and</span> Settings<span class="string">\&lt;username&gt;\Application</span> Data<span class="string">\Mozilla\Firefox\Profiles\&lt;profile</span> ID&gt;.<span class="keyword">default</span><span class="string">\</span></span><br></pre></td></tr></table></figure><p>需要说明一点的是，我们最好不要直接修改这个文件，如果非修改不可，<strong>最好事先备份一份</strong>。<br>如果你想找到你机器上prefs.js文件在哪里，使用操作系统自带的搜索功能就好了。linux上可以使用这个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~/.mozilla/firefox | grep prefs.js</span><br></pre></td></tr></table></figure></p><p>下面重点说一些能够改善用户体验的配置项。<br>事先说明一下，我这里只介绍了很小一部分配置项，更多的配置项以及每个配置项的含义大家可以在<a href="http://kb.mozillazine.org/Category:Preferences" target="_blank" rel="noopener">mozillazine</a>中找到。</p><h2 id="渲染-render-相关"><a href="#渲染-render-相关" class="headerlink" title="渲染(render)相关"></a>渲染(render)相关</h2><h3 id="减少渲染延迟"><a href="#减少渲染延迟" class="headerlink" title="减少渲染延迟"></a>减少渲染延迟</h3><p>创建一个整型配置项<code>nglayout.initialpaint.delay</code>，这个配置定义了firefox在下载完HTML、CSS等资源后，到真正开始渲染的时间间隔，如果不设置，默认为250毫秒。如果设置为0,就能在使浏览器立即渲染了。</p><p>后面有细心的读者疑问为什么要有这个延迟，去看<a href="http://kb.mozillazine.org/Nglayout.initialpaint.delay" target="_blank" rel="noopener">官方解释</a>就很清楚了:</p><blockquote><p>Since the start of a web page normally doesn’t have much useful information to display, Mozilla applications will wait a short interval before first rendering a page.</p></blockquote><h3 id="减少reflow次数"><a href="#减少reflow次数" class="headerlink" title="减少reflow次数"></a>减少reflow次数</h3><p>当firefox加载一个网页时，它会在加载过程中，根据加载的数据，不间断的对页面进行<a href="http://www.blueidea.com/tech/web/2007/4950.asp" target="_blank" rel="noopener">reflow</a>。创建一个整型配置项<code>content.notify.interval</code>，它能够控制两次reflow的间隔，它的单位是微秒，如果不设置，默认为120000（即0.12秒）。如果reflow次数过多，就会使得浏览器反应迟钝了，所以我们应该把这个值设的大些，500000（即0.5秒）或1000000（即1秒）都可以。<br>需要注意一点的是，如果要是<code>content.notify.interval</code>这个配置项生效，需要先创建一个布尔型的配置项<code>content.notify.ontimer</code>，并且设为true。<br>其次可以通过设置一个整型配置项<code>content.notify.backoffcount</code>控制reflow执行的最大次数，我这里设为5。</p><h3 id="控制”不响应“时间"><a href="#控制”不响应“时间" class="headerlink" title="控制”不响应“时间"></a>控制”不响应“时间</h3><p>在渲染一个网页时，firefox会间歇性地加速渲染过程，mozilla称之为tokenizing。但是这个加速是有代价的，在tokenizing过程中，浏览器不能响应用户的输入，tokenizing的时间长度是由一个整型配置项<code>content.max.tokenizing.time</code>控制的。一般来说，把这个配置项的值设为<code>content.notify.interval</code>值或者它的倍数。如果<code>content.max.tokenizing.time</code>的值小于<code>content.notify.interval</code>的值，浏览器就会因为过多响应用户输入而导致整个加载过程变慢。<br>需要注意一点的是，如果要是<code>content.max.tokenizing.time</code>这个配置项生效，需要先创建两个个布尔型的配置项<code>content.notify.ontimer</code>与<code>content.interrupt.parsing</code>，并且都设为true。</p><h3 id="控制”高响应“时间"><a href="#控制”高响应“时间" class="headerlink" title="控制”高响应“时间"></a>控制”高响应“时间</h3><p>在渲染一个页面时，用户如果进行了某些操作（比如向下滚动）时，firefox会预留更多的时间来响应用户的输入，这里的时间间隔是由一个整型配置项<code>content.switch.threshold</code>设置的。它的值一般是<code>content.notify.interval</code>的三倍，  但是如果我们把这个值调小些，这时firefox虽然对用户的响应不会那么及时，但是会明显加速页面的渲染过程。<br>如果你倾向于在网页加载完成后在进行操作（比如向下滚动），可以把<code>content.max.tokenizing.time</code>值设的大些，<code>content.switch.threshold</code>值设的小些；</p><h2 id="网络-network-相关"><a href="#网络-network-相关" class="headerlink" title="网络(network)相关"></a>网络(network)相关</h2><p>与网络相关的参数一样要慎重设置，否则你的CPU会飙升到90%以上。。。</p><h3 id="pipelining"><a href="#pipelining" class="headerlink" title="pipelining"></a>pipelining</h3><p>把<code>network.http.pipelining</code>与<code>network.http.proxy.pipelining</code>设置为true<br><code>network.http.pipelining.maxrequests</code>可根据实际情况设置，我电脑上是默认值32.</p><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>把<code>network.dns.disableIPv6</code>设为true，因为现在的网站都是ipv4,没听过那个网站是v6的。<br><code>network.dnsCacheEntries</code>，这个设置firefox最多保存dns的数目，可根据个人情况设置，我电脑上chrome大约缓存了1500多个，这是chrome快的原因之一。<br><code>network.dnsCacheExpiration</code>，dns的有限期限，单位为秒，可根据个人情况设置。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>与网络相关的配置项还有很多都是以<code>network.http.</code>，大家可自行修改之。</p><h2 id="内存（memory）相关"><a href="#内存（memory）相关" class="headerlink" title="内存（memory）相关"></a>内存（memory）相关</h2><h3 id="增大缓存空间"><a href="#增大缓存空间" class="headerlink" title="增大缓存空间"></a>增大缓存空间</h3><p>这里说的缓存空间可以用来缓存网页中的图片等资源，整型配置项<code>browser.cache.memory.capacity</code>设置了缓存的最大值，单位为KB，大家根据自己需求修改即可。<br>整型配置项<code>browser.cache.memory.max_entry_size</code>设置了最大缓存资源数。</p><p>需要注意的是，要是上面两个配置项生效，需要把布尔型配置项<code>browser.cache.memory.enable</code>设置为true。</p><p>查看当前firefox使用缓存的情况，可以在地址栏输入<code>about:cache?device=memory</code> 查看。</p><h3 id="减少历史记录"><a href="#减少历史记录" class="headerlink" title="减少历史记录"></a>减少历史记录</h3><p>firefox会把我们已经访问过得网页缓存起来，这样是加速我们下次打开的速度，但是默认的参数有些粗暴了，可以适当修改，毕竟这些东西都是占用内存的。主要有下面三个（如果某个配置项不存在，就用的是默认值）：</p><ul><li><code>browser.history_expire_days</code>这个配置项设置缓存失效的时间，默认为180，可以改为5天。</li><li><code>browser.history_expire_days_min</code>很明显，这是个配置项限制了最小的失效天数，默认90，可改为5</li><li><code>browser.history_expire_sites</code>这个配置项决定了，历史记录中可以最多存储多少个网站，默认为20000，还是觉得有些大了，可改为500</li></ul><h2 id="即时编译（JIT）"><a href="#即时编译（JIT）" class="headerlink" title="即时编译（JIT）"></a>即时编译（JIT）</h2><p>这里的JIT主要指的是JavaScript，我首次接触JIT还是在Java上，新版Android不也是通过JIT来提高系统的运行速度嘛。<br>firefox的JIT是通过<a href="https://wiki.mozilla.org/JavaScript:TraceMonkey" target="_blank" rel="noopener">TraceMonkey</a>这个JavaScript引擎实现的，这里主要有两个布尔型配置项：</p><ul><li><code>javascript.options.jit.content</code>，这个主要是用来JIT网页中的JS的，貌似默认就是true</li><li><code>javascript.options.jit.chrome</code>，这个主要是用来JIT扩展（XUL/chrome）中的JS的，默认好像没有这个配置项，我们可以手动创建，设置为true。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我发现firefox比chrome慢的原因是，很多配置项firefox设置的比较保守，这么做无非是照顾一些“老机器”了，把更多的选择权交给了用户；chrome的默认配置就比较简单暴力了，光是separate-process-per-tab这个就把大家电脑的内存占用了大半。Firefox的<a href="https://wiki.mozilla.org/Electrolysis" target="_blank" rel="noopener">E10 project也称Electrolysis</a>其实也对这项技术提供了支持，但是只在<a href="http://nightly.mozilla.org/" target="_blank" rel="noopener">nightly</a>版本上可用，因为这个技术会导致<a href="https://developer.mozilla.org/en-US/Add-ons/Working_with_multiprocess_Firefox" target="_blank" rel="noopener">很多插件无法使用</a>，所有没有集成到正式版上，firefox更看重软件的兼容性。<br>其实chrome自2008年9月发布，在很短的时间内就超过了firefox的市场份额，究其原因就是顺应了大家对“用户体验”的追求，硬件升级现在很简单，买个内存条也很便宜；而从上个世纪走过来的firefox，相比之下显得保守了，这也可以理解，毕竟早期大家的电脑配置都不高。大家有兴趣的可以去看看<a href="https://www.mozilla.org/en-US/firefox/releases/" target="_blank" rel="noopener">Firefox Release Notes</a>了解Firefox的版本更新信息。</p><p>Happy Hacking！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.computerworld.com/article/2541429/networking/hacking-firefox--the-secrets-of-about-config.html" target="_blank" rel="noopener">Hacking Firefox: The secrets of about:config</a></li><li><a href="http://wikimatze.de/making-firefox-as-fast-as-chrome/" target="_blank" rel="noopener">Making Firefox as Fast as Chrome</a></li><li><a href="https://www.wikivs.com/wiki/Chrome_vs_Firefox" target="_blank" rel="noopener">Chrome_vs_Firefox</a></li><li><a href="http://www.quora.com/Mozilla-Firefox-Why-hasnt-firefox-adopted-a-chrome-like-model-of-having-each-tab-as-a-separate-process" target="_blank" rel="noopener">Why-hasnt-firefox-adopted-tab-as-a-separate-process-like-chrome</a></li><li><a href="https://areweslimyet.com/" target="_blank" rel="noopener">Firefox memory benchmark</a></li><li><a href="http://www.kuqin.com/shuoit/20091006/70402.html" target="_blank" rel="noopener">如何优化Firefox才能比Chrome更快</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在如今这个Web时代，浏览器可以说是仅次于操作系统的软件了，各种应用都可以放到云端、移动端随时随地的使用，&lt;a href=&quot;http://www.w3.org/TR/html5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTML5标准&lt;/a&gt;的最终版
      
    
    </summary>
    
    
      <category term="mozilla" scheme="http://liujiacai.net/tags/mozilla/"/>
    
      <category term="最佳实践" scheme="http://liujiacai.net/tags/best-practice/"/>
    
  </entry>
  
  <entry>
    <title>编程语言的基石——Lambda calculus</title>
    <link href="http://liujiacai.net/blog/2014/10/12/lambda-calculus-introduction/"/>
    <id>http://liujiacai.net/blog/2014/10/12/lambda-calculus-introduction/</id>
    <published>2014-10-12T02:16:42.000Z</published>
    <updated>2019-12-24T10:59:14.598Z</updated>
    
    <content type="html"><![CDATA[<p>Lambda calculus我们一般称为<a href="http://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">λ演算</a>，最早是由<a href="http://en.wikipedia.org/wiki/Alonzo_Church" target="_blank" rel="noopener">邱奇（Alonzo Church，图灵的博导）</a>在20世纪30年代引入，当时的背景是解决<a href="http://en.wikipedia.org/wiki/Computable_function" target="_blank" rel="noopener">函数可计算的本质</a>性问题，初期λ演算成功的解决了在可计算理论中的<a href="http://en.wikipedia.org/wiki/Entscheidungsproblem" target="_blank" rel="noopener">判定性问题</a>，后来根据<a href="http://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis" target="_blank" rel="noopener">Church–Turing thesis</a>，证明了λ演算与图灵机是等价的。</p><p>好了，经过上边简单的介绍，大家应该对λ演算有了初步印象。下面我将重点介绍λ演算的具体内容，并且阐述λ演算是如何奠基了我们现在常用的编程语言（如：Java、python、Lisp等）。</p><h2 id="λ演算的语法与求值"><a href="#λ演算的语法与求值" class="headerlink" title="λ演算的语法与求值"></a>λ演算的语法与求值</h2><h3 id="语法-syntax"><a href="#语法-syntax" class="headerlink" title="语法(syntax)"></a>语法(syntax)</h3><p>因为λ演算研究的是函数的本质性问题，所以形式极其简单：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E = x           variables</span><br><span class="line">  | λx. E       <span class="function"><span class="keyword">function</span> <span class="title">creation</span><span class="params">(abstraction)</span></span></span><br><span class="line">  | E1 E2       <span class="function"><span class="keyword">function</span> <span class="title">application</span></span></span><br></pre></td></tr></table></figure></p><p>上面的E称为λ-表达式(expressions)或λ-terms，它的值有三种形式：</p><ol><li>变量(variables)。</li><li>函数声明或抽象(function creation/abstraction)。需要注意是的，函数中<strong>有且仅有</strong>一个参数。在λx. E中，x是参数，E是函数体</li><li>函数应用(function application)。也就是我们理解的函数调用，但官方术语就叫函数应用，本文后面也会采用“应用”的叫法。</li></ol><h4 id="λ表达式例子"><a href="#λ表达式例子" class="headerlink" title="λ表达式例子"></a>λ表达式例子</h4><p>上面就是λ演算的语法了，很是简单吧。下面看几个例子：</p><ol><li>恒等函数<br><code>λx.x</code></li><li>一个返回恒等函数的函数<br><code>λy. (λx.x)</code><br>可以看到，这里的y参数直接被忽略了</li></ol><p>在使用λ演算时，有一些惯例需要说一下：</p><ol><li><p>函数声明时，函数体尽可能的向右扩展。什么意思呢，举个例子大家就明白了</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">λ<span class="keyword">x</span>.<span class="keyword">x</span> λy.<span class="keyword">x</span> y z 应该理解为 λ <span class="keyword">x</span>. (<span class="keyword">x</span> (λy. ((<span class="keyword">x</span> y) z)))</span><br></pre></td></tr></table></figure></li><li><p>函数应用时，遵循左结合。在举个例子：<br>x y z 应该解释为 (x y) z</p></li></ol><h4 id="Currying带有多个参数的函数"><a href="#Currying带有多个参数的函数" class="headerlink" title="Currying带有多个参数的函数"></a>Currying带有多个参数的函数</h4><p>从上面我们知道，λ演算中函数只有一个参数，那两个参数的函数的是不是就没法表示了呢，那λ演算的功能也太弱了吧，这就是λ的神奇之处，函数在本质上只需要一个参数即可。如果想要声明多个参数的函数，通过currying技术即可。下面来说说currying。<br><code>λx y. (+ x y)----&gt;λx. (λ y. + x y)</code><br>上面这个转化就叫currying，它展示了，我们如何实现加法（这里假设+这个符号已经具有相加的功能，后面我们会讲到如何用λ表达式来实现这个+的功能）。<br>其实就是我们现在意义上的闭包——你调用一个函数，这个函数返回另一个函数，返回的函数中存储保留了调用函数的变量。currying是闭包的鼻祖。<br>如果用Python来表示就是这样的东西：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> y: x+y</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>)(<span class="number">3</span>) //<span class="keyword">return</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>如果用函数式语言clojure来表示就是：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> add [x]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [y] (<span class="name"><span class="builtin-name">+</span></span> x y)))</span><br><span class="line"></span><br><span class="line">((<span class="name">add</span> <span class="number">4</span>) <span class="number">3</span>) <span class="comment">;return 7</span></span><br></pre></td></tr></table></figure><h3 id="求值-evaluation"><a href="#求值-evaluation" class="headerlink" title="求值(evaluation)"></a>求值(evaluation)</h3><p>在λ演算中，有两条求值规则：</p><ol><li>Alpha equivalence( or conversion )</li><li>Beta reduction</li></ol><h4 id="Alpha-equivalence"><a href="#Alpha-equivalence" class="headerlink" title="Alpha equivalence"></a>Alpha equivalence</h4><p>这个比较简单也好理解，就是说λx.x与λy.y是等价的，并不因为换了变量名而改变函数的意义。<br>简单并不说这个规则不重要，在一些变量覆盖的场合很重要，如下这个例子：<br><code>λx. x (λx. x)</code>如果你这么写的话，第二个函数定义中的x与第一个函数定义中的x重复了，也就是在第二个函数里把第一个的x给覆盖了。<br>如果改为<code>λx. x (λy. y)</code>就不会有歧义了。</p><h4 id="Beta-reduction"><a href="#Beta-reduction" class="headerlink" title="Beta reduction"></a>Beta reduction</h4><p>这个规则是λ演算中函数应用的重点了。一句话来解释就是，把参数应用到函数体中。举一个例子：<br>有这么一个函数应用<code>(λx.x)(λy.y)</code>，在这里把<code>(λy.y)</code>带入前面函数的x中，就能得到最终的结果<code>(λy.y)</code>，这里传入一个函数，然后又返回一个函数，这就是最终的结果。</p><h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>考虑下面这个函数应用<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(λ y. (λ x. x) y) E</span><br></pre></td></tr></table></figure></p><p>有两种计算方法，如下图<br><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2fQf6aFXXXXa2XXXXXXXXXXXX_!!581166664.png" alt=" evaluation-order"><br>可以先计算内层的函数调用再计算外层的函数调用，反之也可。<br>根据<a href="http://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem" target="_blank" rel="noopener">Church–Rosser定理</a>，这两种方法是等价的，最终会得到相等的结果，如上图最后都得到了E。<br>但如果我们要自己实现一种语言，就有可能必选二选其一，于是有了下面两种方式：</p><ol><li><p>Call by Value(Eager Evaluation及早求值)<br>也就是上图中的inner，这种方式在函数应用前，就计算函数参数的值。如：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(λy. (λx. x)</span> y) <span class="comment">((λu. u)</span> <span class="comment">(λv. v)</span>) ---&gt;</span><br><span class="line"><span class="comment">(λy. (λx. x)</span> y) <span class="comment">(λv. v)</span>  ---&gt;</span><br><span class="line"><span class="comment">(λx. x)</span> <span class="comment">(λv. v)</span>  ---&gt;</span><br><span class="line">λv. v</span><br></pre></td></tr></table></figure></li><li><p>Call by Name (Lazy Evaluation惰性求值)<br>也就是上图中的outer，这种方式在函数应用前，不计算函数参数的值，直到需要时才求值。如：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(λy. (λx. x)</span> y) <span class="comment">((λu. u)</span> <span class="comment">(λv. v)</span>) ---&gt;</span><br><span class="line"><span class="comment">(λx. x)</span> <span class="comment">((λu. u)</span> <span class="comment">(λv. v)</span>) ---&gt;</span><br><span class="line"><span class="comment">(λu. u)</span> <span class="comment">(λv. v)</span> ---&gt;</span><br><span class="line">λv. v</span><br></pre></td></tr></table></figure></li></ol><p>值得一提的是，Call by Name这种方式在我们目前的语言中，只有函数式语言支持。</p><h2 id="λ演算与编程语言的关系"><a href="#λ演算与编程语言的关系" class="headerlink" title="λ演算与编程语言的关系"></a>λ演算与编程语言的关系</h2><p>在λ演算中只有函数（变量依附于函数而有意义），如果要用纯λ演算来实现一门编程语言的话，我们还需要一些数据类型，比如boolean、number、list等，那怎么办呢？<br>λ的强大又再一次展现出来，所有的数据类型都能用函数模拟出来，秘诀就是<br><code>不要去关心数据的值是什么，重点是我们能对这个值做什么操作</code>，然后我们用合法的λ表达式把这些操作表示出来即可。</p><p>听上去很些云里雾里，但看了我下面的讲解以后，你会发现，编程语言原来还可以这么玩，希望我能把这部分讲清楚些，个人感觉这些东西太funny了 :-)</p><p>好了，我们先从最简单——boolean的开始。</p><h3 id="编码Boolean"><a href="#编码Boolean" class="headerlink" title="编码Boolean"></a>编码Boolean</h3><p>Ask：我们能对boolean值做什么？<br>Answer：我们能够进行条件判断，二选其一。</p><p>好，知道了能对boolean的操作，下面就用λ表达式来定义它：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span> = λ<span class="keyword">x</span>. λy. <span class="keyword">x</span></span><br><span class="line"><span class="keyword">false</span> = λ<span class="keyword">x</span>. λy. y</span><br><span class="line">if E<span class="number">1</span> then E<span class="number">2</span> else E<span class="number">3</span> = E<span class="number">1</span> E<span class="number">2</span> E<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>来简单解释一下，boolean就是这么一个函数，它有两个参数（通过currying实现），返回其中一个。下面看个例子：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span> <span class="keyword">then</span> u <span class="keyword">else</span> v 可以写成   </span><br><span class="line">(λ<span class="function"><span class="title">x</span>. λy. x) u v ---&gt;</span> (λ<span class="function"><span class="title">y</span>. u) v ---&gt;</span> u</span><br></pre></td></tr></table></figure></p><p>哈哈，很神奇吧，更精彩的还在后头呢，继续</p><h3 id="编码pair"><a href="#编码pair" class="headerlink" title="编码pair"></a>编码pair</h3><p>这里简单解释下pair，其实就是序列对，如(1 2)、(hello world)，这些就是pair，只有两个元素，但不要小看了pair，我们用的list就是通过pair连接起来形成的。</p><p>Ask：我们能对pair做什么？<br>Answer：我们能够选择pair中的任意一个元素</p><p>好，知道了能对pair的操作，下面就用λ表达式来定义它：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkpair x y = λ<span class="selector-tag">b</span>. (<span class="selector-tag">b</span> x y)</span><br><span class="line">fst <span class="selector-tag">p</span>      = <span class="selector-tag">p</span> true</span><br><span class="line">snd <span class="selector-tag">p</span>      = <span class="selector-tag">p</span> false</span><br></pre></td></tr></table></figure></p><p>这里用到了true与false的编码。解释一下：<br>pair就是这么一个函数，参数是一个boolean值，根据这个参数确定返回值。还是看例子：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fst</span> (mkpair x y)---&gt;</span>(<span class="function"><span class="title">mkpair</span> x y) <span class="literal">true</span>---&gt;</span><span class="function"><span class="title">true</span> x y---&gt;</span>x</span><br></pre></td></tr></table></figure></p><p>这样我们就能取到pair的第一个元素了。很好玩吧，下面的更有趣，继续</p><h3 id="编码number"><a href="#编码number" class="headerlink" title="编码number"></a>编码number</h3><p>这里讲的number是指的自然数。</p><p>Ask：我们能对number做什么？<br>Answer：我们能够依次遍历这些数字</p><p>好，知道了能对number的操作，下面就用λ表达式来定义它：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> = λf. λs. s</span><br><span class="line"><span class="number">1</span> = λf. λs. f s</span><br><span class="line"><span class="number">2</span> = λf. λs. f (f s)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>解释一下，利用currying，我们知道上面的定义其实相当于一个具有两个参数的函数：一个函数f，另一个是起始值s，然后不断应用f实现遍历数字的操作。先不要管为什么这么定义，看了下面我们如何定义加法乘法的例子你应该就会豁然开朗了：<br>首先我们需要定义一个后继函数(The successor function)<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">succ <span class="built_in">n</span> = λf. λs. f (<span class="built_in">n</span> f s)</span><br></pre></td></tr></table></figure></p><p>然后，就可以定义加法与乘法了<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add <span class="symbol">n1</span> <span class="symbol">n2</span> = <span class="symbol">n1</span> succ <span class="symbol">n2</span></span><br><span class="line">mult <span class="symbol">n1</span> <span class="symbol">n2</span> = <span class="symbol">n1</span> <span class="comment">(add n2)</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>只看定义要想弄懂应该还是有些困难，下面看个具体的例子：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add <span class="number">0</span> = <span class="comment">(λn1. λn2. n1 succ n2)</span> <span class="number">0</span>  <span class="comment">// 这里直接根据上面 add 定义进行展开</span></span><br><span class="line"> </span><br><span class="line">-------将 <span class="number">0</span> 带入 <span class="symbol">n1</span>，可得--------&gt;</span><br><span class="line">λ<span class="symbol">n2</span>. <span class="number">0</span> succ <span class="symbol">n2</span> = λ<span class="symbol">n2</span>. <span class="comment">(λf. λs. s)</span> succ <span class="symbol">n2</span> </span><br><span class="line"> </span><br><span class="line">-------将 succ 带入 f，<span class="symbol">n2</span> 带入 s，可得--&gt;</span><br><span class="line">λ<span class="symbol">n2</span>. <span class="symbol">n2</span> = λx. x</span><br></pre></td></tr></table></figure></p><p>我第一次看这个例子有个疑问，add不是两个参数吗，你怎么就加一个0呢？其实还是currying没理解好，两个参数的函数内部不也是用一个参数的函数来表示的嘛，如果只传递一个参数，那么我们就知道还会返回一个函数，本例中就是<code>λx. x</code>，这是恒等函数，也就是说加 0 ,相当于什么也没加，还是本身。</p><p>哈哈，看来也不过如此嘛，如果你能看到这里，说明你已经对lambda掌握的差不多了。下面再来看个“难点”的例子——<code>1+1</code>：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span> 1 1 ---&gt;</span></span><br><span class="line"><span class="number">1</span> <span class="function"><span class="title">succ</span> 1 ---&gt;</span></span><br><span class="line"><span class="function"><span class="title">succ</span> 1 ---&gt;</span></span><br><span class="line">λ<span class="function"><span class="title">f</span>. λs. f (f s) ---&gt;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>最后一个例子，<code>2*2</code>：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mult</span> 2 2 ---&gt;</span></span><br><span class="line"><span class="number">2</span> (<span class="function"><span class="title">add</span> 2) 0 ---&gt;</span></span><br><span class="line">(<span class="function"><span class="title">add</span> 2) ((add 2) 0) ---&gt;</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="title">succ</span> (add 2 0) ---&gt;</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="title">succ</span> (2 succ 0) ---&gt;</span></span><br><span class="line"><span class="function"><span class="title">succ</span> (succ (succ (succ 0))) ---&gt;</span></span><br><span class="line"><span class="function"><span class="title">succ</span> (succ (succ (λf. λs. f (0 f s)))) ---&gt;</span></span><br><span class="line"><span class="function"><span class="title">succ</span> (succ (succ (λf. λs. f s))) ---&gt;</span></span><br><span class="line">succ (succ (λg. λy. g ((λf. λs. f s) g y)))</span><br><span class="line"><span class="function"><span class="title">succ</span> (succ (λg. λy. g (g y))) ---&gt;</span>......---&gt; λg. λy. g (g (g (g y))) = <span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>不要一看到这么多步骤就吓跑了，原则很简单，就是不断进行函数应用，需要注意的就是这里的2、0不再是单纯的数字了，它是从具有两个参数的函数，如果你应用时只传入一个参数，说明它还会返回一个函数。</p><p>不管怎样，如果你已经看到了这里，我希望你能把上面这个乘法的例子看懂，就是不断进行函数应用而已，没什么东西，我觉得难点在于思维的转化，因为以前都很理所当然认为2×2=4了，而不知道这么简单的计算后面的本质性东西，通过这个例子，希望大家能明确一点：<code>值是什么不重要，重要的是我们能对这个值进行的操作</code>。</p><p>最后再来一个收尾菜：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">如果想要判断一个数字是否为0，可以这么定义</span>                </span><br><span class="line"><span class="string">iszero</span> <span class="string">n</span> <span class="string">=</span> <span class="string">n</span> <span class="string">(λb.</span> <span class="literal">false</span><span class="string">)</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="λ-演算与图灵机"><a href="#λ-演算与图灵机" class="headerlink" title="λ-演算与图灵机"></a>λ-演算与图灵机</h2><p>本文一开始就说明了，λ-演算与图灵机是等价，这里简单说下我对图灵机的理解：</p><blockquote><p>在一个不限时间、不限资源的前提下，图灵机通过前进、后退、跳转、输出1或0这四个简单的命令，在一条无限长的纸带上执行事先编好的程序。</p></blockquote><p>根据目前的证明，图灵机是宇宙间最强大的机器（理想中的），我们现有的计算机都没有超过图灵机。</p><p>如果说一个语言是图灵完备的，就是说，世界上任何可计算性问题，它都能解决。</p><p>我们现有的命令式语言，如C、Java等就是以图灵机为基础的。如果说这些语言图灵完备，需要具有以下两个特征：</p><ol><li>有if、goto语句（或while、for之类的循环语句）</li><li>能够进行赋值操作（也就是改变内存状态）</li></ol><p>与图灵机对应，λ-演算的直接影响是函数式编程语言，如lisp、Haskell等，如果说这些函数式语言图灵完备，需要有以下两个特征：</p><ol><li>能够进行函数抽象（也就是函数定义）</li><li>能够进行函数应用（也就是函数调用）</li></ol><p>鉴别一个语言是不是函数式的标准是：这个语言能否在运行时创建函数，如果能，就是函数式语言。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面长篇大论（希望你能抽时间看完），我们用一些无意义符号表达了我们已经熟知的一些概念，这就是λ演算的精髓之处，通过一套形式化的规则来描述这些东西，要知道，这里面的很多东西我们现如今想当然的接受了，但如何让笨重的计算机来理解这个世界呢，这就需要这些形式化的规则来指导了。</p><p>我这里介绍的lambda calculus并不完全，只是其中的一部分，像<a href="http://en.wikipedia.org/wiki/Lambda_calculus#Recursion_and_fixed_points" target="_blank" rel="noopener">递归</a>这个重要的东西就没说，大家凭借兴趣再自己去看吧，我觉得我这篇文章就是个砖头，希望能引出大家的宝玉就好。</p><p>我们现在的编程语言趋向于多范式化，像python、ruby的兴起就说明了这点。<br>因为纯函数式语言不能改变变量状态，这个恐怕在很多场合不适用吧。<br>纯OO也不好，因为我们大多数程序员，都是用OO的语言来写过程式的程序，看看大家有多Helper类，Util类就明白了。</p><p>有了对 lambda 的认识后，就可以尝试下一个主题了——Y 算子，下面给出我觉得讲解的最好的一篇文章：</p><ul><li><a href="http://shellfly.org/blog/2015/01/07/yi-the-y-combinator-slight-return/" target="_blank" rel="noopener">(译) The Y combinator (Slight Return)</a></li></ul><p>最后，推荐王垠的一篇文章，以飨读者：</p><ul><li><a href="http://geek.csdn.net/news/detail/3603" target="_blank" rel="noopener">面向对象编程和函数式编程的问题出在哪里？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lambda calculus我们一般称为&lt;a href=&quot;http://en.wikipedia.org/wiki/Lambda_calculus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;λ演算&lt;/a&gt;，最早是由&lt;a href=&quot;http://en
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="Lambda" scheme="http://liujiacai.net/tags/lambda/"/>
    
      <category term="Lisp" scheme="http://liujiacai.net/tags/lisp/"/>
    
  </entry>
  
  <entry>
    <title>Mozilla 前世今生</title>
    <link href="http://liujiacai.net/blog/2014/09/14/mozilla-history/"/>
    <id>http://liujiacai.net/blog/2014/09/14/mozilla-history/</id>
    <published>2014-09-13T16:14:52.000Z</published>
    <updated>2019-12-24T10:59:14.597Z</updated>
    
    <content type="html"><![CDATA[<p>用过 Firefox 的同学多多少少都应该对 Mozilla 有些了解，Mozilla 作为一老牌软件公司，诞生了很多传奇性的故事和人物，现在就让我们一起来探索上个世纪九十年代发生的那些激荡人心的时刻吧。</p><p>Mozilla这个词有三个含义:</p><ol><li>以开发Firefox浏览器出名的<a href="http://en.wikipedia.org/wiki/Mozilla" target="_blank" rel="noopener">软件套件</a>，除此之外，产品还有<a href="http://en.wikipedia.org/wiki/Mozilla_Thunderbird" target="_blank" rel="noopener">Thunderbird</a>、 <a href="http://en.wikipedia.org/wiki/Firefox_Mobile" target="_blank" rel="noopener">Firefox_Mobile</a>、<a href="http://en.wikipedia.org/wiki/Firefox_OS" target="_blank" rel="noopener">Firefox OS</a></li><li>指<a href="http://en.wikipedia.org/wiki/Mozilla_Foundation" target="_blank" rel="noopener">Mozilla Foundation</a>，成立于2003-7-15,一个支持并且领导开发Mozilla项目的非盈利组织</li><li>指<a href="http://en.wikipedia.org/wiki/Mozilla_Corporation" target="_blank" rel="noopener">Mozilla Corporation</a>，成立于2005-8-3，是Mozilla Foundation的附属公司，创建Corporation的目的是解决Foundation税务相关的问题，其董事会成员很大部分都是Foundation的人员，这里不用区分这两个组织。</li></ol><p>要想了解Mozilla不的不提上个世纪末的<a href="http://en.wikipedia.org/wiki/Netscape_Communications_Corporation" target="_blank" rel="noopener">Netscape公司</a>与<a href="http://en.wikipedia.org/wiki/Browser_wars#First_browser_war" target="_blank" rel="noopener">第一次浏览器大战</a>,下面我就从1990年开始兴起的<a href="http://en.wikipedia.org/wiki/World_Wide_Web" target="_blank" rel="noopener">WWW</a>开始，简单说一下主流浏览器的发展过程。</p><p>WWW是一份<a href="http://www.w3.org/Proposal" target="_blank" rel="noopener">具有hypertext文档系统</a>，主要是为Internet设计，也就是我们现在看到的网页了，hypertext就是网页中的超链接，这份文档也提出了广为所知的URL、HTTP、HTML。<a href="http://en.wikipedia.org/wiki/Tim_Berners-Lee" target="_blank" rel="noopener">Tim Berners-Lee</a>被认为是WWW之父，Tim也设计出了世界上第一个浏览器<a href="http://en.wikipedia.org/wiki/WorldWideWeb" target="_blank" rel="noopener">WorldWideWeb</a>,当然，发布的第一版是命令行操作的，如下图：<br><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2N9C8apXXXXaoXXXXXXXXXXXX_!!581166664.gif" alt="WorldWideWeb"></p><p>Tim Berners-Lee同时还开发了Libwww这个接口，用以构建浏览器，Line Mode Browser、ViolaWWW、Erwise、MidasWWW和MacWWW等浏览器都是以Libwww为基础。</p><p>第一个具有GUI且较为通用的浏览器是<a href="http://en.wikipedia.org/wiki/Erwise" target="_blank" rel="noopener">Erwise</a>，之后一直到了1993年，<a href="http://en.wikipedia.org/wiki/Marc_Andreessen" target="_blank" rel="noopener"> Marc Andreessen</a>与他雇的全职程序员<a href="http://en.wikipedia.org/wiki/Eric_Bina" target="_blank" rel="noopener">Eric Bina</a>在<a href="http://en.wikipedia.org/wiki/University_of_Illinois_at_Urbana-Champaign" target="_blank" rel="noopener">UIUC</a>的<a href="http://en.wikipedia.org/wiki/National_Center_for_Supercomputing_Applications" target="_blank" rel="noopener">NCSA</a>开发出了<a href="http://en.wikipedia.org/wiki/Mosaic_%28web_browser%29" target="_blank" rel="noopener">Mosaic</a>，Andreessen也是在NCSA人是Time Berners-Lee的。当年Andreessen在UIUC毕业后去加州工作，在加州认识了<a href="http://en.wikipedia.org/wiki/James_H._Clark" target="_blank" rel="noopener">Jim Clark</a>,Clark觉得Mosaic非常有商业价值，想与Andreessen合作开个软件公司，就这样，<a href="http://en.wikipedia.org/wiki/Mosaic_Communications_Corporation" target="_blank" rel="noopener">Mosaic_Communications_Corporation</a>在1994年加州成立了，UIUC大学不满意他们的公司名字中有Mosaic（有可能侵犯了商标权），最后公司名字改为<a href="http://en.wikipedia.org/wiki/Netscape" target="_blank" rel="noopener">Netscape Communications</a>，旗舰(flagship)产品当然是<a href="http://en.wikipedia.org/wiki/Netscape_Navigator" target="_blank" rel="noopener">Netscape_Navigator</a>，值得一提的是，Navigator中没有使用NCSA Mosaic中的代码。</p><p>Netscape在1995年8月9号，IPO非常成功，股票由开始的每股$14，到最后涨的$28，翻了一倍。谁都没想到Netscape会一夜暴富。Andreessen也上了当年的<a href="http://content.time.com/time/covers/0,16641,1101960219,00.html" target="_blank" rel="noopener">Time Magazine封面</a>。</p><p>Netscape的口号是”the web is for everyone”，并声明他们的目标是为不同浏览器平台提供一致的浏览体验。大家不要忘了，这时候Microsoft在PC端发展迅猛，而且MS意识到Netscape的浏览器对他们是个潜在的定时炸弹，因为用户可以在任何操作系统上使用他们浏览器，也就是说用户从Windows切换到其他操作系统，基本没有什么障碍。可见Gates真的是个有远见的企业家，在1995年就遇见到现在移动互联网的情景了，瘦客户端的兴起，BS架构也逐渐替代CS架构。据某些不可考察的言论说：MS的行政领导曾在1995年6月拜访过Netscape，建议分割市场，即Windows上由MS来开发浏览器，其他操作系统由Netscape开发操作系统（当然否认了这些言论，如果为真的话，MS就触犯了反垄断法）。</p><p>MS在<a href="http://en.wikipedia.org/wiki/Windows_95" target="_blank" rel="noopener">Windows 95</a><a href="http://en.wikipedia.org/wiki/Microsoft_Plus!" target="_blank" rel="noopener">Plus Pack</a>上发行了<a href="http://en.wikipedia.org/wiki/Internet_Explorer" target="_blank" rel="noopener">Internet Explorer</a> 1.0，据曾经在Spyglass工作过的程序员<a href="http://en.wikipedia.org/wiki/Eric_Sink" target="_blank" rel="noopener">Eric Sink</a><a href="http://www.ericsink.com/Browser_Wars.html" target="_blank" rel="noopener">描述</a>：IE不是以NSCA Mosaic为基础的，而是由Spyglass开发的Mosaic版本，而Spyglass的版本是基于NSCA的。</p><p>MS为了迅速抢占市场，使用了软件捆绑，即在发布Windows时预装IE，而且是免费的，这样对Netscape来说无疑是重创，想想咱们中国的杀毒行业的360,不也是靠免费把金山、江民、瑞星等等给打的不成样子了嘛。</p><p>MS之后与Netscape展开了第一次浏览器大战，这两个公司都在通过不断研发新功能来争夺市场，但IE在财力、资源上更胜一筹，毕竟MS是靠卖Windows与Office挣钱的，而Netscape虽然也有其他产品，但主要的就是浏览器，无疑Netscape处于劣势。到IE3.0时，IE的功能基本就与Netscape Communicator的相当了，到IE4.0,Windows已经比Macintosh系统更为稳定。同时，MS开始研发Netscape其产品的替代品，像<a href="http://en.wikipedia.org/wiki/Internet_Information_Server" target="_blank" rel="noopener">IIS</a>,与Windows NT捆绑在一起。</p><p><a href="http://en.wikipedia.org/wiki/Netscape" target="_blank" rel="noopener">Netscape</a>在此期间研发出来现在依然广为使用的<a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">SSL</a>与<a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>。</p><p>Netscape直到1998年1月才向公众免费发放Netscape Navigator，而IE与IIS则一直是免费与Windows操作系统捆绑在一起的。</p><p>在MS与Netscape竞争时也有一些好玩的事，我这里说一件<a href="http://home.snafu.de/tilman/mozilla/stomps.html" target="_blank" rel="noopener">mozilla stomps IE</a>。</p><p>事情的简单经过就是MS在发布IE4.0时，把一个很大的IE logo（而且貌似是由“重”金属打造而成）在Netscape公司前面的草坪上，而且是在大晚上的，这样第二天有可能会有一些记者看到并且发表出来。但是事情显然没有MS想的那么简单，Netscape不仅在大晚上的就发现了，而且还把一个身高7英尺（大约2米多）Mozilla的卡通像放到IE logo上，并且Mozilla手上拿这着个牌子，上面写着“Netscape 72, Microsoft 18”，这是当时他们的市场份额。<br><img src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB23EOTapXXXXarXpXXXXXXXXXX_!!581166664.jpg" alt="mozilla-stomps-ie"></p><p>值得一提的是，在1998年1月，Netscape发动了<a href="http://en.wikipedia.org/wiki/Mozilla" target="_blank" rel="noopener">Mozilla</a>开源项目（哈哈，终于进入正题了），Mozilla这个名字是继Netscape Navigator代码号之后，由<a href="http://en.wikipedia.org/wiki/Mosaic_%28web_browser%29" target="_blank" rel="noopener">Mosaic</a>与<a href="http://en.wikipedia.org/wiki/Godzilla" target="_blank" rel="noopener">Godzilla</a>合成而来。<a href="http://en.wikipedia.org/wiki/Jamie_Zawinski" target="_blank" rel="noopener">Jamie Zawinski</a>说是在一次Netscape员工会议上<a href="http://www.davetitus.com/mozilla/" target="_blank" rel="noopener">想到这个名字的</a>。</p><p>Mozilla这个开源项目一开始的目的是为像Netscape这样的公司提供技术服务，而反过来Netscape这些公司可以把<a href="http://www-archive.mozilla.org/hacking/coding-introduction.html" target="_blank" rel="noopener">Mozilla的代码</a>商业化。</p><p>这里有个<a href="http://v.youku.com/v_show/id_XNjA2NDI2MTUy.html" target="_blank" rel="noopener">纪录片《Code Rush》</a>，记录的是1998年3月到1999年4月Netscape内部的一些真实情况，很值得一看。</p><p>很遗憾，Netscape这么一个由hacker组成的优秀公司也免不了被收购的命运，Netscape与AOL的收购谈判自1998年12月24号开始，到1999年3月17号结束，收购后很多优秀的程序员也选择了离开。</p><p>AOL接管Netscape之后也发布过几次Navigator的版本，但到2003年7月，AOL开始缩减开发Mozilla的投入，也就在这时候，<a href="http://www.mozilla.org/en-US/press/mozilla-foundation.html" target="_blank" rel="noopener">mozilla.org</a>应时而出，宣布成立Mozilla Foundation，这之后，Mozilla Foundation 放弃了Mozilla套件(suite)，转而研发功能独立的应用，主要就是<a href="http://en.wikipedia.org/wiki/Firefox" target="_blank" rel="noopener">Firefox</a>浏览器与<a href="http://en.wikipedia.org/wiki/Mozilla_Thunderbird" target="_blank" rel="noopener">Thunderbird</a>邮件客户端。</p><p>最近在移动互联网时代，Mozilla推出了<a href="http://en.wikipedia.org/wiki/Firefox_OS" target="_blank" rel="noopener">Firefox OS</a>，基于WEB的认证系统<a href="http://en.wikipedia.org/wiki/Mozilla_Persona" target="_blank" rel="noopener">Mozilla Persona</a>,以及为开发HTML5应用的marketplace。</p><p>不管怎么说，我还是很由衷的敬佩上个世纪末的这群有想法的hackers，一方面为了为技术而痴迷，另一方面为互联网的开阔奠定了基础。</p><p>最后我附上我在看纪录片<a href="http://www.imdb.com/title/tt0499004/" target="_blank" rel="noopener">《Code Rush》</a>的一些截图，光看到这些截图，我就能感到当时的火药味了。Enjoy :-)</p><p><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2_jO2apXXXXcHXXXXXXXXXXXX_!!581166664.png" alt=" Brendan-Eich"><br>没错，就是<a href="http://en.wikipedia.org/wiki/Brendan_Eich" target="_blank" rel="noopener">Eich这家伙</a>，用了10天时间开发出来JavaScript，其他一开始他是想把Scheme移植到Navigator上的,后来发现不行，于是js出来了</p><p><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2L4eSapXXXXbtXpXXXXXXXXXX_!!581166664.png" alt=" CEO-of-mozilla"><br><a href="http://en.wikipedia.org/wiki/Jim_Barksdale" target="_blank" rel="noopener">Jim Barksdale</a>在纪录片的第15分钟在审判微软垄断的法案时说的一段话：</p><blockquote><p>“How many of you use Intel-based PCs in this audience, not Macintoshes?” Most people in the room raised their hands. “Of that group who use PCs? How many of you use a PC without Microsoft’s operating system?”. All of the hands went down. He said to the Senate panel, “Gentlemen, that is a monopoly.”</p></blockquote><p><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2d4K0apXXXXX4XpXXXXXXXXXX_!!581166664.png" alt="Tara-Hernandez"><br><a href="http://www.linkedin.com/pub/tara-hernandez/3/b26/755" target="_blank" rel="noopener">Tara-Hernandez</a>这是当时的测试工程师吧，她负责Navigator上线前的最后检查。</p><p><img src="http://img02.taobaocdn.com/imgextra/i2/581166664/TB28GG4apXXXXb_XXXXXXXXXXXX_!!581166664.png" alt=" Jamie-Zawinski"><br><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2w7eVapXXXXacXpXXXXXXXXXX_!!581166664.png" alt=" Jamie-Zawinski自由开源软件布道师"><br><a href="http://en.wikipedia.org/wiki/Jamie_Zawinski" target="_blank" rel="noopener">Jamie-Zawinski</a>发型好帅，是个LISP程序员，<a href="http://www.xemacs.org/" target="_blank" rel="noopener">xemacs</a>、<a href="http://www.jwz.org/xscreensaver/" target="_blank" rel="noopener">xscreensaver</a>作者，<a href="http://www.jwz.org" target="_blank" rel="noopener">个人博客</a></p><p><img src="http://img02.taobaocdn.com/imgextra/i2/581166664/TB20A96apXXXXasXXXXXXXXXXXX_!!581166664.png" alt="Jim-Roskind"><br>哥，chrome快是快，但是你知道他有多占内存吗！<a href="http://www.roskind.com/" target="_blank" rel="noopener">个人博客</a></p><p><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2n.S1apXXXXXfXpXXXXXXXXXX_!!581166664.png" alt=" Scott-Collins"><br>比较低调的胖子，网上就找到这么<a href="http://arstechnica.com/information-technology/2004/06/collins-interview/" target="_blank" rel="noopener">一篇关于他的采访</a>。</p><p><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2oB5QapXXXXbYXpXXXXXXXXXX_!!581166664.png" alt=" Stuart-Parmenter"><br><img src="http://img02.taobaocdn.com/imgextra/i2/581166664/TB2e090apXXXXXxXpXXXXXXXXXX_!!581166664.png" alt=" Stuart-Pamener2"><br>又是一个牛叉的小胖子，<a href="https://blog.mozilla.org/blog/author/pavlovmozilla-com/" target="_blank" rel="noopener">Mozilla官方博客</a>，创办<a href="http://www.rise.us/" target="_blank" rel="noopener">rise</a>，并且是CTO。</p><p>好了，纪录片截图就这些，看完后我觉得你也一定会忍不住看一遍吧。Go ahead, buddy!</p><p>我从Mozilla开始，基本上把围绕Mozilla的一些重要的事情都整理了一边，大部分资料都来自<a href="http://en.wikipedia.org" target="_blank" rel="noopener">wikipedia</a>，最后我在副上一张图，让大家了解下浏览器发展史上百家争鸣的场面。</p><p><img src="/images/Timeline_of_web_browsers.svg" alt="Timeline_of_web_browsers" title="Timeline_of_web_browsers"><br>图比较大，建议大家保存到本地后慢慢品味。Enjoy！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用过 Firefox 的同学多多少少都应该对 Mozilla 有些了解，Mozilla 作为一老牌软件公司，诞生了很多传奇性的故事和人物，现在就让我们一起来探索上个世纪九十年代发生的那些激荡人心的时刻吧。&lt;/p&gt;
&lt;p&gt;Mozilla这个词有三个含义:&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="mozilla" scheme="http://liujiacai.net/tags/mozilla/"/>
    
  </entry>
  
  <entry>
    <title>Yarn概述</title>
    <link href="http://liujiacai.net/blog/2014/09/07/yarn-intro/"/>
    <id>http://liujiacai.net/blog/2014/09/07/yarn-intro/</id>
    <published>2014-09-07T14:07:51.000Z</published>
    <updated>2019-12-24T10:59:14.597Z</updated>
    
    <content type="html"><![CDATA[<p>Yarn是随着hadoop发展而催生的新框架，全称是Yet Another Resource Negotiator，可以翻译为“另一个资源管理器”。yarn取代了以前hadoop中jobtracker（后面简写JT）的角色，因为以前JT的任务过重，负责任务的调度、跟踪、失败重启等过程，而且只能运行mapreduce作业，不支持其他编程模式，这也限制了JT使用范围，而yarn应运而生，解决了这两个问题。</p><p>为了表述清楚，大家可以先看<a href="http://blog.csdn.net/jiacai2050/article/details/8656279" target="_blank" rel="noopener">hadoop版本说明</a>这篇文章，我这里要说的是hadoop2.0,也就是新增了yarn之后的版本。</p><h2 id="1-Yarn-或称MRv2"><a href="#1-Yarn-或称MRv2" class="headerlink" title="1. Yarn(或称MRv2)"></a>1. Yarn(或称MRv2)</h2><p>Yarn把jobtracker的任务分解开来，分为：</p><ul><li>ResourceManager（简写RM）负责管理分配全局资源</li><li>ApplicationMaster（简写AM），AM与每个具体任务对应，负责管理任务的整个生命周期内的所有事宜</li></ul><p>除了上面两个以外，tasktracker被NodeManager（简写NM）替代，RM与NM构成了集群的计算平台。这种设计允许NM上长期运行一些辅助服务，这些辅助服务一般都是应用相关的，通过配置项指定，在NM启动时加载。例如在yarn上运行mapreduce程序时，shuffle就是一个由NM加载起来的辅助服务。需要注意的是，在hadoop 0.23之前的版本，shuffle是tasktracker的一部分。</p><p>与每个应用相关的AM是一个框架类库，它与RM沟通协商如何分配资源，与NM协同执行并且监测应用的执行情况。在yarn的设计中，mapreduce只是一种编程模式，yarn还允许像MPI(message passing interface)，Spark等应用构架部署在yarn上运行。</p><h2 id="2-Yarn设计"><a href="#2-Yarn设计" class="headerlink" title="2. Yarn设计"></a>2. Yarn设计</h2><p><img src="http://img.blog.csdn.net/20140818230608465" width="550" height="500"><br>上图是一个典型的YARN集群。可以看到RM有两个主要服务：</p><ul><li>可插拔的Scheduler，只负责用户提交任务的调度</li><li>ApplicationsMaster的（简写AsM）负责管理集群中每个任务的ApplicationMaster（简写AM），负责任务的监控、失败重起等</li></ul><p>在hadoop1.0时，资源分配的单位是slot，再具体分为map的slot与reduce的slot，而且这些slot的个数是在任务运行前事先定义的，在任务运行过程中不能改变，很明显，这会造成资源的分配不均问题。在haodop2.0中，yarn采用了container的概念来分配资源。每个container由一些可以动态改变的属性组成，到现在为止，仅支持内存、cpu两种。但是yarn的这种资源管理方式是通用的，社区以后会加入更多的属性，比如网络带宽，本地硬盘大小等等。</p><h2 id="3-Yarn主要组件"><a href="#3-Yarn主要组件" class="headerlink" title="3. Yarn主要组件"></a>3. Yarn主要组件</h2><p>在这小节里，主要介绍yarn各个组件，以及他们之间是如何通信的。</p><h3 id="3-1-ClientRM"><a href="#3-1-ClientRM" class="headerlink" title="3.1 ClientRM"></a>3.1 Client<-->RM</--></h3><p><img src="http://img02.taobaocdn.com/imgextra/i2/581166664/TB2LOpuapXXXXXXXpXXXXXXXXXX_!!581166664.png_620x10000.jpg" width="450" height="400"></p><p>上面这个图是Client向RM提交任务时的流程。<br>(1) Client通过New Application Request来通知RM中的AsM组建<br>(2) AsM一般会返回一个新生成的全局ID，除此之外，传递的信息还有集群的资源状况，这样Client就可以在需要时请求资源来运行任务的第一个container即AM。<br>(3) 之后，Client就可以构造并发送ASC了。ASC中包括了调度队列，优先级，用户认证信息，除了这些基本的信息之外，还包括用来启动AM的CLC信息，一个CLC中包括jar包、依赖文件、安全token，以及运行任务过程中需要的其他文件。</p><p>经过上面这三步，一个Client就完成了一次任务的提交。之后，Client可以直接通过RM查询任务的状态，在必要时，可以要求RM杀死这个应用。如下图：<br><img src="http://img02.taobaocdn.com/imgextra/i2/581166664/TB2WzhzapXXXXbcXXXXXXXXXXXX_!!581166664.png_620x10000.jpg" width="450" height="400"></p><h3 id="3-2-RMAM"><a href="#3-2-RMAM" class="headerlink" title="3.2 RMAM"></a>3.2 RM<-->AM</--></h3><p>RM在收到Client端发送的ASC后，它会查询是否有满足其资源要求的container来运行AM，找到后，RM会与那个container所在机器上的NM通信，来启动AM。下面这个图描述了这其中的细节。<br><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB21l0xapXXXXcUXXXXXXXXXXXX_!!581166664.png"></p><p>(1) AM向RM注册，这个过程包括handshaking过程，并且传递一些信息，包括AM监听的RPC端口、用于监测任务运行状态的URL等。<br>(2) RM中的Scheduler部件做回应。这个过程会传递AM所需的信息，比如这个集群的最大与最小资源使用情况等。AM利用这些信息来计算并请求任务所需的资源。<br>(3) 这个过程是AM向RM请求资源。传递的信息主要包含请求container的列表，还有可能包含这个AM已经释放的container的列表。<br>(4) 在AM经过(3)请求资源之后，在稍微晚些时候，会把心跳包与任务进度信息发送给RM<br>(5) Scheduler在收到AM的资源请求后，会根据调度策略，来分配container以满足AM的请求。<br>(6) 在任务完成后，AM会给RM发送一个结束消息，然后退出。</p><p>在上面(5)与(6)之间，AM在收到RM返回的container列表后，会与每个container所在机器的NM通信，来启动这个container，下面就说说这个过程。</p><h3 id="3-2-AMNM"><a href="#3-2-AMNM" class="headerlink" title="3.2 AMNM"></a>3.2 AM<-->NM</--></h3><p><img src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB2FQ4AapXXXXaDXXXXXXXXXXXX_!!581166664.png"><br>(1) AM向container所在机器的NM发送CLC来启动container<br>(2)(3) 在container运行过程中，AM可以查询它的运行状态</p><h2 id="4-API"><a href="#4-API" class="headerlink" title="4. API"></a>4. API</h2><p>通过上面的描述，开发者在开发YARN上的应用时主要需要关注以下接口：</p><ul><li><p><a href="http://hadoop.apache.org/docs/stable/api/org/apache/hadoop/yarn/api/ApplicationClientProtocol.html" target="_blank" rel="noopener">ApplicationClientProtocol</a></p><blockquote><p>Client使用这个协议来与RM通信，来启动一个新应用，检查任务的运行状态或杀死任务</p></blockquote></li><li><p><a href="http://hadoop.apache.org/docs/stable/api/org/apache/hadoop/yarn/api/ApplicationMasterProtocol.html" target="_blank" rel="noopener">ApplicationMasterProtocol</a></p><blockquote><p>AM使用这个协议来向RM注册/撤销，请求资源来运行任务。</p></blockquote></li><li><p><a href="http://hadoop.apache.org/docs/stable/api/org/apache/hadoop/yarn/api/ContainerManagementProtocol.html" target="_blank" rel="noopener">ContainerManagementProtocol</a></p><blockquote><p>AM使用这个协议来与NM通信，来启动/停止container，查询container的状态。</p></blockquote></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>用户在使用hadoop1.0 API编写的MapReduce可以不用修改直接运行在yarn上，不过随着yarn的发展，向后兼容性还不知道怎么样。不管怎样，新的yarn平台绝对值得我们使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Yarn是随着hadoop发展而催生的新框架，全称是Yet Another Resource Negotiator，可以翻译为“另一个资源管理器”。yarn取代了以前hadoop中jobtracker（后面简写JT）的角色，因为以前JT的任务过重，负责任务的调度、跟踪、失败
      
    
    </summary>
    
      <category term="大数据" scheme="http://liujiacai.net/categories/bigdata/"/>
    
    
      <category term="hadoop" scheme="http://liujiacai.net/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>两个水壶问题</title>
    <link href="http://liujiacai.net/blog/2014/08/16/two-pot-question/"/>
    <id>http://liujiacai.net/blog/2014/08/16/two-pot-question/</id>
    <published>2014-08-16T05:04:37.000Z</published>
    <updated>2019-12-24T10:59:14.597Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述是这样的：<br>假设有一个池塘，里面有无穷多的水。现有2个空水壶a，b，其容积分别为6升和5升。如何只用这2个水壶从池塘里取得3升的水**（最后，这三升水，在其中一个壶里）。</p><p>这个问题不难，大家自己完成可以推理出来，但是如何让计算机程序自己推算出来呢？一般而言，想把计算机理解这些自然问题，需要某些数学理论作为支撑，这里突然想起前些天看<a href="http://www.ituring.com.cn/article/117596" target="_blank" rel="noopener">码农13期Lisp之父约翰•麦卡锡——不走寻常路的常识逻辑学家</a>的一段关于用逻辑描述事实的话：</p><blockquote><p>利用逻辑表达世界中的事实的进展一直都很缓慢。亚里士多德没有发明形式体系。莱布尼茨没有发明命题演算，尽管这种形式体系比他和牛顿同时发明的微积分更加简单。乔治·布尔发明了命题演算，却没有发明谓词演算。戈特洛布·弗雷格发明了谓词演算，但从未尝试过将非单调推理形式化。我想我们人类明白，要明确地表征我们思维过程中的各种事实，表面来看似乎简单，实际上是很困难的。</p></blockquote><p>我觉得大家可以在看完我这篇文章后去完整的看看这篇文章。</p><p>言归正转，接着说咱们的水壶问题。</p><p>看到这种类似的题目，我就特想知道，题目要求我们取得3升水，为什么不是2升或4升，这其中是不是说有些值取不到，换一个通俗说法，给了容量为a，b的两个水壶，能够取出（测量出）的水的体积可以是多少？是不是有个公式可以套用？</p><p>我觉得这种对于题目本身的反问对于理解题目本身十分有帮助，它能够有助于你看出题目到底想考查那部分数学知识，我们目前水平解决的问题都是有据可寻的，也就是说肯定是考查的对某一个或多个知识点的理解与运用（当然，牛人们遇到的问题可能需要自己创造新理论）。</p><p>把我上面的猜测用数学语言描述出来就是</p><blockquote><p>5x+6y=n   #我们这个题目n=3</p></blockquote><p>看到这里，如果你的数学还算可以，应该会想到数论中下的的定理：</p><blockquote><p>如果gcd(x,y) = 1  #gcd函数用以计算两个数的最大公约数greatest common divisor简写<br>那么肯定有整数（正的或负的）m与n，使得<br>mx + ny = 1</p></blockquote><p>大家从直观上也很好理解这个定理，两个数的线性组合肯定是能凑出它们的最大公约数的呀。</p><p>也就是说，如果这里的a，b两个水壶的体积互质，可以测量出的水的范围x是</p><blockquote><p>1&lt;=x&lt;=max(a,b)</p></blockquote><p>很多题目出的时候（比如本题），一般也都会让a，b互质，因为这样更具有一般性。</p><p>好了，现在我们知道在给定水壶容量为5升与6升的前提下，为什么能够测量出体积为3升的水了，下面就是如何如何操作了，处于21世纪的我们是幸运的，因为这个问题早在2000多年前，就被欧几里得给解决了。没错就是<a href="http://zh.wikipedia.org/wiki/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95" target="_blank" rel="noopener">辗转相除法</a>。这个方法大家早就在中学阶段就直接接触了，但这个算法本身所蕴涵的东西远比课本上那些公式来的深刻。但为了描述，还是要用公式，</p><blockquote><p>gcd(a,b)=gcd(b,a-b) #这里假设a&gt;b</p></blockquote><p>上面这个就是辗转相除法的精髓，简洁(simple)巧妙(ingenious)，而这就是<a href="http://www.oxforddictionaries.com/us/definition/american_english/elegant?q=elegant" target="_blank" rel="noopener">优雅（elegant）</a>。</p><p>把辗转相除法运用到我们的两个水壶a（6升），b（5升）上，就是不断把a的水向b里面倒，具体操作如下：</p><ol><li>查看a，b壶中水的体积是否为目标t（我们这个题目中t=3升），如果是，停止运算，否则到2</li><li>如果a壶空，就装满，否则，到3</li><li>如果b壶满，就把水倒掉，否则到4</li><li>尽可能多的从a壶向b壶倒水</li></ol><p>重复递归执行步骤1-4即可得到最终的结果。<br>这样做可行，原因可以从两方面讲：</p><ol><li>因为a，b壶容量互质，所以在不断重复1-4时肯定会测量出体积为1升的水来（我们这里可以判断1升水第一次出现一定在a壶里，因为6-5=1,也就是说只需要进行一边1-4步骤，就能够得到1升水）</li><li>为了得到我们的目标——3升水，我们从6-5=1这个算式分析，只要等号两边同时乘以3,就能得到我们的目标，所以说整个过程中，我们需要把空壶a加满3次，把装满水的b壶倒掉3次，就能得到结果。</li></ol><p>我想分析到这里，你也肯定是大腿一拍，“原来这么简单，小学数学嘛”！</p><p>但其实我们到这里只是成功了一半，因为gcd(a,b)=gcd(b,a)，对应我们这个题，就是说a壶向b壶倒能得到最终3升水，b向a倒也能得到最终的3升水。</p><p>这个问题看似简单，但其实这涉及到我们对数字，负数一些本质上的理解，我这里有收藏的<a href="http://pan.baidu.com/s/1i321Tvn" target="_blank" rel="noopener">Matrix67大神一个关于负数的视频</a>，大家可以自行看之，Matrix67这么总结了一句：负数的真正涵义是把减法变为加法。好了到这里一切明朗了，我从新整理一遍。</p><blockquote><p>gcd(5,6)=gcd(5,5+(-6))=gcd(6,5)=gcd(6,6+(-5))</p></blockquote><p>也就是说不管我们是从a向b倒水，还是从b向a倒水，其本质上进行的都是加法操作。如果你对这句话还是有疑问，想想Matrix67说的，什么样的动物有负数只腿吧。</p><p>通过上面的分析可以看到，我们解题的最终思路统一起来了，都是用的加法。再一次证明了优雅的含义——简洁巧妙。</p><p>理论部分算是说完了，下面编码实现了，我这里采用了Clojure语言，好久没用了，复习一下：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> gcd [a b]</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">zero?</span></span> b)</span><br><span class="line">    a</span><br><span class="line">    (<span class="name"><span class="builtin-name">recur</span></span> b (<span class="name"><span class="builtin-name">rem</span></span> a b))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> pot [target a-vol b-vol]</span><br><span class="line">  (<span class="name"><span class="builtin-name">letfn</span></span> [(<span class="name">solve</span> [a-current-vol b-current-vol]</span><br><span class="line">            (<span class="name"><span class="builtin-name">let</span></span> [pour-volumn (<span class="name"><span class="builtin-name">min</span></span> a-current-vol (<span class="name"><span class="builtin-name">-</span></span> b-vol b-current-vol))] <span class="comment">;; 返回a壶能够向b壶倒入的最大值</span></span><br><span class="line">              (<span class="name">println</span> <span class="string">" -&gt; "</span> a-current-vol <span class="string">" "</span> b-current-vol)</span><br><span class="line">              (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">                (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">=</span></span> a-current-vol target) (<span class="name"><span class="builtin-name">=</span></span> b-current-vol target)) (<span class="name">println</span> <span class="string">"------- OK! ------"</span>)</span><br><span class="line">                (<span class="name"><span class="builtin-name">=</span></span> a-current-vol <span class="number">0</span>) (<span class="name"><span class="builtin-name">do</span></span> (<span class="name">print</span> <span class="string">"Fill A full"</span>) (<span class="name">solve</span> a-vol b-current-vol))</span><br><span class="line">                (<span class="name"><span class="builtin-name">=</span></span> b-current-vol b-vol) (<span class="name"><span class="builtin-name">do</span></span> (<span class="name">print</span> <span class="string">"Empty pot B"</span>) (<span class="name">solve</span> a-current-vol <span class="number">0</span>))</span><br><span class="line">                <span class="symbol">:else</span> (<span class="name"><span class="builtin-name">do</span></span> (<span class="name">print</span> <span class="string">"Pour A to B"</span>) (<span class="name">solve</span> (<span class="name"><span class="builtin-name">-</span></span> a-current-vol pour-volumn) (<span class="name"><span class="builtin-name">+</span></span> b-current-vol pour-volumn))))))]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> a-vol <span class="number">1</span>) (<span class="name"><span class="builtin-name">&lt;</span></span> b-vol <span class="number">1</span>) (<span class="name"><span class="builtin-name">&lt;</span></span> target <span class="number">0</span>) (<span class="name"><span class="builtin-name">&gt;</span></span> target (<span class="name"><span class="builtin-name">max</span></span> a-vol b-vol))) (<span class="name">print</span> <span class="string">"Arg out of range"</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">rem</span></span> target (<span class="name">gcd</span> a-vol b-vol)) <span class="number">0</span>)) (<span class="name">print</span> <span class="string">"No solve!"</span>)</span><br><span class="line">      <span class="symbol">:else</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">do</span></span> (<span class="name">print</span> <span class="string">"Start with "</span>) (<span class="name">solve</span> <span class="number">0</span> <span class="number">0</span>)))))</span><br></pre></td></tr></table></figure></p><p>下面是REPL中的调用结果：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">user=&gt; (pot <span class="number">3</span> <span class="number">5</span> <span class="number">6</span>)</span><br><span class="line">Start with  -&gt;  <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">Fill A full -&gt;  <span class="number">5</span>   <span class="number">0</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">0</span>   <span class="number">5</span></span><br><span class="line">Fill A full -&gt;  <span class="number">5</span>   <span class="number">5</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">4</span>   <span class="number">6</span></span><br><span class="line">Empty pot B -&gt;  <span class="number">4</span>   <span class="number">0</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">0</span>   <span class="number">4</span></span><br><span class="line">Fill A full -&gt;  <span class="number">5</span>   <span class="number">4</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">------- OK! ------</span><br><span class="line"></span><br><span class="line">user=&gt; (pot <span class="number">3</span> <span class="number">6</span> <span class="number">5</span>)</span><br><span class="line">Start with  -&gt;  <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">Fill A full -&gt;  <span class="number">6</span>   <span class="number">0</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">1</span>   <span class="number">5</span></span><br><span class="line">Empty pot B -&gt;  <span class="number">1</span>   <span class="number">0</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">0</span>   <span class="number">1</span></span><br><span class="line">Fill A full -&gt;  <span class="number">6</span>   <span class="number">1</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line">Empty pot B -&gt;  <span class="number">2</span>   <span class="number">0</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">0</span>   <span class="number">2</span></span><br><span class="line">Fill A full -&gt;  <span class="number">6</span>   <span class="number">2</span></span><br><span class="line">Pour A to B -&gt;  <span class="number">3</span>   <span class="number">5</span></span><br><span class="line">------- OK! ------</span><br></pre></td></tr></table></figure></p><p>题目来源：</p><p><a href="http://www.ituring.com.cn/article/117608" target="_blank" rel="noopener">http://www.ituring.com.cn/article/117608</a></p><p>PS：第一次写算法方面的总结，其实有些观点很早前就有了，但是一直存在于脑海中，现在写出来觉得不一定能够描述清楚，感觉很多地方写的有些罗嗦，应该是还没理解透，以后有了更深刻的理解再来修改吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述是这样的：&lt;br&gt;假设有一个池塘，里面有无穷多的水。现有2个空水壶a，b，其容积分别为6升和5升。如何只用这2个水壶从池塘里取得3升的水**（最后，这三升水，在其中一个壶里）。&lt;/p&gt;
&lt;p&gt;这个问题不难，大家自己完成可以推理出来，但是如何让计算机程序自己推算出来呢
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://liujiacai.net/categories/aha-computer/"/>
    
    
      <category term="算法" scheme="http://liujiacai.net/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>inter- intra- cept -ee -er词缀讲解</title>
    <link href="http://liujiacai.net/blog/2014/08/09/inter-intra-cept-ee-er/"/>
    <id>http://liujiacai.net/blog/2014/08/09/inter-intra-cept-ee-er/</id>
    <published>2014-08-09T07:46:12.000Z</published>
    <updated>2019-12-24T10:59:14.597Z</updated>
    
    <content type="html"><![CDATA[<p>故事是这么开始的，我遇到了inter-organizational与intra-organizational这么两个词组，其实也很好区分，前面是“不同组织之间的”，后者是“同一组织内部的”，搞计算机的应该知道有个叫intranet的网，它是与internet不一样的，专指企业内部网络。我这里想以这两个词缀为基准，展开一系列联想，学英语的乐趣不就在于此嘛。</p><p>##inter-<br>a prefix occurring in loanwords from Latin, where it meant “between,” “among,” “in the midst of,” “mutually,” “reciprocally,” “together,” “during”</p><blockquote><p>intercept　拦截。在里面（inter）握住（cept），想想小时侯站在河里用手抓鱼的场景吧</p><blockquote><p>cept也是词根，意为take、hold、seize“拿，抓，握住”<br>deceptive　de坏+cept拿,抓,握住+ive……的→拿坏的东西来→骗人的； 靠不住的； 迷惑的； 虚伪的<br>susceptible　sus+cept+ible→能被拿下→易受影响</p><blockquote><p>sus前缀，表示在…下面<br>suspect(sus+pect看→在下面看一看→怀疑)<br>suspend悬挂，中止(sus+pend挂→挂在下面→悬挂)<br>suspire叹息，渴望(sus+spir呼吸+e→喝望)</p><blockquote><p>conspire 搞阴谋； 协力促成 (con共同+spir+e→一起呼吸→共谋、阴谋)</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>sustain支撑;承受(sus+tain握住→在下面握住→支撑)</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>accept(ac再+cept拿,抓,握住→一再拿→接受)<br>except除外 (ex出+cept拿,抓,握住→拿出)<br>perception理解;感知,感觉 (per全部+cept拿,抓,握住+ion状态→全部抓住→理解;感知)<br>concept观念, 概念 (con共同+cept拿,抓,握住→共同把握→共同的想法→观念,概念)<br>receipt收据,收到 (re再+ceipt=cept抓→再次拿到→得到的收据)</p></blockquote></blockquote><blockquote><p>interest(inter在……中+est存在,实质→实质在什么里面→兴趣，爱好，利益)</p></blockquote><p>解释inter-含义时出现了个词loanword，loan就是贷款的意思，那loan接＋word字→外来词，借用词。</p><p>##intra-<br>a prefix meaning “within,” used in the formation of compound words</p><blockquote><p>intramural校内的(反义intermural)；市内的(反义extramural)(intra+mural抽象概念的”墙”)<br>intra respiration 胞内呼吸</p></blockquote><p>说实话，ee、er后缀是我看到loan后想到的</p><p>##-ee</p><ol><li><p>a suffix forming from transitive verbs nouns which denote a person who is the object or beneficiary of the act specified by the verb ( addressee; employee; grantee  ); recent formations now also mark the performer of an act, with the base being an intransitive verb ( escapee; returnee; standee ) or, less frequently, a transitive verb ( attendee  ) or another part of speech ( absentee; refugee  ).<br>我简单翻译下上面的解释。-ee后缀一般的功能是把一个动词转化为具有该动词性质的人，通常是被动的，像loanee(债务人，借入者)、employee（员工）、addressee(收件人)、grantee(受颁赠者)。<br>但是最近一些年也能表达主动的概念，像escapee逃脱者、returnee回国人员（returner指重返工作岗位的人，尤指生完小孩的女性<br>）、standee站着看的人，（公共汽车上的站客； 站立的乘客，但这些动词一般都是非及物动词。及物动词占很少一部分，典型的有attendee（会议等的）出席者、absentee缺席者、refugee避难者。</p></li><li><p>除了上面的含义外，还有一个意思，indicating a diminutive小型的 form of something，典型的例子有bootee女人的短靴</p></li></ol><p>##-er</p><ol><li>从人所占用的物品来指明人的身份。<blockquote><p>hatter帽子制造者<br>tiler盖瓦工人<br>tinner锡矿工人<br>moonshiner烈酒走私者（是的，你没看错，moonshine除了月光外，还有妄想、私酒的意思，貌似后面这两个意思一般都是在有月光的大晚上干的哈）</p></blockquote></li><li>从一些特征或环境来指明某人的身份<blockquote><p>six-footer身高六英尺的人，六英尺长的东西<br>three-master 三桅的船； 三桅船<br>teetotaler 绝对禁酒者，禁酒主义者<br>fiver　&lt;英·非正&gt;五镑钞票a five-pound note；&lt;美&gt;五元钞a five-dollar bill.<br>tenner &lt;美&gt;十磅纸币，十元纸币</p></blockquote></li><li>用于动词，表明动作具有反复的性质<blockquote><p>flicker闪烁； 飘扬，摆动<br>flutter飘动； 鼓翼<br>shiver发抖，颤抖<br>shudder战栗； 发抖； 震动； 颤动</p></blockquote></li></ol><p>##单词参考</p><ol><li><a href="http://dictionary.reference.com/" target="_blank" rel="noopener">http://dictionary.reference.com/</a></li><li><a href="http://www.iciba.com/" target="_blank" rel="noopener">http://www.iciba.com/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;故事是这么开始的，我遇到了inter-organizational与intra-organizational这么两个词组，其实也很好区分，前面是“不同组织之间的”，后者是“同一组织内部的”，搞计算机的应该知道有个叫intranet的网，它是与internet不一样的，专指企
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>Yarn的安全模式与高可靠性安装总结</title>
    <link href="http://liujiacai.net/blog/2014/08/06/cdh-yarn-ha-kerberos/"/>
    <id>http://liujiacai.net/blog/2014/08/06/cdh-yarn-ha-kerberos/</id>
    <published>2014-08-06T14:36:08.000Z</published>
    <updated>2019-12-24T10:59:14.596Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天又重新把cdh的安全模块与高可靠性模块重新搭建了一遍，这次用是的目前最新的5.1.0的tar包安装，以前把MRv1搭建了好，这次主要是熟悉安装过程，并且把YARN的安全模块与HA模块成功搭建起来。遇到的错误还是不少，安装过程也是废了我好几天，现在想想很多错误都比较典型，现在此记录下我搭建过程中遇到的错误与心得，一方面为自己以后查阅，另一方面希望也能对遇到同样问题的人有所启发。<br><a id="more"></a><br>先说下我的环境，centos6.5, cdh用的目前最新的5.1.0的tar包。</p><p>下面在先说说YARN的安全模块与HA安装时的遇到的错误，之后在说说我在安装整个CDH的HDFS、MRv1、YARN时一些不容易注意但很难地位的错误。</p><h3 id="（一）-YARN的安全模块与HA安装时遇到的错误"><a href="#（一）-YARN的安全模块与HA安装时遇到的错误" class="headerlink" title="（一） YARN的安全模块与HA安装时遇到的错误"></a>（一） YARN的安全模块与HA安装时遇到的错误</h3><h4 id="安全模块"><a href="#安全模块" class="headerlink" title="安全模块"></a>安全模块</h4><ol><li>对于container-executor文件，tar包中没有，需要自己编译</li><li>按照<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Security-Guide/cdh5sg_yarn_security.html" target="_blank" rel="noopener">官方教程</a>做配置后，执行 mapreduce 任务时，在 shuffle 阶段，会报下面的错误：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span><span class="number">-08</span><span class="number">-03</span> <span class="number">00</span>:<span class="number">34</span>:<span class="number">19</span>,<span class="number">619</span> WARN [main] <span class="keyword">org.apache.hadoop.mapred.YarnChild: </span>Exception running child : <span class="keyword">org.apache.hadoop.mapreduce.task.reduce.Shuffle$ShuffleError: </span>error in <span class="keyword">shuffle </span>in fetcher<span class="comment">#4</span></span><br><span class="line">        <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.mapreduce.task.reduce.Shuffle.run(Shuffle.java:134)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.mapred.ReduceTask.run(ReduceTask.java:376)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.mapred.YarnChild$2.run(YarnChild.java:167)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">java.security.AccessController.doPrivileged(Native </span>Method)</span><br><span class="line">        <span class="built_in">at</span> <span class="keyword">javax.security.auth.Subject.doAs(Subject.java:415)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1554)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.mapred.YarnChild.main(YarnChild.java:162)</span></span><br><span class="line"><span class="keyword">Caused </span><span class="keyword">by: </span><span class="keyword">java.io.IOException: </span>Exceeded MAX_FAILED_UNIQUE_FETCHES<span class="comment">; bailing-out.</span></span><br><span class="line">        <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.mapreduce.task.reduce.ShuffleSchedulerImpl.checkReducerHealth(ShuffleSchedulerImpl.java:323)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.mapreduce.task.reduce.ShuffleSchedulerImpl.copyFailed(ShuffleSchedulerImpl.java:245)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyFromHost(Fetcher.java:347)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">org.apache.hadoop.mapreduce.task.reduce.Fetcher.run(Fetcher.java:165)</span></span><br></pre></td></tr></table></figure></li></ol><p>在nodemanger服务器上，在执行该job的container的syslog日志中还可以找到下面的错误<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2014-08-03 00:34:19,614 WARN [fetcher#3] org.apache.hadoop.mapreduce.task.reduce.Fetcher: Invalid map id</span><br><span class="line">java.lang.IllegalArgumentException: TaskAttemptId string : TTP/1.1 500 Internal<span class="built_in"> Server </span>Error</span><br><span class="line">Content-Type: text/plain; <span class="attribute">charset</span>=UTF is <span class="keyword">not</span> properly formed</span><br><span class="line">        at org.apache.hadoop.mapreduce.TaskAttemptID.forName(TaskAttemptID.java:201)</span><br><span class="line">        at org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyMapOutput(Fetcher.java:386)</span><br><span class="line">        at org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyFromHost(Fetcher.java:341)</span><br><span class="line">        at org.apache.hadoop.mapreduce.task.reduce.Fetcher.<span class="builtin-name">run</span>(Fetcher.java:165)</span><br><span class="line">2014-08-03 00:34:19,614 WARN [fetcher#4] org.apache.hadoop.mapreduce.task.reduce.Fetcher: Invalid map id</span><br><span class="line">java.lang.IllegalArgumentException: TaskAttemptId string : TTP/1.1 500 Internal<span class="built_in"> Server </span>Error</span><br></pre></td></tr></table></figure></p><p><a href="http://mail-archives.apache.org/mod_mbox/hadoop-hdfs-user/201211.mbox/%3CBD42F346AE90F544A731516A805D1B8AD8548A@SMAIL1.prd.mpac.ca%3E" target="_blank" rel="noopener">网上很多说</a><strong>Shuffle$ShuffleError: error in shuffle in fetcher#4</strong>这个错误与内存，很明显，我这里不是这种情况，因为从<strong> TTP/1.1 500 Internal Server Error</strong>就应该知道是resourcemanager内部的错误。</p><p>经过我验证，这时由于tar包默认并不包含native的lib，位置在<code>&lt;hadoop&gt;/lib/native</code>文件夹，需要我们自己编译，把编译好的native文件拷贝到这里即可。</p><h4 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h4><p>按照<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Installation-Guide/cdh5ig_yarn_cluster_deploy.html?scroll=topic_11_4_10_unique_1" target="_blank" rel="noopener">官方教程</a>，先直接安装YARN时有点小错误，就是historyserver进程开启（由maprd用户开启）后无法aggregate log，我发现是有两个问题导致：</p><ol><li><p>我服务器上的mapred用户只属于mapred用户组（useradd mapred这条命令执行后，就会创建mapred用户，并且属于mapred组），而由mapred启动的historyserver需要访问${yarn.app.mapreduce.am.staging-dir}/history/done_intermediate/${username}文件夹下不同用户的文件，而这个文件夹的权限是770,own为${username}:hadoop，所以historyserver没有权限读取，我这里把mapred添加到hadoop用户组去即可：s<br>这里mapred用户也需要属于mapred组，是因为也需要向${yarn.nodemanager.remote-app-log-dir}/${username}目录下写一些日志（因为开启了log-aggregation），而这个目录权限也是770,own为${username}:mapred。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -<span class="keyword">a</span> G hadoop mapred <span class="comment">#这里需要-a选项，这样mapred用户即属于mapred组又属于hadoop组</span></span><br></pre></td></tr></table></figure></li><li><p>教程上说的开启log-aggregation的配置不对，教程上写的是</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span>&gt;</span><br><span class="line">    &lt;<span class="built_in">name</span>&gt;yarn.<span class="built_in">log</span>.aggregation.enable&lt;/<span class="built_in">name</span>&gt;</span><br><span class="line">    &lt;value&gt;<span class="literal">true</span>&lt;/value&gt; </span><br><span class="line">&lt;/<span class="keyword">property</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><p>应改为<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span>&gt;</span><br><span class="line">    &lt;<span class="built_in">name</span>&gt;yarn.<span class="built_in">log</span>-aggregation-enable&lt;/<span class="built_in">name</span>&gt;</span><br><span class="line">    &lt;value&gt;<span class="literal">true</span>&lt;/value&gt; </span><br><span class="line">&lt;/<span class="keyword">property</span>&gt;</span><br></pre></td></tr></table></figure></p><p>—————下面正式说HA——————</p><p>YARN的HA想对于hdfs与MRv1的简单了许多，自动Failover也不需要另起个进程，ResourceManager中一个ActiveStandbyElector，它负责Automatic failover。这里只需要修改yarn-site.xml文件即可。<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-High-Availability-Guide/cdh5hag_rm_ha_config.html" target="_blank" rel="noopener">官方教程</a>的给出的默认配置改一项就能运行成功。</p><p>把<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.zk.state-store.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>改成<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其实上面的表格说的很详细了，不知道为什么给出的示例没写，不过这个错也比较好找，因为按照上面配置的开启RM时会报<strong>yarn.resourcemanager.zk-address</strong>没定义。</p><p>其次需要注意的是<strong>yarn.resourcemanager.ha.id</strong>在active与standby的服务器上的值是不一样的，按照官方给的配置，那就一个是rm1,一个是rm2。</p><p>如果我们在开启了安全模式还需要修改一处property即<strong>yarn.resourcemanager.hostname</strong>，ha中的两个RM这个property值是不一样的，分别为其hostname。这是因为我们在配置yarn的principal时用了<strong>yarn/_HOST</strong>这种方式，而_HOST对于NN与RM来说，不是按照hostname来替换的，而是分别按照<strong>fs.defaultFS</strong>与<strong>yarn.resourcemanager.hostname</strong>这两个property的值来替换的。DN与NM是按照每个服务器的hostname来替换的。替换规则也在<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Security-Guide/cdh5sg_secure_hdfs_config.html" target="_blank" rel="noopener">HDFS的安全模式文档</a>中有说明。</p><p>下面是我rm1服务器上这两个property的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.id<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>rm1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>下面是我rm2服务器上这两个property的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.id<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>rm2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="（二）-CDH各个模块安装总结"><a href="#（二）-CDH各个模块安装总结" class="headerlink" title="（二） CDH各个模块安装总结"></a>（二） CDH各个模块安装总结</h3><p>还是先说些我在安装过程中遇到的一些不起眼但遇到后就很难定位的错误。</p><ol><li>如果把hadoop放到/root下，像hdfs、yarn这些用户是没法执行bin、sbin下面的脚本的，因为/root的默认权限是550，我安装时直接放到/opt下。</li><li>在安装HDFS的安全模块时，开启某个进程，比如namenode时，经常会出现某个文件找不到，这是因为我在前后开启、关闭、格式化namenode过程中，先后用了root与hdfs，用root用户开启的namenode在本地写文件hdfs用户是没法读取的。这里一定要谨记，除了开启datanode时需要用root用户，与namenode相关的都是用hdfs用户，包括namenode的format、start与stop。</li><li>还有个比较tricky的问题，本来的journalnode是开启在slaves节点上的，我现在想把它们分开，我集群内的hosts文件是这样的<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span>   localhost</span><br><span class="line"><span class="number">10.4.13.85</span>  master</span><br><span class="line"><span class="number">10.4.15.239</span> master2 zk1 jn1  #hostname为master2</span><br><span class="line"><span class="number">10.4.9.14</span>   zk2 jn2          #hostname为zk2</span><br><span class="line"><span class="number">10.4.14.123</span> zk3 jn3          #hostname为zk3</span><br><span class="line"><span class="number">10.4.13.63</span>  node1</span><br><span class="line"><span class="number">10.4.13.2</span>   node2</span><br><span class="line"><span class="number">10.4.11.89</span>  node3</span><br></pre></td></tr></table></figure></li></ol><p>我这里为一台服务器配置多个domain.name是方便我在后面的配置时做到见名知意，比如，我在配置journalnode时我可以这么配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://jn1:8485;jn2:8485;jn3:8485/ljc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.kerberos.principal<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs/_HOST@MY-REALM<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">…………</span><br></pre></td></tr></table></figure></p><p>但这里问题来了，因为journalnode从active的NameNode那里取数据时需要验证身份，而我这里的principal用了<strong>_HOST</strong>，按理说CDH在运行时会自动把 _HOST替换为hostname，而且我在生产keytab时也是根据hostname来生成的，比如对于master2,我会生产下面的principal：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hdfs/master2<span class="meta">@MY</span>-REALM</span><br><span class="line">HTTP/master2<span class="meta">@MY</span>-REALM</span><br><span class="line">mapred/master2<span class="meta">@MY</span>-REALM</span><br><span class="line">yarn/master2<span class="meta">@MY</span>-REALM</span><br></pre></td></tr></table></figure></p><p>但是我这样配置后，开启第一个时namenode就会报错，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">08</span>-<span class="number">06</span> <span class="number">18</span>:<span class="number">27</span>:<span class="number">05</span>,<span class="number">929</span> WARN org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.UserGroupInformation</span>: PriviledgedActionException as:hdfs/master@MY-REALM (auth:KERBEROS) cause:java<span class="selector-class">.io</span><span class="selector-class">.IOException</span>: org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.authentication</span><span class="selector-class">.client</span><span class="selector-class">.AuthenticationException</span>: GSSException: No valid credentials provided (Mechanism level: Server not found <span class="keyword">in</span> Kerberos database (<span class="number">7</span>) - UNKNOWN_SERVER)</span><br><span class="line"><span class="number">2014</span>-<span class="number">08</span>-<span class="number">06</span> <span class="number">18</span>:<span class="number">27</span>:<span class="number">05</span>,<span class="number">929</span> ERROR org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span><span class="selector-class">.EditLogInputStream</span>: caught exception initializing http:<span class="comment">//jn3:8480/getJournal?jid=ljc&amp;segmentTxId=1&amp;storageInfo=-55%3A845458164%3A0%3ACID-b6f3e623-e3c0-45d0-a44c-ec3f01d57ea3</span></span><br><span class="line">java<span class="selector-class">.io</span><span class="selector-class">.IOException</span>: org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.authentication</span><span class="selector-class">.client</span><span class="selector-class">.AuthenticationException</span>: GSSException: No valid credentials provided (Mechanism level: Server not found <span class="keyword">in</span> Kerberos database (<span class="number">7</span>) - UNKNOWN_SERVER)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span>.EditLogFileInputStream<span class="variable">$URLLog</span>$<span class="number">1</span>.run(EditLogFileInputStream<span class="selector-class">.java</span>:<span class="number">406</span>) </span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span>.EditLogFileInputStream<span class="variable">$URLLog</span>$<span class="number">1</span>.run(EditLogFileInputStream<span class="selector-class">.java</span>:<span class="number">398</span>)</span><br><span class="line">    at java<span class="selector-class">.security</span><span class="selector-class">.AccessController</span>.doPrivileged(Native Method)</span><br><span class="line">    at javax<span class="selector-class">.security</span><span class="selector-class">.auth</span><span class="selector-class">.Subject</span>.doAs(Subject<span class="selector-class">.java</span>:<span class="number">415</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.UserGroupInformation</span>.doAs(UserGroupInformation<span class="selector-class">.java</span>:<span class="number">1554</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.SecurityUtil</span>.doAsUser(SecurityUtil<span class="selector-class">.java</span>:<span class="number">448</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.SecurityUtil</span>.doAsCurrentUser(SecurityUtil<span class="selector-class">.java</span>:<span class="number">442</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span>.EditLogFileInputStream<span class="variable">$URLLog</span>.getInputStream(EditLogFileInputStream<span class="selector-class">.java</span>:<span class="number">397</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span><span class="selector-class">.EditLogFileInputStream</span>.init(EditLogFileInputStream<span class="selector-class">.java</span>:<span class="number">139</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span><span class="selector-class">.EditLogFileInputStream</span>.nextOpImpl(EditLogFileInputStream<span class="selector-class">.java</span>:<span class="number">188</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span><span class="selector-class">.EditLogFileInputStream</span>.nextOp(EditLogFileInputStream<span class="selector-class">.java</span>:<span class="number">239</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span><span class="selector-class">.EditLogInputStream</span>.readOp(EditLogInputStream<span class="selector-class">.java</span>:<span class="number">83</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span><span class="selector-class">.EditLogInputStream</span>.skipUntil(EditLogInputStream<span class="selector-class">.java</span>:<span class="number">140</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span><span class="selector-class">.RedundantEditLogInputStream</span>.nextOp(RedundantEditLogInputStream<span class="selector-class">.java</span>:<span class="number">178</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span><span class="selector-class">.EditLogInputStream</span>.readOp(EditLogInputStream<span class="selector-class">.java</span>:<span class="number">83</span>)</span><br><span class="line"></span><br><span class="line">Caused by: org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.authentication</span><span class="selector-class">.client</span><span class="selector-class">.AuthenticationException</span>: GSSException: No valid credentials provided (Mechanism level: Server not found <span class="keyword">in</span> Kerberos database (<span class="number">7</span>) - UNKNOWN_SERVER)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.authentication</span><span class="selector-class">.client</span><span class="selector-class">.KerberosAuthenticator</span>.doSpnegoSequence(KerberosAuthenticator<span class="selector-class">.java</span>:<span class="number">306</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.authentication</span><span class="selector-class">.client</span><span class="selector-class">.KerberosAuthenticator</span>.authenticate(KerberosAuthenticator<span class="selector-class">.java</span>:<span class="number">196</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.authentication</span><span class="selector-class">.client</span><span class="selector-class">.AuthenticatedURL</span>.openConnection(AuthenticatedURL<span class="selector-class">.java</span>:<span class="number">232</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.web</span><span class="selector-class">.URLConnectionFactory</span>.openConnection(URLConnectionFactory<span class="selector-class">.java</span>:<span class="number">164</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.server</span><span class="selector-class">.namenode</span>.EditLogFileInputStream<span class="variable">$URLLog</span>$<span class="number">1</span>.run(EditLogFileInputStream<span class="selector-class">.java</span>:<span class="number">403</span>)</span><br><span class="line">    ... <span class="number">30</span> more</span><br><span class="line">Caused by: GSSException: No valid credentials provided (Mechanism level: Server not found <span class="keyword">in</span> Kerberos database (<span class="number">7</span>) - UNKNOWN_SERVER)</span><br><span class="line">    at sun<span class="selector-class">.security</span><span class="selector-class">.jgss</span><span class="selector-class">.krb5</span><span class="selector-class">.Krb5Context</span>.initSecContext(Krb5Context<span class="selector-class">.java</span>:<span class="number">710</span>)</span><br><span class="line">    at sun<span class="selector-class">.security</span><span class="selector-class">.jgss</span><span class="selector-class">.GSSContextImpl</span>.initSecContext(GSSContextImpl<span class="selector-class">.java</span>:<span class="number">248</span>)</span><br><span class="line">    at sun<span class="selector-class">.security</span><span class="selector-class">.jgss</span><span class="selector-class">.GSSContextImpl</span>.initSecContext(GSSContextImpl<span class="selector-class">.java</span>:<span class="number">179</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.authentication</span><span class="selector-class">.client</span>.KerberosAuthenticator$<span class="number">1</span>.run(KerberosAuthenticator<span class="selector-class">.java</span>:<span class="number">285</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.security</span><span class="selector-class">.authentication</span><span class="selector-class">.client</span>.KerberosAuthenticator$<span class="number">1</span>.run(KerberosAuthenticator<span class="selector-class">.java</span>:<span class="number">261</span>)</span><br><span class="line">    at java<span class="selector-class">.security</span><span class="selector-class">.AccessController</span>.doPrivileged(Native Method)</span><br><span class="line">    at javax<span class="selector-class">.security</span><span class="selector-class">.auth</span><span class="selector-class">.Subject</span>.doAs(Subject<span class="selector-class">.java</span>:<span class="number">415</span>)</span><br></pre></td></tr></table></figure></p><p>大致意思是说无法读取journalnode那里的edits，认证失败了，没有权限。我还以为是我生产的keytab有错，我去jn1所在服务器（hostname为master2）上用kinit加上tabkey也能的到TGT，后来我把配置改成这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://master2:8485;zk2:8485;zk3:8485/ljc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样就能吧Namenode起来了，证明这里<strong>_HOST</strong>被直接替换成了我这里的domain.name了，而不是每个服务器上的hostname，我这里不用domain.name，直接换为ip，也没问题。要是想了解这个细节，需要看源代码了，以后在看吧。</p><ol start="4"><li>如果遇到<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> "<span class="selector-tag">main</span>" <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.HadoopIllegalArgumentException</span>: <span class="selector-tag">HA</span> <span class="selector-tag">is</span> <span class="selector-tag">not</span> <span class="selector-tag">enabled</span> <span class="selector-tag">for</span> <span class="selector-tag">this</span> <span class="selector-tag">namenode</span>.</span><br><span class="line">        <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.tools</span><span class="selector-class">.DFSZKFailoverController</span><span class="selector-class">.create</span>(<span class="selector-tag">DFSZKFailoverController</span><span class="selector-class">.java</span><span class="selector-pseudo">:121)</span></span><br><span class="line">        <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.hdfs</span><span class="selector-class">.tools</span><span class="selector-class">.DFSZKFailoverController</span><span class="selector-class">.main</span>(<span class="selector-tag">DFSZKFailoverController</span><span class="selector-class">.java</span><span class="selector-pseudo">:172)</span></span><br></pre></td></tr></table></figure></li></ol><p>说明 <strong>dfs.nameservices</strong> 配置有误，我当时把值配置成 <strong>hdfs://ljc</strong> 了，其实应该配成 <strong>ljc</strong> 就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从熟悉hadoop各个模块开始，到现在把最基本的环境搭建起来，前前后后也是有一个月的时间了，我发现我耗时比较多的是遇到问题后，没有看源码的意识，去网上搜，虽然有可能有人也遇到这个问题，但是明显和我的不相符，这时我就仔细检查我的配置文件，看看是否遗漏官方教程上的某一项，有些盲目，最近开始把cdh的src导入了eclipse，遇到一些错误后开始慢慢看源代码，我发现这样能很快定位到问题出错的范围，以后一定多尝试。</p><p>其次就是服务器比较多，hadoop也需要配置不少东西，这就需要自动化来帮助了，我最近把shell脚本又熟悉起来，写了一些用于管理hadoop的脚本，加上使用了<a href="http://en.wikipedia.org/wiki/Salt_(software)" target="_blank" rel="noopener">salt</a>这个自动化工具，这样方便多了。但是shell我还不是很熟悉，像数组的使用，很恶心有木有，交互式shell加载环境变量与非交互式（ssh -t -t hostname cmd这种方式就是非交互式）的不一样，等回来还要慢慢总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几天又重新把cdh的安全模块与高可靠性模块重新搭建了一遍，这次用是的目前最新的5.1.0的tar包安装，以前把MRv1搭建了好，这次主要是熟悉安装过程，并且把YARN的安全模块与HA模块成功搭建起来。遇到的错误还是不少，安装过程也是废了我好几天，现在想想很多错误都比较典型，现在此记录下我搭建过程中遇到的错误与心得，一方面为自己以后查阅，另一方面希望也能对遇到同样问题的人有所启发。&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://liujiacai.net/categories/bigdata/"/>
    
    
      <category term="hadoop" scheme="http://liujiacai.net/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>hadoop1.0 高可靠性(HA)安装与总结</title>
    <link href="http://liujiacai.net/blog/2014/07/17/cdh-ha-installation/"/>
    <id>http://liujiacai.net/blog/2014/07/17/cdh-ha-installation/</id>
    <published>2014-07-17T15:07:34.000Z</published>
    <updated>2019-12-24T10:59:14.596Z</updated>
    
    <content type="html"><![CDATA[<p>继上次<a href="/blog/2014/07/15/cdh-kerberos-installation/">安装完Kerberos安全认证</a>后，现在我在这基础上，又给CDH加上了HA（high availability），也就是高可靠性，具体来讲就是双NameNode，双Jobtracker（我还是在MRv1模式下），有了HA后，这下集群的健壮性就能够得到很好的保证了。</p><p>我还是按照<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-High-Availability-Guide/CDH5-High-Availability-Guide.html" target="_blank" rel="noopener">官方文档</a>来操作的，有了上次的经验，建议大家在具体操作实施前，先快速阅读一遍，做到心中有数，我还阅读了<a href="http://hadoop.apache.org/docs/r2.3.0/hadoop-yarn/hadoop-yarn-site/HDFSHighAvailabilityWithNFS.html" target="_blank" rel="noopener">Apache官方的说明</a>，也不用怎么详细，大概知道怎么回事就行了。<br><a id="more"></a><br>首先说明一点的就是，CDH5 只支持Quorum Journal Manager(QJM)模式下的HA，不支持NFS模式的，这点和Apache官方的不一样，大家要留意下。</p><p>下面说说我遇到的坑：</p><ul><li>按照<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-High-Availability-Guide/cdh5hag_hdfs_ha_software_config.html" target="_blank" rel="noopener">software_config</a>上面说的配置一步步来，如果要实现自动的Failover，需要安装zookeeper，安装也很简单，从<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a>下载<a href="http://archive.cloudera.com/cdh5/cdh/5/zookeeper-3.4.5-cdh5.0.2.tar.gz" target="_blank" rel="noopener">zookeeper-3.4.5-cdh5.0.2.tar.gz</a>，然后按照<a href="http://archive.cloudera.com/cdh5/cdh/5/zookeeper/zookeeperStarted.html" target="_blank" rel="noopener">zookeeper的安装说明</a>安装即可，官方推荐zookeeper的集群数目为奇数，推荐值为3,我这样也配置了3台，zookeeper服务在在启动时会向集群内其他服务器发送认证数据，但是在第一次启动时难免有个先后顺序，所以先启动的节点向还没有启动的服务器发生数据时会报错，类型下面的错误信息<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">06</span>,<span class="number">151</span> [myid:<span class="number">1</span>] - INFO  [WorkerReceiver[myid=<span class="number">1</span>]:FastLeaderElection@<span class="number">542</span>] - Notification: <span class="number">1</span> (n.leader), <span class="number">0</span>x100000106 (n.zxid), <span class="number">0</span>x1 (n.round), LOOKING (n.state), <span class="number">1</span> (n.sid), <span class="number">0</span>x2 (n.peerEPoch), LOOKING (my state)</span><br><span class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">17</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">06</span>,<span class="number">153</span> [myid:<span class="number">1</span>] - WARN  [WorkerSender[myid=<span class="number">1</span>]:QuorumCnxManager@<span class="number">368</span>] - Cannot open channel to <span class="number">2</span> at election <span class="selector-tag">address</span> node1/<span class="number">10.4</span>.<span class="number">13.63</span>:<span class="number">3888</span></span><br><span class="line">java<span class="selector-class">.net</span><span class="selector-class">.ConnectException</span>: Connection refused</span><br><span class="line">    at java<span class="selector-class">.net</span><span class="selector-class">.PlainSocketImpl</span>.socketConnect(Native Method)</span><br><span class="line">    at java<span class="selector-class">.net</span><span class="selector-class">.AbstractPlainSocketImpl</span>.doConnect(AbstractPlainSocketImpl<span class="selector-class">.java</span>:<span class="number">339</span>)</span><br><span class="line">    at java<span class="selector-class">.net</span><span class="selector-class">.AbstractPlainSocketImpl</span>.connectToAddress(AbstractPlainSocketImpl<span class="selector-class">.java</span>:<span class="number">200</span>)</span><br><span class="line">    at java<span class="selector-class">.net</span><span class="selector-class">.AbstractPlainSocketImpl</span>.connect(AbstractPlainSocketImpl<span class="selector-class">.java</span>:<span class="number">182</span>)</span><br><span class="line">    at java<span class="selector-class">.net</span><span class="selector-class">.SocksSocketImpl</span>.connect(SocksSocketImpl<span class="selector-class">.java</span>:<span class="number">392</span>)</span><br><span class="line">    at java<span class="selector-class">.net</span><span class="selector-class">.Socket</span>.connect(Socket<span class="selector-class">.java</span>:<span class="number">579</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.QuorumCnxManager</span>.connectOne(QuorumCnxManager<span class="selector-class">.java</span>:<span class="number">354</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span><span class="selector-class">.QuorumCnxManager</span>.toSend(QuorumCnxManager<span class="selector-class">.java</span>:<span class="number">327</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span>.FastLeaderElection<span class="variable">$Messenger</span><span class="variable">$WorkerSender</span>.process(FastLeaderElection<span class="selector-class">.java</span>:<span class="number">393</span>)</span><br><span class="line">    at org<span class="selector-class">.apache</span><span class="selector-class">.zookeeper</span><span class="selector-class">.server</span><span class="selector-class">.quorum</span>.FastLeaderElection<span class="variable">$Messenger</span><span class="variable">$WorkerSender</span>.run(FastLeaderElection<span class="selector-class">.java</span>:<span class="number">365</span>)</span><br><span class="line">    at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span>.run(Thread<span class="selector-class">.java</span>:<span class="number">745</span>)</span><br></pre></td></tr></table></figure></li></ul><p>这个是正常的，等3台全部启动后，有如下日志就证明没问题了<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">2014-07-17</span> <span class="selector-tag">11</span><span class="selector-pseudo">:26</span><span class="selector-pseudo">:44</span>,<span class="selector-tag">425</span> <span class="selector-attr">[myid:3]</span> <span class="selector-tag">-</span> <span class="selector-tag">INFO</span>  <span class="selector-attr">[WorkerReceiver[myid=3]</span><span class="selector-pseudo">:FastLeaderElection</span>@<span class="selector-tag">542</span>] <span class="selector-tag">-</span> <span class="selector-tag">Notification</span>: <span class="selector-tag">3</span> (n.leader), <span class="selector-tag">0x0</span> (n.zxid), <span class="selector-tag">0x1</span> (n.round), <span class="selector-tag">LOOKING</span> (n.state), <span class="selector-tag">3</span> (n.sid), <span class="selector-tag">0x0</span> (n.peerEPoch), <span class="selector-tag">LOOKING</span> (my state)</span><br><span class="line"><span class="selector-tag">2014-07-17</span> <span class="selector-tag">11</span><span class="selector-pseudo">:26</span><span class="selector-pseudo">:44</span>,<span class="selector-tag">426</span> <span class="selector-attr">[myid:3]</span> <span class="selector-tag">-</span> <span class="selector-tag">INFO</span>  <span class="selector-attr">[WorkerReceiver[myid=3]</span><span class="selector-pseudo">:FastLeaderElection</span>@<span class="selector-tag">542</span>] <span class="selector-tag">-</span> <span class="selector-tag">Notification</span>: <span class="selector-tag">2</span> (n.leader), <span class="selector-tag">0x0</span> (n.zxid), <span class="selector-tag">0x1</span> (n.round), <span class="selector-tag">LOOKING</span> (n.state), <span class="selector-tag">1</span> (n.sid), <span class="selector-tag">0x0</span> (n.peerEPoch), <span class="selector-tag">LOOKING</span> (my state)</span><br></pre></td></tr></table></figure></p><ul><li>在配置Securing access to ZooKeeper这步时，我也能得到像官方教程上说的<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">digest:</span>hdfs-<span class="string">zkfcs:</span>vlUvLnd8MlacsE80rDuu6ONESbM=:rwcda</span><br></pre></td></tr></table></figure></li></ul><p>与这个类似的信息，但是在执行zkfc -formatZK时，老是说的我得到的字符串（’-&gt;’ 后面的那部分）不对，我也不知道为什么，不知道是不是哪步少了什么，因为zookeeper集群在内网，集群内安全性一般不用考虑，我这里就直接忽略了这步，以后机会再找原因。</p><ul><li><p>在配置Fencing Configuration时，我用了sshfence的方式，这里需要配置ssh的密钥，我直接把hdfs用户的密钥路径给上，后来在我验证双Namenode是否生效（通过kill掉active的NN，看看standby的NN能不能变为active的NN）发现不对，老是报错，连接不上另一个Namenode，后来发现需要用root的密钥，但是hdfs用户又不能读取root的密钥，所以我这里直接把root的.ssh文件下的文件全copy到hdfs用户的$HOME下，并设置为hdfs为其owner（我的root用户在集群内也是可以免密码登录的），这样就没问题了。</p></li><li><p>需要说明的是，在开启namenode之前，必须先开启journalnode，因为namenode开启时会去连接journalnode</p></li><li><p>然后就是开启双Namenode的步骤了，下面记录一些需要用到的命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo -u hdfs <span class="keyword">bin/hdfs </span>zkfc -formatZK</span><br><span class="line">sudo -u hdfs <span class="keyword">sbin/hadoop-daemon.sh </span>start <span class="keyword">journalnode </span><span class="comment">#开启journalnode进程</span></span><br><span class="line"></span><br><span class="line">sudo -u hdfs <span class="keyword">sbin/hadoop-daemon.sh </span>start zkfc <span class="comment">#开启automatic failover进程</span></span><br><span class="line"></span><br><span class="line">sudo -u hdfs <span class="keyword">bin/hdfs </span>namenode -initializeSharedEdits <span class="comment">#把一个non-HA的NameNode转为HA时用到</span></span><br><span class="line"></span><br><span class="line">sudo -u hdfs <span class="keyword">bin/hdfs </span>namenode -<span class="keyword">bootstrapStandby </span></span><br><span class="line">sudo -u hdfs <span class="keyword">sbin/hadoop-daemon.sh </span>start namenode</span><br><span class="line"><span class="comment">#上面命这两个命令在运行第二个Namenode服务器上执行，必须先执行-bootstrapStandby 这行命令再开启namenode </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面这些命令之前，需要以hdfs用户用kinit拿到TGT，否则会报错</span></span><br><span class="line">sudo -u hdfs <span class="keyword">bin/hdfs </span>haadmin -getServiceState nn1 <span class="comment">#查看nn1是active的还是standby的</span></span><br></pre></td></tr></table></figure></li><li><p>按照<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-High-Availability-Guide/cdh5hag_jt_ha_config.html" target="_blank" rel="noopener">jobtracker的HA官方配置</a>进行配置后，使用</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u mapred sbin/hadoop-daemon.sh <span class="literal">start</span> jobtrackerha</span><br></pre></td></tr></table></figure></li></ul><p>命令开启jobtrackerha</p><ul><li>通过<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行下面这些命令之前，要先以mapred用户用kinit拿到TGT，否则会报错</span></span><br><span class="line"></span><br><span class="line">sudo -u mapred <span class="keyword">bin/hadoop </span>mrhaadmin -getServiceState <span class="keyword">jt1</span></span><br></pre></td></tr></table></figure></li></ul><p>查看jt1是active的还是standby的</p><ul><li><p>最后一个，还是关于HDFS的权限问题，因为mapreduce在执行任务时会向HDFS上写一些临时文件，如果权限不对，肯定就会报错了，不过这种错误也很好该，根据错误信息就能知道那个目录权限不对，然后改过来就行了，我这里进行下总结：</p></li><li><p>根据官方的教程配置教程，配置了如下选项：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>mapred.job.tracker.persist.jobstatus.dir<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span><span class="meta-keyword">/jobtracker/</span>jobsInfo<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>所以需要在HDFS上创建相应目录，并修改其owner为mapred</p><ul><li>其次是staging目录，如果没有配置，其默认值从<a href="http://archive.cloudera.com/cdh4/cdh/4/hadoop/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml" target="_blank" rel="noopener">默认配置</a>可以看到mapreduce.jobtracker.staging.root.dir的值为${hadoop.tmp.dir}/mapred/staging，而${hadoop.tmp.dir}的值从<a href="http://archive.cloudera.com/cdh4/cdh/4/hadoop/hadoop-project-dist/hadoop-common/core-default.xml" target="_blank" rel="noopener">这里</a>可以看到值默认是/tmp/hadoop-${user.name}，有因为我们使用mapred用户来执行tasktracker进行的，所以需要创建/tmp/hadoop-mapred/mapred/staging文件夹，并且其owner为mapred，权限为1777，可以用下面的命令来实现：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -u hdfs bin/hdfs dfs -mkdir -p <span class="meta-keyword">/tmp/</span>hadoop-mapred<span class="meta-keyword">/mapred/</span>staging</span><br><span class="line">sudo -u hdfs bin/hdfs dfs -chown mapred <span class="meta-keyword">/tmp/</span>hadoop-mapred<span class="meta-keyword">/mapred/</span>staging</span><br><span class="line">sudo -u hdfs bin/hdfs dfs -chmod <span class="number">1777</span> <span class="meta-keyword">/tmp/</span>hadoop-mapred<span class="meta-keyword">/mapred/</span>staging</span><br></pre></td></tr></table></figure></li></ul><p>此外，还需要配置mapreduce.jobtracker.system.dir指定的文件，默认为${hadoop.tmp.dir}/mapred/system，所以还需要执行下面的命令：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -u hdfs bin/hdfs dfs -mkdir -p /tmp/hadoop-mapred/mapred/system</span><br><span class="line">sudo -u hdfs bin/hdfs dfs -chown mapred /tmp/hadoop-mapred/mapred/system</span><br></pre></td></tr></table></figure></p><p>这个目录只由mapred用户来写入，所以不用再修改其权限（的755即可）。</p><p>总结：这次配置HA的整个过程还是比较顺利的，除了烦人的各种权限问题，我觉得这也是我没有弄明白hadoop各个进程是如何工作导致的，通过支持配置HA，算是对job的运行又有了更深的的认识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继上次&lt;a href=&quot;/blog/2014/07/15/cdh-kerberos-installation/&quot;&gt;安装完Kerberos安全认证&lt;/a&gt;后，现在我在这基础上，又给CDH加上了HA（high availability），也就是高可靠性，具体来讲就是双NameNode，双Jobtracker（我还是在MRv1模式下），有了HA后，这下集群的健壮性就能够得到很好的保证了。&lt;/p&gt;
&lt;p&gt;我还是按照&lt;a href=&quot;http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-High-Availability-Guide/CDH5-High-Availability-Guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;来操作的，有了上次的经验，建议大家在具体操作实施前，先快速阅读一遍，做到心中有数，我还阅读了&lt;a href=&quot;http://hadoop.apache.org/docs/r2.3.0/hadoop-yarn/hadoop-yarn-site/HDFSHighAvailabilityWithNFS.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache官方的说明&lt;/a&gt;，也不用怎么详细，大概知道怎么回事就行了。&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://liujiacai.net/categories/bigdata/"/>
    
    
      <category term="hadoop" scheme="http://liujiacai.net/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>hadoop1.0 安全认证(kerberos)安装与总结</title>
    <link href="http://liujiacai.net/blog/2014/07/15/cdh-kerberos-installation/"/>
    <id>http://liujiacai.net/blog/2014/07/15/cdh-kerberos-installation/</id>
    <published>2014-07-15T13:56:28.000Z</published>
    <updated>2019-12-24T10:59:14.596Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说得好，万事开头难。在软件开发中，环境部署要算是第一门槛了。我最近折腾了一周时间把cdh5.0.2.tar.gz版本在MRv1模式下，成功集成了Kerberos安全认证，并且是在全分布式模式下。经过这次安装过程，对hadoop的了解又深入了一层。现在趁着自己刚搭建完环境，脑子还时不时的闪现遇到的错误，把我的安装过程记录于此，一方面方便自己今后查阅，另一方面希望对今后遇到同样问题人有所启发。<br><a id="more"></a><br>首先说下为什么要用tarball安装，cdh提供了一种manager方式进行安装，对Debian系列提供apt-get，对Redhat系列提供yum安装，但是这些安装方式把一些细节都替我们做了，如果我们今后希望遇到出现什么情况，不方便调试。另外，作为一个爱折腾的人，tar.gz也是我按照软件的首选。</p><p>先说下我的搭建环境，4台Centos6.5服务器，一台做master，运行namenode、jobtracker;另外三台运行datanode、tasktracker。此外master机器上还运行Kerberos服务器。JDK的版本是1.7.60。关于5.0.2版本的环境要求可以参考<a href="http://www.cloudera.com/content/support/en/downloads/cdh/cdh-5-0-2.html#SystemRequirements" target="_blank" rel="noopener">http://www.cloudera.com/content/support/en/downloads/cdh/cdh-5-0-2.html#SystemRequirements</a>。</p><p>这篇文章主要是我在参照cloudera<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Security-Guide/cdh5sg_cdh5_hadoop_security.html" target="_blank" rel="noopener">官网的教程</a>时遇到的坑。大家可以先去看看这个教程，再来看我的文章。</p><p>cdh5.0.2这里不再使用hadoop用户，取而代之的是mapred用户与hdfs用户，这里需要分别为它们生产ssh的公钥与秘钥，并且配置免密码登录（当然你可以为其中一个生产，然后直接copy过去）。</p><h2 id="1-Kerberos安装"><a href="#1-Kerberos安装" class="headerlink" title="1. Kerberos安装"></a>1. Kerberos安装</h2><p>首先，Kerberos的原理、安装什么大家自己去维基百科去查，具体命令像kinit、kadmin怎么用也是大家自己查，以后有时间我会单独抽时间讲讲Kerberos。<br>大家现在可以按照这个文章来进行操作：<a href="https://www.centos.org/docs/5/html/5.2/Deployment_Guide/s1-kerberos-server.html" target="_blank" rel="noopener">Kerberos deploy guide</a>。</p><p>后面需要为集群中每个节点的mapred与hdfs用户生成各自的principal与keytab，所以这里大家一定要熟悉kerberos的命令，把这些东西做成脚本，要不能烦死你。</p><h2 id="2-CDH5-0-2-tar-gz安装"><a href="#2-CDH5-0-2-tar-gz安装" class="headerlink" title="2. CDH5.0.2.tar.gz安装"></a>2. CDH5.0.2.tar.gz安装</h2><h3 id="2-1-下载相关tar包"><a href="#2-1-下载相关tar包" class="headerlink" title="2.1 下载相关tar包"></a>2.1 下载相关tar包</h3><p>首先在这里<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a>下载5.0.2的hadoop的tar包<a href="http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.3.0-cdh5.0.2.tar.gz" target="_blank" rel="noopener">hadoop-2.3.0-cdh5.0.2.tar.gz</a>，除了这个外，为了集成Kerberos，还需要下载<a href="http://archive.cloudera.com/cdh5/cdh/5/bigtop-jsvc-1.0.10-cdh5.0.2.tar.gz" target="_blank" rel="noopener">bigtop-jsvc-1.0.10-cdh5.0.2.tar.gz</a>。</p><h3 id="2-2-YARN模式改成MRv1模式"><a href="#2-2-YARN模式改成MRv1模式" class="headerlink" title="2.2 YARN模式改成MRv1模式"></a>2.2 YARN模式改成MRv1模式</h3><p>这里需要讲一点是，5.0.2 tarball版本模式是YARN模式，我这里搭建的是MRv1（也就是普通的MapReduce）模式，所以需要对tar包解压出的文件做一些修改。</p><p>把hadoop-2.3.0-cdh5.0.2.tar.gz解压，假设你解压到了/opt目录下，把hadoop-2.3.0-cdh5.0.2直接重命名为hadoop（现在你的cdh根目录是/opt/hadoop），下面进行我们的修改工作：</p><ol><li>把bin-mapreduce1的所以文件拷贝到bin下，对于相同的文件，直接覆盖即可。</li><li>在/opt/hadoop/share/hadoop文件夹下有如下的文件结构<br><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB20NG9apXXXXaoXXXXXXXXXXXX_!!581166664.png" alt="share/hadoop目录结构"></li></ol><p>把其中的mapreduce这个软链接文件删除，然后创建一个同名的软链接指向mapreduce1<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/hadoop/share/hadoop/</span><br><span class="line">rm mapreduce -rf</span><br><span class="line"><span class="keyword">ln</span> -s mapreduce1 mapreduce</span><br></pre></td></tr></table></figure></p><p>经过上面这两步后，就默认启用了MRv1模式了，大家可以先把不带Kerberos安全认证的全分布式搭建起来，等到不带Kerberos安全认证的全分布式搭建起来后（可参考<a href="http://blog.csdn.net/jiacai2050/article/details/8630329" target="_blank" rel="noopener">Hadoop全分布式搭建</a>），再进行下面的操作。</p><h3 id="2-3-配置HDFS"><a href="#2-3-配置HDFS" class="headerlink" title="2.3 配置HDFS"></a>2.3 配置HDFS</h3><p>下面大家就可以按照<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Security-Guide/cdh5sg_cdh5_hadoop_security.html" target="_blank" rel="noopener">官网的教程</a>进行操作，下面说下我遇到的坑：</p><ul><li>在STEP 2中，必须参照<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Installation-Guide/cdh5ig_mr_cluster_deploy.html#topic_11_3" target="_blank" rel="noopener">MRv1 cluster deploy</a>，在hdfs中创建/tmp，与mapred.system.dir制定的目录，并且修改为相应的权限。</li><li>在STEP 7中，最后的dfs.http.policy这个property不用配置，否则在后面启动namnode是会报.keystore文件找不到的异常。</li><li>STEP 8、9、10可选，配不配都行</li><li>在STEP 11中，需要配置JSVC_HOME这个属性，这里把我们一开始下载的bigtop-jsvc-1.0.10-cdh5.0.2.tar.gz解压后，放到它制定的位置上即可。</li><li>在STEP 12、13,启动datanode、namenode时，用sbin下的命令<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/hadoop-daemon.sh <span class="literal">start</span> namenode</span><br><span class="line">sbin/hadoop-daemons.sh <span class="literal">start</span> datanode</span><br></pre></td></tr></table></figure></li></ul><p>这两条命令都是用root用户执行。</p><p>在这过程中，如果遇到什么logs文件夹不能写入，将其权限改为777即可。</p><h3 id="2-4-配置mapreduce"><a href="#2-4-配置mapreduce" class="headerlink" title="2.4 配置mapreduce"></a>2.4 配置mapreduce</h3><p>配置mapreduce接着参考官方的<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Security-Guide/cdh5sg_mrv1_security.html" target="_blank" rel="noopener">教程</a>，下面继续说我遇到的坑：</p><ul><li>首先是taskcontroller.cfg文件问题，hadoop会在<path of task-controller binary>/../../conf/下去找这个文件，所以我们需要在/opt/hadoop下面（也就是我们解压后的根目录下），创建一个conf文件，然后在按照官方说的配置就行了，官方教程中有一条<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">banned.users</span>=mapred,hdfs,bin</span><br></pre></td></tr></table></figure></path></li></ul><p>这里这样配置后，后面运行wordcount会报异常，这里可直接将其值配置为bin即可</p><ul><li>然后就是task-controller这个文件的权限问题了，一定要用下面命令进行修改<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown root:mapred <span class="keyword">task</span>-controller</span><br><span class="line">chmod <span class="number">4754</span> <span class="keyword">task</span>-controller</span><br></pre></td></tr></table></figure></li></ul><p>其解释也在<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-Security-Guide/cdh5sg_other_hadoop_security.html#topic_18_unique_2" target="_blank" rel="noopener">官网</a>上有。</p><ul><li>当这一切都配置好后，启动jobtracker与tasktracker还是有错，这个错误是<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="selector-tag">-07-15</span> 18<span class="selector-pseudo">:15</span><span class="selector-pseudo">:25</span>,722 <span class="selector-tag">ERROR</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.mapred</span><span class="selector-class">.TaskTracker</span>: <span class="selector-tag">Can</span> <span class="selector-tag">not</span> <span class="selector-tag">start</span> <span class="selector-tag">task</span> <span class="selector-tag">tracker</span> <span class="selector-tag">because</span> <span class="selector-tag">java</span><span class="selector-class">.io</span><span class="selector-class">.IOException</span>: <span class="selector-tag">Secure</span> <span class="selector-tag">IO</span> <span class="selector-tag">is</span> <span class="selector-tag">necessary</span> <span class="selector-tag">to</span> <span class="selector-tag">run</span> <span class="selector-tag">a</span> <span class="selector-tag">secure</span> <span class="selector-tag">task</span> <span class="selector-tag">tracker</span>.</span><br><span class="line">        <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.mapred</span><span class="selector-class">.TaskTracker</span><span class="selector-class">.checkSecurityRequirements</span>(<span class="selector-tag">TaskTracker</span><span class="selector-class">.java</span><span class="selector-pseudo">:943)</span></span><br><span class="line">        <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.mapred</span><span class="selector-class">.TaskTracker</span><span class="selector-class">.initialize</span>(<span class="selector-tag">TaskTracker</span><span class="selector-class">.java</span><span class="selector-pseudo">:976)</span></span><br><span class="line">        <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.mapred</span><span class="selector-class">.TaskTracker</span>.&lt;<span class="selector-tag">init</span>&gt;(<span class="selector-tag">TaskTracker</span><span class="selector-class">.java</span><span class="selector-pseudo">:1780)</span></span><br><span class="line">        <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.hadoop</span><span class="selector-class">.mapred</span><span class="selector-class">.TaskTracker</span><span class="selector-class">.main</span>(<span class="selector-tag">TaskTracker</span><span class="selector-class">.java</span><span class="selector-pseudo">:4124)</span></span><br></pre></td></tr></table></figure></li></ul><p>这个错误是因为缺少native包所致，这个包应该是在/opt/hadoop/lib/native/，很遗憾，这些东西需要我们自己编译，因为每个版本都不一样，我把apache hadoop的native直接copy过去也不行。<del>这里我偷了个懒，直接从同事那里copy过来了。以后会说说如何从源码编译。</del>下面说说如何编译。<br>cdh的源码都放在src文件夹下，安装好maven后直接到这个文件夹下编译就可以，我这里使用的是centos6.5编译的，遇到的问题主要有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. maven repository经常连接不上，需要多次重复操作。以后最好做一个本地repo</span><br><span class="line">2. centos上需要自己安装一些依赖，否则回报各种错误，可以用下面这条命令 </span><br><span class="line">   yum <span class="keyword">install</span> -y glibc-headers gcc-c++ zlib-devel openssl-devel </span><br><span class="line"><span class="number">3.</span> 一些<span class="keyword">test</span>通过不了，需要跳过，用下面这条命令进行编译</span><br><span class="line">   mvn <span class="keyword">package</span> -Pdist,<span class="keyword">native</span> -DskipTests</span><br></pre></td></tr></table></figure><p>好了，如果在编译过程中还是遇到什么依赖缺失，直接去google下就ok了。</p><ul><li>在用root启动jobtracker与tasktracker命令行会有错误信息，提示我们不能直接用root启动这两个进程，在haooop-env.sh配置下面的信息就好了<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">HADOOP_JOBTRACKER_USER</span>=mapred</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HADOOP_TASKTRACKER_USER</span>=mapred</span><br></pre></td></tr></table></figure></li></ul><p>启动的命令是<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sbin/hadoop-daemon.sh </span>start <span class="keyword">jobtracker</span></span><br><span class="line"><span class="keyword">sbin/hadoop-daemons.sh </span>start tasktracker</span><br></pre></td></tr></table></figure></p><p>也有由root启动。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这次搭建过程前前后后用了一个星期，麻烦是一回事，各种权限问题，最主要是还是我对hadoop的基本组成不够了解，hadoop的各个部分都是分开的，在share/hadoop目录下的每个文件夹都对应与一个功能，我一开始就想着把他们都放一起，导致不同模块的配置文件重复并产生冲突，最后导致进程起不来，今后还是要加强对基本概念的理解。其次是遇到错误多看看日志文件，很多错误能够直接根据错误信息就能够改正。</p><p>还有需要吐槽的就是不能完全按部就班的照着教程来操作，应该先看看像faq这些信息，做到有个整体上的把握，不至于拆了东墙补西墙，到最后也没能完全解决问题。</p><p>下面进行<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/CDH5/latest/CDH5-High-Availability-Guide/CDH5-High-Availability-Guide.html" target="_blank" rel="noopener">HA的环境搭建</a>，这次一定要提高效率了！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说得好，万事开头难。在软件开发中，环境部署要算是第一门槛了。我最近折腾了一周时间把cdh5.0.2.tar.gz版本在MRv1模式下，成功集成了Kerberos安全认证，并且是在全分布式模式下。经过这次安装过程，对hadoop的了解又深入了一层。现在趁着自己刚搭建完环境，脑子还时不时的闪现遇到的错误，把我的安装过程记录于此，一方面方便自己今后查阅，另一方面希望对今后遇到同样问题人有所启发。&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://liujiacai.net/categories/bigdata/"/>
    
    
      <category term="hadoop" scheme="http://liujiacai.net/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>JVM 的类初始化机制</title>
    <link href="http://liujiacai.net/blog/2014/07/12/order-of-initialization-in-java/"/>
    <id>http://liujiacai.net/blog/2014/07/12/order-of-initialization-in-java/</id>
    <published>2014-07-12T05:02:29.000Z</published>
    <updated>2019-12-24T10:59:14.595Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更新日志</p></blockquote><ul><li>2014-07-12, 根据校招经验，完成<a href="https://github.com/jiacai2050/jiacai2050.github.io/blob/c7a3e971d8906841eb2ac8b592ea2453d3ad2533/source/_posts/2014-07-12-order-of-initialization-in-java.markdown" target="_blank" rel="noopener">初稿</a>，很多地方没写清楚</li><li>2017-01-15，全部重写，<a href="https://github.com/jiacai2050/jiacai2050.github.io/blob/c9f20af48feec16904c666b87f5cc44b3408b765/source/_posts/2014-07-12-order-of-initialization-in-java.markdown" target="_blank" rel="noopener">增加 Load、Link、Initialization 过程与三个示例</a></li><li>2018-03-30，调整示例代码，增加「什么是类的加载」、「双亲委托模式」两小节</li></ul><hr><p>当你在 Java 程序中<code>new</code>对象时，有没有考虑过 JVM 是如何把静态的字节码（byte code）转化为运行时对象的呢，这个问题看似简单，但里面的细节很多，而且由于开发者在平时与之打交道较少，很少有同学会去主动探索这块知识，但这个知识点却是面试时常考的地方，而且熟练掌握类加载是实现代码热部署的关键。</p><p>本文将结合几个具体案例，来阐述 JVM 类初始化这个问题，希望引起大家对这个知识点的注意。</p><h2 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h2><p>通俗来讲，类的加载就是指将 .class 文件中的字节码读入内存，将其放在运行时数据区的方法区（method code）内，最终在堆区（heap）中创建一个 java.lang.Class 对象。</p><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2iQhEcYFlpuFjy0FgXXbRBVXa_!!581166664.png" alt="JVM 内部结构"></p><p>Class 对象封装了类在方法区内的数据结构，并且向提供了访问方法区内的数据结构的接口。</p><h2 id="何时进行类加载"><a href="#何时进行类加载" class="headerlink" title="何时进行类加载"></a>何时进行类加载</h2><p>一般来说，只有在<strong>第一次</strong> <strong>主动调用</strong> 某个类时才会去进行类加载。如果一个类有父类，会先去加载其父类，然后再加载其自身。</p><p>上面这段话有两个关键词：<strong>第一次</strong> 与 <strong>主动调用</strong>。<strong>第一次</strong> 是说只在第一次时才会有初始化过程，以后就不需要了，可以理解为每个类 <strong>有且仅有一次</strong> 初始化的机会。那么什么是 <strong>主动调用</strong> 呢？<br>JVM 规定了以下六种情况为 <strong>主动调用</strong>，其余的皆为 <strong>被动调用</strong>：</p><ol><li>一个类的实例被创建（<code>new</code>操作、反射、<code>cloning</code>，反序列化）</li><li>调用类的<code>static</code>方法</li><li>使用或对类/接口的<code>static</code>属性进行赋值时（这不包括<code>final</code>的与在编译期确定的常量表达式）</li><li>当调用 API 中的某些反射方法时</li><li>子类被初始化</li><li>被设定为 JVM 启动时的启动类（具有<code>main</code>方法的类）</li></ol><p>关于主动加载与被动加载的区别，可以参考下面这个例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewParent</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> hoursOfSleep = (<span class="keyword">int</span>) (Math.<span class="built_in">random</span>() * <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"NewParent was initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewbornBaby</span> <span class="title">extends</span> <span class="title">NewParent</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> hoursOfCrying = <span class="number">6</span> + (<span class="keyword">int</span>) (Math.<span class="built_in">random</span>() * <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"NewbornBaby was initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUsageDemo</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoking main() is an active use of ActiveUsageDemo</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using hoursOfSleep is an active use of NewParent,</span></span><br><span class="line">        <span class="comment">// but a passive use of NewbornBaby</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(NewbornBaby.hoursOfSleep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"ActiveUsageDemo was initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序最终输出：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActiveUsageDemo was initialized.</span><br><span class="line">NewParent was initialized.</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>之所以没有输出<code>NewbornBaby was initialized.</code>是因为没有主动去调用<code>NewbornBaby</code>，如果把打印的内容改为<code>NewbornBaby.hoursOfCrying</code> 那么这时就是主动调用<code>NewbornBaby</code>了，相应的语句也会打印出来。</p><h2 id="类加载的生命周期"><a href="#类加载的生命周期" class="headerlink" title="类加载的生命周期"></a>类加载的生命周期</h2><p>JVM 将字节码转化为运行时对象分为三个阶段，分别是：loading 、Linking、initialization。</p><p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2kGtOc88lpuFjy0FnXXcZyXXa_!!581166664.gif" alt="The beginning of a class&#39;s lifetime"></p><p>下面分别介绍这三个过程：</p><h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><p>Loading 过程主要工作是由<code>ClassLoader</code>完成。该过程具体包括三件事：</p><ol><li>根据类的全名，生成一份二进制字节码来表示该类</li><li>将二进制的字节码解析成<a href="http://www.artima.com/insidejvm/ed2/jvm5.html" target="_blank" rel="noopener">方法区</a>对应的数据结构</li><li>最后生成一 <code>Class</code> 对象的实例来表示该类</li></ol><p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2HtNyc4dkpuFjy0FbXXaNnpXa_!!581166664.gif" alt="ClassLoader 继承关系，不同 CL 负责加载不同类"></p><p>JVM 中除了最顶层的<code>Boostrap ClassLoader</code>是用 C/C++ 实现外，其余类加载器均由 Java 实现，我们可以用<code>getClassLoader</code>方法来获取当前类的类加载器：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># sun.misc.Launcher$AppClassLoader@30a4effe</span></span><br><span class="line"># AppClassLoader 也就是上图中的 System Class Loader</span><br></pre></td></tr></table></figure></p><p>此外，我们在启动<code>java</code>传入<code>-verbose:class</code>来查看加载的类有那些。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="symbol">verbose:</span><span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span></span></span><br><span class="line"></span><br><span class="line">[Opened /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">[Loaded java.lang.Object from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">[Loaded java.io.Serializable from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">[Loaded java.lang.Comparable from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">[Loaded java.lang.CharSequence from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">[Loaded java.security.BasicPermissionCollection from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">[Loaded ClassLoaderDemo from <span class="symbol">file:</span>/Users/liujiacai/codes/IdeaProjects/mysql-test/target/classes/]</span><br><span class="line">[Loaded sun.launcher.LauncherHelper$FXHelper from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">[Loaded java.lang.Class$MethodArray from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">2</span>a139a55</span><br><span class="line">[Loaded java.lang.Shutdown from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br><span class="line">[Loaded java.lang.Shutdown$Lock from /Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0_112</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span>]</span></span><br></pre></td></tr></table></figure></p><p>ClassLoader 还具有一重要特性：双亲委派模型。具体来说就是：</p><blockquote><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></blockquote><h3 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h3><h4 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h4><p><code>Verification</code> 主要是保证类符合 Java 语法规范，确保不会影响 JVM 的运行。包括但不限于以下事项：</p><ul><li>bytecode 的完整性（integrity）</li><li>检查<code>final</code>类没有被继承，<code>final</code>方法没有被覆盖</li><li>确保没有不兼容的方法签名</li></ul><h4 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h4><p>在这个阶段，JVM 会为 <strong>类成员变量</strong>（不包括实例变量）分配内存空间并且赋予默认初始值，需要注意的是这个阶段不会执行任何代码，而只是根据<code>变量类型</code>决定初始值。如果不进行默认初始化，分配的空间的值是随机的，有点类型c语言中的<a href="http://zh.wikipedia.org/zh/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88" target="_blank" rel="noopener">野指针</a>问题。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TypeInitial Value</span><br><span class="line"><span class="keyword">int</span><span class="number">0</span></span><br><span class="line"><span class="keyword">long</span><span class="number">0</span>L</span><br><span class="line"><span class="keyword">short</span>(<span class="keyword">short</span>) <span class="number">0</span></span><br><span class="line"><span class="keyword">char</span><span class="string">'\u0000'</span></span><br><span class="line"><span class="keyword">byte</span>(<span class="keyword">byte</span>) <span class="number">0</span></span><br><span class="line"><span class="keyword">boolean</span><span class="keyword">false</span></span><br><span class="line">reference<span class="keyword">null</span></span><br><span class="line"><span class="keyword">float</span><span class="number">0.0</span>f</span><br><span class="line"><span class="keyword">double</span><span class="number">0.0</span>d</span><br></pre></td></tr></table></figure></p><p>另一个需要注意的是实例<br>在这个阶段，JVM 也可能会为有助于提高程序性能的数据结构分配内存，常见的一个称为<code>method table</code>的数据结构，它包含了指向所有类方法（也包括也从父类继承的方法）的指针，这样再调用父类方法时就不用再去搜索了。</p><h4 id="Resolution"><a href="#Resolution" class="headerlink" title="Resolution"></a>Resolution</h4><p><code>Resolution</code> 阶段主要工作是确认类、接口、属性和方法在类<code>run-time constant pool</code>的位置，并且把这些符号引用（symbolic references）替换为直接引用（direct references）。</p><blockquote><p>locating classes, interfaces, fields, and methods referenced symbolically from a type’s constant pool, and replacing those symbolic references with direct references.</p></blockquote><p>这个过程不是必须的，也可以发生在第一次使用某个符号引用时。</p><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>经过了上面的<code>load</code>、<code>link</code>后，就到了 <code>Initialization</code>。这个阶段会去真正执行代码，具体包括：代码块（static与static）、构造函数、变量显式赋值。</p><p>这些代码执行的顺序遵循以下两个原则：</p><ol><li>有static先初始化static，然后是非static的</li><li>显式初始化，构造块初始化，最后调用构造函数进行初始化</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="属性在不同时期的赋值"><a href="#属性在不同时期的赋值" class="headerlink" title="属性在不同时期的赋值"></a>属性在不同时期的赋值</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance = <span class="keyword">new</span> Singleton();<span class="comment">// 位置1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static Singleton mInstance = new Singleton();// 位置2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstantce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitDemo</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Singleton singleton = Singleton.getInstantce();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"counter1: "</span> + singleton.counter1);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"counter2: "</span> + singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>mInstance</code>在位置1时，打印出<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">counter1:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">counter2:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>当<code>mInstance</code>在位置2时，打印出<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">counter1:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">counter2:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><code>Singleton</code>中的三个属性在<code>Preparation</code>阶段会根据类型赋予默认值，在<code>Initialization</code>阶段会根据显示赋值的表达式再次进行赋值（按顺序自上而下执行）。根据这两点，就不难理解上面的结果了。</p><h3 id="首次主动调用才会初始化"><a href="#首次主动调用才会初始化" class="headerlink" title="首次主动调用才会初始化"></a>首次主动调用才会初始化</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alibaba</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Alibaba t1 = <span class="keyword">new</span> Alibaba(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Alibaba t2 = <span class="keyword">new</span> Alibaba(<span class="string">"t2"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="built_in">print</span>(<span class="string">"i"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = <span class="built_in">print</span>(<span class="string">"j"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Alibaba</span><span class="params">(<span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>((++k) + <span class="string">":"</span> + str + <span class="string">"   i="</span> + i + <span class="string">"    n="</span> + n);</span><br><span class="line">        ++i;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>((++k) + <span class="string">":"</span> + str + <span class="string">"   i="</span> + i + <span class="string">"    n="</span> + n);</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span> </span>&#123;</span><br><span class="line">        Alibaba t = <span class="keyword">new</span> Alibaba(<span class="string">"init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子是阿里巴巴在14年的校招附加题，我当时看到这个题，就觉得与阿里无缘了。囧</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1:j   <span class="attribute">i</span>=0    <span class="attribute">n</span>=0</span><br><span class="line">2:构造块   <span class="attribute">i</span>=1    <span class="attribute">n</span>=1</span><br><span class="line">3:t1   <span class="attribute">i</span>=2    <span class="attribute">n</span>=2</span><br><span class="line">4:j   <span class="attribute">i</span>=3    <span class="attribute">n</span>=3</span><br><span class="line">5:构造块   <span class="attribute">i</span>=4    <span class="attribute">n</span>=4</span><br><span class="line">6:t2   <span class="attribute">i</span>=5    <span class="attribute">n</span>=5</span><br><span class="line">7:i   <span class="attribute">i</span>=6    <span class="attribute">n</span>=6</span><br><span class="line">8:静态块   <span class="attribute">i</span>=7    <span class="attribute">n</span>=99</span><br><span class="line">9:j   <span class="attribute">i</span>=8    <span class="attribute">n</span>=100</span><br><span class="line">10:构造块   <span class="attribute">i</span>=9    <span class="attribute">n</span>=101</span><br><span class="line">11:init   <span class="attribute">i</span>=10    <span class="attribute">n</span>=102</span><br></pre></td></tr></table></figure><p>上面是程序的输出结果，下面我来一行行分析之。</p><ol><li>由于<code>Alibaba</code>是 JVM 的启动类，属于主动调用，所以会依此进行 loading、linking、initialization 三个过程。</li><li>经过 loading与 linking 阶段后，所有的属性都有了默认值，然后进入最后的 initialization 阶段。</li><li>在 initialization 阶段，先对 static 属性赋值，然后在非 static 的。<code>k</code> 第一个显式赋值为 0 。</li><li><p>接下来是<code>t1</code>属性，由于这时<code>Alibaba</code>这个类已经处于 initialization 阶段，static 变量无需再次初始化了，所以忽略 static 属性的赋值，只对非 static 的属性进行赋值，所有有了开始的：</p><pre><code>1:j   i=0    n=02:构造块   i=1    n=13:t1   i=2    n=2</code></pre></li><li><p>接着对<code>t2</code>进行赋值，过程与t1相同</p><pre><code>4:j   i=3    n=35:构造块   i=4    n=46:t2   i=5    n=5</code></pre></li><li><p>之后到了 static 的 <code>i</code> 与 <code>n</code>：</p><pre><code>7:i   i=6    n=6</code></pre></li><li><p>到现在为止，所有的static的成员变量已经赋值完成，接下来就到了 static 代码块</p><pre><code>8:静态块   i=7    n=99</code></pre></li><li><p>至此，所有的 static 部分赋值完毕，接下来是非 static 的 <code>j</code></p><pre><code>9:j   i=8    n=100</code></pre></li><li><p>所有属性都赋值完毕，最后是构造块与构造函数</p><pre><code>10:构造块   i=9    n=10111:init   i=10    n=102</code></pre></li></ol><p>经过上面这9步，<code>Alibaba</code>这个类的初始化过程就算完成了。这里面比较容易出错的是第3步，认为会再次初始化 static 变量或代码块。而实际上是没必要，否则会出现多次初始化的情况。</p><p>希望大家能多思考思考这个例子的结果，加深 JVM 初始化类过程的理解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过最后这三个例子，相信大家对 JVM 的类加载机制都有了更深的理解，如果大家还是有疑问，欢迎留言讨论。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html" target="_blank" rel="noopener">Java Virtual Machine Specification Chapter 5</a></li><li><a href="http://www.artima.com/insidejvm/ed2/lifetypeP.html" target="_blank" rel="noopener">Chapter 7 of Inside the Java Virtual Machine</a></li><li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a></li><li><a href="https://www.quora.com/What-kind-of-method-is-Constructor-static-or-non-static" target="_blank" rel="noopener">What kind of method is Constructor, static or non static?</a></li><li><a href="http://www.ibm.com/developerworks/java/tutorials/j-classloader/j-classloader.html" target="_blank" rel="noopener">Understanding the Java ClassLoader</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;更新日志&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;2014-07-12, 根据校招经验，完成&lt;a href=&quot;https://github.com/jiacai2050/jiacai2050.github.io/blob/c7a3e9
      
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>计算思维之三语义符号化表达与计算</title>
    <link href="http://liujiacai.net/blog/2014/06/06/computational-thinking-3/"/>
    <id>http://liujiacai.net/blog/2014/06/06/computational-thinking-3/</id>
    <published>2014-06-06T13:13:30.000Z</published>
    <updated>2019-12-24T10:59:14.595Z</updated>
    
    <content type="html"><![CDATA[<p>##0和1与逻辑——思维符号化表达与逻辑运算<br><a id="more"></a><br><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2G2hDapXXXXacXXXXXXXXXXXX_!!581166664.png" alt="语义符号化表达与计算"></p><p>有上图可知，在进行语义符号化表达与计算过程中分为如图所示的六步，下面分别进行阐述。</p><h3 id="1-语义符号化与符号计算化"><a href="#1-语义符号化与符号计算化" class="headerlink" title="1. 语义符号化与符号计算化"></a>1. 语义符号化与符号计算化</h3><h4 id="1-1-自然现象"><a href="#1-1-自然现象" class="headerlink" title="1.1 自然现象"></a>1.1 自然现象</h4><p>老师用的例子是我们中国的经典著作《易经》讲述的，首先讲解卦相，最基本的两类元素是“阴”与“阳”，有这两种元素的不同组合，可以得到更多的卦相;此外，我们还可以对“阴”与“阳”进行语义化，比如“阴”代表“凉”，“阳”代表“热”，这样我们就可以得到二十四节气的变化图。</p><p><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2z4tzapXXXXbkXXXXXXXXXXXX_!!581166664.png" alt="二十四节气"></p><h4 id="1-2-思维符号化与逻辑运算"><a href="#1-2-思维符号化与逻辑运算" class="headerlink" title="1.2 思维符号化与逻辑运算"></a>1.2 思维符号化与逻辑运算</h4><p>逻辑是指事物因果之间所遵循的规律，是现实中普适的思维方式。</p><p>逻辑的基本表示形式是<strong>命题</strong>与<strong>推理</strong>，推理即根据由简单命题的判断推导得出复杂命题的判断结论的过程。命题由语句表述，即内容为“真”或为“假”的一个判断语句！</p><p>举个例子：在一次中学测验过程中，有三位老师做了测评：A.学习委员及格;B.有人不及格;C.全班都不及格。在考试后，证明只有一个老师的预测是对的，请问谁对谁错？</p><p>求解过程：</p><ul><li>命题A：“学习委员及格（有人及格）”</li><li>命题B：“有人不及格”</li><li>命题C：“全班都不及格”</li></ul><p>由题目假设和命题之间的关系得出“已知”：A、B、C只有一个为真</p><ul><li>如果A真，则C假;如果C真，则A假</li><li>如果B真，而A，C可能有一个为真，与题目矛盾，所以B为假。</li><li>如果B假，则“全班都及格”为真，而由此推断C为假。</li></ul><p>由上“已知”，推理：A为真。</p><p>如果我们将逻辑表达为0和1及其运算：1为真，0为假，运算规则有“AND”、“OR”、“NOT”、“XOR”。</p><p>一个命题用A、B等符号表达，其中符号的值可能为0也可能为1</p><p>求解过程：</p><ul><li>命题A：“学习委员及格（有人及格）”</li><li>命题B：“有人不及格”</li><li>命题C：“全班都不及格”</li></ul><p>已知：</p><ul><li>( A AND (NOT C) ) OR ( (NOT A) AND C ) = 1</li><li>(NOT B) AND ( ( A AND (NOT C) ) OR ( (NOT A) AND C ) ) = 1</li><li>(NOT B) AND (NOT C) = 1</li></ul><p>组合形成所有可能解：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;A=<span class="number">1</span>,B=<span class="number">0</span>,C=<span class="number">0</span>&gt;,&lt;A=<span class="number">0</span>,B=<span class="number">1</span>,C=<span class="number">0</span>&gt;,&lt;A=<span class="number">0</span>,B=<span class="number">0</span>,C=<span class="number">1</span>&gt;&#125;</span><br></pre></td></tr></table></figure></p><p>就上面这三种情况，将这三种情况分别带入到已知条件中，都满足的便是问题的解：</p><p>&lt;A=1,B=0,C=0&gt;</p><p>####深入知识：</p><ul><li>亚里士多德（公元前384-322），古希腊哲学家：形式逻辑</li></ul><blockquote><p>典型概念：命题、推理、三段论</p></blockquote><ul><li>莱布尼茨（1646-1716），德国数学家：数理逻辑</li></ul><blockquote><p>典型概念：谓词、谓词演算</p></blockquote><ul><li>布尔（1815-1864），德国数学家：布尔代数</li></ul><blockquote><p>典型概念：布尔量、布尔值、布尔运算、布尔操作</p></blockquote><ul><li>其他：时序逻辑（Temporal Logics）、模态逻辑（Model Logics）、归纳逻辑（Inductive Logics）、模糊逻辑（Fuzzy Logics）、粗糙逻辑（Rough Logics）、非单逻辑等</li></ul><p>整个第一大节所说为语义符号化表达与计算过程的前两步的内容。</p><p><a name="buma"></a></p><h3 id="2-计算0-1化"><a href="#2-计算0-1化" class="headerlink" title="2. 计算0/1化"></a>2. 计算0/1化</h3><p>这一部分主要是数值与非数值的数字化表示。</p><h4 id="2-1-数值信息的表示"><a href="#2-1-数值信息的表示" class="headerlink" title="2.1 数值信息的表示"></a>2.1 数值信息的表示</h4><p>数值信息比较好表示，无非就是原码、反码、补码这些东西，其中我有疑问的是为什么使用补码后就可以在进行算数运算时把符号位也算进去？？<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举个例子，用5位二进制为表示数字，其中一位为符号位，计算10-3=？, -5-7=?</span></span><br><span class="line">    <span class="number">0</span> <span class="number">1010</span>            <span class="number">1</span> <span class="number">1011</span>        </span><br><span class="line">+)  <span class="number">1</span> <span class="number">1101</span>         +) <span class="number">1</span> <span class="number">1001</span>  </span><br><span class="line">------------    ------------</span><br><span class="line">    <span class="number">0</span> <span class="number">0111</span>            <span class="number">1</span> <span class="number">0100</span></span><br><span class="line">    这是<span class="number">7</span>的反码        这是<span class="number">-12</span>的反码</span><br></pre></td></tr></table></figure></p><p>经过<a href="http://www.douban.com/note/223507364/" target="_blank" rel="noopener">一番google</a>后发现了其中的奥秘，因为现在计算机中只有加法器，<font color="red">没有减法器（这里我还不知道为什么计算机设计时没什么没有减法器，不知道是出于什么考虑）</font>，所以计算机需要把所有的运算（包括减法，乘法，除法）转化为加法运算，补码就是为了将减法运行转化为加法运算而提出的概念。补码的本质就求模运算，可以这么想，以我们常见的分钟（模为60）为例，假设现在是30分，要想回到20分，有两种途径：</p><ul><li>在30分的基础上，减去10分钟，30-10=20</li><li>在30分的基础上，加上50分钟，如果不考虑小时的大小，那么30+50-60=20,也是回到了20分</li></ul><p>我们都知道负数的补码=反码+1，现在有了模的概念，我们还有这么个公式，补码=模-|负数|。</p><p>上面时间的例子，要想得到-10分钟的补码，我们用60-10即可得到补码50,在用模的思想来考虑补码时，就没有什么符号位的概念了，符号位和其他数码位一样，就是通过模减去负数的绝对值得到的，最高位该是0就是0，该是1就是1，比如为什么-128的补码是1000 0000呢，因为<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用模的概念来求反码</span></span><br><span class="line"><span class="code">    1 0000 0000</span></span><br><span class="line">-)    1000 0000</span><br><span class="line">-----------------</span><br><span class="line"><span class="code">      1000 0000</span></span><br></pre></td></tr></table></figure></p><p>从上面可以看出，模就是现有二进制能表示的范围（在8位二进制中，表示范围为0～255,即256个不同的元素）。如果进一步推导可以得到1 0000 0000 = 1111 1111 + 1，那么求-128的补码的过程还可以这么做：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//补码=反码+1 的本质</span></span><br><span class="line"><span class="code">      1111 1111</span></span><br><span class="line">-)    1000 0000</span><br><span class="line">-----------------</span><br><span class="line"><span class="code">      0111 1111</span></span><br><span class="line">+)    0000 0001          </span><br><span class="line">-----------------</span><br><span class="line"><span class="code">      1000 0000</span></span><br></pre></td></tr></table></figure></p><p>这样求负数补码的过程就对应了：</p><ol><li>先求一个负数的反码（减法过程）</li><li>反码+1（加1过程）</li></ol><p>当然，模的概念是我们人为的理解，计算机肯定不会这么“理解”，它是严格按照补码=反码+1的公式来运作的，因为采用模的思路来计算补码时需要用到减法，而计算机是不会做减法的。</p><p><center>图2. 8位二进制的补码表</center><br><img src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB2OJ54apXXXXXXXpXXXXXXXXXX_!!581166664.jpg" alt="补码"></p><p>如图2所示，8位二进制的补码表示的数值范围在-128～+127之间，之所以负数比正数的绝对值大1是因为只有+0,没有-0,在补码=反码+1公式中的+1操作把-0加没了，而与之对应的是负数的另一端向前（向负数轴方向）加1不就得到了-128了嘛。</p><h4 id="2-2-非数值信息的表示"><a href="#2-2-非数值信息的表示" class="headerlink" title="2.2 非数值信息的表示"></a>2.2 非数值信息的表示</h4><p>这里无非就是各种编码，像ASCII，BCD码,Unicode编码。这里不同的编码所用的字节长度是不一样，所以我们在声明变量是需要指定变量的类型。</p><ul><li>汉字内码，汉字在计算机内部采用汉字内码编码，汉字内码是一两字节且最高位均为1的编码</li><li>汉字输入码，是用键盘上的字母符号编码每一个汉字的编码，常见的有：拼音码、字型码、区位码……</li><li>汉字字型码，用0和1编码无亮点和有亮点像素，形成汉字字型的一种编码。</li></ul><h3 id="3-自动化0-1，分层构造化，构造集成化"><a href="#3-自动化0-1，分层构造化，构造集成化" class="headerlink" title="3. 自动化0/1，分层构造化，构造集成化"></a>3. 自动化0/1，分层构造化，构造集成化</h3><p>实现0和1的基本元器件：电信号和继电器开关、二极管、三极管。话说这一部门主要是数字逻辑部分的知识。这让我想起了我大学的沙老师。下面给几张电路图找找感觉：<br><img src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB2MHSVapXXXXbDXpXXXXXXXXXX_!!581166664.png" alt="用二极管实现门电路"></p><p><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2li94apXXXXXmXpXXXXXXXXXX_!!581166664.png" alt="加法器"></p><p><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2PP54apXXXXcFXXXXXXXXXXXX_!!581166664.png" alt="2-4译码器"></p><p>复杂的逻辑器件是通过已证明无误的简单器件构成。这体现了分层处理问题的思想，和计算机网络上的ISO/OSI七层协议一样。</p><p><img src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB2Lwa6apXXXXcdXXXXXXXXXXXX_!!581166664.png" alt=" 0-1-conclusion"><br>最后这张图片是这部分的一个总结。</p>]]></content>
    
    <summary type="html">
    
      0和1与逻辑——思维符号化表达与逻辑运算
    
    </summary>
    
    
      <category term="mooc" scheme="http://liujiacai.net/tags/mooc/"/>
    
  </entry>
  
  <entry>
    <title>计算思维之二计算之树</title>
    <link href="http://liujiacai.net/blog/2014/06/06/computational-thinking-2/"/>
    <id>http://liujiacai.net/blog/2014/06/06/computational-thinking-2/</id>
    <published>2014-06-06T05:07:27.000Z</published>
    <updated>2019-12-24T10:59:14.594Z</updated>
    
    <content type="html"><![CDATA[<p>这次从计算机的宏观角度对整个计算机行业做个剖析，这里老师引入一个计算之树的模型。<br><a id="more"></a></p><p><center>图1.计算之树全貌</center><br><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2x7JuapXXXXXUXpXXXXXXXXXX_!!581166664.png" alt=" 计算之树"></p><h2 id="1-计算之树第一维度——计算思维的奠基行思维"><a href="#1-计算之树第一维度——计算思维的奠基行思维" class="headerlink" title="1. 计算之树第一维度——计算思维的奠基行思维"></a>1. 计算之树第一维度——计算思维的奠基行思维</h2><ul><li>0和1思维—&gt;符号话—&gt;计算化—&gt;自动化</li><li>“程序”思维—&gt;千变万化复杂功能的构造、表达与执行</li><li>“递归”思维—&gt;无限事物及重复过程的表达与执行</li></ul><h2 id="2-计算之树第二维度——通用环境的演化思维"><a href="#2-计算之树第二维度——通用环境的演化思维" class="headerlink" title="2. 计算之树第二维度——通用环境的演化思维"></a>2. 计算之树第二维度——通用环境的演化思维</h2><ul><li>冯.诺依曼计算机，程序在内存中直接执行</li><li>个人计算机，程序一般都存放在外存中，需要操作系统把它们加载到内存</li><li>并行分布计算环境</li><li>云计算环境</li></ul><p>程序执行环境:由CPU-内存环境—&gt;到CPU-存储体系环境—&gt;到多CPU-多存储器环境—&gt;云计算虚拟计算环境</p><p><center>图2. 通用环境的演化思维</center><br><img src="http://img02.taobaocdn.com/imgextra/i2/581166664/TB2zBXwapXXXXXQXpXXXXXXXXXX_!!581166664.png" alt="计算之树第二维度——通用环境的演化思维"></p><h2 id="3-计算之树第三维度——-交替促进与共同进化的问题求解思维"><a href="#3-计算之树第三维度——-交替促进与共同进化的问题求解思维" class="headerlink" title="3. 计算之树第三维度—— 交替促进与共同进化的问题求解思维"></a>3. 计算之树第三维度—— 交替促进与共同进化的问题求解思维</h2><blockquote><p>算法：问题求解的一种手段——构造与设计算法<br></p><blockquote><p>算法是计算的灵魂;算法强调数学建模;算法考虑的是可计算行与计算复杂度;算法研究通常被认为是计算学科的理论研究。</p></blockquote></blockquote><blockquote><p>系统：问题求解的另一中手段——构造与设计系统<br></p><blockquote><p>系统是改造自然的手段;系统强调非数学建模;系统考虑的是如何化负责为简单（使其能够被做出来）;系统强调结构性、可靠性、安全性等。</p></blockquote></blockquote><p>系统是龙，算法是睛，画龙要点睛。</p><h2 id="4-计算之树第四维度——计算与社会-自然环境的融合思维"><a href="#4-计算之树第四维度——计算与社会-自然环境的融合思维" class="headerlink" title="4. 计算之树第四维度——计算与社会/自然环境的融合思维"></a>4. 计算之树第四维度——计算与社会/自然环境的融合思维</h2><p>发生这两种融合的本质就在于抽象与自动化，如下图3所示：</p><ul><li>左边，从树枝到树干的过程，是抽象的过程，把社会中的问题抽象成可以用计算机表示的模型;</li><li>右边，从树干到树枝的过程，是自动化的过程，把计算机算出的数据展示给用户</li></ul><p>在解决人、机器、业务等沟通时抽象出来了以下几个事物：</p><ul><li>模型与系统，解决了业务-计算的问题</li><li>语言与编译器，解决了人-计算机的问题</li><li>协议与编码/解码，解决了机器与机器、物体与物体通信的问题</li></ul><p><center>图3. 计算与社会/自然环境的融合思维</center><br><img src="http://img01.taobaocdn.com/imgextra/i1/581166664/TB2pNBzapXXXXbzXXXXXXXXXXXX_!!581166664.png" alt="计算之树第四维度——计算与社会/自然环境的融合思维"></p><h2 id="5-计算之树第五、六维度——网络化思维和数据化思维"><a href="#5-计算之树第五、六维度——网络化思维和数据化思维" class="headerlink" title="5. 计算之树第五、六维度——网络化思维和数据化思维"></a>5. 计算之树第五、六维度——网络化思维和数据化思维</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次从计算机的宏观角度对整个计算机行业做个剖析，这里老师引入一个计算之树的模型。&lt;br&gt;
    
    </summary>
    
    
      <category term="mooc" scheme="http://liujiacai.net/tags/mooc/"/>
    
  </entry>
  
  <entry>
    <title>计算思维之一序言篇</title>
    <link href="http://liujiacai.net/blog/2014/06/06/computational-thinking-1/"/>
    <id>http://liujiacai.net/blog/2014/06/06/computational-thinking-1/</id>
    <published>2014-06-06T03:58:43.000Z</published>
    <updated>2019-12-24T10:59:14.594Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列笔记是我在上一个mooc课<a href="http://www.icourse163.org/course/hit/hit001?tid=7001" target="_blank" rel="noopener">大学计算机—计算思维导论</a>上的笔记，我觉得比较实用，尤其是在知识爆炸的如今，如何找到一种科学的学习方式，准确理解事物的本质是非常重要的能力。</p><p>##1. 学习三种境界<br><a id="more"></a><br>首先，老师讲了一下王国维关于学习三种境界的总结，这三个境界我姐在我上高中的时候也给我说过，如今再次提及，有种醍醐灌顶的感觉，具体内容如下：</p><ul><li>看山是山，看水是水 <strong>概念与知识</strong></li><li>看山不是山，看水不是水 <strong>联想与贯通</strong></li><li>看山还是山，看水还是水 <strong>训练与实践</strong></li></ul><p>也就是说对一个知识先从基本概念入手，有个大概了解;然后通过不断实践与验证，对自己先前的理解产生质疑;最后是通过一段时间的总结与归纳，对这个新知识点有了自己的理解方式。</p><p>很合理的学习进阶方式，希望自己在今后的学习过程中严格按照上述三个步骤来进行，把看过的每个知识点都转化为自己的东西。</p><p>##2. 三种思维</p><p>讲完了学习的三种境界后，老师讲了现在社会中人们应该具备的三种思维：</p><ul><li>实验思维：实验—&gt;观察—&gt;发现、推断总结。  <strong>归纳与观察</strong></li><li>理论思维：假设/预设—&gt;定义/性质/定理—&gt;证明。  <strong>推理和演绎</strong></li><li>计算思维：设计，构造与计算  <strong>设计与构造</strong></li></ul><p>这个mooc课主要讲解计算思维，实验思维与理论思维我们在中学阶段的化学与数学课程中已经接触过了。</p><p>计算思维的本质是抽象（abstraction）与自动化（automation），即在<strong>不同层面</strong>进行抽象，以及将这些抽象“机器化”。</p><p>##3. 自动计算的探索（数据表示——自动存储——自动执行的角度）</p><ul><li>Pascal（1623-1662）机：告诉人们“用纯机械装置可代替人的思维与记忆”，开辟了“自动计算”的道路。</li><li>Leibniz莱布尼茨（1646-1716）机：连续重复自动执行。提出二进制及其计算规则。数理逻辑创始人。</li><li>1834年，巴贝奇——分析机</li><li>1805年，杰卡德——打孔卡</li><li>1854年，布尔创立了布尔代数，为数字计算机的电路设计提供了理论基础</li><li>……</li></ul><p>冯.诺依曼的创新：将运算与存储分离why、how？？</p><p>###3.1 自动计算过程中元器件的发展</p><ul><li>电子管：可自动控制0和1变化的元件</li><li>晶体管：体积变小</li><li>集成电路：元件直接的连接性问题</li></ul><p>电子管—&gt;晶体管<br>体积更小、可靠性更高、可控制性更灵活 why、how？</p><p>晶体管—&gt;集成电路1959年 J.Kilby—&gt;超大规模集成电路（Intel的摩尔发明，more摩尔定律）—&gt;1981年，第一台个人计算机诞生。</p><p>##4. 计算机系统要解决的几个问题</p><ul><li>控制与计算——微处理器</li></ul><blockquote><p>字长：8为—&gt;16—&gt;32—&gt;64<br><br>主频：几十MHz—&gt;几百MHz<br><br>晶体管数量与功能规模：微处理器—&gt;微处理器+协处理器（浮点运算）—&gt;微处理器+图形运算单元GPU—&gt;微处理器+3D处理器+多媒体处理器—&gt;多核微处理器</p></blockquote><ul><li>输入——外部信息如何输入到计算机中</li><li>输出——计算机如何将信息输出到外部</li><li>永久性存储与临时性存储——计算机的信息如何永久保持或临时保持</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列笔记是我在上一个mooc课&lt;a href=&quot;http://www.icourse163.org/course/hit/hit001?tid=7001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大学计算机—计算思维导论&lt;/a&gt;上的笔记，我觉得比较实用，尤其是在知识爆炸的如今，如何找到一种科学的学习方式，准确理解事物的本质是非常重要的能力。&lt;/p&gt;
&lt;p&gt;##1. 学习三种境界&lt;br&gt;
    
    </summary>
    
    
      <category term="mooc" scheme="http://liujiacai.net/tags/mooc/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎概貌</title>
    <link href="http://liujiacai.net/blog/2014/05/22/search-engine-overview/"/>
    <id>http://liujiacai.net/blog/2014/05/22/search-engine-overview/</id>
    <published>2014-05-22T07:28:26.000Z</published>
    <updated>2019-12-24T10:59:14.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>以前参加齐鲁软件大师时用过lucene，但是仅仅只是停留在API调用层面上，这次借着看《lucene in action》第二版的机会把与lucene和搜索相关的知识系统整理一遍。以下内容来自lucene in action的翻译加上我自己的理解，如有疑问或错误，请指出，谢谢。<br><a id="more"></a><br>首先来看一个搜索的宏观布局图</p><p>图1. 搜索的一般架构<br><br><img src="http://img02.taobaocdn.com/imgextra/i2/581166664/TB2810wapXXXXclXXXXXXXXXXXX_!!581166664.png" alt=" search-arch"></p><font color="red">其中深颜色部分是使用Lucene的地方，浅颜色部分需要程序员使用其他工具来完成。</font><h2 id="2-Lucene与搜索引擎概貌"><a href="#2-Lucene与搜索引擎概貌" class="headerlink" title="2. Lucene与搜索引擎概貌"></a>2. Lucene与搜索引擎概貌</h2><p>Lucene只是一个完整搜索引擎中的一部分，它主要是提供了index（建立索引）与search（搜索）的功能。在具体学习Lucene使用之前，了解搜索引擎的概貌对以后Lucene的学习大有裨益。</p><h3 id="1-1-索引相关部分（Components-for-indexing）"><a href="#1-1-索引相关部分（Components-for-indexing）" class="headerlink" title="1.1 索引相关部分（Components for indexing）"></a>1.1 索引相关部分（Components for indexing）</h3><p>如果我们想在一些文件中搜索某些词组，比如“中国”，最直接的方式就是依次遍历这些文件，对每个文件进行字符串匹配，显然这种方式比较低效，而且不容易扩展，所以我们需要对这些文件中的内容建立索引，在lucene中你可以想象索引是一种加速获取文件中内容的数据结构，一般搜索引擎都采用倒排索引。建立索引一般可以分为一下几步：</p><h4 id="1-1-1-获取数据（Acquire-Content）"><a href="#1-1-1-获取数据（Acquire-Content）" class="headerlink" title="1.1.1 获取数据（Acquire Content）"></a>1.1.1 获取数据（Acquire Content）</h4><p>这里的数据根据具体的业务而定，有的在数据库里、有的在doc、pdf等文档里，更一般的是通过网络爬虫（crawler）抓取互联网上的网页数据。</p><p>为了获取不同的数据，我们可以使用不同的工具：数据库的话可以直接使用JDBC来读取;doc等文档可以使用Tika等第三库完成;网络爬虫可以使用一些开源的项目：</p><ul><li><a href="http://lucene.apache.org/solr/" target="_blank" rel="noopener">Solr</a>——一个Lucene的姐妹项目，可以获取关系型数据库或xml中的数据，通过集成Tika可以获取富文本（rich documents）中的信息。</li><li><a href="http://nutch.apache.org/" target="_blank" rel="noopener">Nutch</a>——Lucene另一个姐妹项目，通过一个高扩展性的网络爬虫</li><li><a href="http://sourceforge.net/projects/grub/" target="_blank" rel="noopener">Grub</a>——一个流行的开源网络爬虫,截至本文写作时间，最后一次更新为2013-04-03，用C++编写</li></ul><h4 id="1-1-2-创建文档（BUILD-DOCUMENT）"><a href="#1-1-2-创建文档（BUILD-DOCUMENT）" class="headerlink" title="1.1.2 创建文档（BUILD DOCUMENT）"></a>1.1.2 创建文档（BUILD DOCUMENT）</h4><p>数据获取完成后，就需要把这些原始数据转化为搜素引擎理解的单元，这个单元在Lucene中叫做Document，你可以把一个文档、一个网页、一封电子邮件看作一篇文档，而像文章的title、date、author等信息作为Document的Field，上述情形Document比较好区分，但是真实环境中很有可能并不是那么好区分，比如说邮件中的附件，是作为另一个Document与正文的Document相关联还是包含在正文Document的Field里面呢？</p><p>有了一个Document以后我们可以很方便的定制搜索结果，比如如果某个Document比较重要，我们可以通过修改Document的boost来实现提高它在搜索中的排名。</p><p>Lucene为建立Document提供了一套简单方便的API，后面再介绍。</p><h4 id="1-1-3-分析文档（ANALYZE-DOCUMENT）"><a href="#1-1-3-分析文档（ANALYZE-DOCUMENT）" class="headerlink" title="1.1.3 分析文档（ANALYZE DOCUMENT）"></a>1.1.3 分析文档（ANALYZE DOCUMENT）</h4><p>这里主要是指在对原始内容进行分词，因为我们不可能把一整篇文档放到一个Field中，在Lucene中每个分词后的结果称为token，英文中还稍微简单一些，可以直接通过空格键区分，但在非中文环境中，比如我们汉语，分词是个比较难的问题，但网上免费的分词器也有不少，像<a href="https://code.google.com/p/ik-analyzer/" target="_blank" rel="noopener">IKAnalyzer</a>、<a href="http://www.ictclas.org/" target="_blank" rel="noopener">ICTCLAS</a>、<a href="https://code.google.com/p/paoding/" target="_blank" rel="noopener">庖丁解牛分词器</a>，不过貌似商业用的话，像百度、淘宝这样的，一般都是自己写的。</p><h4 id="1-1-4-建立索引"><a href="#1-1-4-建立索引" class="headerlink" title="1.1.4 建立索引"></a>1.1.4 建立索引</h4><p>完成上面这些以后，我们就可以使用lucene提供的api建立索引了。</p><h3 id="1-2-搜索相关部分（Components-for-searching）"><a href="#1-2-搜索相关部分（Components-for-searching）" class="headerlink" title="1.2 搜索相关部分（Components for searching）"></a>1.2 搜索相关部分（Components for searching）</h3><p>搜索就是在索引中查询用户输入的关键字的过程。评价搜索的质量有两个指标</p><ul><li>准确率（precision）——指在搜索结果中过滤掉无关Document的程度（measures how well the search system find relevant documents）</li><li>召回率（recall）——指在搜索结果中Document与用户输入的关键字的相关性（measures how well the system filters out the irrelevant documents）</li></ul><p>通过Lucene的contrib中的benchmark可以检测我们搜索系统中的准确率与召回率。</p><h4 id="1-2-1-搜索接口（SEARCH-USER-INTERFACE）"><a href="#1-2-1-搜索接口（SEARCH-USER-INTERFACE）" class="headerlink" title="1.2.1 搜索接口（SEARCH USER INTERFACE）"></a>1.2.1 搜索接口（SEARCH USER INTERFACE）</h4><p>要想搜索首先需要提供一个搜索界面，这里一般是指的网页应用中，这个是很重要的一步，现在都强调用户体验，如果你的搜索界面让用户感到厌烦，用户怎么可以有使用你产品的欲望呢。</p><p>搜索界面主要是强调简洁，像百度、google那样，在搜索结果页面中，Document结果的展示也必须恰到好处，不能显示太多的文字，也不能显示太少的文字。除此之外，用户必须可以很方便的找到“相关搜索”、“结果过滤”等功能，如果你对搜索结果进行了定制（通过修改Document的boost），必须让用户知道，而且必须提供一个关闭定制的选项。</p><h4 id="1-2-2-创建Query-BUILD-QUERY"><a href="#1-2-2-创建Query-BUILD-QUERY" class="headerlink" title="1.2.2 创建Query(BUILD QUERY)"></a>1.2.2 创建Query(BUILD QUERY)</h4><p>用户输入的关键字在会被Lucene处理为一个Query类的对象，Query有很多子类，可以实现逻辑上的“与或非”的BooleanQuery，比如我们搜索时可以收入下面的关键字“java &amp; 书籍”， 说明我们想要搜索的是与java有关的书籍。lucene中有各种Query，lucene为了方便用户使用，提供了一个QueryParser对象，它可以自动解析用户输入的关键字转为相应的query对象</p><h4 id="1-2-3-搜索Query（SEARCH-QUERY）"><a href="#1-2-3-搜索Query（SEARCH-QUERY）" class="headerlink" title="1.2.3 搜索Query（SEARCH QUERY）"></a>1.2.3 搜索Query（SEARCH QUERY）</h4><p>当Query构建好后，就可以进行搜索了。一般有三种实用的搜索模型：</p><ul><li>逻辑模型（Pure Boolean model）——每个Document要么包含这个查询的内容，要么不包含，就这两种情况。在这种模型下，包含查询内容的Documents没有相关性的强弱之分，所以这种情况下也就没有办法为结果排序。</li><li>向量空间模型（Vector space model）——Query对象与Document对象都用高维向量表示，没一个term就是一个维度。通过计算query与document对象的距离（余弦定理）可以得到Document相关性的强弱，这样也就可以为结果排序了。</li><li>概率模型（Probabilistic model）——通过全概率方法计算每个Document符合查询query的概率来表示相关性。（In this model, you compute the probability that a document<br>is a good match to a query using a full probabilistic approach）</li></ul><h4 id="1-2-4-结果展示（RENDER-RESULTS）"><a href="#1-2-4-结果展示（RENDER-RESULTS）" class="headerlink" title="1.2.4 结果展示（RENDER RESULTS）"></a>1.2.4 结果展示（RENDER RESULTS）</h4><p>在Lucene中，结合了逻辑模型与向量空间模型来匹配query，得到了匹配的Document对象后，你需要负责把结果友好的展现出来，这一步决定了用户的体验程序好坏。</p><h3 id="1-3-搜索的其他方面（The-rest-of-the-search-application）"><a href="#1-3-搜索的其他方面（The-rest-of-the-search-application）" class="headerlink" title="1.3 搜索的其他方面（The rest of the search application）"></a>1.3 搜索的其他方面（The rest of the search application）</h3><p>完成了建立索引与搜索这两大模块后，还有一些工作要去做，这些工作一般都存在于web项目中。第一，需要提供一个管理界面，用来跟踪应用的状态，配置应用的不同部分，开启与关闭服务器等。第二，还必须要包括分析工具，可以你就可以知道用户都热衷于搜索那些关键词，这样你就能更好的维护你的应用。第三，一个健壮的搜索引擎一般都支持扩展性（scaling）。下面对上面说的这三点分别进行阐述。</p><h4 id="1-3-1-管理员界面（ADMINISTRATION-INTERFACE）"><a href="#1-3-1-管理员界面（ADMINISTRATION-INTERFACE）" class="headerlink" title="1.3.1 管理员界面（ADMINISTRATION INTERFACE）"></a>1.3.1 管理员界面（ADMINISTRATION INTERFACE）</h4><p>现在的搜索引擎一般都是个负责的系统，有许多部分都需要配置才能使系统发挥最好的性能。如果你用爬虫抓取网页，你可以通过管理界面给出需要爬的根网页，爬的范围、速度等参数。</p><p>Lucene有许多可以配置的地方。比如RAM buffer的大小，提交修改索引的频率与优化索引中的删除项等等不一而足。</p><h4 id="1-3-2-分析界面（ANALYTICS-INTERFACE）"><a href="#1-3-2-分析界面（ANALYTICS-INTERFACE）" class="headerlink" title="1.3.2 分析界面（ANALYTICS INTERFACE）"></a>1.3.2 分析界面（ANALYTICS INTERFACE）</h4><p>通过对用户搜索行为的学习与分析，系统能够提供更好的用户体验。在与Lucene相关的分析一般包括以下几点：</p><ul><li>不同种类型的query，比如single term，phrase，boolean query的使用频率</li><li>哪些query的搜索结果比较少（Queries that hit low relevance）</li><li>对于哪些query用户没去再次点击结果</li><li>搜索的时间</li></ul><h4 id="1-3-3-扩展（scaling）"><a href="#1-3-3-扩展（scaling）" class="headerlink" title="1.3.3 扩展（scaling）"></a>1.3.3 扩展（scaling）</h4><p>搜索引擎的扩展一般包括两个方面：</p><ul><li>索引数据的扩展</li><li>用户并发搜索的扩展</li></ul><p>可扩展是一个系统很重要的特性，想想如果提供搜索的服务器只有一台，那么如果该服务器fail了，那整个搜索就没法用了，这是不能忍受了，这时往往需要用两台或多台服务器来提供搜索服务。多台机器同时提供搜索还是比较困难的，比如，在用户输入一个query后，系统需要有一个front-end来将这个query转发给后台的服务器，由于各个服务器是孤立的，每个服务器在将搜索结果返回时如何排序是个大问题。</p><p>Lucene没有为扩展做专门的处理，需要用户自己解决。但是在用户自己动手实现scaling之前，可以先参照开源世界中的<a href="http://lucene.apache.org/solr/" target="_blank" rel="noopener">Solr</a>与<a href="http://nutch.apache.org/" target="_blank" rel="noopener">Nutch</a>，这两个都是lucene的姐妹项目，除此之外还有<a href="http://katta.sourceforge.net/" target="_blank" rel="noopener">Katta</a>与<a href="http://www.elasticsearch.com/" target="_blank" rel="noopener">ElasticSearch</a>，他们都为搜索提供了很好的扩展性。</p><p>PS: 在本文写作期间，katta貌似已经停止了更新，最后一次更新是在2010年，ElasticSearch则比较活跃，而且在<a href="https://www.found.no/" target="_blank" rel="noopener">found.no</a>可以找到很详细的参考的资料。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;以前参加齐鲁软件大师时用过lucene，但是仅仅只是停留在API调用层面上，这次借着看《lucene in action》第二版的机会把与lucene和搜索相关的知识系统整理一遍。以下内容来自lucene in action的翻译加上我自己的理解，如有疑问或错误，请指出，谢谢。&lt;br&gt;
    
    </summary>
    
      <category term="搜索引擎" scheme="http://liujiacai.net/categories/search-engine/"/>
    
    
      <category term="lucene" scheme="http://liujiacai.net/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>深入Java世界</title>
    <link href="http://liujiacai.net/blog/2014/05/19/go-into-java-world/"/>
    <id>http://liujiacai.net/blog/2014/05/19/go-into-java-world/</id>
    <published>2014-05-19T00:18:39.000Z</published>
    <updated>2019-12-24T10:59:14.593Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说的好：不经一事，不长一智。<br><a id="more"></a><br>最近状态很不好，考研与找工作的事一直让我纠结到现在，现在在学校里和一些同学聊天得知，软件工程读研也是偏理论方面，毕竟是工程学科嘛，理论功夫要做足。所以，我在内推网上试着投了一份简历，想着要是能有个合适的工作，学习的事在工作上也可以进行嘛，结果是我想的太过美好了，自己实力不行，别人怎么回去要你呢，昨天电话面试的，我当时正在修改毕业论文，其实我可以向后退退的，但是当时就直接面了，这次直接暴露出自己的钻研精神不够的问题，这次面试主要有下面几个题：</p><ul><li>java中的classloader有哪些？</li><li>java中与tree有关的数据结构的原理？</li><li>java中Collection中的常见类的理解？</li><li>红黑树剪枝问题以及常见的树有哪些？</li><li>lisp为什么没有流行起来？</li></ul><p>主要是就是这几个问题，我回答的是一塌糊涂，根本就没在节拍上，连最后一个开放性问题我回答的也不好，其实这个问题我以前想过不少，电话面试时就懵了，其实完全可以从lisp语言的主要面向对象来谈的，我当时直接就说了类库少，那java一开始不也没几个类库嘛，那java为什么这么火呢？？！！当时思路完全没有打开，事后找到一篇比较靠谱的文章<a href="http://locklessinc.com/articles/why_lisp_failed/" target="_blank" rel="noopener">why lisp failed</a>。</p><p>其次就是java相关的知识，像classloader的分类，说实话这个classloader相关的知识真的是看过，但不知道是那时候的事了，这么一问我，我是真的不知道，这也反映出了我的钻研精神不够，天天用java，却不知道java的加载机制，用的安心吗？其实很多东西我都理解的不够深入，java的helloworld程序太简单了，但是要想深入进去，不要老是停留在表面那些api调用上，还需要下不少功夫。</p><p>说实话，现在考研的目的性不是那么强了，毕竟考研和直接工作需要掌握的东西又不一样，工作三年与上考三年各有利弊，没有谁能说哪个比哪个好，可怕的是自己也不知道如何选择，老是徘徊不定，现在我就是这个状态，算法不行，代码能力不够，好悲惨的说。</p><p>近阶段需要做的是深入java，然后再投简历，看看自己到底是几斤几两。下面是java官方一些好的资源：</p><ul><li><a href="http://docs.oracle.com/javase/tutorial/" target="_blank" rel="noopener">java turtorial</a></li><li><a href="http://docs.oracle.com/javase/tutorial/collections/index.html" target="_blank" rel="noopener">Trail: Collections</a></li><li><a href="http://docs.oracle.com/javase/7/docs/index.html" target="_blank" rel="noopener">Java Platform Standard Edition 7 Documentation</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说的好：不经一事，不长一智。&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://liujiacai.net/categories/langs/"/>
    
    
      <category term="Java" scheme="http://liujiacai.net/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一个音乐盲如何才能听&#39;懂&#39;严肃音乐？</title>
    <link href="http://liujiacai.net/blog/2014/05/09/understand-serious-music/"/>
    <id>http://liujiacai.net/blog/2014/05/09/understand-serious-music/</id>
    <published>2014-05-09T03:59:40.000Z</published>
    <updated>2019-12-24T10:59:14.593Z</updated>
    
    <content type="html"><![CDATA[<p>##初识古典</p><p>今天收获太大了，我也终于能享受“严肃”音乐了。</p><p>事情的经过是这么样的，以前了解过<a href="http://book.douban.com/subject/1291204/" target="_blank" rel="noopener">GEB</a>，都说他怎么怎么好，怎么把巴赫的音乐与艾舍尔的画相对比，我是个音乐盲，平时也就是听听流行歌曲，上哪里去听懂老巴赫的音乐，对音乐的唯一一点记忆是高三时上基本能力课时，一个有激情的音乐老师讲过巴赫如何牛叉，但是当时应付高考，谁去认真理睬这60分的基本能力呀。</p><p>现在作为一个程序员，职业习惯让我对任务事情都有刨根问题的兴趣，想弄明白它的本质到底是怎么样的，现在这个疑惑跑到了音乐身上。为什么我就不能“听懂”巴赫音乐中所表达出的意境呢，是我没有乐理知识嘛，为了这个我还下载了<a href="http://www.56.com/w43/album-aid-8156170.html" target="_blank" rel="noopener">宋大叔教音乐</a>,但是没能听下，然后我想了万能的知乎，我上提了一问题<a href="http://www.zhihu.com/question/23698905" target="_blank" rel="noopener">一个音乐盲如何才能听懂莫扎特、贝多芬、巴赫的作品？</a>,希望知友们能给我指条明道，让我尽快能够掌握音乐入门方法。</p><p>不出所料，在强大的知友帮助下我找了一个视频<a href="http://www.tudou.com/programs/view/6ULRRxqmBFM/" target="_blank" rel="noopener">走进音乐世界</a>，这貌似应该是一个中央民族大学的老师做的一个演讲，真的是太赞了，这位周老师讲的实在是太好了，道出了想我这样的“音乐凡人”为什么听不懂想巴赫的“高雅”音乐的原因，对音乐感兴趣的人推荐去看这个视频，这个视频2个多小时，但绝对能让你物有所值。</p><p>很喜欢周老师的开场，视频一开始周老师就从大家都知道的典故<a href="http://baike.baidu.com/view/42504.htm?fr=aladdin#2" target="_blank" rel="noopener">俞伯牙和钟子期的故事</a>切题，通过这两个人的故事，大家都懂的了知音难求的道理，但是到现在几千年来我们对音乐的欣赏水平还是没变。 </p><p>通过这个切题我就能知道这个周老师绝对是个博才多学的人，通过看完这个视频也证明了这一点。周老师说音乐艺术的基本材料是音响，而音响有两个基本属性：</p><blockquote><ul><li>没有造型性，这说明音响不能<strong>直接</strong>传达视觉形象</li><li>没有语义性，这说明音响不能<strong>直接</strong>传达思想概念</li></ul></blockquote><p> 这也就说明了我们为什么听不懂，因为音乐本身不能直传达作者的思想，不仅仅我们不懂，那么专业搞音乐的人也不懂。看到周老说这些话我真是全身舒畅，原来大家都是不懂装呀。哈哈！</p><p>但是音乐作为一门让无数人着迷的艺术，不可能装了几千年吧，肯定还是少了些什么吧。周老师说这里的关键是<strong>联觉</strong>，其实这个大家平时也都知道，就是我们平时看到一种东西联想到另一种东西的能力，这种能力是我们每个人与生俱来的，所以我们每个人都能听“懂”音乐。</p><blockquote><ul><li>高音，轻快、活泼</li><li>低音，沉重、压抑</li></ul></blockquote><p>这就是音乐中给人最直接的感受</p><p>比较有意思的是，周老师还爆料了他们音乐圈一些众所周知的秘密，其实说音乐鉴赏课都是扯淡，评论都是后人加上去的，要不然没法卖呀，大家想想自己买回来一碟音乐光盘，发现里面没有什么讲解，会不会很失望，这就是商业与艺术的差别。写评论主观因素很大，所以这就导致了我们听不懂。周老师以前就干过不少为音乐作品写评论的事，周老师说这里有个秘诀，把评论写的抽象些，比如“倾诉”，具体什么内容都可以，这样最起码不会跑题了吧。周老师确实很可爱有没有。</p><p>到这里我就豁然开朗了，以前接受的教育都是错误的，为什么听音乐前<strong>必须</strong>了解作者的经历，创作背景一类的东西呀，都是扯淡，听音乐就是放松的，根本没必要去做那么多的准备，好听就听，不好听就换一个，这也是知友们所说的。</p><p>最后周老师把音乐鉴赏上升到国家软实力问题上了，为什么大家买手机都说不要买国产手机，就因为设计不好呗，为什么不好，这里的根本原因是，<strong>感性意识</strong>差，我们从小的教育都是带有功利性的，去春游回来必须写日记，导致玩也玩的不痛快，想我听巴赫的音乐非要生搬硬套到艾舍尔的画上，也是教育体制的受害者。长此以往下去，导致我们失去了对事物感性的认识，其实这点和现在所倡导的“用户体验”很相似，我们在设计一个产品是功能再强大，但是界面丑陋无比，我相信也是没人会用的，这也给我提了个醒，技术要与市场结合，需要深入掌握用户的心理，怎么设计让用户用着舒服，怎么才能提供用户更好的体验，这都是重中之重的问题。</p><p>中国人一直认为<strong>实用</strong>的价值大于<strong>感性</strong>的认识，这也就导致了我们的厕所为什么这么脏，能用就行呗！</p><p>说了不少了，因为这个问题困扰了我好久，在周老师的视频和知友们的解答下终于让我又有了新的认识，感觉真的是太好了。</p><p>PS:百度后发现这位周老师竟是中央音乐学院的副校长，网上的好评也是不断。<br>最后附上周老师演讲的ppt与为我们准备的音乐资源（按类别分好）<br><img src="http://img03.taobaocdn.com/imgextra/i3/581166664/TB2m4K_apXXXXX5XXXXXXXXXXXX_!!581166664.png" alt="周海宏功能音乐10CD MP3"></p><p><a href>http://pan.baidu.com/s/1kTr5fy3</a></p><p>##更新认识，2014.5.19</p><p>我的这个问题在<a href="http://www.zhihu.com/question/23698905" target="_blank" rel="noopener">知乎</a>、<a href="http://v2ex.com/t/111959" target="_blank" rel="noopener">v2ex</a>上发起的问题讨论十分热烈，主要是围绕这对音乐的态度，其中<a href="http://www.zhihu.com/people/han-edward" target="_blank" rel="noopener">Han Edwar</a>从专业角度出发，强调必须去弄懂一首曲子中所传递的意思，关于这个问题我想的是我想试着去听听古典音乐吧，老是空说也没什么用，还需要用实践来证明一下。</p><p>##更新认识，2015.4.19</p><p>将近一年后再来看看这个问题，貌似和当初差不多少，现在偶尔也会在网上找一些古典音乐听听，但还是没能听出感觉，看来我的路还很长。这个问题在知乎上有了875个关注了，看来大家对这个问题都还蛮感兴趣的。其中有个<a href="http://www.zhihu.com/question/23698905/answer/34179234" target="_blank" rel="noopener">匿名的回复</a>，从GEB这本书阐述的中心思想入手，倒是给了我不少的启发。怕以后找不到了，在这里留个存根：</p><pre><code>音乐我不熟，GEB那本书我很喜欢，这里给题主提供另一个看问题的角度。首先，GEB这本书讲的是什么？它探讨的是“什么是自我”。自我这个概念，是人与眼下世间万物的区别（因为我们还没发现外星智慧、也没发现地球上的其他生物有自我意识）。那么，如果机器，或者严格的说，程序，有了自我意识，这程序，该叫什么？它是不是人？同时，我们怎样才能判断某程序有了自我意识？第一个问题，目前大家有比较一致的答案，倾向于叫它“人工智能”（没错，AI就是从这儿来的！）。但是对第二个问题，不同的人有不同的看法。以图灵为首的计算机科学家倾向于从行为上判断。从著名的“中文小屋”（图灵测试的出处）到今天的谷歌翻译、机器学习，都可以归于这个学派。侯士达（GEB的作者）不这么看。他坚持认为，有self-consciousness的程序才叫人工智能。在深度学习几乎要席卷世界的今天，他成了少数派；但是在出版GEB的上世纪七十年代末八十年代初，正是学界反思五十年代提出的“人工智能”概念的时期。所以他的这种观点在当时并不像今天听来这么离经叛道，反而还有点追本溯源的意思。关键是，他文笔好啊。这本书一出，立刻引爆了流行，荣获普利策奖和美国国家图书奖。美国人民一起竖大拇指：原来搞CS的人也可以萌萌的！扯远了。侯士达虽然认为自我很重要，是判断人工智能的标准。但是你怎么描述自我呢？我当然可以指着鼻子说：“我就是我，是颜色不一样的烟火。”但是机器人也可以指着自己的鼻子/显示器这么说。你怎么证明，机器人指着自己的鼻子，跟你指着自己的鼻子，两件事当中有某些决定性的区别呢？GEB整本书就试图干这件事。侯士达到处搜集、自己创作了大量的例子，想要展示给读者，自我是什么，自我意识是怎么回事，什么样的行为中体现了自我意识。比方说，一台唱机（就是放唱片的机器，现在很少见到了）X，播放了一张叫“我不能在唱机X上播放”的唱片后，就爆炸了。他不断展示，是因为他意识到“自我”或许不是一个可以证明的东西。但是他知道这东西存在，你也可以感受到这东西的存在。就好比禅宗里常说的“不要把我的手指当成月亮”。（是的，侯士达也很喜欢禅宗公案）接下来，自我跟巴赫的音乐有什么关系？如上所述，侯士达的这本书最后成了一本自指案例大全（身为程序员的你，是不是看到此时产生了巨大的熟悉感？）。自指不仅包括递归，也包括元小说（metafiction，也可以叫超小说，后设小说等等），字谜等等众多形态。侯士达认为最了不起的自指的例子，就是标题里这三个人的创作：哥德尔不完备性定理的证明；艾舍尔的石板画；巴赫的赋格、卡农等作品。在他看来（我懂的少，当然赞成他的看法了），这三者是自指这一概念在三个不同领域的最高成就，是他这本书想要表达的主题的完美再现。所以，你也可以认为这本书就是针对“自我”这个主题的不断重复、变形、强化。身为程序员，想必你已经了解了哥德尔不完备性定理证明的思路。艾舍尔画中的自指，只要视力正常的人也可以一眼看出。所以对你来说，可能理解的唯一障碍就是“巴赫的音乐到底是怎么回事？”简而言之，你可以把它理解成下图的音乐版：</code></pre><p><img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2J1Y2cpXXXXc_XXXXXXXXXXXX_!!581166664.jpg" alt="荷兰画家埃舍尔的视觉迷宫"></p><pre><code>接下来，回到原问题的子问题，如何欣赏巴赫的作品？不知道你听没听过《赋格的艺术》和《音乐的奉献》，如果还没听，不妨一试：The Art of Fugue / Musical Offering专辑，地址：http://www.xiami.com/album/488768简单（且不准确的）来说，卡农就是只有一段旋律，复制后通过时序排列形成“和谐组合”。- 难度比简单的和声创作要大。因为假设与音符a和谐的音符有c、e、A，那么创作和声时a下方对应的音符就有3个选择，a后面的音符也可以任意选择；而创作卡农时假设下方的旋律序列比上方晚一拍，那么a后面的音符就只有3个选择（因为要与a和谐），且该选择要与下一个音符和谐，而同时要避免横向序列不能听……赋格就是允许把第一段旋律X做变形后得到Y，X与Y通过时序排列形成“和谐组合”。巴赫的厉害之处在于，它不仅掌握了这些规则、在规则下创作出了“好听”的音乐，而且还可以玩花活儿：[果壳搬运] 巴赫螃蟹卡农视觉图解，地址：http://www.iqiyi.com/w_19rr9svtnh.html有了类似视频的帮助，巴赫的作品就不只是一段莫名其妙的声音，而具备了与哥德尔、艾舍尔的视觉可比性。这种结构/形式的完美性体现出的乐趣，我相信是擅长编程的人都可以轻易体会到的。最后，回到你的原问题：如何听懂莫扎特、贝多芬、巴赫的音乐？如果要“懂”，前面陈壮壮说的懂乐器、这里说的玩结构、还有晓渔赞成的情感体验和反对的历史背景了解，你最好都要涉及；但如果只想“欣赏”，那我觉得怎样能让你觉得“有所得”，你就怎样来。即使是知乎上炮轰的“装备党”（水电和火电哪个更适合听古典？）、豆瓣上讽刺的“看谱党”（只通过看乐谱欣赏古典乐）、爱乐群体中的“版本党”（热衷于比较不同演奏家、不同年代录制的古典乐唱片版本间的优劣），也都从古典乐中获得了自己想要的乐趣。所以，这最后的问题，需要问题主你：你想从古典乐中获得什么？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##初识古典&lt;/p&gt;
&lt;p&gt;今天收获太大了，我也终于能享受“严肃”音乐了。&lt;/p&gt;
&lt;p&gt;事情的经过是这么样的，以前了解过&lt;a href=&quot;http://book.douban.com/subject/1291204/&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="热爱生活" scheme="http://liujiacai.net/categories/life/"/>
    
    
      <category term="music" scheme="http://liujiacai.net/tags/music/"/>
    
      <category term="GEB" scheme="http://liujiacai.net/tags/GEB/"/>
    
  </entry>
  
  <entry>
    <title>开启个人博客之旅</title>
    <link href="http://liujiacai.net/blog/2014/05/07/hello-weblog/"/>
    <id>http://liujiacai.net/blog/2014/05/07/hello-weblog/</id>
    <published>2014-05-07T07:14:41.000Z</published>
    <updated>2019-12-24T10:59:14.593Z</updated>
    
    <content type="html"><![CDATA[<p>这是第一篇用octopress折腾的博客真是废了不少劲，以后就以这里为大本营了。</p><p>——update———</p><p>octopress由于文章生成速度太慢，现在已经换成hexo。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是第一篇用octopress折腾的博客真是废了不少劲，以后就以这里为大本营了。&lt;/p&gt;
&lt;p&gt;——update———&lt;/p&gt;
&lt;p&gt;octopress由于文章生成速度太慢，现在已经换成hexo。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>

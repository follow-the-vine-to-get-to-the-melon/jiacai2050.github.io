<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>深入浅出垃圾回收（二）Mark-Sweep 详析及其优化 - Keep Coding</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="刘家财" /><meta name="description" content="在上一篇文中介绍的追踪类（tracing）GC 较引用计数（Reference Counting）性能更高，但原生的追踪类 GC 也有其自身缺点，需要" /><meta name="keywords" content="lisp, clojure, emacs, database, life" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="https://liujiacai.net/2018/07/08/mark-sweep/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="深入浅出垃圾回收（二）Mark-Sweep 详析及其优化" />
<meta property="og:description" content="在上一篇文中介绍的追踪类（tracing）GC 较引用计数（Reference Counting）性能更高，但原生的追踪类 GC 也有其自身缺点，需要" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liujiacai.net/2018/07/08/mark-sweep/" />
<meta property="article:published_time" content="2018-07-08T12:26:31+00:00" />
<meta property="article:modified_time" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="name" content="深入浅出垃圾回收（二）Mark-Sweep 详析及其优化">
<meta itemprop="description" content="在上一篇文中介绍的追踪类（tracing）GC 较引用计数（Reference Counting）性能更高，但原生的追踪类 GC 也有其自身缺点，需要">
<meta itemprop="datePublished" content="2018-07-08T12:26:31+00:00" />
<meta itemprop="dateModified" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="wordCount" content="4016">



<meta itemprop="keywords" content="GC," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入浅出垃圾回收（二）Mark-Sweep 详析及其优化"/>
<meta name="twitter:description" content="在上一篇文中介绍的追踪类（tracing）GC 较引用计数（Reference Counting）性能更高，但原生的追踪类 GC 也有其自身缺点，需要"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Keep Coding</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/podcast/">
        <li class="mobile-menu-item">Podcast</li>
      </a><a href="/blogrolls/">
        <li class="mobile-menu-item">友链</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Keep Coding</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/podcast/">Podcast</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/blogrolls/">友链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-07-08 </span>
        <div class="post-category">
            <a href="/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 理解计算机 </a>
            </div>
          <span class="more-meta"> 约 4016 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#术语">术语</a></li>
        <li><a href="#ms-基本流程">MS 基本流程</a></li>
        <li><a href="#优化ms">优化MS</a>
          <ul>
            <li><a href="#bitmap-marking">Bitmap marking</a></li>
            <li><a href="#lazy-sweeping">Lazy sweeping</a></li>
            <li><a href="#其他优化">其他优化</a></li>
          </ul>
        </li>
        <li><a href="#碎片问题">碎片问题</a>
          <ul>
            <li><a href="#mark-compact">Mark-Compact</a></li>
            <li><a href="#copying-gc">Copying GC</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在上一篇文中介绍的追踪类（tracing）GC 较引用计数（Reference Counting）<a href="/blog/2018/06/15/garbage-collection-intro/#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-counting%EF%BC%89">性能更高</a>，但原生的追踪类 GC 也有其自身缺点，需要对其进行改造才能真正的名副其实。这篇文章就来介绍与之相关的内容。</p>
<h2 id="术语">术语</h2>
<p>为了后面叙述方便，首先明确以下几个名词的含义：</p>
<ul>
<li>Collector，用于进行垃圾回收的线程</li>
<li>Mutators，应用程序的线程，可以修改 heap</li>
<li>MS，mark-sweep 算法的简写</li>
<li>MC，mark-compact 算法的简写</li>
<li>RC，reference-counting 的简写</li>
<li>liveness，一个对象的可到达性</li>
<li>引用关系图，由可到达对象引用形成的图结构</li>
<li>locality，现代CPU在访问内存时，有多级缓存。缓存以 cache line （一般64字节）为最小操作单位，所以当访问内存中连续的数据时会比较高校，这称为 locality</li>
</ul>
<h2 id="ms-基本流程">MS 基本流程</h2>
<p>首先来回顾下追踪类 GC 最基本的 <a href="/blog/2018/06/15/garbage-collection-intro/#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95-mark-and-sweep">mark-and-sweep 算法</a> ：先扫描整个 heap，标出可到达对象，然后执行 sweep 操作回收不可到达对象。这个算法本身比较简单，下面给出其实现伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// mutator 通过 new 函数来申请内存
new():
    ref = allocate()
    if ref == null
        collect()
        ref = allocate()
        
        if ref == null
            error &#34;Out of memory&#34;
    return ref

atomic collect():  // 这里 atomic 表明 gc 是原子性的，mutator 需要暂停
    markFromRoots()
    sweep(heapStart, heapEnd)
    
markFromRoots():
    initialize(worklist)
    
    for each reference in Roots  // Roots 表示所有根对象，比如全局对象，stack 中的对象
        if ref != null &amp;&amp; !isMarked(reference)
            setMarked(reference)
            add(worklist, reference)
            mark()          // mark 也可以放在循环外面
            
            
initialize():
    // 对于单线程的collector 来说，可以用队列实现 worklist
    worklist = emptyQueue()

//如果 worklist 是队列，那么 mark 采用的是 BFS（广度优先搜索）方式来遍历引用树                
mark():
    while !isEmpty(worklist):
        ref = remove(worklist)  // 从 worklist 中取出第一个元素
        for each field in Pointers(ref)  // Pointers(obj) 返回一个object的所有属性，可能是数据，对象，指向其他对象的指针
            child = *field
            if child != null &amp;&amp; !isMarked(child)
                setMarked(child)
                add(worklist, child)
                
sweep(start, end):
    scan = start
    while scan &lt; end
        if isMarked(scan)
            unsetMarked(scan)
        else
            free(scan)
        scan = nextObject(scan)
</code></pre></td></tr></table>
</div>
</div><p>通过上面伪代码描述，不难得出 MS 有以下问题：</p>
<ol>
<li>heap 容易出现碎片</li>
<li>破坏引用本地性（由于对象不会被移动，存活的对象与空闲空间交错在一起）</li>
<li>GC 时间与 heap 空间大小成正比</li>
<li>在进行 GC 期间，整个系统会被挂起，即stop-the-world</li>
</ol>
<p>需要说明一点，RC 类 GC 同样有前两个问题，但是对于 RC 来说，并没有好的优化措施来缓解。下面我们就来看追踪类 GC 是如何解决上述问题。</p>
<h2 id="优化ms">优化MS</h2>
<h3 id="bitmap-marking">Bitmap marking</h3>
<p>在 mark 过程中，需要去标记（mark-bits）对象的 liveness，有两种方式来实现：</p>
<ol>
<li>在每个对象的header部分（in-object mark-bit）</li>
<li>使用一个单独的 bitmap，每一位 bit 对应一个对象</li>
</ol>
<p>两种方式各有利弊，需要结合具体场景进行分析。In-object mark-bit 是最直接的方式，对于 JVM/.NET 运行时来说，每个 object 都会有 header，使用这种方式也就理所应当了；
对于 bitmap 来说，需要在 bit 位与 object 之间进行映射，这就要求 object 进行对齐，比如：heap 大小为 65536 字节，所有的对象以 16 字节对齐，那么堆内就有 4096 个地址可以作为对象的起始地址，与之对应需要 4096 个 bit 即 512 个字节。除此之外，bitmap 还有下面两个优势：</p>
<ol>
<li>sweep 操作更高效，这是由于 bitmap 结构紧凑，可以一次性加载到内存中；通过整型的 ALU 操作与<a href="https://en.wikipedia.org/wiki/Branch_%28computer_science%29">条件分支（conditional branch）</a> 一次性可进行 32 位的检测</li>
<li>在类 Unix 系统中，bitmap 有利于 fork() 出来的进程与主进程进行 copy-on-write 数据共享，<a href="http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0#">Ruby 2.0 就因此获得较大性能提升</a>。</li>
</ol>
<p>下面给出 bitmap 方式的伪代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">mark():
    cur = nextInBitmap()
    while cur &lt; heapEnd
        add(worklist, cur)
        markStep(cur)
        cur = nextInBitmap()
        
markStep(start):
    while !isEmpty():
        ref = remove(worklist)
        for each field in Pointers(ref):
            child = *field
            if child != null &amp;&amp; !isMarked(child)
                setMarked(child)
                if child &gt; start         //这里与之前不同，只需要把高于当前地址的子节点加入到 worklist 即可
                    add(worklist, child)
</code></pre></td></tr></table>
</div>
</div><h3 id="lazy-sweeping">Lazy sweeping</h3>
<p>MS 算法有以下几个特点：</p>
<ol>
<li>某对象一旦被标为garbage，它永远都会是 garbage，不会被 mutator 再访问</li>
<li>mutator 不能修改 mark-bit</li>
</ol>
<p>基于以上几点，sweep 操作完全可以与 mutator 同时运行（parallel）的。
Lazy sweep 指的是把较为耗时（相对 mark 来说）的 sweep 操作放在 allocate 过程中，并且只在有足够的空间时才去真正进行回收。<a href="https://www.infoq.com/news/2011/08/ruby193-gc">Ruby 1.9.3 引入 lazy sweep 获得较大性能提升</a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">atomic collect():
    markFromRoots()
    for each block in Blocks  // 这里以 block 为单位管理更高效
        if not isMarked(block)
            add(blockAllocator, block)
        else
            add(reclaimList, block)    // 把待回收的 block 放入队列中延迟回收
            
atomic allocate(sz):
    result = remove(sz)
    if result = null
        lazySweep(sz)
        result = remove(sz)
    return result
    
lazySweep(sz):
    repeat
        block = nextBlock(reclaimList, sz)  // 这里需要分配一个 sz 大小的 block，可见 block 需要按大小 group 起来管理
        if block != null
            sweep(start(block), end(block))
            if spaceFound(block)
                return
    until block == null
    allocSlow(sz)
    
allocSlow(sz):
    block = allocateBlock(sz)
    if block != null
        init(block)
</code></pre></td></tr></table>
</div>
</div><p>Lazy Sweep 除了降低 sweep 阶段 mutator 的暂停时间外，还有以下优点：</p>
<ul>
<li>更好的 locality。这是因为被回收的 block 会尽快地重新使用</li>
<li>GC 复杂度只于<strong>可到达对象</strong>成正比</li>
<li>在大部分 heap 空间为空时效率最好</li>
</ul>
<h3 id="其他优化">其他优化</h3>
<p>除了上面介绍的两类优化，比较新的优化手段还有如下几个：</p>
<ul>
<li>FIFO prefetch buffer [Cher et al, 2004]</li>
<li>Edge marking [Garner et al, 2007]</li>
</ul>
<p>鉴于篇幅原因，这里不再讲述，感兴趣的读者可自行搜索。</p>
<h2 id="碎片问题">碎片问题</h2>
<p>上面优化的措施虽然能提高 MS 性能，但都无法解决 heap 碎片问题，这就需要新的算法去解决。</p>
<h3 id="mark-compact">Mark-Compact</h3>
<p>MC 算法与 MS 类似，先是一个 mark 过程标记可到达对象，这里取代 sweep 的是一个 compact，工作流程如下：</p>
<ol>
<li>重新安排（relocate）可到达对象</li>
<li>更新指向可到达对象的指针</li>
</ol>
<p>关于第一步中的安排策略，一般有如下三种选择：</p>
<ol>
<li>任意（Arbitrary）。特点是快，但是空间的 locality 较差</li>
<li>线性（Linearising）。重新分配到附近有关系的（siblings/pointer/reference&hellip;）对象周边</li>
<li>滑动（Sliding）。所有活对象被滑动到 heap 的一端，保证原有顺序，这有利于改善 locality 的情况。这是现在采用较多的方案</li>
</ol>
<p>对于采用 MC 的系统，allocate 过程就变得较为简单，只需要bump pointer 即可。
但是这类算法需要多次遍历对象，第一次遍历算出对象将要移动到的新位置，接下来的遍历来真正移动对象，并更新指针，所以MC相对MS要更耗时，这在 heap 较大时更为明显。
这里比较有名的是 Edward 的 Two-pointer 压缩算法。大致过程如下：</p>
<ol>
<li>在 heap 两端各准备一指针，由外向内 scan 寻找可压缩的对象</li>
<li>自顶向下的指针寻找可到达对象，自底向上的指针寻找 heap 中的“洞”来存放可到达对象</li>
</ol>
<p>关于这个算法还有很多变种，这里不在讲述，感兴趣可以自行搜索：</p>
<ul>
<li>Threaded compaction [Jonkers, 1979]</li>
<li>One pass algorithms [Abuaiadh et al, 2004,Kermany and Petrank, 2006]</li>
</ul>
<h3 id="copying-gc">Copying GC</h3>
<p>MC 算法虽然能解决内存碎片问题，但是需要多次遍历heap空间，这会导致较大性能损耗，Copying GC 采用空间换时间的方式来提升性能。
这类 GC 并不会真正去“回收”不可到达对象，而是会把所有可到达对象移动到一个区域，heap 中剩余的空间就是可用的了（因为这里面都是垃圾）。这里并没有进行 sweep/compact，而是用 scavenging（净化） 来描述回收这一过程。</p>
<h4 id="semispace-collector">Semispace collector</h4>
<p>Copying GC 典型的代表半空间回收器（semispace collector）。其工作过程是这样的：</p>
<ol>
<li>heap 被分成2份相邻的空间（semispace）：fromspace 与 tospace</li>
<li>在程序运行时，只有 fromspace 会被使用（分配新对象）</li>
<li>在 fromspace 没有足够空间容纳新对象时，程序会被挂起，然后把 fromspace 的可到达对象拷贝到 tospace</li>
<li>在拷贝完成时，之前的2个空间交换身份，tospace 成了新一轮的 fromspace</li>
</ol>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2XvQXuS8YBeNkSnb4XXaevFXa_!!581166664.png" alt="semispace 示意图">
    <figcaption><center>semispace 示意图</center></figcaption>
  </figure>

</p>
<h4 id="cheney-算法">Cheney 算法</h4>
<p><a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm">Cheney 算法</a>是用来解决如何遍历引用关系图，将之移动到 tospace 的算法，其步骤如下：</p>
<ol>
<li>所有可直接到达的对象组成一队列，作为宽度优先遍历的起点，同时有两个辅助指针：scan 指针指向起始位置，free 指针指向末尾</li>
<li>通过移动 scan 来依次遍历队列，当 scan 的对象存在指向 fromspace 中对象的指针时，把被指向的对象添加到队列末端，同时更新指针，使之指向新对象；</li>
<li>更新 free 使之始终指向队列末尾，重复步骤2</li>
<li>当 scan 移动到队列末尾时，算法结束</li>
</ol>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i1/581166664/TB2hTZWC1ySBuNjy1zdXXXPxFXa_!!581166664.png" alt="Cheney 宽度优先遍历复制示意图">
    <figcaption><center>Cheney 宽度优先遍历复制示意图</center></figcaption>
  </figure>

</p>
<p>如果按照上述算法操作，会把被指向多次的对象复制多次，所以在拷贝对象到 tospace 时，会在原始版本的对象上记录一个重定向指针（forwarding pointer），来标明这个对象已经被复制过了，并且告知新对象的位置；后面 scan 对象时，如果发现具有重定向指针的对象时就会跳过复制操作，直接更新指针就可以了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">initialize():
    tospace = N/2
    fromspace = 0
    allocPtr = fromspace
    scanPtr = whatever // 只在 collect 阶段使用
    
allocate(n):
    if allocPtr + n &gt; fromspace + N/2
        collect()
    if allocPtr + n &gt; fromspace + N/2
        fail &#34;Insufficient memory&#34;
    
    o = allocPtr
    allocPtr = allocPtr + n
    return o
    
atomic collect():
    swap(fromspace, tospace)
    allocPtr = fromspace
    scanPtr = fromspace
    
    for each field in Roots
        copy(field)
        
    while scanPtr &lt; allocPtr:
        for each reference in o // scanPtr 指向 o
            copy(reference)
        scanPtr = scanPtr + o.size()

copy(o):
    if hasForwardingAddress(o)
        return forwardAddress(o)
    else
        o&#39; = allocPtr
        allocPtr = allocPtr + o.size()
        copy the contents of o to o&#39;
        forwardAddress(o) = o&#39;
</code></pre></td></tr></table>
</div>
</div><h4 id="优缺点">优缺点</h4>
<p>通过上述描述，不难发现Copying GC 一最大缺点在于所需空间翻倍，不过现如今内存已经普遍较大，这个问题不是很严重。
其次，复制的效率于可到达对象成正比，如果每次 GC 时可到达对象相近，那么降低 GC 频率就会减少 GC 对程序的影响。如果降低 GC 频率呢？答案就是加大 semispace 空间，这样程序就需要更多的时间来填满它。</p>
<p>如果程序中有一些大对象体积（比如：大数组），且存活时间较长，那么这个复制操作对程序影响就会会比较严重，基于此，Baker 提出了一种衍化方案：Non-Copying Implicit GC</p>
<h4 id="non-copying-implicit-gc">Non-Copying Implicit GC</h4>
<p>这类 GC 从 Copying GC 衍化而来，巧妙之处在于，semispace 不必是物理上分割的空间，可以用两个用双向链表来表示，一般称为 ：from-set 与 to-set。为了实现这种策略，需要在每个对象上多加以下两个信息：</p>
<ul>
<li>两个指针，用来形成链表</li>
<li>一个flag，标明属于哪个集合</li>
</ul>
<p>当 from-set 耗尽时，只需遍历 from-set，把其中的可到达对象插入到 to-set，然后改变flag即可，复制操作变成了链表指针操作。这类 GC 的优势除了不用进行真正的拷贝外，还有下面两处优点：</p>
<ol>
<li>语言级别的指针不需要改变了（因为对象没动），这对编译器的要求更小了</li>
<li>如果一个对象不含有指针，那么就没必要 scan 了</li>
</ol>
<p>缺点当然也比较明显：</p>
<ul>
<li>每个对象需要而外的空间</li>
<li>碎片问题依旧</li>
</ul>
<p>所以这类 GC 虽然是 Copying GC 的优化，但也只适用于某些特定的场景。</p>
<h2 id="总结">总结</h2>
<p>通过上面的介绍，觉得最重要的就是要分清一个算法的优势与劣势，软件工程里面没有「银弹」，都是有取舍的。
上面对 MS 算法的优化，基本都是在 sweep 阶段，mark 阶段没怎么改进。鉴于文章篇幅，将在下一篇中介绍 Incremental GC，来说明如何优化 mark 阶段；而且通过不断研究，前辈们总结出「大部分对象的生命周期较短」的特性，所以就延伸出了 Generational GC，这也将在下文中介绍。Stay Tuned！</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://www.cs.tau.ac.il/~maon/teaching/2014-2015/seminar/seminar1415a-lec2-mark-sweep-mark-compact.pdf">http://www.cs.tau.ac.il/~maon/teaching/2014-2015/seminar/seminar1415a-lec2-mark-sweep-mark-compact.pdf</a></li>
<li><a href="https://the.gregor.institute/t/5n/842/slides/6.pdf">https://the.gregor.institute/t/5n/842/slides/6.pdf</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec26-gc/lec26.html">https://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec26-gc/lec26.html</a></li>
<li><a href="https://stackoverflow.com/questions/23057531/what-are-the-advantages-and-disadvantages-of-having-mark-bits-together-and-separ">https://stackoverflow.com/questions/23057531/what-are-the-advantages-and-disadvantages-of-having-mark-bits-together-and-separ</a></li>
<li><a href="http://xiao-feng.blogspot.com/2007/11/better-bitmap-design-for-mark-sweep-gc.html">http://xiao-feng.blogspot.com/2007/11/better-bitmap-design-for-mark-sweep-gc.html</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">刘家财</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-12-04
        <a href="https://github.com/jiacai2050/jiacai2050.github.io/commit/8f8c30acc9eabc6498854bdbb13df6a4b744f17d" title="fix bad categories">(8f8c30a)</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/gc/">GC</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2018/08/04/incremental-gc/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">深入浅出垃圾回收（三）增量式 GC</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2018/06/15/garbage-collection-intro/">
            <span class="next-text nav-default">深入浅出垃圾回收（一）简介篇</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'jiacai2050';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jiacai2050&#43;blog@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/2163429/jiacai-liu" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.twitter.com/liujiacai" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/jiacai2050" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/liujiacai" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/jiacai2050" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/liujiacai/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://liujiacai.net/atom.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2014 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>刘家财</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-50745138-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>

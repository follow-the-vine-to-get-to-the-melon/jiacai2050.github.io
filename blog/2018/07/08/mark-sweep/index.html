<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>深入浅出垃圾回收（二）Mark-Sweep 详析及其优化 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</h1><div class="post-meta">Jul 8, 2018<span> | </span><span class="category"><a href="/categories/aha-computer/">理解计算机</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2018/07/08/mark-sweep/" href="/blog/2018/07/08/mark-sweep/#disqus_thread"></a><div class="post-content"><p>在上一篇文中介绍的追踪类（tracing）GC 较引用计数（Reference Counting）<a href="/blog/2018/06/15/garbage-collection-intro/#引用计数（Reference-counting）">性能更高</a>，但原生的追踪类 GC 也有其自身缺点，需要对其进行改造才能真正的名副其实。这篇文章就来介绍与之相关的内容。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>为了后面叙述方便，首先明确以下几个名词的含义：</p>
<ul>
<li>Collector，用于进行垃圾回收的线程</li>
<li>Mutators，应用程序的线程，可以修改 heap</li>
<li>MS，mark-sweep 算法的简写</li>
<li>MC，mark-compact 算法的简写</li>
<li>RC，reference-counting 的简写</li>
<li>liveness，一个对象的可到达性</li>
<li>引用关系图，由可到达对象引用形成的图结构</li>
<li>locality，现代CPU在访问内存时，有多级缓存。缓存以 cache line （一般64字节）为最小操作单位，所以当访问内存中连续的数据时会比较高校，这称为 locality</li>
</ul>
<h2 id="MS-基本流程"><a href="#MS-基本流程" class="headerlink" title="MS 基本流程"></a>MS 基本流程</h2><p>首先来回顾下追踪类 GC 最基本的 <a href="/blog/2018/06/15/garbage-collection-intro/#基本算法-mark-and-sweep">mark-and-sweep 算法</a> ：先扫描整个 heap，标出可到达对象，然后执行 sweep 操作回收不可到达对象。这个算法本身比较简单，下面给出其实现伪代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutator 通过 new 函数来申请内存</span></span><br><span class="line"><span class="keyword">new</span>():</span><br><span class="line">    <span class="keyword">ref</span> = allocate()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">ref</span> == <span class="literal">null</span></span><br><span class="line">        collect()</span><br><span class="line">        <span class="keyword">ref</span> = allocate()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">ref</span> == <span class="literal">null</span></span><br><span class="line">            error <span class="string">"Out of memory"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ref</span></span><br><span class="line"></span><br><span class="line"><span class="function">atomic <span class="title">collect</span>(<span class="params"></span>):  <span class="comment">// 这里 atomic 表明 gc 是原子性的，mutator 需要暂停</span></span></span><br><span class="line"><span class="function">    <span class="title">markFromRoots</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    <span class="title">sweep</span>(<span class="params">heapStart, heapEnd</span>)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="title">markFromRoots</span>(<span class="params"></span>):</span></span><br><span class="line"><span class="function">    <span class="title">initialize</span>(<span class="params">worklist</span>)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> each reference <span class="keyword">in</span> Roots  <span class="comment">// Roots 表示所有根对象，比如全局对象，stack 中的对象</span></span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="keyword">ref</span> !</span>= <span class="literal">null</span> &amp;&amp; !isMarked(reference)</span><br><span class="line">            setMarked(reference)</span><br><span class="line">            <span class="keyword">add</span>(worklist, reference)</span><br><span class="line">            mark()          <span class="comment">// mark 也可以放在循环外面</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">initialize():</span><br><span class="line">    <span class="comment">// 对于单线程的collector 来说，可以用队列实现 worklist</span></span><br><span class="line">    worklist = emptyQueue()</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 worklist 是队列，那么 mark 采用的是 BFS（广度优先搜索）方式来遍历引用树                </span></span><br><span class="line">mark():</span><br><span class="line">    <span class="keyword">while</span> !isEmpty(worklist):</span><br><span class="line">        <span class="keyword">ref</span> = <span class="keyword">remove</span>(worklist)  <span class="comment">// 从 worklist 中取出第一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">for</span> each field <span class="keyword">in</span> <span class="title">Pointers</span>(<span class="params"><span class="keyword">ref</span></span>)  <span class="comment">// Pointers(obj) 返回一个object的所有属性，可能是数据，对象，指向其他对象的指针</span></span></span><br><span class="line"><span class="function">            child</span> = *field</span><br><span class="line">            <span class="keyword">if</span> child != <span class="literal">null</span> &amp;&amp; !isMarked(child)</span><br><span class="line">                setMarked(child)</span><br><span class="line">                <span class="keyword">add</span>(worklist, child)</span><br><span class="line">                </span><br><span class="line">sweep(start, end):</span><br><span class="line">    scan = start</span><br><span class="line">    <span class="keyword">while</span> scan &lt; end</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">isMarked</span>(<span class="params">scan</span>)</span></span><br><span class="line"><span class="function">            <span class="title">unsetMarked</span>(<span class="params">scan</span>)</span></span><br><span class="line"><span class="function">        else</span></span><br><span class="line"><span class="function">            <span class="title">free</span>(<span class="params">scan</span>)</span></span><br><span class="line"><span class="function">        scan</span> = nextObject(scan)</span><br></pre></td></tr></table></figure>
<p>通过上面伪代码描述，不难得出 MS 有以下问题：</p>
<ol>
<li>heap 容易出现碎片</li>
<li>破坏引用本地性（由于对象不会被移动，存活的对象与空闲空间交错在一起）</li>
<li>GC 时间与 heap 空间大小成正比</li>
<li>在进行 GC 期间，整个系统会被挂起，即stop-the-world</li>
</ol>
<p>需要说明一点，RC 类 GC 同样有前两个问题，但是对于 RC 来说，并没有好的优化措施来缓解。下面我们就来看追踪类 GC 是如何解决上述问题。</p>
<h2 id="优化MS"><a href="#优化MS" class="headerlink" title="优化MS"></a>优化MS</h2><h3 id="Bitmap-marking"><a href="#Bitmap-marking" class="headerlink" title="Bitmap marking"></a>Bitmap marking</h3><p>在 mark 过程中，需要去标记（mark-bits）对象的 liveness，有两种方式来实现：</p>
<ol>
<li>在每个对象的header部分（in-object mark-bit）</li>
<li>使用一个单独的 bitmap，每一位 bit 对应一个对象</li>
</ol>
<p>两种方式各有利弊，需要结合具体场景进行分析。In-object mark-bit 是最直接的方式，对于 JVM/.NET 运行时来说，每个 object 都会有 header，使用这种方式也就理所应当了；<br>对于 bitmap 来说，需要在 bit 位与 object 之间进行映射，这就要求 object 进行对齐，比如：heap 大小为 65536 字节，所有的对象以 16 字节对齐，那么堆内就有 4096 个地址可以作为对象的起始地址，与之对应需要 4096 个 bit 即 512 个字节。除此之外，bitmap 还有下面两个优势：</p>
<ol>
<li>sweep 操作更高效，这是由于 bitmap 结构紧凑，可以一次性加载到内存中；通过整型的 ALU 操作与<a href="https://en.wikipedia.org/wiki/Branch_%28computer_science%29" target="_blank" rel="noopener">条件分支（conditional branch）</a> 一次性可进行 32 位的检测</li>
<li>在类 Unix 系统中，bitmap 有利于 fork() 出来的进程与主进程进行 copy-on-write 数据共享，<a href="http://patshaughnessy.net/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0#" target="_blank" rel="noopener">Ruby 2.0 就因此获得较大性能提升</a>。</li>
</ol>
<p>下面给出 bitmap 方式的伪代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mark():</span><br><span class="line">    cur = nextInBitmap()</span><br><span class="line">    <span class="keyword">while</span> cur &lt; heapEnd</span><br><span class="line">        <span class="keyword">add</span>(worklist, cur)</span><br><span class="line">        markStep(cur)</span><br><span class="line">        cur = nextInBitmap()</span><br><span class="line">        </span><br><span class="line">markStep(start):</span><br><span class="line">    <span class="keyword">while</span> !isEmpty():</span><br><span class="line">        <span class="keyword">ref</span> = <span class="keyword">remove</span>(worklist)</span><br><span class="line">        <span class="function"><span class="keyword">for</span> each field <span class="keyword">in</span> <span class="title">Pointers</span>(<span class="params"><span class="keyword">ref</span></span>):</span></span><br><span class="line"><span class="function">            child</span> = *field</span><br><span class="line">            <span class="keyword">if</span> child != <span class="literal">null</span> &amp;&amp; !isMarked(child)</span><br><span class="line">                setMarked(child)</span><br><span class="line">                <span class="keyword">if</span> child &gt; start         <span class="comment">//这里与之前不同，只需要把高于当前地址的子节点加入到 worklist 即可</span></span><br><span class="line">                    <span class="keyword">add</span>(worklist, child)</span><br></pre></td></tr></table></figure></p>
<h3 id="Lazy-sweeping"><a href="#Lazy-sweeping" class="headerlink" title="Lazy sweeping"></a>Lazy sweeping</h3><p>MS 算法有以下几个特点：</p>
<ol>
<li>某对象一旦被标为garbage，它永远都会是 garbage，不会被 mutator 再访问</li>
<li>mutator 不能修改 mark-bit</li>
</ol>
<p>基于以上几点，sweep 操作完全可以与 mutator 同时运行（parallel）的。<br>Lazy sweep 指的是把较为耗时（相对 mark 来说）的 sweep 操作放在 allocate 过程中，并且只在有足够的空间时才去真正进行回收。<a href="https://www.infoq.com/news/2011/08/ruby193-gc" target="_blank" rel="noopener">Ruby 1.9.3 引入 lazy sweep 获得较大性能提升</a>。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">atomic collect():</span><br><span class="line">    markFromRoots()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">block</span> <span class="keyword">in</span> Blocks  <span class="comment">// 这里以 block 为单位管理更高效</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isMarked(<span class="keyword">block</span>)</span><br><span class="line">            <span class="keyword">add</span>(blockAllocator, <span class="keyword">block</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">add</span>(reclaimList, <span class="keyword">block</span>)    <span class="comment">// 把待回收的 block 放入队列中延迟回收</span></span><br><span class="line">            </span><br><span class="line">atomic allocate(sz):</span><br><span class="line">    <span class="keyword">result</span> = <span class="keyword">remove</span>(sz)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">result</span> = null</span><br><span class="line">        lazySweep(sz)</span><br><span class="line">        <span class="keyword">result</span> = <span class="keyword">remove</span>(sz)</span><br><span class="line">    return <span class="keyword">result</span></span><br><span class="line">    </span><br><span class="line">lazySweep(sz):</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">block</span> = nextBlock(reclaimList, sz)  <span class="comment">// 这里需要分配一个 sz 大小的 block，可见 block 需要按大小 group 起来管理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">block</span> != null</span><br><span class="line">            sweep(start(<span class="keyword">block</span>), <span class="keyword">end</span>(<span class="keyword">block</span>))</span><br><span class="line">            <span class="keyword">if</span> spaceFound(<span class="keyword">block</span>)</span><br><span class="line">                return</span><br><span class="line">    <span class="keyword">until</span> <span class="keyword">block</span> == null</span><br><span class="line">    allocSlow(sz)</span><br><span class="line">    </span><br><span class="line">allocSlow(sz):</span><br><span class="line">    <span class="keyword">block</span> = allocateBlock(sz)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">block</span> != null</span><br><span class="line">        init(<span class="keyword">block</span>)</span><br></pre></td></tr></table></figure>
<p>Lazy Sweep 除了降低 sweep 阶段 mutator 的暂停时间外，还有以下优点：</p>
<ul>
<li>更好的 locality。这是因为被回收的 block 会尽快地重新使用</li>
<li>GC 复杂度只于<strong>可到达对象</strong>成正比</li>
<li>在大部分 heap 空间为空时效率最好</li>
</ul>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><p>除了上面介绍的两类优化，比较新的优化手段还有如下几个：</p>
<ul>
<li>FIFO prefetch buffer [Cher et al, 2004]</li>
<li>Edge marking [Garner et al, 2007]</li>
</ul>
<p>鉴于篇幅原因，这里不再讲述，感兴趣的读者可自行搜索。</p>
<h2 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h2><p>上面优化的措施虽然能提高 MS 性能，但都无法解决 heap 碎片问题，这就需要新的算法去解决。</p>
<h3 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h3><p>MC 算法与 MS 类似，先是一个 mark 过程标记可到达对象，这里取代 sweep 的是一个 compact，工作流程如下：</p>
<ol>
<li>重新安排（relocate）可到达对象</li>
<li>更新指向可到达对象的指针</li>
</ol>
<p>关于第一步中的安排策略，一般有如下三种选择：</p>
<ol>
<li>任意（Arbitrary）。特点是快，但是空间的 locality 较差</li>
<li>线性（Linearising）。重新分配到附近有关系的（siblings/pointer/reference…）对象周边</li>
<li>滑动（Sliding）。所有活对象被滑动到 heap 的一端，保证原有顺序，这有利于改善 locality 的情况。这是现在采用较多的方案</li>
</ol>
<p>对于采用 MC 的系统，allocate 过程就变得较为简单，只需要bump pointer 即可。<br>但是这类算法需要多次遍历对象，第一次遍历算出对象将要移动到的新位置，接下来的遍历来真正移动对象，并更新指针，所以MC相对MS要更耗时，这在 heap 较大时更为明显。<br>这里比较有名的是 Edward 的 Two-pointer 压缩算法。大致过程如下：</p>
<ol>
<li>在 heap 两端各准备一指针，由外向内 scan 寻找可压缩的对象</li>
<li>自顶向下的指针寻找可到达对象，自底向上的指针寻找 heap 中的“洞”来存放可到达对象</li>
</ol>
<p>关于这个算法还有很多变种，这里不在讲述，感兴趣可以自行搜索：</p>
<ul>
<li>Threaded compaction [Jonkers, 1979]</li>
<li>One pass algorithms [Abuaiadh et al, 2004,Kermany and Petrank, 2006]</li>
</ul>
<h3 id="Copying-GC"><a href="#Copying-GC" class="headerlink" title="Copying GC"></a>Copying GC</h3><p>MC 算法虽然能解决内存碎片问题，但是需要多次遍历heap空间，这会导致较大性能损耗，Copying GC 采用空间换时间的方式来提升性能。<br>这类 GC 并不会真正去“回收”不可到达对象，而是会把所有可到达对象移动到一个区域，heap 中剩余的空间就是可用的了（因为这里面都是垃圾）。这里并没有进行 sweep/compact，而是用 scavenging（净化） 来描述回收这一过程。</p>
<h4 id="Semispace-collector"><a href="#Semispace-collector" class="headerlink" title="Semispace collector"></a>Semispace collector</h4><p>Copying GC 典型的代表半空间回收器（semispace collector）。其工作过程是这样的：</p>
<ol>
<li>heap 被分成2份相邻的空间（semispace）：fromspace 与 tospace</li>
<li>在程序运行时，只有 fromspace 会被使用（分配新对象）</li>
<li>在 fromspace 没有足够空间容纳新对象时，程序会被挂起，然后把 fromspace 的可到达对象拷贝到 tospace</li>
<li>在拷贝完成时，之前的2个空间交换身份，tospace 成了新一轮的 fromspace</li>
</ol>
<p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2XvQXuS8YBeNkSnb4XXaevFXa_!!581166664.png" alt="semispace 示意图"></p>
<h4 id="Cheney-算法"><a href="#Cheney-算法" class="headerlink" title="Cheney 算法"></a>Cheney 算法</h4><p><a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm" target="_blank" rel="noopener">Cheney 算法</a>是用来解决如何遍历引用关系图，将之移动到 tospace 的算法，其步骤如下：</p>
<ol>
<li>所有可直接到达的对象组成一队列，作为宽度优先遍历的起点，同时有两个辅助指针：scan 指针指向起始位置，free 指针指向末尾</li>
<li>通过移动 scan 来依次遍历队列，当 scan 的对象存在指向 fromspace 中对象的指针时，把被指向的对象添加到队列末端，同时更新指针，使之指向新对象；</li>
<li>更新 free 使之始终指向队列末尾，重复步骤2</li>
<li>当 scan 移动到队列末尾时，算法结束</li>
</ol>
<p><img src="https://img.alicdn.com/imgextra/i1/581166664/TB2hTZWC1ySBuNjy1zdXXXPxFXa_!!581166664.png" alt="Cheney 宽度优先遍历复制示意图"></p>
<p>如果按照上述算法操作，会把被指向多次的对象复制多次，所以在拷贝对象到 tospace 时，会在原始版本的对象上记录一个重定向指针（forwarding pointer），来标明这个对象已经被复制过了，并且告知新对象的位置；后面 scan 对象时，如果发现具有重定向指针的对象时就会跳过复制操作，直接更新指针就可以了。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">initialize():</span><br><span class="line">    <span class="attr">tospace</span> = N/<span class="number">2</span></span><br><span class="line">    <span class="attr">fromspace</span> = <span class="number">0</span></span><br><span class="line">    <span class="attr">allocPtr</span> = fromspace</span><br><span class="line">    <span class="attr">scanPtr</span> = whatever // 只在 collect 阶段使用</span><br><span class="line">    </span><br><span class="line">allocate(n):</span><br><span class="line">    <span class="keyword">if</span> allocPtr + n &gt; fromspace + N/<span class="number">2</span></span><br><span class="line">        collect()</span><br><span class="line">    <span class="keyword">if</span> allocPtr + n &gt; fromspace + N/<span class="number">2</span></span><br><span class="line">        fail <span class="string">"Insufficient memory"</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">o</span> = allocPtr</span><br><span class="line">    <span class="attr">allocPtr</span> = allocPtr + n</span><br><span class="line">    return o</span><br><span class="line">    </span><br><span class="line">atomic collect():</span><br><span class="line">    swap(fromspace, tospace)</span><br><span class="line">    <span class="attr">allocPtr</span> = fromspace</span><br><span class="line">    <span class="attr">scanPtr</span> = fromspace</span><br><span class="line">    </span><br><span class="line">    for each field <span class="keyword">in</span> Roots</span><br><span class="line">        copy(field)</span><br><span class="line">        </span><br><span class="line">    while scanPtr &lt; allocPtr:</span><br><span class="line">        for each reference <span class="keyword">in</span> o // scanPtr 指向 o</span><br><span class="line">            copy(reference)</span><br><span class="line">        <span class="attr">scanPtr</span> = scanPtr + o.size()</span><br><span class="line"></span><br><span class="line">copy(o):</span><br><span class="line">    <span class="keyword">if</span> hasForwardingAddress(o)</span><br><span class="line">        return forwardAddress(o)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        o' = allocPtr</span><br><span class="line">        <span class="attr">allocPtr</span> = allocPtr + o.size()</span><br><span class="line">        copy the contents of o to o'</span><br><span class="line">        forwardAddress(o) = o'</span><br></pre></td></tr></table></figure>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>通过上述描述，不难发现Copying GC 一最大缺点在于所需空间翻倍，不过现如今内存已经普遍较大，这个问题不是很严重。<br>其次，复制的效率于可到达对象成正比，如果每次 GC 时可到达对象相近，那么降低 GC 频率就会减少 GC 对程序的影响。如果降低 GC 频率呢？答案就是加大 semispace 空间，这样程序就需要更多的时间来填满它。</p>
<p>如果程序中有一些大对象体积（比如：大数组），且存活时间较长，那么这个复制操作对程序影响就会会比较严重，基于此，Baker 提出了一种衍化方案：Non-Copying Implicit GC</p>
<h4 id="Non-Copying-Implicit-GC"><a href="#Non-Copying-Implicit-GC" class="headerlink" title="Non-Copying Implicit GC"></a>Non-Copying Implicit GC</h4><p>这类 GC 从 Copying GC 衍化而来，巧妙之处在于，semispace 不必是物理上分割的空间，可以用两个用双向链表来表示，一般称为 ：from-set 与 to-set。为了实现这种策略，需要在每个对象上多加以下两个信息：</p>
<ul>
<li>两个指针，用来形成链表</li>
<li>一个flag，标明属于哪个集合</li>
</ul>
<p>当 from-set 耗尽时，只需遍历 from-set，把其中的可到达对象插入到 to-set，然后改变flag即可，复制操作变成了链表指针操作。这类 GC 的优势除了不用进行真正的拷贝外，还有下面两处优点：</p>
<ol>
<li>语言级别的指针不需要改变了（因为对象没动），这对编译器的要求更小了</li>
<li>如果一个对象不含有指针，那么就没必要 scan 了</li>
</ol>
<p>缺点当然也比较明显：</p>
<ul>
<li>每个对象需要而外的空间</li>
<li>碎片问题依旧</li>
</ul>
<p>所以这类 GC 虽然是 Copying GC 的优化，但也只适用于某些特定的场景。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的介绍，觉得最重要的就是要分清一个算法的优势与劣势，软件工程里面没有「银弹」，都是有取舍的。<br>上面对 MS 算法的优化，基本都是在 sweep 阶段，mark 阶段没怎么改进。鉴于文章篇幅，将在下一篇中介绍 Incremental GC，来说明如何优化 mark 阶段；而且通过不断研究，前辈们总结出「大部分对象的生命周期较短」的特性，所以就延伸出了 Generational GC，这也将在下文中介绍。Stay Tuned！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cs.tau.ac.il/~maon/teaching/2014-2015/seminar/seminar1415a-lec2-mark-sweep-mark-compact.pdf" target="_blank" rel="noopener">http://www.cs.tau.ac.il/~maon/teaching/2014-2015/seminar/seminar1415a-lec2-mark-sweep-mark-compact.pdf</a></li>
<li><a href="https://the.gregor.institute/t/5n/842/slides/6.pdf" target="_blank" rel="noopener">https://the.gregor.institute/t/5n/842/slides/6.pdf</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec26-gc/lec26.html" target="_blank" rel="noopener">https://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec26-gc/lec26.html</a></li>
<li><a href="https://stackoverflow.com/questions/23057531/what-are-the-advantages-and-disadvantages-of-having-mark-bits-together-and-separ" target="_blank" rel="noopener">https://stackoverflow.com/questions/23057531/what-are-the-advantages-and-disadvantages-of-having-mark-bits-together-and-separ</a></li>
<li><a href="http://xiao-feng.blogspot.com/2007/11/better-bitmap-design-for-mark-sweep-gc.html" target="_blank" rel="noopener">http://xiao-feng.blogspot.com/2007/11/better-bitmap-design-for-mark-sweep-gc.html</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2018/07/08/mark-sweep/" data-id="ck5w7gy400051maljkm8dfvca" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aO27DMBBFUe9/03KTwgYs5b4ZqeDwqjJihuJxQczv9cLP8fHcu/5zTfqW+JEhQ8ayjOPyOVtzdpQajL/3dB8ZMmRswCBXIT8Q55F3Xa+XIUOGjLM1KYzsIEOGDBn3MmpJ6dlfyLcyZMiQQZLY641IsSxNUB/JxWXIkLEg464k84nPj/Q3ZMiQsRTjCB8SrqWhYec8f/vIkCFjNKPTgKwVyMhPU2yIypAhYyiDJIf8ZTzhTMtt/6TQMmTI2ICRJq683JYeK72Uvy5cGTJkDGXwYn0a3vELvdNmiHsOMmTIWJaRppEESf7CQ8ZgjQwZMsYxauLOmAUPRoNBMRkyZGzA4ONWJAWttQHSnX9cuDJkyBjNqDUa+/9VCz1R1VCGDBmDGDxE40NdaUDJ18dlOBkyZAxiPB3w1doShCRDhowdGPyIKS89Yms3GTJkjGaQr/sDFjxATBuZMmTI2IHRCfV4IzMdzkhLezJkyJjN4DlgpwGZthDSMFGGDBn7MMiYRe3b9DrmV/CPC1eGDBmjGSSNJM1LcsS06BaX22TIkDGa0TloOuwVTH/UklgZMmSMYBzhkwaLvBVaTFzJLyRDhozFGf3butaSJDzyOYbJkCFjWUatGUCKaLVfrnjhypAhYwNG5+Ljhf67kDJkyJDRiS47Y2F8HxkyZMjo58FxAzIc1ECdWBkyZIxjpKOld1X4eFNThgwZOzPS1JFfpnxEIx3XKDY1ZciQsR7jDR+O2xmVMOUvAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/gc/">GC</a></div><div class="post-nav"><a class="pre" href="/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a><a class="next" href="/blog/2018/06/15/garbage-collection-intro/">深入浅出垃圾回收（一）简介篇</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2018/07/08/mark-sweep/';
    this.page.identifier = 'blog/2018/07/08/mark-sweep/';
    this.page.title = '深入浅出垃圾回收（二）Mark-Sweep 详析及其优化';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">24</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/07/08/mark-sweep/">深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/06/15/garbage-collection-intro/">深入浅出垃圾回收（一）简介篇</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java 线程同步原理探析 - Keep Coding</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="刘家财" /><meta name="description" content="现如今，服务器性能日益增长，并发（concurrency）编程已经“深入人心”，但由于冯诺依式计算机“指令存储，顺序执行”的特性，使得编写跨" /><meta name="keywords" content="lisp, clojure, emacs, database, life" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="https://liujiacai.net/blog/2018/12/29/how-java-synchronizer-work/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/jiacai.css">


<meta property="og:title" content="Java 线程同步原理探析" />
<meta property="og:description" content="现如今，服务器性能日益增长，并发（concurrency）编程已经“深入人心”，但由于冯诺依式计算机“指令存储，顺序执行”的特性，使得编写跨" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liujiacai.net/blog/2018/12/29/how-java-synchronizer-work/" />
<meta property="article:published_time" content="2018-12-29T22:40:42+00:00" />
<meta property="article:modified_time" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="name" content="Java 线程同步原理探析">
<meta itemprop="description" content="现如今，服务器性能日益增长，并发（concurrency）编程已经“深入人心”，但由于冯诺依式计算机“指令存储，顺序执行”的特性，使得编写跨">
<meta itemprop="datePublished" content="2018-12-29T22:40:42+00:00" />
<meta itemprop="dateModified" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="wordCount" content="5225">



<meta itemprop="keywords" content="Java," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 线程同步原理探析"/>
<meta name="twitter:description" content="现如今，服务器性能日益增长，并发（concurrency）编程已经“深入人心”，但由于冯诺依式计算机“指令存储，顺序执行”的特性，使得编写跨"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Keep Coding</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/podcast/">
        <li class="mobile-menu-item">Podcast</li>
      </a><a href="/blogrolls/">
        <li class="mobile-menu-item">友链</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Keep Coding</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/podcast/">Podcast</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/blogrolls/">友链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java 线程同步原理探析</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-12-29 </span>
        <div class="post-category">
            <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"> 编程语言 </a>
            </div>
          <span class="more-meta"> 约 5225 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#juc">JUC</a>
          <ul>
            <li><a href="#abstractqueuedsynchronizer">AbstractQueuedSynchronizer</a></li>
          </ul>
        </li>
        <li><a href="#java-如何实现堵塞通知">Java 如何实现堵塞、通知</a>
          <ul>
            <li><a href="#waitnotify">wait/notify</a></li>
            <li><a href="#lockunlock">lock/unlock</a></li>
          </ul>
        </li>
        <li><a href="#os-支持的同步原语">OS 支持的同步原语</a>
          <ul>
            <li><a href="#semaphore">Semaphore</a></li>
            <li><a href="#monitors">Monitors</a></li>
            <li><a href="#big-picture">Big Picture</a></li>
          </ul>
        </li>
        <li><a href="#interruptible">Interruptible</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>现如今，服务器性能日益增长，并发（concurrency）编程已经“深入人心”，但由于冯诺依式计算机“指令存储，顺序执行”的特性，使得编写跨越时间维度的并发程序异常困难，所以现代编程语言都对并发编程提供了一定程度的支持，像 Golang 里面的 <a href="https://tour.golang.org/concurrency/1">Goroutines</a>、Clojure 里面的 <a href="https://clojure.org/reference/refs">STM（Software Transactional Memory）</a>、Erlang 里面的 <a href="https://en.wikipedia.org/wiki/Actor_model">Actor</a>。</p>
<p>Java 对于并发编程的解决方案是多线程（Multi-threaded programming），而且 Java 中的线程 与 native 线程一一对应，多线程也是早期操作系统支持并发的方案之一（其他方案：多进程、IO多路复用）。</p>
<p>本文着重介绍 Java 中线程同步的原理、实现机制，更侧重操作系统层面，部分原理参考 <a href="http://hg.openjdk.java.net/jdk/jdk/file/cfceb4df2499">openjdk 源码</a>。阅读本文需要对 CyclicBarrier、CountDownLatch 有基本的使用经验。</p>
<h2 id="juc">JUC</h2>
<p>在 Java 1.5 版本中，引入 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html">JUC</a> 并发编程辅助包，很大程度上降低了并发编程的门槛，JUC 里面主要包括：</p>
<ul>
<li>线程调度的 Executors</li>
<li>缓冲任务的 Queues</li>
<li>超时相关的 TimeUnit</li>
<li>并发集合（如 ConcurrentHashMap）</li>
<li>线程同步类（Synchronizers，如 CountDownLatch ）</li>
</ul>
<p>个人认为其中最重要也是最核心的是线程同步这一块，因为并发编程的难点就在于如何保证「共享区域（专业术语：临界区，Critical Section）的访问时序问题」。</p>
<h3 id="abstractqueuedsynchronizer">AbstractQueuedSynchronizer</h3>
<p>JUC 提供的同步类主要有如下几种：</p>
<ul>
<li><code>Semaphore</code> is a classic concurrency tool.</li>
<li><code>CountDownLatch</code> is a very simple yet very common utility for blocking until a given number of signals, events, or conditions hold.</li>
<li>A <code>CyclicBarrier</code> is a resettable multiway synchronization point useful in some styles of parallel programming.</li>
<li>A <code>Phaser</code> provides a more flexible form of barrier that may be used to control phased computation among multiple threads.</li>
<li>An <code>Exchanger</code> allows two threads to exchange objects at a rendezvous(约会) point, and is useful in several pipeline designs.</li>
</ul>
<p>通过阅读其源码可以发现，其实现都基于 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">AbstractQueuedSynchronizer</a> 这个抽象类（一般简写 AQS），正如其 javadoc 开头所说：</p>
<blockquote>
<p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state.</p>
</blockquote>
<p>也就是说，AQS 通过维护内部的 FIFO 队列和具备原子更新的整型 state 这两个属性来实现各种锁机制，包括：是否公平，是否可重入，是否共享，是否可中断（interrupt），并在这基础上，提供了更方便实用的同步类，也就是一开始提及的 Latch、Barrier 等。</p>
<p>这里暂时不去介绍 AQS 实现细节与如何基于 AQS 实现各种同步类（挖个坑），感兴趣的可以移步美团的一篇文章<a href="https://tech.meituan.com/Java_Lock.html">《不可不说的Java“锁”事》</a> 第六部分“独享锁 VS 共享锁”。</p>
<p>在学习 Java 线程同步这一块时，对我来说困扰最大的是「线程唤醒」，试想一个已经 wait/sleep/block 的线程，是如何响应 interrupt 的呢？当调用 Object.wait() 或 lock.lock() 时，JVM 究竟做了什么事情能够在调用 Object.notify 或 lock.unlock 时重新激活相应线程？</p>
<p>带着上面的问题，我们从源码中寻找答案。</p>
<h2 id="java-如何实现堵塞通知">Java 如何实现堵塞、通知</h2>
<h3 id="waitnotify">wait/notify</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">notify</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p>在 JDK 源码中，上述两个方法均用 native 实现（即 cpp 代码），追踪相关代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// java.base/share/native/libjava/Object.c
</span><span class="c1"></span><span class="k">static</span> <span class="n">JNINativeMethod</span> <span class="n">methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&#34;hashCode&#34;</span><span class="p">,</span>    <span class="s">&#34;()I&#34;</span><span class="p">,</span>                    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">JVM_IHashCode</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;wait&#34;</span><span class="p">,</span>        <span class="s">&#34;(J)V&#34;</span><span class="p">,</span>                   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">JVM_MonitorWait</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;notify&#34;</span><span class="p">,</span>      <span class="s">&#34;()V&#34;</span><span class="p">,</span>                    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">JVM_MonitorNotify</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;notifyAll&#34;</span><span class="p">,</span>   <span class="s">&#34;()V&#34;</span><span class="p">,</span>                    <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">JVM_MonitorNotifyAll</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;clone&#34;</span><span class="p">,</span>       <span class="s">&#34;()Ljava/lang/Object;&#34;</span><span class="p">,</span>   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">JVM_Clone</span><span class="p">},</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>通过上面的 cpp 代码，我们大概能猜出 JVM 是使用 monitor 来实现的 wait/notify 机制，至于这里的 monitor 是何种机制，这里暂时跳过，接着看 lock 相关实现</p>
<h3 id="lockunlock">lock/unlock</h3>
<p>LockSupport 是用来实现堵塞语义模型的基础辅助类，主要有两个方法：park 与 unpark。（在英文中，park 除了“公园”含义外，还有“停车”的意思）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// LockSupport.java
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">unpark</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">thread</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">UNSAFE</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">thread</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">park</span><span class="o">(</span><span class="n">Object</span> <span class="n">blocker</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="n">setBlocker</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">blocker</span><span class="o">);</span>
        <span class="n">UNSAFE</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">0L</span><span class="o">);</span>
        <span class="n">setBlocker</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
<span class="c1">// Unsafe.java
</span><span class="c1"></span>    <span class="cm">/**
</span><span class="cm">     * Unblocks the given thread blocked on {@code park}, or, if it is
</span><span class="cm">     * not blocked, causes the subsequent call to {@code park} not to
</span><span class="cm">     * block.  Note: this operation is &#34;unsafe&#34; solely because the
</span><span class="cm">     * caller must somehow ensure that the thread has not been
</span><span class="cm">     * destroyed. Nothing special is usually required to ensure this
</span><span class="cm">     * when called from Java (in which there will ordinarily be a live
</span><span class="cm">     * reference to the thread) but this is not nearly-automatically
</span><span class="cm">     * so when calling from native code.
</span><span class="cm">     *
</span><span class="cm">     * @param thread the thread to unpark.
</span><span class="cm">     */</span>
    <span class="nd">@HotSpotIntrinsicCandidate</span>
    <span class="kd">public</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">unpark</span><span class="o">(</span><span class="n">Object</span> <span class="n">thread</span><span class="o">);</span>

    <span class="cm">/**
</span><span class="cm">     * Blocks current thread, returning when a balancing
</span><span class="cm">     * {@code unpark} occurs, or a balancing {@code unpark} has
</span><span class="cm">     * already occurred, or the thread is interrupted, or, if not
</span><span class="cm">     * absolute and time is not zero, the given time nanoseconds have
</span><span class="cm">     * elapsed, or if absolute, the given deadline in milliseconds
</span><span class="cm">     * since Epoch has passed, or spuriously (i.e., returning for no
</span><span class="cm">     * &#34;reason&#34;). Note: This operation is in the Unsafe class only
</span><span class="cm">     * because {@code unpark} is, so it would be strange to place it
</span><span class="cm">     * elsewhere.
</span><span class="cm">     */</span>
    <span class="nd">@HotSpotIntrinsicCandidate</span>
    <span class="kd">public</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">park</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">isAbsolute</span><span class="o">,</span> <span class="kt">long</span> <span class="n">time</span><span class="o">);</span>

<span class="c1">// hotspot/share/prims/unsafe.cpp
</span><span class="c1"></span><span class="n">UNSAFE_ENTRY</span><span class="o">(</span><span class="kt">void</span><span class="o">,</span> <span class="n">Unsafe_Park</span><span class="o">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="o">,</span> <span class="n">jobject</span> <span class="n">unsafe</span><span class="o">,</span> <span class="n">jboolean</span> <span class="n">isAbsolute</span><span class="o">,</span> <span class="n">jlong</span> <span class="n">time</span><span class="o">))</span> <span class="o">{</span>
  <span class="n">HOTSPOT_THREAD_PARK_BEGIN</span><span class="o">((</span><span class="n">uintptr_t</span><span class="o">)</span> <span class="n">thread</span><span class="o">-&gt;</span><span class="n">parker</span><span class="o">(),</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">isAbsolute</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>
  <span class="n">EventThreadPark</span> <span class="n">event</span><span class="o">;</span>

  <span class="n">JavaThreadParkedState</span> <span class="nf">jtps</span><span class="o">(</span><span class="n">thread</span><span class="o">,</span> <span class="n">time</span> <span class="o">!=</span> <span class="n">0</span><span class="o">);</span>
  <span class="n">thread</span><span class="o">-&gt;</span><span class="n">parker</span><span class="o">()-&gt;</span><span class="n">park</span><span class="o">(</span><span class="n">isAbsolute</span> <span class="o">!=</span> <span class="n">0</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">should_commit</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">post_thread_park_event</span><span class="o">(&amp;</span><span class="n">event</span><span class="o">,</span> <span class="n">thread</span><span class="o">-&gt;</span><span class="n">current_park_blocker</span><span class="o">(),</span> <span class="n">time</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">HOTSPOT_THREAD_PARK_END</span><span class="o">((</span><span class="n">uintptr_t</span><span class="o">)</span> <span class="n">thread</span><span class="o">-&gt;</span><span class="n">parker</span><span class="o">());</span>
<span class="o">}</span> <span class="n">UNSAFE_END</span>
    
</code></pre></td></tr></table>
</div>
</div><p>通过上述 unsafe.cpp 可以看到每个 thread 都会有一个 Parker 对象，所以我们需要查看 parker 对象的定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// hotspot/share/runtime/park.hpp
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Parker</span> <span class="o">:</span> <span class="k">public</span> <span class="n">os</span><span class="o">::</span><span class="n">PlatformParker</span>
<span class="p">...</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// For simplicity of interface with Java, all forms of park (indefinite,
</span><span class="c1"></span>  <span class="c1">// relative, and absolute) are multiplexed into one call.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="n">park</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isAbsolute</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">time</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">unpark</span><span class="p">();</span>

<span class="c1">// hotspot/os/posix/os_posix.hpp
</span><span class="c1"></span><span class="k">class</span> <span class="nc">PlatformParker</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CHeapObj</span><span class="o">&lt;</span><span class="n">mtInternal</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">REL_INDEX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">ABS_INDEX</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">};</span>
  <span class="kt">int</span> <span class="n">_cur_index</span><span class="p">;</span>  <span class="c1">// which cond is in use: -1, 0, 1
</span><span class="c1"></span>  <span class="n">pthread_mutex_t</span> <span class="n">_mutex</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">pthread_cond_t</span>  <span class="n">_cond</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// one for relative times and one for absolute
</span><span class="c1"></span>  <span class="p">...</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>看到这里大概就能知道 park 是使用 <code>pthread_mutex_t</code> 与 <code>pthread_cond_t</code> 实现。好了，到目前为止，就引出了 Java 中与堵塞相关的实现，不难想象，都是依赖底层操作系统的功能。</p>
<h2 id="os-支持的同步原语">OS 支持的同步原语</h2>
<h3 id="semaphore">Semaphore</h3>
<p>并发编程领域的先锋人物 <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger Dijkstra</a>（也是最短路径算法的作者）在 1965 年首次提出了信号量（ Semaphores） 这一概念来解决线程同步的问题。信号量是一种特殊的变量类型，为非负整数，只有两个特殊操作PV：</p>
<ul>
<li>P(s) 如果 s!=0，将 s-1；否则将当前线程挂起，直到 s 变为非零</li>
<li>V(s) 将 s+1，如果有线程堵塞在 P 操作等待 s 变成非零，那么 V 操作会重启这些线程中的任意一个</li>
</ul>
<p>注：Dijkstra 为荷兰人，名字 P 和 V 来源于荷兰单词 Proberen（测试）和Verhogen（增加），为方便理解，后文会用 Wait 与 Signal 来表示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">semaphore</span> <span class="p">{</span>
     <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
     <span class="n">thread_list</span> <span class="n">waiting</span><span class="p">;</span>  <span class="c1">// List of threads waiting for semaphore
</span><span class="c1"></span><span class="p">}</span>
<span class="n">wait</span><span class="p">(</span><span class="n">semaphore</span> <span class="n">Sem</span><span class="p">)</span><span class="o">:</span>    <span class="c1">// Wait until &gt; 0 then decrement
</span><span class="c1"></span>  <span class="c1">// 这里用的是 while 而不是 if
</span><span class="c1"></span>  <span class="c1">// 这是因为在 wait 过程中，其他线程还可能继续调用 wait
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">Sem</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">add</span> <span class="k">this</span> <span class="kr">thread</span> <span class="n">to</span> <span class="n">Sem</span><span class="p">.</span><span class="n">waiting</span><span class="p">;</span>
    <span class="n">block</span><span class="p">(</span><span class="k">this</span> <span class="kr">thread</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">Sem</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">Sem</span><span class="p">.</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">return</span><span class="p">;</span>

<span class="n">signal</span><span class="p">(</span><span class="n">semaphore</span> <span class="n">Sem</span><span class="p">)</span><span class="o">:</span><span class="c1">// Increment value and wake up next thread
</span><span class="c1"></span>     <span class="n">Sem</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">Sem</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">Sem</span><span class="p">.</span><span class="n">waiting</span> <span class="n">is</span> <span class="n">nonempty</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">remove</span> <span class="n">a</span> <span class="kr">thread</span> <span class="n">T</span> <span class="n">from</span> <span class="n">Sem</span><span class="p">.</span><span class="n">waiting</span><span class="p">;</span>
         <span class="n">wakeup</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
     <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有两点注意事项：</p>
<ol>
<li>wait 中的「测试和减 1 操作」，signal 中的「加 1 操作」需要保证原子性。一般来说是使用硬件支持的 <a href="https://en.wikipedia.org/wiki/Read-modify-write">read-modify-write 原语</a>，比如 test-and-set/fetch-and-add/compare-and-swap，除了硬件支持外，还可以用 <a href="https://en.wikipedia.org/wiki/Mutual_exclusion#Software_solutions">busy wait</a> 的软件方式来模拟。</li>
<li>signal 中没有定义重新启动的线程顺序，也即多个线程在等待同一信号量时，无法预测重启哪一个线程</li>
</ol>
<h4 id="使用场景">使用场景</h4>
<p>信号量为控制并发程序的执行提供了强有力工具，这里列举两个场景：</p>
<h5 id="互斥">互斥</h5>
<p>信号量提供了了一种很方便的方法来保证对共享变量的互斥访问，基本思想是</p>
<blockquote>
<p>将每个共享变量（或一组相关的共享变量）与一个信号量 s （初始化为1）联系起来，然后用 wait/signal 操作将相应的临界区包围起来。</p>
</blockquote>
<p>二元信号量也被称为互斥锁（mutex，mutual exclusve, 也称为 binary semaphore），wait 操作相当于加锁，signal 相当于解锁。
一个被用作一组可用资源的计数器的信号量称为计数信号量（counting semaphore）</p>
<h5 id="调度共享资源">调度共享资源</h5>
<p>除了互斥外，信号量的另一个重要作用是调度对共享资源的访问，比较经典的案例是生产者消费者，伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">emptySem</span> <span class="o">=</span> <span class="n">N</span>
<span class="n">fullSem</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1">// Producer
</span><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="n">whatever</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">locally</span> <span class="n">generate</span> <span class="n">item</span>
    <span class="nf">wait</span><span class="p">(</span><span class="n">emptySem</span><span class="p">)</span>
    <span class="n">fill</span> <span class="n">empty</span> <span class="n">buffer</span> <span class="n">with</span> <span class="n">item</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">fullSem</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Consumer
</span><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="n">whatever</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">fullSem</span><span class="p">)</span>
    <span class="n">get</span> <span class="n">item</span> <span class="n">from</span> <span class="n">full</span> <span class="n">buffer</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">emptySem</span><span class="p">)</span>
    <span class="n">use</span> <span class="n">item</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="posix-实现">POSIX 实现</h4>
<p>POSIX 标准中有定义信号量相关的逻辑，在 <a href="http://pubs.opengroup.org/onlinepubs/007904875/basedefs/semaphore.h.html">semaphore.h</a> 中，为 sem_t 类型，相关 API：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Intialize: 
</span><span class="c1"></span><span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">theSem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">initialVal</span><span class="p">);</span>
<span class="c1">// Wait: 
</span><span class="c1"></span><span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">theSem</span><span class="p">);</span>
<span class="c1">// Signal: 
</span><span class="c1"></span><span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">theSem</span><span class="p">);</span>
<span class="c1">// Get the current value of the semaphore:       
</span><span class="c1"></span><span class="n">sem_getvalue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">theSem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>信号量主要有两个缺点：</p>
<ul>
<li>Lack of structure，在设计大型系统时，很难保证 wait/signal 能以正确的顺序成对出现，顺序与成对缺一不可，否则就会出现死锁！</li>
<li>Global visiblity，一旦程序出现死锁，整个程序都需要去检查</li>
</ul>
<p>解决上述两个缺点的新方案是<a href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29">监控器（monitor）</a>。</p>
<h3 id="monitors">Monitors</h3>
<p><a href="https://en.wikipedia.org/wiki/C._A._R._Hoare">C. A. R. Hoare</a>（也是 Quicksort 的作者） 在 1974 年的论文 <a href="https://dl.acm.org/citation.cfm?doid=355620.361161">Monitors: an operating system structuring concept</a> 首次提出了「监控器」概念，它提供了对信号量互斥和调度能力的更高级别的抽象，使用起来更加方便，一般形式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">monitor1 . . . monitorM
process1 . . . processN
</code></pre></td></tr></table>
</div>
</div><p>我们可以认为监控器是这么一个对象：</p>
<ul>
<li>所有访问同一监控器的线程通过条件变量（condition variables）间接通信</li>
<li>某一个时刻，只能有一个线程访问监控器</li>
</ul>
<h4 id="condition-variables">Condition variables</h4>
<p>上面提到监控器通过条件变量（简写 cv）来协调线程间的通信，那么条件变量是什么呢？它其实是一个 FIFO 的队列，用来保存那些因等待某些条件成立而被堵塞的线程，对于一个条件变量 c 来说，会关联一个断言（assertion） P。线程在等待 P 成立的过程中，该线程不会锁住该监控器，这样其他线程就能够进入监控器，修改监控器状态；在 P 成立时，其他线程会通知堵塞的线程，因此条件变量上主要有三个操作：</p>
<ol>
<li><code>wait(cv, m)</code> 等待 cv 成立，m 表示与监控器关联的一 mutex 锁</li>
<li><code>signal(cv)</code> 也称为 <code>notify(cv)</code> 用来通知 cv 成立，这时会唤醒等待的线程中的一个执行。根据唤醒策略，监控器分为两类：Hoare vs. Mesa，后面会介绍</li>
<li><code>broadcast(cv)</code> 也称为 <code>notifyAll(cv)</code> 唤醒所有等待 cv 成立的线程</li>
</ol>
<h5 id="posix-实现-1">POSIX 实现</h5>
<p>在 pthreads 中，条件变量的类型是 <code>pthread_cond_t</code>，主要有如下几个方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// initialize
</span><span class="c1"></span><span class="n">pthread_cond_init</span><span class="p">()</span> 
<span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">theCV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">someLock</span><span class="p">);</span>
<span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">theCV</span><span class="p">);</span>
<span class="n">pthread_cond_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">theCV</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="使用方式">使用方式</h4>
<p>在 pthreads 中，所有使用条件变量的地方都必须用一个 mutex 锁起来，这是为什么呢？看下面一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">pthread_mutex_t</span> <span class="n">myLock</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">myCV</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Thread A
</span><span class="c1"></span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myLock</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myCV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myLock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myLock</span><span class="p">);</span>

<span class="c1">// Thread B
</span><span class="c1"></span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myLock</span><span class="p">);</span>
<span class="n">count</span> <span class="o">++</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myCV</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myLock</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>如果没有锁，那么</p>
<ul>
<li>线程 A 可能会在其他线程将 count 赋值为10后继续等待</li>
<li>线程 B 无法保证加一操作与测试 count 是否为零 的原子性</li>
</ul>
<p>这里的关键点是，在进行条件变量的 wait 时，会释放该锁，以保证其他线程能够将之唤醒。不过需要注意的是，在线程 B 通知（signal） myCV 时，线程 A 无法立刻恢复执行，这是因为 myLock 这个锁还被线程 B 持有，只有在线程 B <code>unlock(&amp;myLock)</code> 后，线程 A 才可恢复。总结一下：</p>
<ol>
<li>wait 时会释放锁</li>
<li>signal 会唤醒等待同一 cv 的线程</li>
<li>被唤醒的线程需要重新获取锁，然后才能从 wait 中返回</li>
</ol>
<h4 id="hoare-vs-mesa-监控器语义">Hoare vs. Mesa 监控器语义</h4>
<p>在上面条件变量中，我们提到 signal 在调用时，会去唤醒等待同一 cv 的线程，根据唤醒策略的不同，监控器也分为两类：</p>
<ul>
<li>Hoare 监控器（1974），最早的监控器实现，在调用 signal 后，会立刻运行等待的线程，这时调用 signal 的线程会被堵塞（因为锁被等待线程占有了）</li>
<li>Mesa 监控器（Xerox PARC, 1980），signal 会把等待的线程重新放回到监控的 ready 队列中，同时调用 signal 的线程继续执行。这种方式是现如今 pthreads/Java/C# 采用的</li>
</ul>
<p>这两类监控器的关键区别在于等待线程被唤醒时，需要重新检查 P 是否成立。</p>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01opA7ut1z69s6EhwrR_!!581166664.png" alt="监控器工作示意图">
    <figcaption><center>监控器工作示意图</center></figcaption>
  </figure>

</p>
<p>上图表示蓝色的线程在调用监控器的 get 方式时，数据为空，因此开始等待 emptyFull 条件；紧接着，红色线程调用监控器的 set 方法改变 emptyFull 条件，这时</p>
<ul>
<li>按照 Hoare 思路，蓝色线程会立刻执行，并且红色线程堵塞</li>
<li>按照 Mesa 思路，红色线程会继续执行，蓝色线程会重新与绿色线程竞争与监控器关联的锁</li>
</ul>
<h4 id="java-中的监控器">Java 中的监控器</h4>
<p>在 Java 中，每个对象都是一个监控器（因此具备一个 lock 与 cv），调用对象 o 的 synchronized 方法 m 时，会首先去获取 o 的锁，除此之外，还可以调用 o 的 wait/notify/notify 方法进行并发控制</p>
<h3 id="big-picture">Big Picture</h3>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01RZViZw1z69s99tJfI_!!581166664.png" alt="操作系统并发相关 API 概括图">
    <figcaption><center>操作系统并发相关 API 概括图</center></figcaption>
  </figure>


来源：https://www.cs.princeton.edu/courses/archive/fall11/cos318/lectures/L8_SemaphoreMonitor_v2.pdf</p>
<h2 id="interruptible">Interruptible</h2>
<p>通过介绍操作系统支持的同步原语，我们知道了 park/unpark、wait/notify 其实就是利用信号量（ <code>pthread_mutex_t</code>）、条件变量（ <code>pthread_cond_t</code>）实现的，其实监控器也可以用信号量来实现。在查看 AQS 中，发现有这么一个属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="cm">/**
</span><span class="cm">     * The number of nanoseconds for which it is faster to spin
</span><span class="cm">     * rather than to use timed park. A rough estimate suffices
</span><span class="cm">     * to improve responsiveness with very short timeouts.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">spinForTimeoutThreshold</span> <span class="o">=</span> <span class="n">1000L</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是说，在小于 1000 纳秒时，await 条件变量 P 时，会使用一个循环来代替条件变量的堵塞与唤醒，这是由于堵塞与唤醒本身的操作开销可能就远大于 await 的 timeout。相关代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// AQS 的 doAcquireNanos 方法节选
</span><span class="c1"></span><span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC
</span><span class="c1"></span>        <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">nanosTimeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">nanosTimeout</span> <span class="o">&gt;</span> <span class="n">spinForTimeoutThreshold</span><span class="o">)</span>
        <span class="n">LockSupport</span><span class="o">.</span><span class="na">parkNanos</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nanosTimeout</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 JUC 提供的高级同步类中，acquire 对应 park，release 对应 unpark，interrupt 其实就是个布尔的 flag 位，在 unpark 被唤醒时，检查该 flag ，如果为 true，则会抛出我们熟悉的 InterruptedException。</p>
<p><code>Selector.select()</code> 响应中断异常的逻辑有些特别，因为对于这类堵塞 IO 操作来说，没有条件变量的堵塞唤醒机制，我们可以再看下 Thread.interrupt 的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">interrupt</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">!=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">())</span>
            <span class="n">checkAccess</span><span class="o">();</span>

        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">blockerLock</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Interruptible</span> <span class="n">b</span> <span class="o">=</span> <span class="n">blocker</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">interrupt0</span><span class="o">();</span>           <span class="c1">// Just to set the interrupt flag
</span><span class="c1"></span>                <span class="n">b</span><span class="o">.</span><span class="na">interrupt</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">interrupt0</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>OpenJDK 使用了这么一个技巧来实现堵塞 IO 的中断唤醒：在一个线程被堵塞时，会关联一个 Interruptible 对象。
对于 Selector 来说，在开始时，会关联这么一个<a href="http://hg.openjdk.java.net/jdk/jdk/file/cfceb4df2499/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java#l154">Interruptible 对象</a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">begin</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">interruptor</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">interruptor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Interruptible</span><span class="o">()</span> <span class="o">{</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">interrupt</span><span class="o">(</span><span class="n">Thread</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">closeLock</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">closed</span><span class="o">)</span>
                                <span class="k">return</span><span class="o">;</span>
                            <span class="n">closed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                            <span class="n">interrupted</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
                            <span class="k">try</span> <span class="o">{</span>
                                <span class="n">AbstractInterruptibleChannel</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">implCloseChannel</span><span class="o">();</span>
                            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}};</span>
        <span class="o">}</span>
        <span class="n">blockedOn</span><span class="o">(</span><span class="n">interruptor</span><span class="o">);</span>
        <span class="n">Thread</span> <span class="n">me</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">me</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">())</span>
            <span class="n">interruptor</span><span class="o">.</span><span class="na">interrupt</span><span class="o">(</span><span class="n">me</span><span class="o">);</span>
    <span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>当调用 interrupt 方式时，会关闭该 channel，这样就会关闭掉这个堵塞线程，可见为了实现这个功能，代价也是比较大的。LockSupport.park 中采用了类似技巧。</p>
<h2 id="总结">总结</h2>
<p>也许基于多线程的并发编程不是最好的（可能是最复杂的，Clojure 大法好 :-），但却是最悠久的。
即便我们自己不去写往往也需要阅读别人的多线程代码，而且能够写出“正确”（who knows?）的多线程程序往往也是区分 senior 与 junior 程序员的标志，希望这篇文章能帮助大家理解 Java 是如何实现线程控制，有疑问欢迎留言指出，谢谢！</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://carlmastrangelo.com/blog/javas-mysterious-interrupt">https://carlmastrangelo.com/blog/javas-mysterious-interrupt</a></li>
<li><a href="https://blog.csdn.net/hengyunabc/article/details/28126139">Java的LockSupport.park()实现分析</a></li>
<li>课件 <a href="http://www.cse.unsw.edu.au/~cs3151/17s2/lec/PDF/lecture06a.pdf">COMP3151/9151 Foundations of Concurrency Lecture 6 - Semaphores, Monitors, POSIX Threads, Java</a></li>
<li>课件 <a href="http://crystal.uta.edu/~ylei/cse6324/data/semaphore.pdf">http://crystal.uta.edu/~ylei/cse6324/data/semaphore.pdf</a></li>
<li>课件 <a href="https://cs61.seas.harvard.edu/wiki/images/1/12/Lec19-Semaphores.pdf">https://cs61.seas.harvard.edu/wiki/images/1/12/Lec19-Semaphores.pdf</a></li>
<li><a href="https://barrgroup.com/Embedded-Systems/How-To/RTOS-Mutex-Semaphore">Mutexes and Semaphores Demystified</a></li>
<li><a href="https://book.douban.com/subject/1888733/">https://book.douban.com/subject/1888733/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion">https://en.wikipedia.org/wiki/Mutual_exclusion</a></li>
<li><a href="https://stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore">https://stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore</a></li>
<li><a href="https://stackoverflow.com/questions/2332765/lock-mutex-semaphore-whats-the-difference">https://stackoverflow.com/questions/2332765/lock-mutex-semaphore-whats-the-difference</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">刘家财</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-12-04
        <a href="https://github.com/jiacai2050/jiacai2050.github.io/commit/8f8c30acc9eabc6498854bdbb13df6a4b744f17d" title="fix bad categories">(8f8c30a)</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java/">Java</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/blog/2019/01/09/java-gc-definitive-guide/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Java 垃圾回收权威指北</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/blog/2018/11/10/damn-single-socket/">
            <span class="next-text nav-default">形单影只的 Socket</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'jiacai2050';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jiacai2050&#43;blog@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/2163429/jiacai-liu" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.twitter.com/liujiacai" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/jiacai2050" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/liujiacai" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/jiacai2050" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/liujiacai/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://liujiacai.net/atom.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2014 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>刘家财</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-50745138-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>

<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>Java 线程同步原理探析 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java 线程同步原理探析</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java 线程同步原理探析</h1><div class="post-meta">Dec 29, 2018<span> | </span><span class="category"><a href="/categories/langs/">编程语言</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.1k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 17</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2018/12/29/how-java-synchronizer-work/" href="/blog/2018/12/29/how-java-synchronizer-work/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC"><span class="toc-number">1.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractQueuedSynchronizer"><span class="toc-number">1.1.</span> <span class="toc-text">AbstractQueuedSynchronizer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-如何实现堵塞、通知"><span class="toc-number">2.</span> <span class="toc-text">Java 如何实现堵塞、通知</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-notify"><span class="toc-number">2.1.</span> <span class="toc-text">wait/notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-unlock"><span class="toc-number">2.2.</span> <span class="toc-text">lock/unlock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OS-支持的同步原语"><span class="toc-number">3.</span> <span class="toc-text">OS 支持的同步原语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">3.1.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用场景"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#互斥"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#调度共享资源"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">调度共享资源</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#POSIX-实现"><span class="toc-number">3.1.2.</span> <span class="toc-text">POSIX 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitors"><span class="toc-number">3.2.</span> <span class="toc-text">Monitors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition-variables"><span class="toc-number">3.2.1.</span> <span class="toc-text">Condition variables</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#POSIX-实现-1"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">POSIX 实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用方式"><span class="toc-number">3.2.2.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hoare-vs-Mesa-监控器语义"><span class="toc-number">3.2.3.</span> <span class="toc-text">Hoare vs. Mesa 监控器语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-中的监控器"><span class="toc-number">3.2.4.</span> <span class="toc-text">Java 中的监控器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Big-Picture"><span class="toc-number">3.3.</span> <span class="toc-text">Big Picture</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interruptible"><span class="toc-number">4.</span> <span class="toc-text">Interruptible</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>现如今，服务器性能日益增长，并发（concurrency）编程已经“深入人心”，但由于冯诺依式计算机“指令存储，顺序执行”的特性，使得编写跨越时间维度的并发程序异常困难，所以现代编程语言都对并发编程提供了一定程度的支持，像 Golang 里面的 <a href="https://tour.golang.org/concurrency/1" target="_blank" rel="noopener">Goroutines</a>、Clojure 里面的 <a href="https://clojure.org/reference/refs" target="_blank" rel="noopener">STM（Software Transactional Memory）</a>、Erlang 里面的 <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank" rel="noopener">Actor</a>。</p>
<p>Java 对于并发编程的解决方案是多线程（Multi-threaded programming），而且 Java 中的线程 与 native 线程一一对应，多线程也是早期操作系统支持并发的方案之一（其他方案：多进程、IO多路复用）。</p>
<p>本文着重介绍 Java 中线程同步的原理、实现机制，更侧重操作系统层面，部分原理参考 <a href="http://hg.openjdk.java.net/jdk/jdk/file/cfceb4df2499" target="_blank" rel="noopener">openjdk 源码</a>。阅读本文需要对 CyclicBarrier、CountDownLatch 有基本的使用经验。</p>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>在 Java 1.5 版本中，引入 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html" target="_blank" rel="noopener">JUC</a> 并发编程辅助包，很大程度上降低了并发编程的门槛，JUC 里面主要包括：</p>
<ul>
<li>线程调度的 Executors</li>
<li>缓冲任务的 Queues</li>
<li>超时相关的 TimeUnit</li>
<li>并发集合（如 ConcurrentHashMap）</li>
<li>线程同步类（Synchronizers，如 CountDownLatch ）</li>
</ul>
<p>个人认为其中最重要也是最核心的是线程同步这一块，因为并发编程的难点就在于如何保证「共享区域（专业术语：临界区，Critical Section）的访问时序问题」。</p>
<h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><p>JUC 提供的同步类主要有如下几种：</p>
<ul>
<li><code>Semaphore</code> is a classic concurrency tool.</li>
<li><code>CountDownLatch</code> is a very simple yet very common utility for blocking until a given number of signals, events, or conditions hold.</li>
<li>A <code>CyclicBarrier</code> is a resettable multiway synchronization point useful in some styles of parallel programming.</li>
<li>A <code>Phaser</code> provides a more flexible form of barrier that may be used to control phased computation among multiple threads.</li>
<li>An <code>Exchanger</code> allows two threads to exchange objects at a rendezvous(约会) point, and is useful in several pipeline designs.</li>
</ul>
<p>通过阅读其源码可以发现，其实现都基于 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer</a> 这个抽象类（一般简写 AQS），正如其 javadoc 开头所说：</p>
<blockquote>
<p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state.</p>
</blockquote>
<p>也就是说，AQS 通过维护内部的 FIFO 队列和具备原子更新的整型 state 这两个属性来实现各种锁机制，包括：是否公平，是否可重入，是否共享，是否可中断（interrupt），并在这基础上，提供了更方便实用的同步类，也就是一开始提及的 Latch、Barrier 等。</p>
<p>这里暂时不去介绍 AQS 实现细节与如何基于 AQS 实现各种同步类（挖个坑），感兴趣的可以移步美团的一篇文章<a href="https://tech.meituan.com/Java_Lock.html" target="_blank" rel="noopener">《不可不说的Java“锁”事》</a> 第六部分“独享锁 VS 共享锁”。</p>
<p>在学习 Java 线程同步这一块时，对我来说困扰最大的是「线程唤醒」，试想一个已经 wait/sleep/block 的线程，是如何响应 interrupt 的呢？当调用 Object.wait() 或 lock.lock() 时，JVM 究竟做了什么事情能够在调用 Object.notify 或 lock.unlock 时重新激活相应线程？</p>
<p>带着上面的问题，我们从源码中寻找答案。</p>
<h2 id="Java-如何实现堵塞、通知"><a href="#Java-如何实现堵塞、通知" class="headerlink" title="Java 如何实现堵塞、通知"></a>Java 如何实现堵塞、通知</h2><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>在 JDK 源码中，上述两个方法均用 native 实现（即 cpp 代码），追踪相关代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.base/share/native/libjava/Object.c</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"hashCode"</span>,    <span class="string">"()I"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;<span class="string">"wait"</span>,        <span class="string">"(J)V"</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;<span class="string">"notify"</span>,      <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;<span class="string">"notifyAll"</span>,   <span class="string">"()V"</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;<span class="string">"clone"</span>,       <span class="string">"()Ljava/lang/Object;"</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上面的 cpp 代码，我们大概能猜出 JVM 是使用 monitor 来实现的 wait/notify 机制，至于这里的 monitor 是何种机制，这里暂时跳过，接着看 lock 相关实现</p>
<h3 id="lock-unlock"><a href="#lock-unlock" class="headerlink" title="lock/unlock"></a>lock/unlock</h3><p>LockSupport 是用来实现堵塞语义模型的基础辅助类，主要有两个方法：park 与 unpark。（在英文中，park 除了“公园”含义外，还有“停车”的意思）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LockSupport.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unblocks the given thread blocked on &#123;<span class="doctag">@code</span> park&#125;, or, if it is</span></span><br><span class="line"><span class="comment">     * not blocked, causes the subsequent call to &#123;<span class="doctag">@code</span> park&#125; not to</span></span><br><span class="line"><span class="comment">     * block.  Note: this operation is "unsafe" solely because the</span></span><br><span class="line"><span class="comment">     * caller must somehow ensure that the thread has not been</span></span><br><span class="line"><span class="comment">     * destroyed. Nothing special is usually required to ensure this</span></span><br><span class="line"><span class="comment">     * when called from Java (in which there will ordinarily be a live</span></span><br><span class="line"><span class="comment">     * reference to the thread) but this is not nearly-automatically</span></span><br><span class="line"><span class="comment">     * so when calling from native code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> thread the thread to unpark.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Blocks current thread, returning when a balancing</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> unpark&#125; occurs, or a balancing &#123;<span class="doctag">@code</span> unpark&#125; has</span></span><br><span class="line"><span class="comment">     * already occurred, or the thread is interrupted, or, if not</span></span><br><span class="line"><span class="comment">     * absolute and time is not zero, the given time nanoseconds have</span></span><br><span class="line"><span class="comment">     * elapsed, or if absolute, the given deadline in milliseconds</span></span><br><span class="line"><span class="comment">     * since Epoch has passed, or spuriously (i.e., returning for no</span></span><br><span class="line"><span class="comment">     * "reason"). Note: This operation is in the Unsafe class only</span></span><br><span class="line"><span class="comment">     * because &#123;<span class="doctag">@code</span> unpark&#125; is, so it would be strange to place it</span></span><br><span class="line"><span class="comment">     * elsewhere.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hotspot/share/prims/unsafe.cpp</span></span><br><span class="line">UNSAFE_ENTRY(<span class="keyword">void</span>, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time)) &#123;</span><br><span class="line">  HOTSPOT_THREAD_PARK_BEGIN((uintptr_t) thread-&gt;parker(), (<span class="keyword">int</span>) isAbsolute, time);</span><br><span class="line">  EventThreadPark event;</span><br><span class="line"></span><br><span class="line">  <span class="function">JavaThreadParkedState <span class="title">jtps</span><span class="params">(thread, time != <span class="number">0</span>)</span></span>;</span><br><span class="line">  thread-&gt;parker()-&gt;park(isAbsolute != <span class="number">0</span>, time);</span><br><span class="line">  <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">    post_thread_park_event(&amp;event, thread-&gt;current_park_blocker(), time);</span><br><span class="line">  &#125;</span><br><span class="line">  HOTSPOT_THREAD_PARK_END((uintptr_t) thread-&gt;parker());</span><br><span class="line">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>通过上述 unsafe.cpp 可以看到每个 thread 都会有一个 Parker 对象，所以我们需要查看 parker 对象的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotspot/share/runtime/park.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parker</span> :</span> <span class="keyword">public</span> os::PlatformParker</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// For simplicity of interface with Java, all forms of park (indefinite,</span></span><br><span class="line">  <span class="comment">// relative, and absolute) are multiplexed into one call.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">bool</span> isAbsolute, jlong time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hotspot/os/posix/os_posix.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformParker</span> :</span> <span class="keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    REL_INDEX = <span class="number">0</span>,</span><br><span class="line">    ABS_INDEX = <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">int</span> _cur_index;  <span class="comment">// which cond is in use: -1, 0, 1</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> _mutex[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">pthread_cond_t</span>  _cond[<span class="number">2</span>]; <span class="comment">// one for relative times and one for absolute</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到这里大概就能知道 park 是使用 <code>pthread_mutex_t</code> 与 <code>pthread_cond_t</code> 实现。好了，到目前为止，就引出了 Java 中与堵塞相关的实现，不难想象，都是依赖底层操作系统的功能。</p>
<h2 id="OS-支持的同步原语"><a href="#OS-支持的同步原语" class="headerlink" title="OS 支持的同步原语"></a>OS 支持的同步原语</h2><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>并发编程领域的先锋人物 <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" target="_blank" rel="noopener">Edsger Dijkstra</a>（也是最短路径算法的作者）在 1965 年首次提出了信号量（ Semaphores） 这一概念来解决线程同步的问题。信号量是一种特殊的变量类型，为非负整数，只有两个特殊操作PV：</p>
<ul>
<li>P(s) 如果 s!=0，将 s-1；否则将当前线程挂起，直到 s 变为非零</li>
<li>V(s) 将 s+1，如果有线程堵塞在 P 操作等待 s 变成非零，那么 V 操作会重启这些线程中的任意一个</li>
</ul>
<p>注：Dijkstra 为荷兰人，名字 P 和 V 来源于荷兰单词 Proberen（测试）和Verhogen（增加），为方便理解，后文会用 Wait 与 Signal 来表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     thread_list waiting;  <span class="comment">// List of threads waiting for semaphore</span></span><br><span class="line">&#125;</span><br><span class="line">wait(semaphore Sem):    <span class="comment">// Wait until &gt; 0 then decrement</span></span><br><span class="line">  <span class="comment">// 这里用的是 while 而不是 if</span></span><br><span class="line">  <span class="comment">// 这是因为在 wait 过程中，其他线程还可能继续调用 wait</span></span><br><span class="line">  <span class="keyword">while</span> (Sem.val &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    add <span class="keyword">this</span> thread to Sem.waiting;</span><br><span class="line">    block(<span class="keyword">this</span> thread);</span><br><span class="line">  &#125;</span><br><span class="line">  Sem.val = Sem.val - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">signal(semaphore Sem):<span class="comment">// Increment value and wake up next thread</span></span><br><span class="line">     Sem.val = Sem.val + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (Sem.waiting is nonempty) &#123;</span><br><span class="line">         remove a thread T from Sem.waiting;</span><br><span class="line">         wakeup(T);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>有两点注意事项：</p>
<ol>
<li>wait 中的「测试和减 1 操作」，signal 中的「加 1 操作」需要保证原子性。一般来说是使用硬件支持的 <a href="https://en.wikipedia.org/wiki/Read-modify-write" target="_blank" rel="noopener">read-modify-write 原语</a>，比如 test-and-set/fetch-and-add/compare-and-swap，除了硬件支持外，还可以用 <a href="https://en.wikipedia.org/wiki/Mutual_exclusion#Software_solutions" target="_blank" rel="noopener">busy wait</a> 的软件方式来模拟。</li>
<li>signal 中没有定义重新启动的线程顺序，也即多个线程在等待同一信号量时，无法预测重启哪一个线程</li>
</ol>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>信号量为控制并发程序的执行提供了强有力工具，这里列举两个场景：</p>
<h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>信号量提供了了一种很方便的方法来保证对共享变量的互斥访问，基本思想是</p>
<blockquote>
<p>将每个共享变量（或一组相关的共享变量）与一个信号量 s （初始化为1）联系起来，然后用 wait/signal 操作将相应的临界区包围起来。</p>
</blockquote>
<p>二元信号量也被称为互斥锁（mutex，mutual exclusve, 也称为 binary semaphore），wait 操作相当于加锁，signal 相当于解锁。<br>一个被用作一组可用资源的计数器的信号量称为计数信号量（counting semaphore）</p>
<h5 id="调度共享资源"><a href="#调度共享资源" class="headerlink" title="调度共享资源"></a>调度共享资源</h5><p>除了互斥外，信号量的另一个重要作用是调度对共享资源的访问，比较经典的案例是生产者消费者，伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">emptySem = N</span><br><span class="line">fullSem = <span class="number">0</span></span><br><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">while</span>(whatever) &#123;</span><br><span class="line">    locally generate item</span><br><span class="line">    wait(emptySem)</span><br><span class="line">    fill empty buffer with item</span><br><span class="line">    signal(fullSem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="keyword">while</span>(whatever) &#123;</span><br><span class="line">    wait(fullSem)</span><br><span class="line">    get item from full buffer</span><br><span class="line">    signal(emptySem)</span><br><span class="line">    use item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POSIX-实现"><a href="#POSIX-实现" class="headerlink" title="POSIX 实现"></a>POSIX 实现</h4><p>POSIX 标准中有定义信号量相关的逻辑，在 <a href="http://pubs.opengroup.org/onlinepubs/007904875/basedefs/semaphore.h.html" target="_blank" rel="noopener">semaphore.h</a> 中，为 sem_t 类型，相关 API：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intialize: </span></span><br><span class="line">sem_init(&amp;theSem, <span class="number">0</span>, initialVal);</span><br><span class="line"><span class="comment">// Wait: </span></span><br><span class="line">sem_wait(&amp;theSem);</span><br><span class="line"><span class="comment">// Signal: </span></span><br><span class="line">sem_post(&amp;theSem);</span><br><span class="line"><span class="comment">// Get the current value of the semaphore:       </span></span><br><span class="line">sem_getvalue(&amp;theSem, &amp;result);</span><br></pre></td></tr></table></figure>
<p>信号量主要有两个缺点：</p>
<ul>
<li>Lack of structure，在设计大型系统时，很难保证 wait/signal 能以正确的顺序成对出现，顺序与成对缺一不可，否则就会出现死锁！</li>
<li>Global visiblity，一旦程序出现死锁，整个程序都需要去检查</li>
</ul>
<p>解决上述两个缺点的新方案是<a href="https://en.wikipedia.org/wiki/Monitor_%28synchronization%29" target="_blank" rel="noopener">监控器（monitor）</a>。</p>
<h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><p><a href="https://en.wikipedia.org/wiki/C._A._R._Hoare" target="_blank" rel="noopener">C. A. R. Hoare</a>（也是 Quicksort 的作者） 在 1974 年的论文 <a href="https://dl.acm.org/citation.cfm?doid=355620.361161" target="_blank" rel="noopener">Monitors: an operating system structuring concept</a> 首次提出了「监控器」概念，它提供了对信号量互斥和调度能力的更高级别的抽象，使用起来更加方便，一般形式如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">monitor1</span> . . . monitorM</span><br><span class="line">process1 . . . processN</span><br></pre></td></tr></table></figure></p>
<p>我们可以认为监控器是这么一个对象：</p>
<ul>
<li>所有访问同一监控器的线程通过条件变量（condition variables）间接通信</li>
<li>某一个时刻，只能有一个线程访问监控器</li>
</ul>
<h4 id="Condition-variables"><a href="#Condition-variables" class="headerlink" title="Condition variables"></a>Condition variables</h4><p>上面提到监控器通过条件变量（简写 cv）来协调线程间的通信，那么条件变量是什么呢？它其实是一个 FIFO 的队列，用来保存那些因等待某些条件成立而被堵塞的线程，对于一个条件变量 c 来说，会关联一个断言（assertion） P。线程在等待 P 成立的过程中，该线程不会锁住该监控器，这样其他线程就能够进入监控器，修改监控器状态；在 P 成立时，其他线程会通知堵塞的线程，因此条件变量上主要有三个操作：</p>
<ol>
<li><code>wait(cv, m)</code> 等待 cv 成立，m 表示与监控器关联的一 mutex 锁</li>
<li><code>signal(cv)</code> 也称为 <code>notify(cv)</code> 用来通知 cv 成立，这时会唤醒等待的线程中的一个执行。根据唤醒策略，监控器分为两类：Hoare vs. Mesa，后面会介绍</li>
<li><code>broadcast(cv)</code> 也称为 <code>notifyAll(cv)</code> 唤醒所有等待 cv 成立的线程</li>
</ol>
<h5 id="POSIX-实现-1"><a href="#POSIX-实现-1" class="headerlink" title="POSIX 实现"></a>POSIX 实现</h5><p>在 pthreads 中，条件变量的类型是 <code>pthread_cond_t</code>，主要有如下几个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize</span></span><br><span class="line">pthread_cond_init() </span><br><span class="line">pthread_cond_wait(&amp;theCV, &amp;someLock);</span><br><span class="line">pthread_cond_signal(&amp;theCV);</span><br><span class="line">pthread_cond_broadcast(&amp;theCV);</span><br></pre></td></tr></table></figure>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>在 pthreads 中，所有使用条件变量的地方都必须用一个 mutex 锁起来，这是为什么呢？看下面一个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> myLock;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> myCV;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread A</span></span><br><span class="line">pthread_mutex_lock(&amp;myLock);</span><br><span class="line"><span class="keyword">while</span>(count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;myCV, &amp;myLock);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;myLock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread B</span></span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;myLock);</span><br><span class="line">count ++;</span><br><span class="line"><span class="keyword">while</span>(count == <span class="number">10</span>) &#123;</span><br><span class="line">    pthread_cond_signal(&amp;myCV);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;myLock);</span><br></pre></td></tr></table></figure></p>
<p>如果没有锁，那么</p>
<ul>
<li>线程 A 可能会在其他线程将 count 赋值为10后继续等待</li>
<li>线程 B 无法保证加一操作与测试 count 是否为零 的原子性</li>
</ul>
<p>这里的关键点是，在进行条件变量的 wait 时，会释放该锁，以保证其他线程能够将之唤醒。不过需要注意的是，在线程 B 通知（signal） myCV 时，线程 A 无法立刻恢复执行，这是因为 myLock 这个锁还被线程 B 持有，只有在线程 B <code>unlock(&amp;myLock)</code> 后，线程 A 才可恢复。总结一下：</p>
<ol>
<li>wait 时会释放锁</li>
<li>signal 会唤醒等待同一 cv 的线程</li>
<li>被唤醒的线程需要重新获取锁，然后才能从 wait 中返回</li>
</ol>
<h4 id="Hoare-vs-Mesa-监控器语义"><a href="#Hoare-vs-Mesa-监控器语义" class="headerlink" title="Hoare vs. Mesa 监控器语义"></a>Hoare vs. Mesa 监控器语义</h4><p>在上面条件变量中，我们提到 signal 在调用时，会去唤醒等待同一 cv 的线程，根据唤醒策略的不同，监控器也分为两类：</p>
<ul>
<li>Hoare 监控器（1974），最早的监控器实现，在调用 signal 后，会立刻运行等待的线程，这时调用 signal 的线程会被堵塞（因为锁被等待线程占有了）</li>
<li>Mesa 监控器（Xerox PARC, 1980），signal 会把等待的线程重新放回到监控的 ready 队列中，同时调用 signal 的线程继续执行。这种方式是现如今 pthreads/Java/C# 采用的</li>
</ul>
<p>这两类监控器的关键区别在于等待线程被唤醒时，需要重新检查 P 是否成立。</p>
<p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01opA7ut1z69s6EhwrR_!!581166664.png" alt="监控器工作示意图"></p>
<p>上图表示蓝色的线程在调用监控器的 get 方式时，数据为空，因此开始等待 emptyFull 条件；紧接着，红色线程调用监控器的 set 方法改变 emptyFull 条件，这时</p>
<ul>
<li>按照 Hoare 思路，蓝色线程会立刻执行，并且红色线程堵塞</li>
<li>按照 Mesa 思路，红色线程会继续执行，蓝色线程会重新与绿色线程竞争与监控器关联的锁</li>
</ul>
<h4 id="Java-中的监控器"><a href="#Java-中的监控器" class="headerlink" title="Java 中的监控器"></a>Java 中的监控器</h4><p>在 Java 中，每个对象都是一个监控器（因此具备一个 lock 与 cv），调用对象 o 的 synchronized 方法 m 时，会首先去获取 o 的锁，除此之外，还可以调用 o 的 wait/notify/notify 方法进行并发控制</p>
<h3 id="Big-Picture"><a href="#Big-Picture" class="headerlink" title="Big Picture"></a>Big Picture</h3><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01RZViZw1z69s99tJfI_!!581166664.png" alt="操作系统并发相关 API 概括图"><br>来源：<a href="https://www.cs.princeton.edu/courses/archive/fall11/cos318/lectures/L8_SemaphoreMonitor_v2.pdf" target="_blank" rel="noopener">https://www.cs.princeton.edu/courses/archive/fall11/cos318/lectures/L8_SemaphoreMonitor_v2.pdf</a></p>
<h2 id="Interruptible"><a href="#Interruptible" class="headerlink" title="Interruptible"></a>Interruptible</h2><p>通过介绍操作系统支持的同步原语，我们知道了 park/unpark、wait/notify 其实就是利用信号量（ <code>pthread_mutex_t</code>）、条件变量（ <code>pthread_cond_t</code>）实现的，其实监控器也可以用信号量来实现。在查看 AQS 中，发现有这么一个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of nanoseconds for which it is faster to spin</span></span><br><span class="line"><span class="comment"> * rather than to use timed park. A rough estimate suffices</span></span><br><span class="line"><span class="comment"> * to improve responsiveness with very short timeouts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，在小于 1000 纳秒时，await 条件变量 P 时，会使用一个循环来代替条件变量的堵塞与唤醒，这是由于堵塞与唤醒本身的操作开销可能就远大于 await 的 timeout。相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS 的 doAcquireNanos 方法节选</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">    <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">        nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">        LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JUC 提供的高级同步类中，acquire 对应 park，release 对应 unpark，interrupt 其实就是个布尔的 flag 位，在 unpark 被唤醒时，检查该 flag ，如果为 true，则会抛出我们熟悉的 InterruptedException。</p>
<p><code>Selector.select()</code> 响应中断异常的逻辑有些特别，因为对于这类堵塞 IO 操作来说，没有条件变量的堵塞唤醒机制，我们可以再看下 Thread.interrupt 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OpenJDK 使用了这么一个技巧来实现堵塞 IO 的中断唤醒：在一个线程被堵塞时，会关联一个 Interruptible 对象。<br>对于 Selector 来说，在开始时，会关联这么一个<a href="http://hg.openjdk.java.net/jdk/jdk/file/cfceb4df2499/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java#l154" target="_blank" rel="noopener">Interruptible 对象</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        interruptor = <span class="keyword">new</span> Interruptible() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">(Thread target)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (closed)</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        closed = <span class="keyword">true</span>;</span><br><span class="line">                        interrupted = target;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            AbstractInterruptibleChannel.<span class="keyword">this</span>.implCloseChannel();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException x) &#123; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    blockedOn(interruptor);</span><br><span class="line">    Thread me = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (me.isInterrupted())</span><br><span class="line">        interruptor.interrupt(me);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 interrupt 方式时，会关闭该 channel，这样就会关闭掉这个堵塞线程，可见为了实现这个功能，代价也是比较大的。LockSupport.park 中采用了类似技巧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也许基于多线程的并发编程不是最好的（可能是最复杂的，Clojure 大法好 :-），但却是最悠久的。<br>即便我们自己不去写往往也需要阅读别人的多线程代码，而且能够写出“正确”（who knows?）的多线程程序往往也是区分 senior 与 junior 程序员的标志，希望这篇文章能帮助大家理解 Java 是如何实现线程控制，有疑问欢迎留言指出，谢谢！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://carlmastrangelo.com/blog/javas-mysterious-interrupt" target="_blank" rel="noopener">https://carlmastrangelo.com/blog/javas-mysterious-interrupt</a></li>
<li><a href="https://blog.csdn.net/hengyunabc/article/details/28126139" target="_blank" rel="noopener">Java的LockSupport.park()实现分析</a></li>
<li>课件 <a href="http://www.cse.unsw.edu.au/~cs3151/17s2/lec/PDF/lecture06a.pdf" target="_blank" rel="noopener">COMP3151/9151 Foundations of Concurrency Lecture 6 - Semaphores, Monitors, POSIX Threads, Java</a></li>
<li>课件 <a href="http://crystal.uta.edu/~ylei/cse6324/data/semaphore.pdf" target="_blank" rel="noopener">http://crystal.uta.edu/~ylei/cse6324/data/semaphore.pdf</a></li>
<li>课件 <a href="https://cs61.seas.harvard.edu/wiki/images/1/12/Lec19-Semaphores.pdf" target="_blank" rel="noopener">https://cs61.seas.harvard.edu/wiki/images/1/12/Lec19-Semaphores.pdf</a></li>
<li><a href="https://barrgroup.com/Embedded-Systems/How-To/RTOS-Mutex-Semaphore" target="_blank" rel="noopener">Mutexes and Semaphores Demystified</a></li>
<li><a href="https://book.douban.com/subject/1888733/" target="_blank" rel="noopener">https://book.douban.com/subject/1888733/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mutual_exclusion</a></li>
<li><a href="https://stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore" target="_blank" rel="noopener">https://stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore</a></li>
<li><a href="https://stackoverflow.com/questions/2332765/lock-mutex-semaphore-whats-the-difference" target="_blank" rel="noopener">https://stackoverflow.com/questions/2332765/lock-mutex-semaphore-whats-the-difference</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2018/12/29/how-java-synchronizer-work/" data-id="ckhxlinxc005bszljewi4oam0" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsUlEQVR42u3aQW7DQAgF0Nz/0um2Ulr7A0PkxfMqSizPPC8GArxe8fX+dSW/ft75/riq3/+3+oELDw8Pb7D13mLX7PwVXN+Z7OePZ+Lh4eGt8ZLN5Yslr68Kq75QPDw8vKfxrlPnan57Nqjg4eHhPZOXlAaqLygn4eHh4T2BVy03JIv1yrjVUHGs1oKHh4cX8/Iu0nM+r/T38PDw8MZd9bPtrjyJzwvBN7vFw8PDW+D1EuLrjVYbYPnR39wnHh4e3hd5eUjoNa56Zdny0/Dw8PCO8vICaLJMXixIBlJ7tYWocoyHh4c34OWp8OSlzMPJZLd4eHh427zmYFMrBT8Vll6TWISHh4dX5FUT5XwTyXOqBd/rJ//b38PDw8Nb4M2Hn6obqra+mq8eDw8Pb4GXHNzJr73jPh/wSl7fzdAVHh4e3iFe9WiuHuK94YPJAMGrfBMeHh5en1f+q98q/k7CTDUU4eHh4W3wesXTakjIy7u9UFQYGsDDw8Mb8/JjN9lifk/1zmqBAw8PD2+bd7ZwkCe7SWDoNdX+GB3Aw8PDO8Q7lSJfH9x5itwrRkxK0nh4eHhVXr58L/nOj/h5++2mGIGHh4e3zDvbuPrOoAAeHh7e93nVh1bbV8fKB/l/BTw8PLwF3qTwmqfRvTJEnspHaT0eHh7eUV7eiKoe+tWWVV7OKNSk8fDw8JZ5+WKTgkV1mKA6gIWHh4f3Hd68AdYbC+gFpEKRFw8PD+8o7128ToEno1qFAQU8PDy8BV614dRbuDdw0As/zQsPDw+vyEuCQTXxzdtmeUm3WZLAw8PDW+Odaln1CsGLAQwPDw/vMbzJkEFeqkjS9Jvv8fDw8B7Am4eNKmY04oCHh4e3xpsUAvKjPx8XyI/+0UwZHh4eXouX/8nfaGj1wsBKDQMPDw/v/voBquhek1D6ddAAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/java/">Java</a></div><div class="post-nav"><a class="pre" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a><a class="next" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2018/12/29/how-java-synchronizer-work/';
    this.page.identifier = 'blog/2018/12/29/how-java-synchronizer-work/';
    this.page.title = 'Java 线程同步原理探析';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率工具/">效率工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">26</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/Emacs/" style="font-size: 15px;">Emacs</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/11/25/why-emacs/">Emacs 入门指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/08/08/go-meet-java/">实践总结：在 Java 中调用 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/14/go-struct-interface/">Go struct/interface 最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/02/review-2019/">2019 年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
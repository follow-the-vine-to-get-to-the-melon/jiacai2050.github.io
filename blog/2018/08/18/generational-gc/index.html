<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>深入浅出垃圾回收（四）分代式 GC | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深入浅出垃圾回收（四）分代式 GC</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深入浅出垃圾回收（四）分代式 GC</h1><div class="post-meta">Aug 18, 2018<span> | </span><span class="category"><a href="/categories/aha-computer/">理解计算机</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2018/08/18/generational-gc/" href="/blog/2018/08/18/generational-gc/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#分代的必要性"><span class="toc-number">1.</span> <span class="toc-text">分代的必要性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分代的问题"><span class="toc-number">2.</span> <span class="toc-text">分代的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#提升策略"><span class="toc-number">2.1.</span> <span class="toc-text">提升策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆组织"><span class="toc-number">2.2.</span> <span class="toc-text">堆组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Subareas-in-Copying"><span class="toc-number">2.2.1.</span> <span class="toc-text">Subareas in Copying</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ungar’s-Generation-Scavenging"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">Ungar’s Generation Scavenging</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generations-in-Non-copying"><span class="toc-number">2.2.2.</span> <span class="toc-text">Generations in Non-copying</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他讨论"><span class="toc-number">2.2.3.</span> <span class="toc-text">其他讨论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交叉引用"><span class="toc-number">2.3.</span> <span class="toc-text">交叉引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Indirect-tables"><span class="toc-number">2.3.1.</span> <span class="toc-text">Indirect tables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ungar’s-Remembered-Sets"><span class="toc-number">2.3.2.</span> <span class="toc-text">Ungar’s Remembered Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Page-Marking"><span class="toc-number">2.3.3.</span> <span class="toc-text">Page Marking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Word-Marking"><span class="toc-number">2.3.4.</span> <span class="toc-text">Word Marking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Card-Marking"><span class="toc-number">2.3.5.</span> <span class="toc-text">Card Marking</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p><a href="/blog/2018/08/04/incremental-gc">上文</a>介绍的增量式 GC 是对 mark 阶段的一大优化，可以极大避免 STW 的影响。本文将要介绍的分代式 GC 根据对象生命周期（后面称为 age）的特点来优化 GC，降低其性能消耗。</p>
<p>阅读本文需要熟悉<a href="/blog/2018/07/08/mark-sweep/#术语">之前提及的术语</a>。</p>
<h1 id="分代的必要性"><a href="#分代的必要性" class="headerlink" title="分代的必要性"></a>分代的必要性</h1><p>虽然对象的生命周期因应用而异，但对于大多数应用来说，80% 的对象在创建不久即会成为垃圾<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>。因此，针对不同 age 的对象「划分不同区域，采用不同的回收策略」也就不难理解了。</p>
<p>对于 Copying GC 来说，需要在两个 semispace 间移动对象，如果移动对象较大，就会对程序造成较大影响，而分代就能解决这个问题。简单情况下可以分为两个代：younger、older。</p>
<blockquote>
<p>younger 用于分配新对象，在这里的对象经过几轮 GC 后会移动到 older。younger 与 older 相比空间要小，且 GC 发生更频繁。</p>
</blockquote>
<p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2xIAtpY3nBKNjSZFMXXaUSFXa_!!581166664.jpg" alt="分代式 GC 示意图"><br>即便采用的是 non-copying GC，也可以通过分代，减少 GC 作用范围，缩小耗时。</p>
<h1 id="分代的问题"><a href="#分代的问题" class="headerlink" title="分代的问题"></a>分代的问题</h1><p>天下没有免费的午餐，GC 采用分代算法，一个首要的问题是「如何在不回收 older 的同时安全的回收 younger 里面的对象」。由于引用关系图是全局的属性，older 里面的对象也必须考虑的。比如 younger 里面的一对象只被 older 里面的对象引用了，如何保证 GC 不会错误的回收这个对象呢？<br>避免上述问题的一个方法是采用写屏障（write barrier），在 mutator 进行指针存储时，进行一些额外的操作（bookkeeping）。写屏障的主要目的是保证所有由 <code>older--&gt;younger</code> 的指针在进行 younger 内的 GC 时被考虑在内，并且作为 root set 进行 copy 遍历。需要注意的是，这里的写屏障与增量式 GC 同样具有一定的保守性。这是由于所有由 <code>older--&gt;younger</code> 的指针都会被当作 root set，但在 older 内对象的 liveness 在进行下一次 older GC 前是不可知的，这也就造成了一些 floating garbage，不过这在实现中问题不是很大。</p>
<p>为了独立回收 older，通过记录所有由 <code>younger--&gt;older</code> 的指针也是可行的，不过这会比较消耗性能。这是因为：</p>
<blockquote>
<p>在大多数情况下，由 <code>younger--&gt;older</code> 的指针数目要远大于 <code>older--&gt;younger</code> 的，这是符合程序运行规律的——创建一个新对象，将至指向一个老对象。</p>
</blockquote>
<p>即便不记录 <code>younger--&gt;older</code> 的指针，也可以在不回收 younger 的前提下回收 older，只不过这时会把 younger 里面的所有对象作为 root set。尽管这样遍历的时间会与 younger 里面的对象数目成正比，但考虑到 younger 内对象数量一般都要小于 older 的，而且遍历操作的消耗要远小于 copying，所以这也是一种可以接受的方式。</p>
<p>除了上面交叉引用的问题，对于一个分代的 GC 来说，还需要考虑下面几个方面：</p>
<ol>
<li>提升策略（advancement policy）。在一个代内的对象经过多少次 GC 会晋级到下一个代</li>
<li>堆组织（heap organization）。在代与代之间或者一个代内，heap 空间如何组织可以保证高的 locality 与 缓存命中率</li>
<li>代之间的交叉引用（intergenerational references）。采用哪种方式来记录这些指针最好？dirty bit or indirect table</li>
</ol>
<p>下面就针对这三点分别进行阐述。</p>
<h2 id="提升策略"><a href="#提升策略" class="headerlink" title="提升策略"></a>提升策略</h2><p>最简单的提升策略是在每次 GC 遍历时，把 live 的对象移动到下一代去。这样的优势有：</p>
<ol>
<li>实现简单，不需要去区分一个代内不同对象的 age。对于 copying GC 来说，只需要用一块连续的区域表示即可，不需要 semispace，也不需要额外的 header 来保存 age 信息</li>
<li>可以尽快的把大对象提升的 GC 频率小的下一代中去</li>
</ol>
<p>当然，这样做的问题也比较明显，可能会把一些 age 较小的对象移动到下一代中去，导致下一代被更快的填满，所以一般会让 younger 里面的对象停留一次，即第二次 GC 时才去提升，当然这时就需要记录对象的 age 了。</p>
<p>至于是不是需要停留两次，这个就不好说了，这个和应用也比较相关。一般来说，如果代分的少，比如2个，那么会倾向多停留几次，减慢 older 被填满的速度；如果代的数目大于2，那么就倾向于快速提升，因为这些对象很有可能在中间的某个代就会死亡，不会到达最终的 older。</p>
<h2 id="堆组织"><a href="#堆组织" class="headerlink" title="堆组织"></a>堆组织</h2><p>分代式 GC 需要对不同 age 的对象采取不同的处理方式，所以在 GC 遍历时，必须能够判断当前对象属于哪个代，写屏障也需要这个信息来识别 <code>older--&gt;younger</code> 指针。</p>
<ul>
<li>对于 copying GC 来说，一般是把不同 age 的对象放在不同的连续区域内，这样一个对象的代就能够从内存地址推断出来了。也有一些系统不采用连续地址，而是采用由 <code>page number of object--&gt;generation</code> 的表来辅助判断。</li>
<li>对于 non-copying GC，一般是存放在 header 内</li>
</ul>
<h3 id="Subareas-in-Copying"><a href="#Subareas-in-Copying" class="headerlink" title="Subareas in Copying"></a>Subareas in Copying</h3><p>分代式 copying GC 一般会把 generation 分为几个子区域，比如 semispace，通过来回的移动对象让它们一直处于当前代中。如果一个代内只有一个区域，那么每次 GC 时都需要把对象提升到下一代（没有可移动的地方）。<br>但是 semispace 的 locality 比较差，一个代的内存只有一半可以使用，且来回需要移动。</p>
<h4 id="Ungar’s-Generation-Scavenging"><a href="#Ungar’s-Generation-Scavenging" class="headerlink" title="Ungar’s Generation Scavenging"></a>Ungar’s Generation Scavenging</h4><p><a href="https://en.wikipedia.org/wiki/David_Ungar" target="_blank" rel="noopener">Ungar</a> 在其论文<a href="https://people.cs.umass.edu/~emery/classes/cmpsci691s-fall2004/papers/p157-ungar.pdf" target="_blank" rel="noopener">《Generation Scavenging》</a> 中提出一个解决方法：</p>
<blockquote>
<p>一个代内除了两个 semispace 外，还有第三个区域，这里称为Third。在 Third 内分配新对象，在 GC 时，Third 内 live 对象与 semispace 中的一个对象会复制到 semispace 中的另一个去，GC 结束时 Third 会被清空，用于再次分配对象。这样就能够与只有一个区域的代类似的 locality 了。</p>
</blockquote>
<p>乍一看，增加的 Third 区域会增加内存使用，但实际情况要好很多。Third 区域会被充分利用，semispace 用来保存每次 GC 后的存活对象（survivors）。一般来说，新创建的对象只有少部分能“活过”一次 GC，所以每个 semispace 中只有一小部分会使用，因此总的来说内存使用较小。</p>
<p>最后一个代（oldest generation，后面称为 oldest）在一些系统中有特殊处理。比如，在 Lisp Machine 中，每次 GC 后，大多数代都会被清空，并将其内对象拷贝到下一代去，但是 oldest 后面没有可用代了，因此 oldest 内会被分为 semispace。另一个优化是分配一个特殊的区域，称为 static space，用来分配 system data &amp; compiled code 等这些基本不会变的数据，这个区域基本不会有 GC。</p>
<p>在一些基于 Ungar 的 Generation Scavenging 的系统中，把 oldest 分为一个区域，在这个区域使用 mark-compact 算法。使用一个区域可以提高内存利用率，MC 虽然比 copying 算法成本更高，但对于 oldest 来说减少<a href="https://en.wikipedia.org/wiki/Page_fault" target="_blank" rel="noopener">换页（page fault）</a>也是有价值的。（copying GC 由于 semispace 的原因，所以内存使用率只有一半，所以更容易导致发生换页的问题<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>）。关于<a href="https://en.wikipedia.org/wiki/Paging" target="_blank" rel="noopener">虚拟内存的分页</a>对 GC 影响的研究不是很多，感兴趣可以参考下面的链接：</p>
<ul>
<li><a href="https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/virtual-memory-paging-and-swapping/" target="_blank" rel="noopener">Virtual Memory, Paging, and Swapping</a></li>
<li><a href="https://cs.stackexchange.com/questions/22649/are-there-any-garbage-collectors-that-take-into-account-paging" target="_blank" rel="noopener">Are there any garbage collectors that take into account paging?</a></li>
<li><a href="https://stackoverflow.com/questions/21810059/relation-between-garbage-collection-and-swapping-paging" target="_blank" rel="noopener">Relation between garbage collection and swapping,paging</a></li>
</ul>
<h3 id="Generations-in-Non-copying"><a href="#Generations-in-Non-copying" class="headerlink" title="Generations in Non-copying"></a>Generations in Non-copying</h3><p>上面的讨论主要围绕 copying GC 来说，其实那些技巧也可以用在 non-copying GC 之上，只不过它们更容易发生碎片问题。在增量式 GC 那里使用<a href="/blog/2018/08/04/incremental-gc/#三色标记">三色标记</a>来抽象，分代算法可以用不同 age 的对象集合来抽象。在 GC 遍历时，通过检查 header 里面的 age 来决定是否需要提升。</p>
<h3 id="其他讨论"><a href="#其他讨论" class="headerlink" title="其他讨论"></a>其他讨论</h3><ul>
<li>对于 copying GC 来说，大对象会被特殊的分配在一特殊区域「large object area」来避免拷贝。</li>
<li>对于明确指定不含有指针的对象，最好也能与其他对象分开，来降低检查交叉引用的成本。</li>
<li>一般情况下，对 younger 代采用 stop-and-copy 方式的 GC；对 older 采用 incremental-and-sweep GC</li>
</ul>
<h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>上面已经介绍的，<code>older--&gt;younger</code> 的交叉引用是由写屏障来保障的。对于某些系统（如 Lisp，指针存储指令占全部指令的1%<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>），这个写屏障的成本对分代式 GC 来说非常严重，因此写屏障的策略就十分重要了。下面介绍几种常见的策略</p>
<h3 id="Indirect-tables"><a href="#Indirect-tables" class="headerlink" title="Indirect tables"></a>Indirect tables</h3><p>重定向表（indirect tables）的思路是这样的：</p>
<p>所有 <code>older--&gt;younger</code> 的指针经由一个称为「<a href="http://www.memorymanagement.org/glossary/e.html" target="_blank" rel="noopener">entry table</a>」的表进行中转，每个代都有其对应的 entry table 来记录后一个代指向当前代的指针。这样在回收一个代时，只需要把 entry table 里面的引用考虑在内就可以了。<br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB208pDqcUrBKNjSZPxXXX00pXa_!!581166664.png" alt="indirect table 示意图"></p>
<p>但这种重定向表在普通机器（stock hardware）上不够快或高效，因此最近的分代式 GC 都避免使用这种方式，而是采用记录的方式（pointer recording schemes）来保存这些交叉引用。</p>
<h3 id="Ungar’s-Remembered-Sets"><a href="#Ungar’s-Remembered-Sets" class="headerlink" title="Ungar’s Remembered Sets"></a>Ungar’s Remembered Sets</h3><p>Ungar 的 generation scavenging 采用一个称为 Remembered Sets（后面简写 RS） 的结构来记录交叉引用。在每一次指针存储时，写屏障通过检查</p>
<ol>
<li>将要保存的对象是否为指针</li>
<li>指针是否指向 younger</li>
<li>是否被保存到 older 内</li>
</ol>
<p>这三个条件，判断是否会创建交叉引用，如果上述三个条件都满足，就会把 older 的对象添加到 RS 中。每个对象的 header 都有一位表示其是否存在于 RS 中，所以可以保证 RS 的内元素的唯一性，这样可以缩短扫描 RS 的时间。</p>
<p>这种方式的主要弊端是 RS 里面的所有对象在 GC 时，需要全部扫描一边，这对于下面两种情况来说成本是比较高的：</p>
<ol>
<li>younger 里面的一对象可能被多个 older 里的对象引用，这会导致不必要的重复检查</li>
<li>RS 里面的对象在回收 older 时需要再被扫描一边，这里面有一些大对象时情况会更严重</li>
</ol>
<h3 id="Page-Marking"><a href="#Page-Marking" class="headerlink" title="Page Marking"></a>Page Marking</h3><p><a href="https://en.wikipedia.org/wiki/David_A._Moon" target="_blank" rel="noopener">Moon</a> 在为 Symbolics Lisp machine 开发的 <a href="https://news.ycombinator.com/item?id=13225876" target="_blank" rel="noopener">Ephemeral GC</a> 中采用了另一种 pointer-recording 方式。这种方式不去记录哪些对象中含有交叉引用，而是记录哪些「虚拟内存页（virtual memory pages）」里保存了交叉引用。采用页为记录单位避免了扫描特大对象的问题。虽然整个页还需要扫描，但成本对 <a href="https://en.wikipedia.org/wiki/Symbolics" target="_blank" rel="noopener">Symbolics</a> 公司生产的机器来说不是很大，这是因为：</p>
<ol>
<li>有特殊的 tag 支持，可以让检查代的操作非常快的完成</li>
<li>page 相对来说比较小</li>
</ol>
<p>但这种方式对于普通机器来说就要慢很多了，除了普通机器的 page 较大（一般4K）以及没有特殊的 tag 支持外，还需要能够「从头扫描任意页」，这也是比较困难的，Symbolics 机器是因为每个 machine word 都有一额外标志位，所有这个扫描才比较快。</p>
<h3 id="Word-Marking"><a href="#Word-Marking" class="headerlink" title="Word Marking"></a>Word Marking</h3><p><a href="https://www.linkedin.com/in/psobalvarro/" target="_blank" rel="noopener">Sobalvarro</a> 通过为普通机器适配 Moon 的 Page marking 算法，采用 word marking 策略，使用一个 bitmap 来记录哪些 machine word 有交叉引用，这就避免了扫描任意页的问题。<br>但这种方式最大的问题时对于大 heap 来说，bitmap 会比较大，需要占整个内存空间的1/3，bitmap 如果是一维线性数组的话会比较耗时。</p>
<h3 id="Card-Marking"><a href="#Card-Marking" class="headerlink" title="Card Marking"></a>Card Marking</h3><p>为了解决页太大、字太小的问题，Sobalvarro <a href="https://dspace.mit.edu/bitstream/handle/1721.1/6795/AITR-1417.pdf?sequence=2" target="_blank" rel="noopener">又提出</a>了一个中等大小的新单位，也就是 card。card 避免了 </p>
<ul>
<li>page 太大，造成需要额外遍历多余对象</li>
<li>word 大小，造成遍历 bitmap 过长</li>
</ul>
<p><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2PyJEqDmWBKNjSZFBXXXxUFXa_!!581166664.png" alt="card marking 示意图"><br>card marking 的一个问题是，即使 card 的开端不是一个对象的开端，也需要去扫描。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分代式 GC 由于其普适性，已经被多数语言所采纳，比如：</p>
<ul>
<li>JavaScript：<a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection" target="_blank" rel="noopener">V8</a>、<a href="https://hacks.mozilla.org/2014/09/generational-garbage-collection-in-firefox/" target="_blank" rel="noopener">SpiderMonkey</a></li>
<li><a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby" target="_blank" rel="noopener">Generational GC in Python and Ruby</a>，这里面有介绍 Python 如何使用分代来解决「循环引用」</li>
<li><a href="https://www.mono-project.com/docs/advanced/garbage-collector/sgen/" target="_blank" rel="noopener">Mono Generational GC</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html" target="_blank" rel="noopener">JVM Generations</a></li>
</ul>
<p>截止到这篇文章，<a href="/tags/gc/">GC 的理论知识</a>就告一段落，主要参考了 Wilson 的论文 <a href="https://www.cs.cmu.edu/~fp/courses/15411-f08/misc/wilson94-gc.pdf" target="_blank" rel="noopener">Uniprocessor Garbage Collection Techniques</a>。有很多细节点都没有涉及到，比如</p>
<ol>
<li>locality 在不同策略下的影响</li>
<li>一个对象包含数据部分与指针部分，如何识别出指针</li>
</ol>
<p>可能是 C 语言已经离我比较久远，需要重新拾起来才能更好理解不同 GC实现上的取舍，谁让现如今大多数编译器、运行时都是由 C/C++ 编写的呢？<br>不过我觉得最重要的一点就是意识到 GC 的技术是通过一代又一代大师的努力不断进化的，像 Cheney、Baker、Guy Steele。即便站在巨人肩膀上的我们，GC 这个话题也还有很多问题需要解决。<br>后面的文章会主要集中在 JVM 的 GC，包括原理、调优、实现细节，做到理论与实践相结合。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://wiki.c2.com/?GenerationalGarbageCollection" target="_blank" rel="noopener">http://wiki.c2.com/?GenerationalGarbageCollection</a></li>
<li><a href="https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/</a></li>
</ul>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html" target="_blank" rel="noopener">http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="http://www.hboehm.info/gc/complexity.html" target="_blank" rel="noopener">http://www.hboehm.info/gc/complexity.html</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://dl.acm.org/citation.cfm?id=36183" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=36183</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2018/08/18/generational-gc/" data-id="ckcro6im4005125lj3roabtie" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACI0lEQVR42u3aS27jMBAFQN//0s52BoHk99hyAFHFlRA5JEsLgv15veLx/mf8/sv527U5X98YGBgYt2W8T8fRbxLM+abbz/FhFQwMjAcwjhY+fz6fJ+FdtRYGBgZGPnVy1Tv6JQYGBsZVjOTClxzER88YGBgYkyB2kuk633QCuywWx8DAuCEjz7r//fNX6hsYGBi3YrzL0RY1k6vh2k7+WwUDA2NrRn7AteHlWqlysh8MDIy9GclFsE2Q5Y0X+WxJihADA2NvxqQxIi8tTADRuhgYGA9gzFsi2vA1Xz16i4GB8QBGG4K2YW1b4KzDVwwMjEcy8ue2RaMNiaM5MTAwtmPkh9o8NTZ5++FQxsDAeBijLT1OAtE2MXf4yTAwMB7AaBu5WkybvKuDWAwMjK0Z+XRRj0ZZEP16hwgGBsYWjLWJJlfD/MDNE3wYGBh7M/JTK3mbhKCLCbW1ZgsMDIwtGPmm59T8yti2bmBgYOzNWPu3HLl2cRy1cWBgYGzKaAPLSTvXJND98GkwMDAew8hh7X+1BYa2sIqBgfEcxlqCPrkgtgFzXXDFwMDYlPEuR77dfHOXxd8YGBibMiZtXjm43Vx+Ma1hGBgYt2UkG5pfGSefLJoTAwPjAYwi6v1CkWAtiMXAwMBoE/3XBrptMwcGBgZG2ySRX0An5cwPlVgMDIztGEkQO0+xrSXXLk63YWBg3JCxFjq22youeRcd8RgYGFswfgDSWLJQeAGDCgAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/gc/">GC</a></div><div class="post-nav"><a class="pre" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a><a class="next" href="/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2018/08/18/generational-gc/';
    this.page.identifier = 'blog/2018/08/18/generational-gc/';
    this.page.title = '深入浅出垃圾回收（四）分代式 GC';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">25</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/14/go-struct-interface/">Go struct/interface 最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/02/review-2019/">2019 年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>深入浅出垃圾回收（四）分代式 GC - Keep Coding</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="刘家财" /><meta name="description" content="上文介绍的增量式 GC 是对 mark 阶段的一大优化，可以极大避免 STW 的影响。本文将要介绍的分代式 GC 根据对象生命周期（后面称为 age）的特点来优化 GC，降低" /><meta name="keywords" content="lisp, clojure, emacs, database, life" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="https://liujiacai.net/blog/2018/08/18/generational-gc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/jiacai.css">


<meta property="og:title" content="深入浅出垃圾回收（四）分代式 GC" />
<meta property="og:description" content="上文介绍的增量式 GC 是对 mark 阶段的一大优化，可以极大避免 STW 的影响。本文将要介绍的分代式 GC 根据对象生命周期（后面称为 age）的特点来优化 GC，降低" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liujiacai.net/blog/2018/08/18/generational-gc/" />
<meta property="article:published_time" content="2018-08-18T12:12:30+00:00" />
<meta property="article:modified_time" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="name" content="深入浅出垃圾回收（四）分代式 GC">
<meta itemprop="description" content="上文介绍的增量式 GC 是对 mark 阶段的一大优化，可以极大避免 STW 的影响。本文将要介绍的分代式 GC 根据对象生命周期（后面称为 age）的特点来优化 GC，降低">
<meta itemprop="datePublished" content="2018-08-18T12:12:30+00:00" />
<meta itemprop="dateModified" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="wordCount" content="4179">



<meta itemprop="keywords" content="GC," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入浅出垃圾回收（四）分代式 GC"/>
<meta name="twitter:description" content="上文介绍的增量式 GC 是对 mark 阶段的一大优化，可以极大避免 STW 的影响。本文将要介绍的分代式 GC 根据对象生命周期（后面称为 age）的特点来优化 GC，降低"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Keep Coding</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/podcast/">
        <li class="mobile-menu-item">Podcast</li>
      </a><a href="/blogrolls/">
        <li class="mobile-menu-item">友链</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Keep Coding</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/podcast/">Podcast</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/blogrolls/">友链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">深入浅出垃圾回收（四）分代式 GC</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-18 </span>
        <div class="post-category">
            <a href="/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 理解计算机 </a>
            </div>
          <span class="more-meta"> 约 4179 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#分代的必要性">分代的必要性</a></li>
    <li><a href="#分代的问题">分代的问题</a>
      <ul>
        <li><a href="#提升策略">提升策略</a></li>
        <li><a href="#堆组织">堆组织</a>
          <ul>
            <li><a href="#subareas-in-copying">Subareas in Copying</a></li>
            <li><a href="#generations-in-non-copying">Generations in Non-copying</a></li>
            <li><a href="#其他讨论">其他讨论</a></li>
          </ul>
        </li>
        <li><a href="#交叉引用">交叉引用</a>
          <ul>
            <li><a href="#indirect-tables">Indirect tables</a></li>
            <li><a href="#ungars-remembered-sets">Ungar&rsquo;s Remembered Sets</a></li>
            <li><a href="#page-marking">Page Marking</a></li>
            <li><a href="#word-marking">Word Marking</a></li>
            <li><a href="#card-marking">Card Marking</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><a href="/blog/2018/08/04/incremental-gc">上文</a>介绍的增量式 GC 是对 mark 阶段的一大优化，可以极大避免 STW 的影响。本文将要介绍的分代式 GC 根据对象生命周期（后面称为 age）的特点来优化 GC，降低其性能消耗。</p>
<p>阅读本文需要熟悉<a href="/blog/2018/07/08/mark-sweep/#%E6%9C%AF%E8%AF%AD">之前提及的术语</a>。</p>
<h1 id="分代的必要性">分代的必要性</h1>
<p>虽然对象的生命周期因应用而异，但对于大多数应用来说，80% 的对象在创建不久即会成为垃圾<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。因此，针对不同 age 的对象「划分不同区域，采用不同的回收策略」也就不难理解了。</p>
<p>对于 Copying GC 来说，需要在两个 semispace 间移动对象，如果移动对象较大，就会对程序造成较大影响，而分代就能解决这个问题。简单情况下可以分为两个代：younger、older。</p>
<blockquote>
<p>younger 用于分配新对象，在这里的对象经过几轮 GC 后会移动到 older。younger 与 older 相比空间要小，且 GC 发生更频繁。</p>
</blockquote>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i3/581166664/TB2xIAtpY3nBKNjSZFMXXaUSFXa_!!581166664.jpg" alt="分代式 GC 示意图">
    <figcaption><center>分代式 GC 示意图</center></figcaption>
  </figure>


即便采用的是 non-copying GC，也可以通过分代，减少 GC 作用范围，缩小耗时。</p>
<h1 id="分代的问题">分代的问题</h1>
<p>天下没有免费的午餐，GC 采用分代算法，一个首要的问题是「如何在不回收 older 的同时安全的回收 younger 里面的对象」。由于引用关系图是全局的属性，older 里面的对象也必须考虑的。比如 younger 里面的一对象只被 older 里面的对象引用了，如何保证 GC 不会错误的回收这个对象呢？
避免上述问题的一个方法是采用写屏障（write barrier），在 mutator 进行指针存储时，进行一些额外的操作（bookkeeping）。写屏障的主要目的是保证所有由 <code>older--&gt;younger</code> 的指针在进行 younger 内的 GC 时被考虑在内，并且作为 root set 进行 copy 遍历。需要注意的是，这里的写屏障与增量式 GC 同样具有一定的保守性。这是由于所有由 <code>older--&gt;younger</code> 的指针都会被当作 root set，但在 older 内对象的 liveness 在进行下一次 older GC 前是不可知的，这也就造成了一些 floating garbage，不过这在实现中问题不是很大。</p>
<p>为了独立回收 older，通过记录所有由 <code>younger--&gt;older</code> 的指针也是可行的，不过这会比较消耗性能。这是因为：</p>
<blockquote>
<p>在大多数情况下，由 <code>younger--&gt;older</code> 的指针数目要远大于 <code>older--&gt;younger</code> 的，这是符合程序运行规律的——创建一个新对象，将至指向一个老对象。</p>
</blockquote>
<p>即便不记录 <code>younger--&gt;older</code> 的指针，也可以在不回收 younger 的前提下回收 older，只不过这时会把 younger 里面的所有对象作为 root set。尽管这样遍历的时间会与 younger 里面的对象数目成正比，但考虑到 younger 内对象数量一般都要小于 older 的，而且遍历操作的消耗要远小于 copying，所以这也是一种可以接受的方式。</p>
<p>除了上面交叉引用的问题，对于一个分代的 GC 来说，还需要考虑下面几个方面：</p>
<ol>
<li>提升策略（advancement policy）。在一个代内的对象经过多少次 GC 会晋级到下一个代</li>
<li>堆组织（heap organization）。在代与代之间或者一个代内，heap 空间如何组织可以保证高的 locality 与 缓存命中率</li>
<li>代之间的交叉引用（intergenerational references）。采用哪种方式来记录这些指针最好？dirty bit or indirect table</li>
</ol>
<p>下面就针对这三点分别进行阐述。</p>
<h2 id="提升策略">提升策略</h2>
<p>最简单的提升策略是在每次 GC 遍历时，把 live 的对象移动到下一代去。这样的优势有：</p>
<ol>
<li>实现简单，不需要去区分一个代内不同对象的 age。对于 copying GC 来说，只需要用一块连续的区域表示即可，不需要 semispace，也不需要额外的 header 来保存 age 信息</li>
<li>可以尽快的把大对象提升的 GC 频率小的下一代中去</li>
</ol>
<p>当然，这样做的问题也比较明显，可能会把一些 age 较小的对象移动到下一代中去，导致下一代被更快的填满，所以一般会让 younger 里面的对象停留一次，即第二次 GC 时才去提升，当然这时就需要记录对象的 age 了。</p>
<p>至于是不是需要停留两次，这个就不好说了，这个和应用也比较相关。一般来说，如果代分的少，比如2个，那么会倾向多停留几次，减慢 older 被填满的速度；如果代的数目大于2，那么就倾向于快速提升，因为这些对象很有可能在中间的某个代就会死亡，不会到达最终的 older。</p>
<h2 id="堆组织">堆组织</h2>
<p>分代式 GC 需要对不同 age 的对象采取不同的处理方式，所以在 GC 遍历时，必须能够判断当前对象属于哪个代，写屏障也需要这个信息来识别 <code>older--&gt;younger</code> 指针。</p>
<ul>
<li>对于 copying GC 来说，一般是把不同 age 的对象放在不同的连续区域内，这样一个对象的代就能够从内存地址推断出来了。也有一些系统不采用连续地址，而是采用由 <code>page number of object--&gt;generation</code> 的表来辅助判断。</li>
<li>对于 non-copying GC，一般是存放在 header 内</li>
</ul>
<h3 id="subareas-in-copying">Subareas in Copying</h3>
<p>分代式 copying GC 一般会把 generation 分为几个子区域，比如 semispace，通过来回的移动对象让它们一直处于当前代中。如果一个代内只有一个区域，那么每次 GC 时都需要把对象提升到下一代（没有可移动的地方）。
但是 semispace 的 locality 比较差，一个代的内存只有一半可以使用，且来回需要移动。</p>
<h4 id="ungars-generation-scavenging">Ungar&rsquo;s Generation Scavenging</h4>
<p><a href="https://en.wikipedia.org/wiki/David_Ungar">Ungar</a> 在其论文<a href="https://people.cs.umass.edu/~emery/classes/cmpsci691s-fall2004/papers/p157-ungar.pdf">《Generation Scavenging》</a> 中提出一个解决方法：</p>
<blockquote>
<p>一个代内除了两个 semispace 外，还有第三个区域，这里称为Third。在 Third 内分配新对象，在 GC 时，Third 内 live 对象与 semispace 中的一个对象会复制到 semispace 中的另一个去，GC 结束时 Third 会被清空，用于再次分配对象。这样就能够与只有一个区域的代类似的 locality 了。</p>
</blockquote>
<p>乍一看，增加的 Third 区域会增加内存使用，但实际情况要好很多。Third 区域会被充分利用，semispace 用来保存每次 GC 后的存活对象（survivors）。一般来说，新创建的对象只有少部分能“活过”一次 GC，所以每个 semispace 中只有一小部分会使用，因此总的来说内存使用较小。</p>
<p>最后一个代（oldest generation，后面称为 oldest）在一些系统中有特殊处理。比如，在 Lisp Machine 中，每次 GC 后，大多数代都会被清空，并将其内对象拷贝到下一代去，但是 oldest 后面没有可用代了，因此 oldest 内会被分为 semispace。另一个优化是分配一个特殊的区域，称为 static space，用来分配 system data &amp; compiled code 等这些基本不会变的数据，这个区域基本不会有 GC。</p>
<p>在一些基于 Ungar 的 Generation Scavenging 的系统中，把 oldest 分为一个区域，在这个区域使用 mark-compact 算法。使用一个区域可以提高内存利用率，MC 虽然比 copying 算法成本更高，但对于 oldest 来说减少<a href="https://en.wikipedia.org/wiki/Page_fault">换页（page fault）</a>也是有价值的。（copying GC 由于 semispace 的原因，所以内存使用率只有一半，所以更容易导致发生换页的问题<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>）。关于<a href="https://en.wikipedia.org/wiki/Paging">虚拟内存的分页</a>对 GC 影响的研究不是很多，感兴趣可以参考下面的链接：</p>
<ul>
<li><a href="https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/virtual-memory-paging-and-swapping/">Virtual Memory, Paging, and Swapping</a></li>
<li><a href="https://cs.stackexchange.com/questions/22649/are-there-any-garbage-collectors-that-take-into-account-paging">Are there any garbage collectors that take into account paging?</a></li>
<li><a href="https://stackoverflow.com/questions/21810059/relation-between-garbage-collection-and-swapping-paging">Relation between garbage collection and swapping,paging</a></li>
</ul>
<h3 id="generations-in-non-copying">Generations in Non-copying</h3>
<p>上面的讨论主要围绕 copying GC 来说，其实那些技巧也可以用在 non-copying GC 之上，只不过它们更容易发生碎片问题。在增量式 GC 那里使用<a href="/blog/2018/08/04/incremental-gc/#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0">三色标记</a>来抽象，分代算法可以用不同 age 的对象集合来抽象。在 GC 遍历时，通过检查 header 里面的 age 来决定是否需要提升。</p>
<h3 id="其他讨论">其他讨论</h3>
<ul>
<li>对于 copying GC 来说，大对象会被特殊的分配在一特殊区域「large object area」来避免拷贝。</li>
<li>对于明确指定不含有指针的对象，最好也能与其他对象分开，来降低检查交叉引用的成本。</li>
<li>一般情况下，对 younger 代采用 stop-and-copy 方式的 GC；对 older 采用 incremental-and-sweep GC</li>
</ul>
<h2 id="交叉引用">交叉引用</h2>
<p>上面已经介绍的，<code>older--&gt;younger</code> 的交叉引用是由写屏障来保障的。对于某些系统（如 Lisp，指针存储指令占全部指令的1%<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>），这个写屏障的成本对分代式 GC 来说非常严重，因此写屏障的策略就十分重要了。下面介绍几种常见的策略</p>
<h3 id="indirect-tables">Indirect tables</h3>
<p>重定向表（indirect tables）的思路是这样的：</p>
<p>所有 <code>older--&gt;younger</code> 的指针经由一个称为「<a href="http://www.memorymanagement.org/glossary/e.html">entry table</a>」的表进行中转，每个代都有其对应的 entry table 来记录后一个代指向当前代的指针。这样在回收一个代时，只需要把 entry table 里面的引用考虑在内就可以了。

  <figure>
    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB208pDqcUrBKNjSZPxXXX00pXa_!!581166664.png" alt="indirect table 示意图">
    <figcaption><center>indirect table 示意图</center></figcaption>
  </figure>

</p>
<p>但这种重定向表在普通机器（stock hardware）上不够快或高效，因此最近的分代式 GC 都避免使用这种方式，而是采用记录的方式（pointer recording schemes）来保存这些交叉引用。</p>
<h3 id="ungars-remembered-sets">Ungar&rsquo;s Remembered Sets</h3>
<p>Ungar 的 generation scavenging 采用一个称为 Remembered Sets（后面简写 RS） 的结构来记录交叉引用。在每一次指针存储时，写屏障通过检查</p>
<ol>
<li>将要保存的对象是否为指针</li>
<li>指针是否指向 younger</li>
<li>是否被保存到 older 内</li>
</ol>
<p>这三个条件，判断是否会创建交叉引用，如果上述三个条件都满足，就会把 older 的对象添加到 RS 中。每个对象的 header 都有一位表示其是否存在于 RS 中，所以可以保证 RS 的内元素的唯一性，这样可以缩短扫描 RS 的时间。</p>
<p>这种方式的主要弊端是 RS 里面的所有对象在 GC 时，需要全部扫描一边，这对于下面两种情况来说成本是比较高的：</p>
<ol>
<li>younger 里面的一对象可能被多个 older 里的对象引用，这会导致不必要的重复检查</li>
<li>RS 里面的对象在回收 older 时需要再被扫描一边，这里面有一些大对象时情况会更严重</li>
</ol>
<h3 id="page-marking">Page Marking</h3>
<p><a href="https://en.wikipedia.org/wiki/David_A._Moon">Moon</a> 在为 Symbolics Lisp machine 开发的 <a href="https://news.ycombinator.com/item?id=13225876">Ephemeral GC</a> 中采用了另一种 pointer-recording 方式。这种方式不去记录哪些对象中含有交叉引用，而是记录哪些「虚拟内存页（virtual memory pages）」里保存了交叉引用。采用页为记录单位避免了扫描特大对象的问题。虽然整个页还需要扫描，但成本对 <a href="https://en.wikipedia.org/wiki/Symbolics">Symbolics</a> 公司生产的机器来说不是很大，这是因为：</p>
<ol>
<li>有特殊的 tag 支持，可以让检查代的操作非常快的完成</li>
<li>page 相对来说比较小</li>
</ol>
<p>但这种方式对于普通机器来说就要慢很多了，除了普通机器的 page 较大（一般4K）以及没有特殊的 tag 支持外，还需要能够「从头扫描任意页」，这也是比较困难的，Symbolics 机器是因为每个 machine word 都有一额外标志位，所有这个扫描才比较快。</p>
<h3 id="word-marking">Word Marking</h3>
<p><a href="https://www.linkedin.com/in/psobalvarro/">Sobalvarro</a> 通过为普通机器适配 Moon 的 Page marking 算法，采用 word marking 策略，使用一个 bitmap 来记录哪些 machine word 有交叉引用，这就避免了扫描任意页的问题。
但这种方式最大的问题时对于大 heap 来说，bitmap 会比较大，需要占整个内存空间的1/3，bitmap 如果是一维线性数组的话会比较耗时。</p>
<h3 id="card-marking">Card Marking</h3>
<p>为了解决页太大、字太小的问题，Sobalvarro <a href="https://dspace.mit.edu/bitstream/handle/1721.1/6795/AITR-1417.pdf?sequence=2">又提出</a>了一个中等大小的新单位，也就是 card。card 避免了</p>
<ul>
<li>page 太大，造成需要额外遍历多余对象</li>
<li>word 大小，造成遍历 bitmap 过长</li>
</ul>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB2PyJEqDmWBKNjSZFBXXXxUFXa_!!581166664.png" alt="card marking 示意图">
    <figcaption><center>card marking 示意图</center></figcaption>
  </figure>


card marking 的一个问题是，即使 card 的开端不是一个对象的开端，也需要去扫描。</p>
<h1 id="总结">总结</h1>
<p>分代式 GC 由于其普适性，已经被多数语言所采纳，比如：</p>
<ul>
<li>JavaScript：<a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">V8</a>、<a href="https://hacks.mozilla.org/2014/09/generational-garbage-collection-in-firefox/">SpiderMonkey</a></li>
<li><a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby">Generational GC in Python and Ruby</a>，这里面有介绍 Python 如何使用分代来解决「循环引用」</li>
<li><a href="https://www.mono-project.com/docs/advanced/garbage-collector/sgen/">Mono Generational GC</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html">JVM Generations</a></li>
</ul>
<p>截止到这篇文章，<a href="/tags/gc/">GC 的理论知识</a>就告一段落，主要参考了 Wilson 的论文 <a href="https://www.cs.cmu.edu/~fp/courses/15411-f08/misc/wilson94-gc.pdf">Uniprocessor Garbage Collection Techniques</a>。有很多细节点都没有涉及到，比如</p>
<ol>
<li>locality 在不同策略下的影响</li>
<li>一个对象包含数据部分与指针部分，如何识别出指针</li>
</ol>
<p>可能是 C 语言已经离我比较久远，需要重新拾起来才能更好理解不同 GC实现上的取舍，谁让现如今大多数编译器、运行时都是由 C/C++ 编写的呢？
不过我觉得最重要的一点就是意识到 GC 的技术是通过一代又一代大师的努力不断进化的，像 Cheney、Baker、Guy Steele。即便站在巨人肩膀上的我们，GC 这个话题也还有很多问题需要解决。
后面的文章会主要集中在 JVM 的 GC，包括原理、调优、实现细节，做到理论与实践相结合。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="http://wiki.c2.com/?GenerationalGarbageCollection">http://wiki.c2.com/?GenerationalGarbageCollection</a></li>
<li><a href="https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/">https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/</a></li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html">http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p><a href="http://www.hboehm.info/gc/complexity.html">http://www.hboehm.info/gc/complexity.html</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="https://dl.acm.org/citation.cfm?id=36183">https://dl.acm.org/citation.cfm?id=36183</a> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">刘家财</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-12-04
        <a href="https://github.com/jiacai2050/jiacai2050.github.io/commit/8f8c30acc9eabc6498854bdbb13df6a4b744f17d" title="fix bad categories">(8f8c30a)</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/gc/">GC</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/blog/2018/11/10/damn-single-socket/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">形单影只的 Socket</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/blog/2018/08/04/incremental-gc/">
            <span class="next-text nav-default">深入浅出垃圾回收（三）增量式 GC</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'jiacai2050';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jiacai2050&#43;blog@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/2163429/jiacai-liu" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.twitter.com/liujiacai" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/jiacai2050" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/liujiacai" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/jiacai2050" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/liujiacai/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://liujiacai.net/atom.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2014 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>刘家财</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-50745138-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>

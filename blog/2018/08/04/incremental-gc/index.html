<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>深入浅出垃圾回收（三）增量式 GC - Keep Coding</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="刘家财" /><meta name="description" content="在上一篇文章中介绍的 MS 优化策略都是围绕 sweep 阶段展开，但 mark 阶段会导致应用程序挂起，也就是常说的：stop-the-world（STW），这严重影" /><meta name="keywords" content="lisp, clojure, emacs, database, life" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="https://liujiacai.net/blog/2018/08/04/incremental-gc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="深入浅出垃圾回收（三）增量式 GC" />
<meta property="og:description" content="在上一篇文章中介绍的 MS 优化策略都是围绕 sweep 阶段展开，但 mark 阶段会导致应用程序挂起，也就是常说的：stop-the-world（STW），这严重影" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liujiacai.net/blog/2018/08/04/incremental-gc/" />
<meta property="article:published_time" content="2018-08-04T22:00:34+00:00" />
<meta property="article:modified_time" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="name" content="深入浅出垃圾回收（三）增量式 GC">
<meta itemprop="description" content="在上一篇文章中介绍的 MS 优化策略都是围绕 sweep 阶段展开，但 mark 阶段会导致应用程序挂起，也就是常说的：stop-the-world（STW），这严重影">
<meta itemprop="datePublished" content="2018-08-04T22:00:34+00:00" />
<meta itemprop="dateModified" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="wordCount" content="3521">



<meta itemprop="keywords" content="GC," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入浅出垃圾回收（三）增量式 GC"/>
<meta name="twitter:description" content="在上一篇文章中介绍的 MS 优化策略都是围绕 sweep 阶段展开，但 mark 阶段会导致应用程序挂起，也就是常说的：stop-the-world（STW），这严重影"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Keep Coding</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/podcast/">
        <li class="mobile-menu-item">Podcast</li>
      </a><a href="/blogrolls/">
        <li class="mobile-menu-item">友链</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Keep Coding</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/podcast/">Podcast</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/blogrolls/">友链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">深入浅出垃圾回收（三）增量式 GC</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-04 </span>
        <div class="post-category">
            <a href="/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 理解计算机 </a>
            </div>
          <span class="more-meta"> 约 3521 字 </span>
          <span class="more-meta"> 预计阅读 8 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#增量式-gc-思路">增量式 GC 思路</a></li>
        <li><a href="#三色标记">三色标记</a></li>
        <li><a href="#增量策略">增量策略</a>
          <ul>
            <li><a href="#写屏障">写屏障</a></li>
            <li><a href="#读屏障">读屏障</a></li>
            <li><a href="#实现细节">实现细节</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在<a href="/blog/2018/07/08/mark-sweep/">上一篇文章</a>中介绍的 MS 优化策略都是围绕 sweep 阶段展开，但 mark 阶段会导致应用程序挂起，也就是常说的：stop-the-world（STW），这严重影响了 Tracing GC 的应用场景。本文即将介绍的增量式 GC 可以大大缓解 STW 问题。</p>
<p>阅读本文需要读者熟悉<a href="/blog/2018/07/08/mark-sweep/#%E6%9C%AF%E8%AF%AD">前文提及的术语</a>。</p>
<h2 id="增量式-gc-思路">增量式 GC 思路</h2>
<p>增量式（incremental）GC 顾名思义，允许 collector 分多个小批次执行，每次造成的 mutator 停顿都很小，达到近似实时的效果。</p>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i3/581166664/TB2QgDSJASWBuNjSszdXXbeSpXa_!!581166664.png" alt="STW vs 增量式">
    <figcaption><center>STW vs 增量式</center></figcaption>
  </figure>

</p>
<p>引用计数类 GC 本身就具有增量式特性，但由于其算法自身的<a href="/blog/2018/06/15/garbage-collection-intro/#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-counting%EF%BC%89">缺陷与效率问题</a>，一般不会采用。而追踪类 GC 实现增量式的难点在于：</p>
<blockquote>
<p>在 collector 遍历引用关系图，mutator 可能会改变对象间的引用关系</p>
</blockquote>
<p>这其实是一个并发问题，collector 线程与 mutator 线程同时去读/写一些共享的数据结构（引用关系图），这就要求把它保护起来，使 collecotr 与 mutator 能够感知其改变，并作出相应调整。
在 GC 期间，对 mutator 改变「引用关系图」的保守度（conservatism）是增量式 GC 一大特性。如果 mutator 在 collector 遍历某对象后将其释放（floating garbage），那么这个对象在本次 GC 不会被回收，但在下一轮 GC 开始时会被回收。
这种弱一致性（relaxed consistency）是允许的，因为它不会对程序逻辑造成影响，只是延迟了垃圾对象的回收，而且一致性越弱，遍历算法的实现就可以更灵活。</p>
<h2 id="三色标记">三色标记</h2>
<p><a href="http://www.memorymanagement.org/glossary/t.html#term-tri-color-marking">三色标记（tricolor marking）</a>抽象屏蔽了 GC 实现的算法（MS/Copying）、遍历策略（宽度优先/深度优先）等细节，对于理解增量式 GC 十分有帮助。具体来说是在 GC 遍历引用关系图时，对象会被标为三种颜色：</p>
<ol>
<li>黑色black，表明对象被 collector 访问过，属于可到达对象</li>
<li>灰色gray，也表明对象被访问过，但是它的子节点还没有被 scan 到</li>
<li>白色white，表明没有被访问到，如果在本轮遍历结束时还是白色，那么就会被收回</li>
</ol>
<p>对于 MS 来说，设置标记位就是着色的过程：有 mark-bit 的即为黑色。对 Copying GC 来说，把对象从 fromspace 移动到 tospace 就是着色过程：在 fromspace 中不可到达的对象为白色，被移动到 tospace 的对象为黑色。
对于增量时 GC 来说，需要在黑白之间有个中间状态来记录「那些之前被 collector 标记黑色，后来又被 mutator 改变的对象」，这就是灰色的作用。
对于 MS 来说，灰色对象是用于协助遍历 queue 里面的对象，即<a href="/blog/2018/07/08/mark-sweep/#MS-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B">上文中描述的 worklist 里面</a>的对象。对于 Copying GC 来说，灰色对象就是那些在 topspace 中还没被 scan 的对象，如果采用 <a href="/blog/2018/07/08/mark-sweep/#Cheney-%E7%AE%97%E6%B3%95">Cheney 的宽度优先遍历算法</a> ，那么就是 scan 与 free 指针之间的对象。</p>
<p>增加的中间状态灰色要求 mutator 不会把黑色对象直接指向白色对象（这称为三色不变性 tri-color invariant），collector 就能够认为黑色对象不需要在 scan，只需要遍历灰色对象即可。</p>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB24SYJIVuWBuNjSszbXXcS7FXa_!!581166664.png" alt="违法三色不变性的一个例子">
    <figcaption><center>违法三色不变性的一个例子</center></figcaption>
  </figure>

</p>
<p>上图描述了一个违法着色不变性的情况。假设 A 已经被完全地 scan，它本身被标为黑色，字节点被标为灰色，现在假设 mutator 交换了 A&ndash;&gt;C 与 B&ndash;&gt;D 的指针，现在指向 D 的指针只有 A，而 A 已经被完全地 scan 了，如果继续 scan 过程的话，B 会被置为黑色，C 会被重新访问，而 D 则不会被访问到，在本轮遍历后，D 由于是白色，会被错误的认为是垃圾并被回收掉。</p>
<h2 id="增量策略">增量策略</h2>
<p>为了解决上面的问题，一般有两类方式来协调 mutator 与 collector 的行为：</p>
<ol>
<li>读屏障（read barrier），它会禁止 mutator 访问白色对象，当检测到 mutator 即将要访问白色对象时，collector 会立刻访问该对象并将之标为灰色。由于 mutator 不能访问指向白色对象的指针，也就无法使黑色对象指向它们了</li>
<li>写屏障（write barrier），它会记录下 mutator 新增的由黑色&ndash;&gt;白色对象的指针，并把该对象标为灰色，这样 collector 就又能访问有问题的对象了</li>
</ol>
<p>读/写屏障本质是一些同步操作——在 mutator 进行某些操作前，它必须激活 collector 进行一些操作。
在实际应用中，调用 collector 只需要一些简单的操作，compiler 可以在输出 mutator 机器码（machine code）的同时，额外输出一些指令（instructions），在进行读/写指针时，会额外执行这些指令。根据读/写屏障复杂度，整个屏障操作可以内联（inline），也可以是个额外的过程调用（out of line procedure call）。</p>
<h3 id="写屏障">写屏障</h3>
<p>如果要使 collector 错误地回收可到达对象，mutator 必须做到以下两点（缺一不可）：</p>
<ol>
<li>把指向白色对象的指针存储在一黑色对象中。称为条件1</li>
<li>在 collector 访问该白色对象之前，破坏指向它的原有指针。称为条件2</li>
</ol>
<p>写屏障也从这两个方面入手，下面分别阐述。</p>
<h4 id="incremental-update">Incremental Update</h4>
<p>Incremental Update 算法（后面简写IU）避免条件1的发生。IU 最常用的实现是由 Dijkstra 提出<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>，该算法核心思想阐述如下：</p>
<blockquote>
<p>它会启发式（或者说是保守式）保留在 GC 遍历结束时 live 的对象。在遍历期死亡的对象（该对象还没被遍历到），不会再被访问、标记。</p>
</blockquote>
<p>为了避免指向白色对象的指针被隐藏在黑色对象中，这些指针在存储到黑色对象中时会被捕捉到，这时会把白色对象重新置为灰色，这个过程会一直迭代下去，直到没有灰色对象为止。</p>
<p>新创建的对象在 Dijkstra 算法中会被乐观的认为是白色，这是该算法的一大优势，因为大多数对象的生命周期都比较短。如果在 GC 遍历到它们之前就已经不可到达，这就意味着它们永远不用访问了。</p>
<p><a href="https://www.cs.utexas.edu/users/mckinley/395Tmm/talks/Mar-23-CMS.pdf">Guy Steele 提出的算法</a>中建议采用一种启发性方式，部分新对象是白色，部分是黑色，来保证短生命周期的对象尽快被回收的同时，避免遍历长生命周期的对象。但这种方式是否更有效不能很好证明。</p>
<p>在 Steele 算法中，如果指向白色对象的指针被储存在了黑色对象内，会把黑色对象变为灰色。Dijkstra 采用的方式与这种方式相比，显得更保守些，因为那些白色对象很有可能会在再次变为白色。这里举一实际例子进行说明：</p>
<blockquote>
<p>假设程序使用一由双向链表实现的 stack 来存储数据，GC 遍历到栈顶元素，并将其标为黑色，这时程序进行一些 push/pop 操作，按照 Dijkstra 算法，pop 出来的所有元素会依次被标为灰色，那么就意味着在本次 GC 时不会被回收；而按照 Steele 算法，则有可能回收掉大部分 pop 出来的元素。</p>
</blockquote>
<h4 id="snapshot-at-beginning">Snapshot at beginning</h4>
<p>Snapshot at beginning（后面简写 SAB）算法避免条件2的发生。该算法在开始 GC 之前，会使用 copy-on-write 的方式复制一份当时的引用关系图。也就是说，在 GC 开始时引用关系图是固定的。
该算法最为人所知的实现由 Yuasa 提出，在该实现中，如果改变某个指针的地址，那么之前的地址会被加入一 marking stack，便于后面再次检查，这样就可以保证在 GC 时，所有的对象都会被遍历到，即使指向它们的指针发生了改变。拿上面三色标记举例来说，B&ndash;&gt;D 的指针会被保存在一个 stack 中。</p>
<h3 id="读屏障">读屏障</h3>
<p>目前来说，最有名的实时性 GC 是 Baker 提出的增量式复制（incremental copying）GC。</p>
<h4 id="incremental-copying">Incremental Copying</h4>
<p>Baker&rsquo;s GC 大部分逻辑与 <a href="/blog/2018/07/08/mark-sweep/#Copying-GC">Copying GC</a> 相似，使用 Cheney 的宽度优先算法遍历引用关系图，把所有引用的对象拷贝到 topspace 的 scan 指针处。但这个过程是与mutator并行的，而且 mutator 为了保证引用关系图的一致性，也可能会触发拷贝操作。下面具体阐述该算法工作流程：</p>
<ol>
<li>GC 开始时会有一个原子性的 flip 过程，会把由 root set 可直接到达的对象由 fromspace 拷贝到 tospace</li>
<li>mutator 恢复执行，与 collector 交替执行</li>
<li>当 mutator 访问到 fromspace 中的对象时，立刻将之拷贝到 topspace 中。这个 copy-on-demand 使用 read-barrier 来保证</li>
</ol>
<p>Barker 算法一个重要特点是：在增量回收时，新分配的对象直接分配在 tospace，当作已遍历对象，也就是三色标记中的黑色。为保证 GC 能在内存耗尽前发现所有可到达对象并复制到 tospace，复制的速率与分配对象的速率息息相关。</p>
<h4 id="non-copyingtreadmill">Non-copying—Treadmill</h4>
<p>Baker 在1991年对其增量式算法提出了 <a href="http://home.pipeline.com/~hbaker1/NoMotionGC.html">non-copying 版本</a>，称为 Treadmill。Treadmill 使用双向链表来区别不同颜色的对象集合，这样就可以通过修改指针来避免移动对象与更新指针的操作。不同集合首尾相连形成环结构，便于对象的转化。如下图：</p>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i1/581166664/TB26SaYnXkoBKNjSZFEXXbrEVXa_!!581166664.png" alt="Treadmill 示意图">
    <figcaption><center>Treadmill 示意图</center></figcaption>
  </figure>

</p>
<p>该环结构分为四个区域：</p>
<ol>
<li>new 区。在 GC 期间的对象分配在这里，默认为黑色。在 GC 开始时，该区为空</li>
<li>from 区。对应 fromspace，GC 开始前对象分配区域</li>
<li>to 区。对应 tospace。在 GC 开始时，该区为空</li>
<li>free 区。与 new、from 区相连，别于分配新对象</li>
</ol>
<p>GC 工作过程与之前方式相似，再将 from 区对象连接到 to 区后，遍历 to 区里面的灰色对象，直到全部为黑色时GC结束。然后，new 与 to 合并后形成新 to 区，from 与 free 合并形成新的 free 区。</p>
<h3 id="实现细节">实现细节</h3>
<p>如果没有特殊的硬件支持，写屏障一般来说效率要高于读屏障，主要原因是：</p>
<blockquote>
<p>heap 指针的读操作要多于写操作</p>
</blockquote>
<p>其中比较特别的是 Lisp Machine 有特殊的硬件支持重定向指针（forwording pointer），可以在不进行 forward 检测的前提下，交替使用新旧两个地址。<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>关于两类屏障在实现细节上的更多差异这里暂且跳过，感兴趣的读者可以重点参考下面这篇论文</p>
<ul>
<li><a href="http://www.cs.colorado.edu/department/publications/reports/docs/CU-CS-494-90.pdf">《Barrier Methods for Garbage Collection》 Benjamin Zorn 1990</a></li>
</ul>
<h2 id="总结">总结</h2>
<p>截止到这里，追逐类 GC 的优化基本都涉及到了，可以参考下面这张 GC 衍化图进行回顾反思：</p>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i1/581166664/TB28nozJXGWBuNjy0FbXXb4sXXa_!!581166664.png" alt="GC 衍化图">
    <figcaption><center>GC 衍化图</center></figcaption>
  </figure>

</p>
<p>可以看到，在右下角还剩下一个 Generational 没有涉及，这也是现代 GC 的必备优化，不过这是下一篇文章的内容了。Stay Tuned！</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://blog.heroku.com/incremental-gc">https://blog.heroku.com/incremental-gc</a></li>
<li><a href="http://xiao-feng.blogspot.com/2007/04/incremental-update-tracing-vs-snapshot.html">http://xiao-feng.blogspot.com/2007/04/incremental-update-tracing-vs-snapshot.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm">https://en.wikipedia.org/wiki/Cheney%27s_algorithm</a></li>
<li><a href="http://www.memorymanagement.org/glossary/f.html#glossary-f">http://www.memorymanagement.org/glossary/f.html#glossary-f</a></li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD05xx/EWD520.html</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p><a href="https://www.iecc.com/gclist/GC-algorithms.html">https://www.iecc.com/gclist/GC-algorithms.html</a> forwarding-pointer 词条 <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">刘家财</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-12-04
        <a href="https://github.com/jiacai2050/jiacai2050.github.io/commit/8f8c30acc9eabc6498854bdbb13df6a4b744f17d" title="fix bad categories">(8f8c30a)</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/gc/">GC</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/blog/2018/08/18/generational-gc/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">深入浅出垃圾回收（四）分代式 GC</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/blog/2018/07/08/mark-sweep/">
            <span class="next-text nav-default">深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'jiacai2050';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jiacai2050&#43;blog@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/2163429/jiacai-liu" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.twitter.com/liujiacai" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/jiacai2050" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/liujiacai" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/jiacai2050" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/liujiacai/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://liujiacai.net/atom.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2014 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>刘家财</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-50745138-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>

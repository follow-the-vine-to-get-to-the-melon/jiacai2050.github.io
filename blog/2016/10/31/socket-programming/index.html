<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>Socket 编程实战 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Socket 编程实战</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Socket 编程实战</h1><div class="post-meta">Oct 31, 2016<span> | </span><span class="category"><a href="/categories/aha-computer/">理解计算机</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2016/10/31/socket-programming/" href="/blog/2016/10/31/socket-programming/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-socket-API"><span class="toc-number">2.</span> <span class="toc-text">Python socket API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-socket"><span class="toc-number">2.1.</span> <span class="toc-text">TCP socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-socket"><span class="toc-number">2.2.</span> <span class="toc-text">UDP socket</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见陷阱"><span class="toc-number">3.</span> <span class="toc-text">常见陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#忽略返回值"><span class="toc-number">3.1.</span> <span class="toc-text">忽略返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#误认为-TCP-具有-framing"><span class="toc-number">3.2.</span> <span class="toc-text">误认为 TCP 具有 framing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-的状态机"><span class="toc-number">4.</span> <span class="toc-text">TCP 的状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实战"><span class="toc-number">5.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-UA"><span class="toc-number">5.1.</span> <span class="toc-text">HTTP UA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unix-domain-socket"><span class="toc-number">5.2.</span> <span class="toc-text">Unix_domain_socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping"><span class="toc-number">5.3.</span> <span class="toc-text">ping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat-vs-ss"><span class="toc-number">5.4.</span> <span class="toc-text">netstat vs ss</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>Socket 在英文中的含义为“（连接两个物品的）凹槽”，像<code>the eye socket</code>，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常是指一个连接的两个端点，这里的连接可以是同一机器上的，像<a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">unix domain socket</a>，也可以是不同机器上的，像<a href="https://en.wikipedia.org/wiki/Network_socket" target="_blank" rel="noopener">network socket</a>。</p>
<p>本文着重介绍现在用的最多的 network socket，包括其在网络模型中的位置、API 的编程范式、常见错误等方面，最后用 Python 语言中的 socket API 实现几个实际的例子。Socket 中文一般翻译为“套接字”，不得不说这是个让人摸不着头脑的翻译，我也没想到啥“信达雅”的翻译，所以本文直接用其英文表述。本文中所有代码均可在 <a href="https://github.com/jiacai2050/socket.py" target="_blank" rel="noopener">socket.py</a> 仓库中找到。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Socket 作为一种通用的技术规范，首次是由 Berkeley 大学在 1983 为 4.2BSD Unix 提供的，后来逐渐演化为 POSIX 标准。Socket API 是由操作系统提供的一个编程接口，让应用程序可以控制使用 socket 技术。Unix 哲学中有一条<code>一切皆为文件</code>，所以 <code>socket</code> 和 <code>file</code> 的 API 使用很类似：可以进行<code>read</code>、<code>write</code>、<code>open</code>、<code>close</code>等操作。</p>
<p>现在的网络系统是分层的，理论上有<a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener">OSI模型</a>，工业界有<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">TCP/IP协议簇</a>。其对比如下：</p>
<center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2V0wfbmqJ.eBjy1zbXXbx8FXa_!!581166664.gif" alt=" osi vs tcp/ip"><br></center><br>每层上都有其相应的协议，socket API 不属于TCP/IP协议簇，只是操作系统提供的一个用于网络编程的接口，工作在应用层与传输层之间：<br><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB2fzkbbhmJ.eBjy0FhXXbBdFXa_!!581166664.gif" alt="where socket works in tcp/ip"><br></center>

<p>我们平常浏览网站所使用的http协议，收发邮件用的smtp与imap，都是基于 socket API 构建的。</p>
<p>一个 socket，包含两个必要组成部分：</p>
<ol>
<li>地址，由 ip 与 端口组成，像<code>192.168.0.1:80</code>。</li>
<li>协议，socket 所是用的传输协议，目前有三种：<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">TCP</a>、<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener">UDP</a>、<a href="https://en.wikipedia.org/wiki/Raw_socket" target="_blank" rel="noopener">raw IP</a>。</li>
</ol>
<p>地址与协议可以确定一个socket；一台机器上，只允许存在一个同样的socket。TCP 端口 53 的 socket 与 UDP 端口 53 的 socket 是两个不同的 socket。</p>
<p>根据 socket 传输数据方式的不同（使用协议不同），可以分为以下三种：</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Stream_socket" target="_blank" rel="noopener">Stream sockets</a>，也称为“面向连接”的 socket，使用 TCP 协议。实际通信前需要进行连接，传输的数据没有特定的结构，所以高层协议需要自己去界定数据的分隔符，但其优势是数据是可靠的。</li>
<li><a href="https://en.wikipedia.org/wiki/Datagram_socket" target="_blank" rel="noopener">Datagram sockets</a>，也称为“无连接”的 socket，使用 UDP 协议。实际通信前不需要连接，一个优势时 UDP 的数据包自身是可分割的（self-delimiting），也就是说每个数据包就标示了数据的开始与结束，其劣势是数据不可靠。</li>
<li><a href="https://en.wikipedia.org/wiki/Raw_socket" target="_blank" rel="noopener">Raw sockets</a>，通常用在路由器或其他网络设备中，这种 socket 不经过TCP/IP协议簇中的传输层（transport layer），直接由网络层（Internet layer）通向应用层（Application layer），所以这时的数据包就不会包含 tcp 或 udp 头信息。<br><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2qOeFX3hJc1FjSZFDXXbvnFXa_!!581166664.png_310x310.jpg" alt=" 数据包在各个层间的变更"><br></center><h2 id="Python-socket-API"><a href="#Python-socket-API" class="headerlink" title="Python socket API"></a>Python socket API</h2></li>
</ol>
<p>Python 里面用<code>(ip, port)</code>的元组来表示 socket 的地址属性，用<code>AF_*</code>来表示协议类型。<br>数据通信有两组动词可供选择：<code>send/recv</code> 或 <code>read/write</code>。<code>read/write</code> 方式也是 Java 采用的方式，这里不会对这种方式进行过多的解释，但是需要注意的是：</p>
<blockquote>
<p><code>read/write</code> 操作的具有 buffer 的“文件”，所以在进行读写后需要调用<code>flush</code>方法去真正发送或读取数据，否则数据会一直停留在缓冲区内。</p>
</blockquote>
<h3 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h3><p>TCP socket 由于在通信前需要建立连接，所以其模式较 UDP socket 复杂些。具体如下：</p>
<center><br><img width="400px" height="700px" src="https://img.alicdn.com/imgextra/i1/581166664/TB2egBSbOKO.eBjSZPhXXXqcpXa_!!581166664.png_620x10000.jpg" alt="TCP socket API "><br></center>

<p>API 的具体含义这里不在赘述，可以查看<a href="https://en.wikipedia.org/wiki/Berkeley_sockets#Socket_API_functions" target="_blank" rel="noopener">手册</a>，这里给出 Python 语言实现的 echo server。</p>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_tcp_echo/echo_server.py" target="_blank" rel="noopener">echo_server.py</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(client_sock, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">'new client from %s:%s'</span> % addr)</span><br><span class="line">        msg = client_sock.recv(<span class="number">100</span>)</span><br><span class="line">        client_sock.send(msg)</span><br><span class="line">        print(<span class="string">'received data[%s] from %s:%s'</span> % ((msg,) + addr))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        client_sock.close()</span><br><span class="line">        print(<span class="string">'client[%s:%s] socket closed'</span> % addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket</span></span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind((<span class="string">''</span>, <span class="number">5500</span>))</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        client_sock, addr = sock.accept()</span><br><span class="line">        handler(client_sock, addr)</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_tcp_echo/echo_client.py" target="_blank" rel="noopener">echo_client.py</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    data_to_sent = <span class="string">'hello tcp socket'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect((<span class="string">''</span>, <span class="number">5500</span>))</span><br><span class="line"></span><br><span class="line">        sent = sock.send(data_to_sent)</span><br><span class="line">        print(sock.recv(<span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br><span class="line">print(<span class="string">'socket closed'</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码有一点需要注意：server 端的 socket 设置了<code>SO_REUSEADDR</code>为1，目的是可以立即使用处于<code>TIME_WAIT</code>状态的socket，那么<code>TIME_WAIT</code>又是什么意思呢？后面在讲解 <a href="#TCP_的状态机">tcp 状态机</a>时再做详细介绍。</p>
<h3 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h3><center><br><img width="400px" height="400px" src="https://img.alicdn.com/imgextra/i3/581166664/TB2.pEmbmGI.eBjSspcXXcVjFXa_!!581166664.jpg_620x10000.jpg" alt=" udp_socket_api"><br></center>

<p>UDP 版的 socket server 的代码在进行<code>bind</code>后，无需调用<code>listen</code>方法。</p>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_udp_echo/echo_server.py" target="_blank" rel="noopener">udp_echo_server.py</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket</span></span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">''</span>, <span class="number">5500</span>))</span><br><span class="line"><span class="comment"># 没有调用 listen</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        data, addr = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'new client from %s:%s'</span> % addr)</span><br><span class="line">        sock.sendto(data, addr)</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_udp_echo/echo_client.py" target="_blank" rel="noopener">udp_echo_client.py</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">udp_server_addr = (<span class="string">''</span>, <span class="number">5500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    data_to_sent = <span class="string">'hello udp socket'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sent = sock.sendto(data_to_sent, udp_server_addr)</span><br><span class="line">        data, server = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">'receive data:[%s] from %s:%s'</span> % ((data,) + server))</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br></pre></td></tr></table></figure>
<h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><h3 id="忽略返回值"><a href="#忽略返回值" class="headerlink" title="忽略返回值"></a>忽略返回值</h3><p>本文中的 echo server 示例因为篇幅限制，也忽略了返回值。网络通信是个非常复杂的问题，通常无法保障通信双方的网络状态，很有可能在发送/接收数据时失败或部分失败。所以有必要对发送/接收函数的返回值进行检查。本文中的 tcp echo client 发送数据时，正确写法应该如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total_send = <span class="number">0</span></span><br><span class="line">content_length = len(data_to_sent)</span><br><span class="line"><span class="keyword">while</span> total_send &lt; content_length:</span><br><span class="line">    sent = sock.send(data_to_sent[total_send:])</span><br><span class="line">    <span class="keyword">if</span> sent == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"socket connection broken"</span>)</span><br><span class="line">    total_send += total_send + sent</span><br></pre></td></tr></table></figure>
<p>同理，接收数据时也应该检查返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chunks = []</span><br><span class="line">bytes_recd = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> bytes_recd &lt; MSGLEN:   <span class="comment"># MSGLEN 为实际数据大小</span></span><br><span class="line">    chunk = self.sock.recv(min(MSGLEN - bytes_recd, <span class="number">2048</span>))</span><br><span class="line">    <span class="keyword">if</span> chunk == <span class="string">b''</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"socket connection broken"</span>)</span><br><span class="line">    chunks.append(chunk)</span><br><span class="line">    bytes_recd = bytes_recd + len(chunk)</span><br><span class="line"><span class="keyword">return</span> <span class="string">b''</span>.join(chunks)</span><br></pre></td></tr></table></figure>
<p><code>send/recv</code>操作的是网络缓冲区的数据，它们不必处理传入的所有数据。</p>
<blockquote>
<p>一般来说，当网络缓冲区填满时，<a href="https://docs.python.org/3/library/socket.html#socket.socket.send" target="_blank" rel="noopener">send函数</a>就返回了；当网络缓冲区被清空时，<a href="https://docs.python.org/3/library/socket.html#socket.socket.recv" target="_blank" rel="noopener">recv 函数</a>就返回。</p>
</blockquote>
<p>可以通过下面的方式设置缓冲区大小。</p>
<pre><code>s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, buffer_size)  # 发送
s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, buffer_size)  # 接受
</code></pre><h3 id="误认为-TCP-具有-framing"><a href="#误认为-TCP-具有-framing" class="headerlink" title="误认为 TCP 具有 framing"></a>误认为 TCP 具有 framing</h3><p>TCP 不提供 framing，这使得其很适合于传输数据流。这是其与 UDP 的重要区别之一。UDP 是一个面向消息的协议，能保持一条消息在发送者与接受者之间的完备性。</p>
<center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2SB4bbB9J.eBjy0FoXXXyvpXa_!!581166664.gif" alt="Framing capabilities of UDP and the lack of framing in TCP"><br></center>

<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/tree/master/framing_assumptions" target="_blank" rel="noopener">framing_assumptions</a></p>
<h2 id="TCP-的状态机"><a href="#TCP-的状态机" class="headerlink" title="TCP 的状态机"></a>TCP 的状态机</h2><p>在前面echo server 的示例中，提到了TIME_WAIT状态，为了正式介绍其概念，需要了解下 TCP 从生成到结束的状态机。（<a href="https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.htm" target="_blank" rel="noopener">图片来源</a>）</p>
<center><br><img width="500px" height="600px" src="https://img.alicdn.com/imgextra/i2/581166664/TB2Us0HbNeK.eBjSZFlXXaywXXa_!!581166664.gif" alt=" tcp_state transition"><br></center>

<p>这个状图转移图非常非常关键，也比较复杂，总共涉及了 11 种状态。我自己为了方便记忆，对这个图进行了拆解，仔细分析这个图，可以得出这样一个结论：</p>
<blockquote>
<p>连接的打开与关闭有被动（passive）与主动（active）两种情况。主动关闭时，涉及到的状态转移最多，包括FIN_WAIT_1、FIN_WAIT_2、CLOSING、TIME_WAIT。（是不是有种 no zuo no die 的感觉）</p>
</blockquote>
<p>此外，由于 TCP 是可靠的传输协议，所以每次发送一个数据包后，都需要得到对方的确认（ACK），有了上面这两个知识后，再来看下面的图：（<a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">图片来源</a>）</p>
<center><br><img width="400px" height="500px" src="https://img.alicdn.com/imgextra/i4/581166664/TB2nwCFbNaK.eBjSZFwXXXjsFXa_!!581166664.jpg" alt=" tcp 关闭时的状态转移时序图"><br></center>

<p>我们重点分析上图中链接断开的过程，其中主动关闭端为 Client，被动关闭端为 Server 。</p>
<ol>
<li>Client 调用 <code>close</code> 方法的同时，会向 Server 发送一个 FIN，然后自己处于 FIN_WAIT_1 状态，在收到 server ACK 回应后变为 FIN_WAIT_2</li>
<li>Server 收到 FIN 后，向 Client 回复 ACK 确认，状态变化为 CLOSE_WAIT，然后开始进行一些清理工作</li>
<li>在 Server 清理工作完成后，会调用<code>close</code>方法，这时向 Client 发送 FIN 信号，状态变化为 LAST_ACK</li>
<li>Client 接收到 FIN 后，状态由 FIN_WAIT_2 变化为 TIME_WAIT，同时向 Server 回复 ACK</li>
<li>Server 收到 ACK 后，状态变化为 CLOSE，表明 Server 端的 socket 已经关闭</li>
<li>处于 TIME_WAIT 状态的 Client 不会立刻转为 CLOSED 状态，而是需要等待 2MSL（max segment life，一个数据包在网络传输中最大的生命周期），以确保 Server 能够收到最后发出的 ACK。如果 Server 没有收到最后的 ACK，那么 Server 就会重新发送 FIN，所以处于TIME_WAIT的 Client 会再次发送一个 ACK 信号，这么一来（FIN来）一回（ACK），正好是两个 MSL 的时间。如果等待的时间小于 2MSL，那么新的 socket 就可以收到之前连接的数据。</li>
</ol>
<p>上面是正常逻辑时的关闭顺序，如果任意一步出现问题都会导致 Socket 状态变化出现问题，下面说几种常见的问题：</p>
<ol>
<li>在上述过程第二步，回复完 ACK 后，如果忘记调用 CLOSE 方法，那么 Server 端在会一直处于 CLOSE_TIME 状态，处于 FIN_WAIT_2 状态的 Client 端会在 60 秒后超时，直接关闭。这个问题的具体案例可参考<a href="https://blog.cloudflare.com/this-is-strictly-a-violation-of-the-tcp-specification" target="_blank" rel="noopener">《This is strictly a violation of the TCP specification》</a></li>
<li>前面 echo server 的示例也说明了，处于 TIME_WAIT 并不是说一定不能使用，可以通过设置 socket 的 <code>SO_REUSEADDR</code> 属性以达到不用等待 2MSL 的时间就可以复用socket 的目的，当然，这仅仅适用于测试环境，正常情况下不要修改这个属性。</li>
</ol>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="HTTP-UA"><a href="#HTTP-UA" class="headerlink" title="HTTP UA"></a>HTTP UA</h3><p>http 协议是如今万维网的基石，可以通过 socket API 来简单模拟一个浏览器（UA）是如何解析 HTTP 协议数据的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket<span class="selector-class">.AF_INET</span>, socket.SOCK_STREAM)</span><br><span class="line">baidu_ip = socket.gethostbyname(<span class="string">'baidu.com'</span>)</span><br><span class="line">sock.connect((baidu_ip, <span class="number">80</span>))</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'connected to %s'</span> % baidu_ip)</span></span></span><br><span class="line"></span><br><span class="line">req_msg = [</span><br><span class="line">    <span class="string">'GET / HTTP/1.1'</span>,</span><br><span class="line">    <span class="string">'User-Agent: curl/7.37.1'</span>,</span><br><span class="line">    <span class="string">'Host: baidu.com'</span>,</span><br><span class="line">    <span class="string">'Accept: */*'</span>,</span><br><span class="line">]</span><br><span class="line">delimiter = <span class="string">'\r\n'</span></span><br><span class="line"></span><br><span class="line">sock.send(delimiter.join(req_msg))</span><br><span class="line">sock.send(delimiter)</span><br><span class="line">sock.send(delimiter)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'%sreceived%s'</span> % (<span class="string">'-'</span>*<span class="number">20</span>, <span class="string">'-'</span>*<span class="number">20</span>)</span></span>)</span><br><span class="line">http_response = sock.recv(<span class="number">4096</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(http_response)</span></span></span><br></pre></td></tr></table></figure>
<p>运行上面的代码可以得到下面的输出</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">--------------------received--------------------</span></span><br><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Tue,</span> <span class="number">01</span> <span class="string">Nov</span> <span class="number">2016</span> <span class="number">12</span><span class="string">:16:53</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Apache</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Tue,</span> <span class="number">12</span> <span class="string">Jan</span> <span class="number">2010</span> <span class="number">13</span><span class="string">:48:00</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">ETag:</span> <span class="string">"51-47cf7e6ee8400"</span></span><br><span class="line"><span class="attr">Accept-Ranges:</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">81</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">max-age=86400</span></span><br><span class="line"><span class="attr">Expires:</span> <span class="string">Wed,</span> <span class="number">02</span> <span class="string">Nov</span> <span class="number">2016</span> <span class="number">12</span><span class="string">:16:53</span> <span class="string">GMT</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;meta</span> <span class="string">http-equiv="refresh"</span> <span class="string">content="0;url=http://www.baidu.com/"&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>http_response</code>是通过直接调用<code>recv(4096)</code>得到的，万一真正的返回大于这个值怎么办？我们前面知道了 TCP 协议是面向流的，它本身并不关心消息的内容，需要应用程序自己去界定消息的边界，对于应用层的 HTTP 协议来说，有几种情况，最简单的一种时通过解析返回值头部的<code>Content-Length</code>属性，这样就知道<code>body</code>的大小了，对于 HTTP 1.1版本，支持<code>Transfer-Encoding: chunked</code>传输，对于这种格式，这里不在展开讲解，大家只需要知道， TCP 协议本身无法区分消息体就可以了。对这块感兴趣的可以查看 CPython 核心模块 <a href="https://github.com/python/cpython/blob/master/Lib/http/client.py" target="_blank" rel="noopener">http.client</a></p>
<h3 id="Unix-domain-socket"><a href="#Unix-domain-socket" class="headerlink" title="Unix_domain_socket"></a>Unix_domain_socket</h3><p>UDS 用于同一机器上不同进程通信的一种机制，其API适用与 network socket 很类似。只是其连接地址为本地文件而已。</p>
<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/uds_server.py" target="_blank" rel="noopener">uds_server.py</a>、<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/uds_client.py" target="_blank" rel="noopener">uds_client.py</a></p>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping 命令作为检测网络联通性最常用的工具，其适用的传输协议既不是TCP，也不是 UDP，而是 <a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol" target="_blank" rel="noopener">ICMP</a>。<br>ICMP 消息（messages）通常用于诊断 IP 协议产生的错误，traceroute 命令也是基于 ICMP 协议实现。利用 Python raw sockets API 可以模拟发送 ICMP 消息，实现类似 ping 的功能。</p>
<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/ping.py" target="_blank" rel="noopener">ping.py</a></p>
<h3 id="netstat-vs-ss"><a href="#netstat-vs-ss" class="headerlink" title="netstat vs ss"></a>netstat vs ss</h3><p>netstat 与 ss 都是类 Unix 系统上查看 Socket 信息的命令。netstat 是比较老牌的命令，常用的选择有</p>
<ul>
<li><code>-t</code>，只显示 tcp 连接</li>
<li><code>-u</code>，只显示 udp 连接</li>
<li><code>-n</code>，不用解析hostname，用 IP 显示主机，可以加快执行速度</li>
<li><code>-p</code>，查看连接的进程信息</li>
<li><code>-l</code>，只显示监听的连接</li>
</ul>
<p>ss 是新兴的命令，其选项和 netstat 差不多，主要区别是能够进行过滤（通过<code>state</code>与<code>exclude</code>关键字）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ss -o state time-wait -n | head</span></span><br><span class="line">Recv-Q Send-Q             Local Address:Port               Peer Address:Port</span><br><span class="line">0      0                 10.200.181.220:2222              10.200.180.28:12865  timer:(timewait,33sec,0)</span><br><span class="line">0      0                      127.0.0.1:45977                 127.0.0.1:3306   timer:(timewait,46sec,0)</span><br><span class="line">0      0                      127.0.0.1:45945                 127.0.0.1:3306   timer:(timewait,6.621ms,0)</span><br><span class="line">0      0                 10.200.181.220:2222              10.200.180.28:12280  timer:(timewait,12sec,0)</span><br><span class="line">0      0                 10.200.181.220:2222              10.200.180.28:35045  timer:(timewait,43sec,0)</span><br><span class="line">0      0                 10.200.181.220:2222              10.200.180.28:42675  timer:(timewait,46sec,0)</span><br><span class="line">0      0                      127.0.0.1:45949                 127.0.0.1:3306   timer:(timewait,11sec,0)</span><br><span class="line">0      0                      127.0.0.1:45954                 127.0.0.1:3306   timer:(timewait,21sec,0)</span><br><span class="line">0      0               ::ffff:127.0.0.1:3306           ::ffff:127.0.0.1:45964  timer:(timewait,31sec,0)</span><br></pre></td></tr></table></figure>
<p>这两个命令更多用法可以参考：</p>
<ul>
<li><a href="http://www.cyberciti.biz/files/ss.html" target="_blank" rel="noopener">SS Utility: Quick Intro</a></li>
<li><a href="http://www.binarytides.com/linux-netstat-command-examples/" target="_blank" rel="noopener">10 basic examples of linux netstat command</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们的生活已经离不开网络，平时的开发也充斥着各种复杂的网络应用，从最基本的数据库，到各种分布式系统，不论其应用层怎么复杂，其底层传输数据的的协议簇是一致的。Socket 这一概念我们很少直接与其打交道，但是当我们的系统出现问题时，往往是对底层的协议认识不足造成的，希望这篇文章能对大家编程网络方面的程序有所帮助。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.python.org/3/howto/sockets.html" target="_blank" rel="noopener">Socket Programming HOWTO</a></li>
<li><a href="https://benohead.com/tcp-about-fin_wait_2-time_wait-and-close_wait/" target="_blank" rel="noopener">TCP: About FIN_WAIT_2, TIME_WAIT and CLOSE_WAIT</a></li>
<li><a href="http://www.ibm.com/developerworks/library/l-sockpit/" target="_blank" rel="noopener">Five pitfalls of Linux sockets programming</a></li>
<li><a href="http://www.ibm.com/developerworks/linux/tutorials/l-sock/" target="_blank" rel="noopener">Programming Linux sockets, Part 1: Using TCP/IP</a></li>
<li><a href="http://stackoverflow.com/questions/10328675/how-to-know-content-length" target="_blank" rel="noopener">http://stackoverflow.com/questions/10328675/how-to-know-content-length</a></li>
<li><a href="http://electronicdesign.com/what-s-difference-between/what-s-difference-between-osi-seven-layer-network-model-and-tcpip" target="_blank" rel="noopener">What’s The Difference Between The OSI Seven-Layer Network Model And TCP/IP?</a></li>
<li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li>
<li><a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html" target="_blank" rel="noopener">Coping with the TCP TIME-WAIT state on busy Linux servers</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2016/10/31/socket-programming/" data-id="ckdkzhqnq003g6yljc6aotf3i" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3aQY4DIQxE0dz/0ow026ShqkwiYT6rKJ0GXhYWxn695DH+x/yb96fz37zPo78VDhgwYBzLGNOhLKZsRVllPtv8LRgwYNzAyELhfMmn32TvLvYMAwYMGCbJ/VNgwIAB4xsBVw++2VMYMGDAyJJYJTXV2W5w35aLw4AB40CGWxj45ecv1jdgwIBxCGOYo1KM1Oe0dwUDBozWDLeRYkRj3oSh4xfhGAYMGE0ZWfjbFVIzxgcMDBgwLmDMX9ADdFaSNK7+n/YJAwaM1gy9GOkuuaulzNgPDBgwrmEogVIPhdnB0U2kYcCA0ZuhJKj6YbGe7matHjBgwOjNcNvCjJTSTFP1o+EiI4cBA0ZThnu5pkxUOVa6IRsGDBg3MFylXoCsFwOMtWDAgNGU4TZGuE+zlHjD2RYGDBiNGFkSu7flq1KcKOXiMGDAOIqhb6WyUWWL+rt2tIYBA8axjEoZQNmiHl71pg27EgsDBozDGe7ySprqJsBuW8bjzDBgwGjKcM+MboOXkqDqR8DHfcKAAeMCRnYczMqc9daKDzPDgAGjNSO7n6sUO5UAnR1DYcCA0ZUxzOEe9dzv9aeLW0MYMGA0YlTas+ZTZw0Z9RIpDBgwujLcIKtfw9Uv9Yz/HgYMGBcw6mHUbapwx6JUAAMGDBhRU5desKzcm8GAAQOGm0zqV2zuYVEqD8CAAaM1w22AyC7mlEJp1jQGAwaM3gw35OlJbHbQdMM3DBgwWjP+AGqlQc94iOoIAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/python/">Python</a></div><div class="post-nav"><a class="pre" href="/blog/2016/11/07/run-2-marathon-in-a-week/">我为什么一周内连跑 2 个马拉松</a><a class="next" href="/blog/2016/06/30/python2-encoding/">Python2 中的编码问题</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2016/10/31/socket-programming/';
    this.page.identifier = 'blog/2016/10/31/socket-programming/';
    this.page.title = 'Socket 编程实战';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">26</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/08/08/go-meet-java/">实践总结：在 Java 中调用 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/14/go-struct-interface/">Go struct/interface 最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/02/review-2019/">2019 年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Socket 编程实战 - Keep Coding</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="刘家财" /><meta name="description" content="Socket 在英文中的含义为“（连接两个物品的）凹槽”，像the eye socket，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常" /><meta name="keywords" content="lisp, clojure, emacs, database, life" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="https://liujiacai.net/blog/2016/10/31/socket-programming/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Socket 编程实战" />
<meta property="og:description" content="Socket 在英文中的含义为“（连接两个物品的）凹槽”，像the eye socket，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liujiacai.net/blog/2016/10/31/socket-programming/" />
<meta property="article:published_time" content="2016-10-31T16:24:17+00:00" />
<meta property="article:modified_time" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="name" content="Socket 编程实战">
<meta itemprop="description" content="Socket 在英文中的含义为“（连接两个物品的）凹槽”，像the eye socket，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常">
<meta itemprop="datePublished" content="2016-10-31T16:24:17+00:00" />
<meta itemprop="dateModified" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="wordCount" content="4291">



<meta itemprop="keywords" content="Python," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Socket 编程实战"/>
<meta name="twitter:description" content="Socket 在英文中的含义为“（连接两个物品的）凹槽”，像the eye socket，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Keep Coding</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/podcast/">
        <li class="mobile-menu-item">Podcast</li>
      </a><a href="/blogrolls/">
        <li class="mobile-menu-item">友链</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Keep Coding</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/podcast/">Podcast</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/blogrolls/">友链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Socket 编程实战</h1>

      <div class="post-meta">
        <span class="post-time"> 2016-10-31 </span>
        <div class="post-category">
            <a href="/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 理解计算机 </a>
            </div>
          <span class="more-meta"> 约 4291 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#概述">概述</a>
          <ul>
            <li><a href="#tcp-socket">TCP socket</a></li>
            <li><a href="#udp-socket">UDP socket</a></li>
          </ul>
        </li>
        <li><a href="#常见陷阱">常见陷阱</a>
          <ul>
            <li><a href="#忽略返回值">忽略返回值</a></li>
            <li><a href="#误认为-tcp-具有-framing">误认为 TCP 具有 framing</a></li>
          </ul>
        </li>
        <li><a href="#tcp-的状态机">TCP 的状态机</a></li>
        <li><a href="#实战">实战</a>
          <ul>
            <li><a href="#http-ua">HTTP UA</a></li>
            <li><a href="#unix_domain_socket">Unix_domain_socket</a></li>
            <li><a href="#ping">ping</a></li>
            <li><a href="#netstat-vs-ss">netstat vs ss</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Socket 在英文中的含义为“（连接两个物品的）凹槽”，像<code>the eye socket</code>，意为“眼窝”，此外还有“插座”的意思。在计算机科学中，socket 通常是指一个连接的两个端点，这里的连接可以是同一机器上的，像<a href="https://en.wikipedia.org/wiki/Unix_domain_socket">unix domain socket</a>，也可以是不同机器上的，像<a href="https://en.wikipedia.org/wiki/Network_socket">network socket</a>。</p>
<p>本文着重介绍现在用的最多的 network socket，包括其在网络模型中的位置、API 的编程范式、常见错误等方面，最后用 Python 语言中的 socket API 实现几个实际的例子。Socket 中文一般翻译为“套接字”，不得不说这是个让人摸不着头脑的翻译，我也没想到啥“信达雅”的翻译，所以本文直接用其英文表述。本文中所有代码均可在 <a href="https://github.com/jiacai2050/socket.py">socket.py</a> 仓库中找到。</p>
<h2 id="概述">概述</h2>
<p>Socket 作为一种通用的技术规范，首次是由 Berkeley 大学在 1983 为 4.2BSD Unix 提供的，后来逐渐演化为 POSIX 标准。Socket API 是由操作系统提供的一个编程接口，让应用程序可以控制使用 socket 技术。Unix 哲学中有一条<code>一切皆为文件</code>，所以 <code>socket</code> 和 <code>file</code> 的 API 使用很类似：可以进行<code>read</code>、<code>write</code>、<code>open</code>、<code>close</code>等操作。</p>
<p>现在的网络系统是分层的，理论上有<a href="https://en.wikipedia.org/wiki/OSI_model">OSI模型</a>，工业界有<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP协议簇</a>。其对比如下：</p>
<center>
<img src="https://img.alicdn.com/imgextra/i2/581166664/TB2V0wfbmqJ.eBjy1zbXXbx8FXa_!!581166664.gif" alt=" osi vs tcp/ip"/>
</center>
每层上都有其相应的协议，socket API 不属于TCP/IP协议簇，只是操作系统提供的一个用于网络编程的接口，工作在应用层与传输层之间：
<center>
<img src="https://img.alicdn.com/imgextra/i3/581166664/TB2fzkbbhmJ.eBjy0FhXXbBdFXa_!!581166664.gif" alt="where socket works in tcp/ip"/>
</center>
<p>我们平常浏览网站所使用的http协议，收发邮件用的smtp与imap，都是基于 socket API 构建的。</p>
<p>一个 socket，包含两个必要组成部分：</p>
<ol>
<li>地址，由 ip 与 端口组成，像<code>192.168.0.1:80</code>。</li>
<li>协议，socket 所是用的传输协议，目前有三种：<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>、<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>、<a href="https://en.wikipedia.org/wiki/Raw_socket">raw IP</a>。</li>
</ol>
<p>地址与协议可以确定一个socket；一台机器上，只允许存在一个同样的socket。TCP 端口 53 的 socket 与 UDP 端口 53 的 socket 是两个不同的 socket。</p>
<p>根据 socket 传输数据方式的不同（使用协议不同），可以分为以下三种：</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Stream_socket">Stream sockets</a>，也称为“面向连接”的 socket，使用 TCP 协议。实际通信前需要进行连接，传输的数据没有特定的结构，所以高层协议需要自己去界定数据的分隔符，但其优势是数据是可靠的。</li>
<li><a href="https://en.wikipedia.org/wiki/Datagram_socket">Datagram sockets</a>，也称为“无连接”的 socket，使用 UDP 协议。实际通信前不需要连接，一个优势时 UDP 的数据包自身是可分割的（self-delimiting），也就是说每个数据包就标示了数据的开始与结束，其劣势是数据不可靠。</li>
<li><a href="https://en.wikipedia.org/wiki/Raw_socket">Raw sockets</a>，通常用在路由器或其他网络设备中，这种 socket 不经过TCP/IP协议簇中的传输层（transport layer），直接由网络层（Internet layer）通向应用层（Application layer），所以这时的数据包就不会包含 tcp 或 udp 头信息。</li>
</ol>
<center>
<img src="https://img.alicdn.com/imgextra/i4/581166664/TB2qOeFX3hJc1FjSZFDXXbvnFXa_!!581166664.png_310x310.jpg" alt=" 数据包在各个层间的变更"/>
</center>
## Python socket API
<p>Python 里面用<code>(ip, port)</code>的元组来表示 socket 的地址属性，用<code>AF_*</code>来表示协议类型。
数据通信有两组动词可供选择：<code>send/recv</code> 或 <code>read/write</code>。<code>read/write</code> 方式也是 Java 采用的方式，这里不会对这种方式进行过多的解释，但是需要注意的是：</p>
<blockquote>
<p><code>read/write</code> 操作的具有 buffer 的“文件”，所以在进行读写后需要调用<code>flush</code>方法去真正发送或读取数据，否则数据会一直停留在缓冲区内。</p>
</blockquote>
<h3 id="tcp-socket">TCP socket</h3>
<p>TCP socket 由于在通信前需要建立连接，所以其模式较 UDP socket 复杂些。具体如下：</p>
<center>
<img width="400px" height="700px" src="https://img.alicdn.com/imgextra/i1/581166664/TB2egBSbOKO.eBjSZPhXXXqcpXa_!!581166664.png_620x10000.jpg" alt="TCP socket API "/>
</center>
<p>API 的具体含义这里不在赘述，可以查看<a href="https://en.wikipedia.org/wiki/Berkeley_sockets#Socket_API_functions">手册</a>，这里给出 Python 语言实现的 echo server。</p>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_tcp_echo/echo_server.py">echo_server.py</a></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;new client from </span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">addr</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">client_sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">client_sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;received data[</span><span class="si">%s</span><span class="s1">] from </span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">msg</span><span class="p">,)</span> <span class="o">+</span> <span class="n">addr</span><span class="p">))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;client[</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">] socket closed&#39;</span> <span class="o">%</span> <span class="n">addr</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">5500</span><span class="p">))</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">client_sock</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="n">handler</span><span class="p">(</span><span class="n">client_sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_tcp_echo/echo_client.py">echo_client.py</a></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">
<span class="kn">import</span> <span class="nn">socket</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">data_to_sent</span> <span class="o">=</span> <span class="s1">&#39;hello tcp socket&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">5500</span><span class="p">))</span>

        <span class="n">sent</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data_to_sent</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;socket closed&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>上面代码有一点需要注意：server 端的 socket 设置了<code>SO_REUSEADDR</code>为1，目的是可以立即使用处于<code>TIME_WAIT</code>状态的socket，那么<code>TIME_WAIT</code>又是什么意思呢？后面在讲解 <a href="#TCP_%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA">tcp 状态机</a>时再做详细介绍。</p>
<h3 id="udp-socket">UDP socket</h3>
<center>
<img width="400px" height="400px" src="https://img.alicdn.com/imgextra/i3/581166664/TB2.pEmbmGI.eBjSspcXXcVjFXa_!!581166664.jpg_620x10000.jpg" alt=" udp_socket_api"/>
</center>
<p>UDP 版的 socket server 的代码在进行<code>bind</code>后，无需调用<code>listen</code>方法。</p>
<ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_udp_echo/echo_server.py">udp_echo_server.py</a></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>
<span class="c1"># 设置 SO_REUSEADDR 后,可以立即使用 TIME_WAIT 状态的 socket</span>
<span class="n">sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">5500</span><span class="p">))</span>
<span class="c1"># 没有调用 listen</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;new client from </span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">addr</span><span class="p">)</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://github.com/jiacai2050/socket.py/blob/master/simple_udp_echo/echo_client.py">udp_echo_client.py</a></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">udp_server_addr</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">5500</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">)</span>
    <span class="n">data_to_sent</span> <span class="o">=</span> <span class="s1">&#39;hello udp socket&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">data_to_sent</span><span class="p">,</span> <span class="n">udp_server_addr</span><span class="p">)</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">server</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;receive data:[</span><span class="si">%s</span><span class="s1">] from </span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">data</span><span class="p">,)</span> <span class="o">+</span> <span class="n">server</span><span class="p">))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="常见陷阱">常见陷阱</h2>
<h3 id="忽略返回值">忽略返回值</h3>
<p>本文中的 echo server 示例因为篇幅限制，也忽略了返回值。网络通信是个非常复杂的问题，通常无法保障通信双方的网络状态，很有可能在发送/接收数据时失败或部分失败。所以有必要对发送/接收函数的返回值进行检查。本文中的 tcp echo client 发送数据时，正确写法应该如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">total_send</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">content_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_to_sent</span><span class="p">)</span>
<span class="k">while</span> <span class="n">total_send</span> <span class="o">&lt;</span> <span class="n">content_length</span><span class="p">:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data_to_sent</span><span class="p">[</span><span class="n">total_send</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">sent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&#34;socket connection broken&#34;</span><span class="p">)</span>
    <span class="n">total_send</span> <span class="o">+=</span> <span class="n">total_send</span> <span class="o">+</span> <span class="n">sent</span>
</code></pre></td></tr></table>
</div>
</div><p>同理，接收数据时也应该检查返回值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">bytes_recd</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">bytes_recd</span> <span class="o">&lt;</span> <span class="n">MSGLEN</span><span class="p">:</span>   <span class="c1"># MSGLEN 为实际数据大小</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">MSGLEN</span> <span class="o">-</span> <span class="n">bytes_recd</span><span class="p">,</span> <span class="mi">2048</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">chunk</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&#34;socket connection broken&#34;</span><span class="p">)</span>
    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
    <span class="n">bytes_recd</span> <span class="o">=</span> <span class="n">bytes_recd</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
<span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>    
</code></pre></td></tr></table>
</div>
</div><p><code>send/recv</code>操作的是网络缓冲区的数据，它们不必处理传入的所有数据。</p>
<blockquote>
<p>一般来说，当网络缓冲区填满时，<a href="https://docs.python.org/3/library/socket.html#socket.socket.send">send函数</a>就返回了；当网络缓冲区被清空时，<a href="https://docs.python.org/3/library/socket.html#socket.socket.recv">recv 函数</a>就返回。</p>
</blockquote>
<p>可以通过下面的方式设置缓冲区大小。</p>
<pre><code>s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, buffer_size)  # 发送
s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, buffer_size)  # 接受
</code></pre>
<h3 id="误认为-tcp-具有-framing">误认为 TCP 具有 framing</h3>
<p>TCP 不提供 framing，这使得其很适合于传输数据流。这是其与 UDP 的重要区别之一。UDP 是一个面向消息的协议，能保持一条消息在发送者与接受者之间的完备性。</p>
<center>
<img src="https://img.alicdn.com/imgextra/i4/581166664/TB2SB4bbB9J.eBjy0FoXXXyvpXa_!!581166664.gif" alt="Framing capabilities of UDP and the lack of framing in TCP"/>
</center>
<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/tree/master/framing_assumptions">framing_assumptions</a></p>
<h2 id="tcp-的状态机">TCP 的状态机</h2>
<p>在前面echo server 的示例中，提到了TIME_WAIT状态，为了正式介绍其概念，需要了解下 TCP 从生成到结束的状态机。（<a href="https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.htm">图片来源</a>）</p>
<center>
<img width="500px" height="600px" src="https://img.alicdn.com/imgextra/i2/581166664/TB2Us0HbNeK.eBjSZFlXXaywXXa_!!581166664.gif" alt=" tcp_state transition"/>
</center>
<p>这个状图转移图非常非常关键，也比较复杂，总共涉及了 11 种状态。我自己为了方便记忆，对这个图进行了拆解，仔细分析这个图，可以得出这样一个结论：</p>
<blockquote>
<p>连接的打开与关闭有被动（passive）与主动（active）两种情况。主动关闭时，涉及到的状态转移最多，包括FIN_WAIT_1、FIN_WAIT_2、CLOSING、TIME_WAIT。（是不是有种 no zuo no die 的感觉）</p>
</blockquote>
<p>此外，由于 TCP 是可靠的传输协议，所以每次发送一个数据包后，都需要得到对方的确认（ACK），有了上面这两个知识后，再来看下面的图：（<a href="http://coolshell.cn/articles/11564.html">图片来源</a>）</p>
<center>
<img width="400px" height="500px" src="https://img.alicdn.com/imgextra/i4/581166664/TB2nwCFbNaK.eBjSZFwXXXjsFXa_!!581166664.jpg" alt=" tcp 关闭时的状态转移时序图"/>
</center>
<p>我们重点分析上图中链接断开的过程，其中主动关闭端为 Client，被动关闭端为 Server 。</p>
<ol>
<li>Client 调用 <code>close</code> 方法的同时，会向 Server 发送一个 FIN，然后自己处于 FIN_WAIT_1 状态，在收到 server ACK 回应后变为 FIN_WAIT_2</li>
<li>Server 收到 FIN 后，向 Client 回复 ACK 确认，状态变化为 CLOSE_WAIT，然后开始进行一些清理工作</li>
<li>在 Server 清理工作完成后，会调用<code>close</code>方法，这时向 Client 发送 FIN 信号，状态变化为 LAST_ACK</li>
<li>Client 接收到 FIN 后，状态由 FIN_WAIT_2 变化为 TIME_WAIT，同时向 Server 回复 ACK</li>
<li>Server 收到 ACK 后，状态变化为 CLOSE，表明 Server 端的 socket 已经关闭</li>
<li>处于 TIME_WAIT 状态的 Client 不会立刻转为 CLOSED 状态，而是需要等待 2MSL（max segment life，一个数据包在网络传输中最大的生命周期），以确保 Server 能够收到最后发出的 ACK。如果 Server 没有收到最后的 ACK，那么 Server 就会重新发送 FIN，所以处于TIME_WAIT的 Client 会再次发送一个 ACK 信号，这么一来（FIN来）一回（ACK），正好是两个 MSL 的时间。如果等待的时间小于 2MSL，那么新的 socket 就可以收到之前连接的数据。</li>
</ol>
<p>上面是正常逻辑时的关闭顺序，如果任意一步出现问题都会导致 Socket 状态变化出现问题，下面说几种常见的问题：</p>
<ol>
<li>在上述过程第二步，回复完 ACK 后，如果忘记调用 CLOSE 方法，那么 Server 端在会一直处于 CLOSE_TIME 状态，处于 FIN_WAIT_2 状态的 Client 端会在 60 秒后超时，直接关闭。这个问题的具体案例可参考<a href="https://blog.cloudflare.com/this-is-strictly-a-violation-of-the-tcp-specification">《This is strictly a violation of the TCP specification》</a></li>
<li>前面 echo server 的示例也说明了，处于 TIME_WAIT 并不是说一定不能使用，可以通过设置 socket 的 <code>SO_REUSEADDR</code> 属性以达到不用等待 2MSL 的时间就可以复用socket 的目的，当然，这仅仅适用于测试环境，正常情况下不要修改这个属性。</li>
</ol>
<h2 id="实战">实战</h2>
<h3 id="http-ua">HTTP UA</h3>
<p>http 协议是如今万维网的基石，可以通过 socket API 来简单模拟一个浏览器（UA）是如何解析 HTTP 协议数据的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
baidu_ip = socket.gethostbyname(&#39;baidu.com&#39;)
sock.connect((baidu_ip, 80))
print(&#39;connected to %s&#39; % baidu_ip)

req_msg = [
    &#39;GET / HTTP/1.1&#39;,
    &#39;User-Agent: curl/7.37.1&#39;,
    &#39;Host: baidu.com&#39;,
    &#39;Accept: */*&#39;,
]
delimiter = &#39;\r\n&#39;

sock.send(delimiter.join(req_msg))
sock.send(delimiter)
sock.send(delimiter)

print(&#39;%sreceived%s&#39; % (&#39;-&#39;*20, &#39;-&#39;*20))
http_response = sock.recv(4096)
print(http_response)
</code></pre></td></tr></table>
</div>
</div><p>运行上面的代码可以得到下面的输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">--------------------received--------------------
HTTP/1.1 200 OK
Date: Tue, 01 Nov 2016 12:16:53 GMT
Server: Apache
Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT
ETag: &#34;51-47cf7e6ee8400&#34;
Accept-Ranges: bytes
Content-Length: 81
Cache-Control: max-age=86400
Expires: Wed, 02 Nov 2016 12:16:53 GMT
Connection: Keep-Alive
Content-Type: text/html

&lt;html&gt;
&lt;meta http-equiv=&#34;refresh&#34; content=&#34;0;url=http://www.baidu.com/&#34;&gt;
&lt;/html&gt;
</code></pre></td></tr></table>
</div>
</div><p><code>http_response</code>是通过直接调用<code>recv(4096)</code>得到的，万一真正的返回大于这个值怎么办？我们前面知道了 TCP 协议是面向流的，它本身并不关心消息的内容，需要应用程序自己去界定消息的边界，对于应用层的 HTTP 协议来说，有几种情况，最简单的一种时通过解析返回值头部的<code>Content-Length</code>属性，这样就知道<code>body</code>的大小了，对于 HTTP 1.1版本，支持<code>Transfer-Encoding: chunked</code>传输，对于这种格式，这里不在展开讲解，大家只需要知道， TCP 协议本身无法区分消息体就可以了。对这块感兴趣的可以查看 CPython 核心模块 <a href="https://github.com/python/cpython/blob/master/Lib/http/client.py">http.client</a></p>
<h3 id="unix_domain_socket">Unix_domain_socket</h3>
<p>UDS 用于同一机器上不同进程通信的一种机制，其API适用与 network socket 很类似。只是其连接地址为本地文件而已。</p>
<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/uds_server.py">uds_server.py</a>、<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/uds_client.py">uds_client.py</a></p>
<h3 id="ping">ping</h3>
<p>ping 命令作为检测网络联通性最常用的工具，其适用的传输协议既不是TCP，也不是 UDP，而是 <a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>。
ICMP 消息（messages）通常用于诊断 IP 协议产生的错误，traceroute 命令也是基于 ICMP 协议实现。利用 Python raw sockets API 可以模拟发送 ICMP 消息，实现类似 ping 的功能。</p>
<p>代码示例参考：<a href="https://github.com/jiacai2050/socket.py/blob/master/in_action/ping.py">ping.py</a></p>
<h3 id="netstat-vs-ss">netstat vs ss</h3>
<p>netstat 与 ss 都是类 Unix 系统上查看 Socket 信息的命令。netstat 是比较老牌的命令，常用的选择有</p>
<ul>
<li><code>-t</code>，只显示 tcp 连接</li>
<li><code>-u</code>，只显示 udp 连接</li>
<li><code>-n</code>，不用解析hostname，用 IP 显示主机，可以加快执行速度</li>
<li><code>-p</code>，查看连接的进程信息</li>
<li><code>-l</code>，只显示监听的连接</li>
</ul>
<p>ss 是新兴的命令，其选项和 netstat 差不多，主要区别是能够进行过滤（通过<code>state</code>与<code>exclude</code>关键字）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ ss -o state time-wait -n <span class="p">|</span> head
Recv-Q Send-Q             Local Address:Port               Peer Address:Port
<span class="m">0</span>      <span class="m">0</span>                 10.200.181.220:2222              10.200.180.28:12865  timer:<span class="o">(</span>timewait,33sec,0<span class="o">)</span>
<span class="m">0</span>      <span class="m">0</span>                      127.0.0.1:45977                 127.0.0.1:3306   timer:<span class="o">(</span>timewait,46sec,0<span class="o">)</span>
<span class="m">0</span>      <span class="m">0</span>                      127.0.0.1:45945                 127.0.0.1:3306   timer:<span class="o">(</span>timewait,6.621ms,0<span class="o">)</span>
<span class="m">0</span>      <span class="m">0</span>                 10.200.181.220:2222              10.200.180.28:12280  timer:<span class="o">(</span>timewait,12sec,0<span class="o">)</span>
<span class="m">0</span>      <span class="m">0</span>                 10.200.181.220:2222              10.200.180.28:35045  timer:<span class="o">(</span>timewait,43sec,0<span class="o">)</span>
<span class="m">0</span>      <span class="m">0</span>                 10.200.181.220:2222              10.200.180.28:42675  timer:<span class="o">(</span>timewait,46sec,0<span class="o">)</span>
<span class="m">0</span>      <span class="m">0</span>                      127.0.0.1:45949                 127.0.0.1:3306   timer:<span class="o">(</span>timewait,11sec,0<span class="o">)</span>
<span class="m">0</span>      <span class="m">0</span>                      127.0.0.1:45954                 127.0.0.1:3306   timer:<span class="o">(</span>timewait,21sec,0<span class="o">)</span>
<span class="m">0</span>      <span class="m">0</span>               ::ffff:127.0.0.1:3306           ::ffff:127.0.0.1:45964  timer:<span class="o">(</span>timewait,31sec,0<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这两个命令更多用法可以参考：</p>
<ul>
<li><a href="http://www.cyberciti.biz/files/ss.html">SS Utility: Quick Intro</a></li>
<li><a href="http://www.binarytides.com/linux-netstat-command-examples/">10 basic examples of linux netstat command</a></li>
</ul>
<h2 id="总结">总结</h2>
<p>我们的生活已经离不开网络，平时的开发也充斥着各种复杂的网络应用，从最基本的数据库，到各种分布式系统，不论其应用层怎么复杂，其底层传输数据的的协议簇是一致的。Socket 这一概念我们很少直接与其打交道，但是当我们的系统出现问题时，往往是对底层的协议认识不足造成的，希望这篇文章能对大家编程网络方面的程序有所帮助。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://docs.python.org/3/howto/sockets.html">Socket Programming HOWTO</a></li>
<li><a href="https://benohead.com/tcp-about-fin_wait_2-time_wait-and-close_wait/">TCP: About FIN_WAIT_2, TIME_WAIT and CLOSE_WAIT</a></li>
<li><a href="http://www.ibm.com/developerworks/library/l-sockpit/">Five pitfalls of Linux sockets programming</a></li>
<li><a href="http://www.ibm.com/developerworks/linux/tutorials/l-sock/">Programming Linux sockets, Part 1: Using TCP/IP</a></li>
<li><a href="http://stackoverflow.com/questions/10328675/how-to-know-content-length">http://stackoverflow.com/questions/10328675/how-to-know-content-length</a></li>
<li><a href="http://electronicdesign.com/what-s-difference-between/what-s-difference-between-osi-seven-layer-network-model-and-tcpip">What’s The Difference Between The OSI Seven-Layer Network Model And TCP/IP?</a></li>
<li><a href="http://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a></li>
<li><a href="https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html">Coping with the TCP TIME-WAIT state on busy Linux servers</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">刘家财</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-12-04
        <a href="https://github.com/jiacai2050/jiacai2050.github.io/commit/8f8c30acc9eabc6498854bdbb13df6a4b744f17d" title="fix bad categories">(8f8c30a)</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python/">Python</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/blog/2016/11/07/run-2-marathon-in-a-week/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">我为什么一周内连跑 2 个马拉松</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/blog/2016/06/30/python2-encoding/">
            <span class="next-text nav-default">Python2 中的编码问题</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'jiacai2050';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jiacai2050&#43;blog@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/2163429/jiacai-liu" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.twitter.com/liujiacai" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/jiacai2050" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/liujiacai" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/jiacai2050" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/liujiacai/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://liujiacai.net/atom.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2014 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>刘家财</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-50745138-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>

<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>编程语言中的变量作用域与闭包 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">编程语言中的变量作用域与闭包</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">编程语言中的变量作用域与闭包</h1><div class="post-meta">May 28, 2016<span> | </span><span class="category"><a href="/categories/langs/">编程语言</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 11</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2016/05/28/scope-closure/" href="/blog/2016/05/28/scope-closure/#disqus_thread"></a><div class="post-content"><p>如果你写过 javascript，应该听说过<a href="https://en.wikipedia.org/wiki/JavaScript_syntax#hoisting" target="_blank" rel="noopener">变量提升</a>（hoisting），如果你自诩“Life is short, I use Python”，那么多多少少会用过<code>global</code>、<code>nonlocal</code>这两个关键字。无论新手还是老手，遇到这些时都会觉得很别扭，稍不留神就会出现意想不到的 bug，如果你仔细观察就会发现，它们其实是一个问题：变量作用域的问题。</p>
<p>其次，随着函数式编程的日趋火热，<a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" target="_blank" rel="noopener">闭包</a>逐渐成为了 buzzword，但我相信没几个人（希望你是那少数人）能够准确概括出闭包的精髓，而其实闭包这一概念也是解决变量作用域问题。</p>
<p>这篇文章首先介绍作用域相关的知识，主要是比较 dynamic scope 与 static(或lexical) scope 语言的优劣势；然后分析 Python 中为什么需要<code>global</code>和<code>nonlocal</code>，Javascript 为什么有<code>变量提升</code>，我这里不仅仅是介绍what，更重要的是why，要知道这两门语言的设计者都是深耕CS领域多年的老手，不会轻易犯错的，肯定有“不为人知”的一面，但遗憾的是网上大部分文章就是解释what，很少有涉及到why的，希望我这篇文章能够填充这一空缺；最后介绍闭包这一重要概念。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>简单来说，作用域限定了程序中变量的查找范围。</p>
<p>在编程语言中有子过程（subroutine，也称为函数、过程）之前，所有的变量都在一个称为“global”的环境中，现在来看这当然是非常不合理，所以在之后有子过程的大部分静态语言（变量的类型不可变）里面，不同的 block（像if、while、for、函数等），具有不同的环境。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);  <span class="comment">// error: use of undeclared identifier 'i'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码片段是一简单的 C 语言程序，在执行 if 代码块时，会新创建一个环境（称为E1，其外围环境为全局环境E0。见下图），然后在 E1 中定义变量<code>i</code>，在 if 代码块结束后，E1 这个环境就会被删除，这时 main 函数后面的程序就无法访问 if 代码块的变量了。</p>
<center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2SPDZpFXXXXaVXXXXXXXXXXXX_!!581166664.png" alt=" if 代码块示意图"><br></center>

<p>上面这一做法符合我们的直观印象，也是比较合理的设计。但是在一些动态语言（变量的类型可以任意改变）中，并没有变量声明与使用的区别，而是在第一次使用时去声明这个变量，像下面这个 Python 示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> i  <span class="comment"># 输出 1</span></span><br></pre></td></tr></table></figure></p>
<p>在 Python 中，执行 if 代码块时不会去创建新的环境，而是在 if 代码块所处的环境中去执行。</p>
<p>根据我目前所了解到的：</p>
<ul>
<li>静态语言（C、Java、C#等）具有块级别（block level，包含if、while、for、switch、函数等）的变量作用域；</li>
<li>动态语言（Javascript、Python、Ruby等）只具有函数级别（function level）的变量作用域</li>
</ul>
<h3 id="dynamic-scope-vs-static-scope"><a href="#dynamic-scope-vs-static-scope" class="headerlink" title="dynamic scope vs. static scope"></a>dynamic scope vs. static scope</h3><p>首先声明一点，这里的dynamic与static是指的变量的作用域，不是指变量的类型，与动态语言与静态语言要区分开。</p>
<p>在上面我们了解到，所有的高级语言都具有函数作用域。我们一般是这样使用函数的，先声明再使用，也就是说函数的声明与使用是分开的，这就涉及到一个问题，函数作用域的外围环境是声明时的还是运行时的呢？不同的外围环境对应不同的语言：</p>
<ul>
<li>dynamic scope 的语言，函数作用域的外围环境是<code>运行时</code></li>
<li>static scope 的语言，函数作用域的外围环境是<code>声明时</code></li>
</ul>
<p>看下面这个 Python 示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># foo.py</span></span><br><span class="line">s = <span class="string">"foo"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># bar.py</span></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> foo</span><br><span class="line">s = <span class="string">"bar"</span></span><br><span class="line">foo()   <span class="comment"># 输出 foo</span></span><br></pre></td></tr></table></figure></p>
<p>上面的示例包括两个文件：<code>foo.py</code>、<code>bar.py</code>，在<code>bar.py</code>中调用<code>foo.py</code>的<code>foo</code>函数，因为 Python 属于 static scope 的语言，所以这时的环境是这样的：</p>
<p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2yp6lpFXXXXXAXFXXXXXXXXXX_!!581166664.png" alt=" 在 bar 中调用 foo 函数时的环境示意图"><br></center><br>在调用 foo 时，会创建一新环境E1，E1 虽然是在 bar 的全局环境中创建的，但是其外围指向的是 foo 的全局环境。在执行 foo 函数时，变量的查找顺序是这样的：</p>
<ol>
<li>首先在 E1 中找到，找不到就会去其外围环境中去查找；找到则直接返回</li>
<li>在E1外围环境中查找，如果找到直接返回，如果找不到则再在外围环境的外围环境中继续查找，止到外围环境为空（foo、bar 模块的全局环境的外围指向均为空）</li>
<li>去语言内置的变量中去查找，找到则直接返回；找不到就会报错。</li>
</ol>
<p>static scope 是比较符合正常思维的，也是比较正确的实现方式，否则我们在使用第三份类库时，很容易就会发生变量冲突或覆盖的情况。采用 dynamic scope 的语言都是比较古老的，现在还比较常见的是 Shell，想想大家在写 Shell 时是多痛苦就知道 dynamic scope 是多么反人类了。</p>
<h2 id="JavaScript-中的变量作用域"><a href="#JavaScript-中的变量作用域" class="headerlink" title="JavaScript 中的变量作用域"></a>JavaScript 中的变量作用域</h2><p>就像前面说的，Javascript 具有 function level 的 static scope，但是这里有一个常见的问题，具体代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + i));</span><br><span class="line"></span><br><span class="line">    item.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"Item "</span> + i + <span class="string">" is clicked."</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    list.appendChild(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也许会想当然的认为依次单击时每个Item会依次显示1,2,3…，但其实这里无论你单击那个Item，都只会显示6，你可以去 <a href="https://jsfiddle.net/jiacai2050/w6agke9d/" target="_blank" rel="noopener">JSFiddle</a> 测试下。<br>究其原因，就是因为每个item click 所对应的回调函数的声明与执行是分开的，而且 Javascript 中只有 function level 的作用域，所以在单击Item时的环境是这样的：</p>
<p><center><br><img src="https://img.alicdn.com/imgextra/i4/581166664/TB2YEkppFXXXXXbXXXXXXXXXXXX_!!581166664.png" alt=" 使用 var 定义 i 时，单击 Item 时的环境模型示意图"><br></center><br>在 for 代码块执行完后，<code>i</code> 的值为6，又因为Javascript 中只有 function level 的作用域，所以这里的 <code>i</code> 被定义在了 E0 中。</p>
<p>为了解决这个问题，ES6 引入了<code>let</code>，使用<code>let</code>定义的变量具有 block level 的作用域，所以如果把上面的代码片段中的<code>var</code>换成<code>let</code>，环境会变成下面的形式：</p>
<p><center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB29sDTpFXXXXXpXpXXXXXXXXXX_!!581166664.png" alt=" 使用 let 定义 i 时，单击 Item 时的环境模型示意图"><br></center><br>相信大家通过上面的图示，可以解决心中的疑惑了。最后，给出一个思考，下面的代码片段输出什么值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"before"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">"after"</span>;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br><span class="line">bar(foo);   <span class="comment">// 输出 ？</span></span><br></pre></td></tr></table></figure></p>
<h3 id="hoisting"><a href="#hoisting" class="headerlink" title="hoisting"></a>hoisting</h3><p>先看一个比较典型的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p>
<p>你也许知道，这里弹出的值是10，而不是1，因为javascript会把所有的变量提前（hositing），也就是说，上面的代码等价于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        foo = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p>
<p>上面这个例子就简单演示了什么是变量提升，下面重点讲述为什么要这么设计？首先看下面一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> is_odd(n - <span class="number">1</span>);      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is_even(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> is_even(n - <span class="number">1</span>);      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按照常规思维，在运行<code>is_even(2);</code> 时，会去调用还没定义的<code>is_odd</code>函数，所以应该会报错，但是由于 Javascript 里面有 hositing，所以是可以运行，但是为什么要这么设计呢？<br>这要追溯到 Javascript 语言设计者的初衷了，Brendan Eich 在创造这门世界级语言时，一开始打算用 Scheme 的思想来实现，而且当时 Brendan 也是在看 SICP 这本书，<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.6" target="_blank" rel="noopener">SICP 4.1.6</a> 在介绍内部定义时，给出了解决变量同一时刻定义的一种解决方式：将所有的变量名提前。这样同一环境中的其他地方就能够使用所有的定义了。需要注意的是，这里只是将变量名提前，赋值的动作不变，显然，Javascript 采用了这一思想（这其实是<a href="https://en.wikipedia.org/wiki/Forward_declaration" target="_blank" rel="noopener">forward_declaration</a> 技术的一种实现手段）。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; SICP 书中的示例代码</span></span><br><span class="line">(<span class="name">lambda</span> &lt;vars&gt;</span><br><span class="line">  (<span class="name">define</span> u &lt;e1&gt;)</span><br><span class="line">  (<span class="name">define</span> v &lt;e2&gt;)</span><br><span class="line">  &lt;e3&gt;)</span><br><span class="line"><span class="comment">;; 转为下面的形式</span></span><br><span class="line">(<span class="name">lambda</span> &lt;vars&gt;</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">u</span> '*unassigned*)</span><br><span class="line">        (<span class="name">v</span> '*unassigned*))</span><br><span class="line">    (<span class="name">set!</span> u &lt;e1&gt;)</span><br><span class="line">    (<span class="name">set!</span> v &lt;e2&gt;)</span><br><span class="line">    &lt;e3&gt;))</span><br></pre></td></tr></table></figure></p>
<p>这个问题有人在 Twitter <a href="https://twitter.com/BrendanEich/status/33403701100154880" target="_blank" rel="noopener">问过 Brendan 这个问题</a>，Brendan是这么回答的：</p>
<blockquote>
<p>Function declaration hoisting is for mutual recursion &amp; generally to avoid painful bottom-up ML-like order</p>
</blockquote>
<p>对 Javascript 历史感兴趣的同学可以看看 Brendan 本人的自述：</p>
<ul>
<li><a href="https://brendaneich.com/2011/06/new-javascript-engine-module-owner/" target="_blank" rel="noopener">https://brendaneich.com/2011/06/new-javascript-engine-module-owner/</a></li>
</ul>
<h2 id="Python-中的变量作用域"><a href="#Python-中的变量作用域" class="headerlink" title="Python 中的变量作用域"></a>Python 中的变量作用域</h2><p>准确来说，Python 里面有四种作用域：<code>function</code>, <code>module</code>, <code>global</code>和 <code>class</code> 作用域。由于 Python 不区分变量的声明，所以在第一次初始化变量时（必须为赋值操作）将变量加入当前环境中。如果在没对变量进行初始化的情况下使用该变量就会报运行时异常，但如果仅仅是访问（并不赋值）的情况下，查找变量的顺序会按照 LEGB 规则 (Local, Enclosing, Global, Built-in)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"hello"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    s += <span class="string">"world"</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># UnboundLocalError: local variable 's' referenced before assignment</span></span><br></pre></td></tr></table></figure>
<p>由于在函数 foo 中在没有对 s 初始化的情况下使用了该值，所以这里会报异常，解决的办法就是使用 global 关键字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"hello"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> s</span><br><span class="line">    s += <span class="string">" world"</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># return "hello world"</span></span><br></pre></td></tr></table></figure></p>
<p>但由于 global 关键字只能限定在<code>global</code>作用域内查找变量，在有嵌套定义的时候就有问题了，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="string">"hello"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> s     <span class="comment"># NameError: global name 's' is not defined</span></span><br><span class="line">        s += <span class="string">" world"</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line">foo()()</span><br></pre></td></tr></table></figure></p>
<p>Python 3 中引入了 <code>nonlocal</code> 关键字来解决这个问题，：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="string">"hello"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> s</span><br><span class="line">        s += <span class="string">" world"</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line">foo()()   <span class="comment"># return "hello world"</span></span><br></pre></td></tr></table></figure></p>
<p>在 Python 2 中，我们可以通过引入一可变容器解决（其实就是绕过直接修改 <code>s</code> 的值）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    s = [<span class="string">"hello"</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        s[<span class="number">0</span>] += <span class="string">" world"</span></span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line">foo()()   <span class="comment"># return "hello world"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="类级别作用域"><a href="#类级别作用域" class="headerlink" title="类级别作用域"></a>类级别作用域</h3><p>还是先看代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    username = <span class="string">"Foo"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Hello %s"</span> % username</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">foo.say_hello()  <span class="comment"># NameError: global name 'username' is not defined</span></span><br></pre></td></tr></table></figure></p>
<p><code>username</code>是定义在<code>Foo</code>类级别的，内部的<code>say_hello</code>方法在查找自由变量<code>username</code>的作用域会按照上面说的LEGB 规则 (Local, Enclosing, Global, Built-in)，并不会去查找类级别作用域的变量，所以这里会报错。修改的方法也很简单：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello %s"</span> % Foo.username</span><br></pre></td></tr></table></figure></p>
<p>可以看到，Python 在试图省略掉变量声明的同时，反而造成了更复杂的情况，相关讨论在 Python mail-list 里面讨论也很火热，有兴趣的读者可以参考：</p>
<ul>
<li><a href="http://legacy.python.org/dev/peps/pep-3104/" target="_blank" rel="noopener">PEP 3104 – Access to Names in Outer Scopes</a></li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>还是先看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add3 = add(<span class="number">3</span>);</span><br><span class="line">alert(add3(<span class="number">4</span>));  <span class="comment">// return 7</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>add3</code>就是一闭包对象，它包括两部分，一个<code>函数</code>与声明函数时的<code>环境</code>。这就是闭包的核心，没有任何神奇的地方，闭包就是解决自由变量作用域的问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="noopener">JavaScript Scoping and Hoisting</a></li>
<li><a href="http://dmitrysoshnikov.com/notes/note-4-two-words-about-hoisting/" target="_blank" rel="noopener">Note 4. Two words about “hoisting”</a></li>
<li><a href="https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/" target="_blank" rel="noopener">ES6 In Depth: let and const</a></li>
<li><a href="https://docs.python.org/3.5/reference/executionmodel.html#interaction-with-dynamic-features" target="_blank" rel="noopener">The Python Language Reference 4. Execution model</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2016/05/28/scope-closure/" data-id="ck5w7gy37003jmalj3eag3l1t" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIUlEQVR42u3aSZLCMAwFUO5/6fQBKOBLcroq9suKYoofC6Hp9Yqv6+369Gry/uRTrzsuDAyMxzKur9f39+TI98fJz5ScDQMD4xzGp6/+9J7kqydhNz8bBgYGxndGHi57R8fAwMDoMQpf3UocMTAwMCZFbBJ8k8bZFVw31uIYGBgPZORd9/9/fMt8AwMD41GMq3jlA8vJscqnwsDA2JqR32bSSqsWq73zYGBg7MrohdfqekRvtSL/UTAwMPZmVG8Qxe94zFltqyU8DAyMXRnz0Nlb0Zg8H/17YGBgbMGYDAjzT/XuUlgBwcDAOICRp3TVNHGyhFG4OwYGxtaMXi7ZGwlMXs1TTwwMjP0YhfSrVaCuSjR/PIOBgbE1Iw98vUQwD53VIrY82cDAwHgsozpWrIbLaltt2WoFBgbGRozecSep4WRE2ly2wMDA2IgxKUTzBa8odE4SRAwMjAMYCSY/4qp0M8oAMTAwtmZUD5qkcb1iNa9MC11DDAyMLRjz5K83hsw/FY0iMDAwDmPkq1o9Xj4QzUekGBgYJzCqza9qmriqDVeoxTEwMLZg9ArXebnbC/eL628MDIyHMKqjxF4rf9VKR69hh4GBsQcjD7J3pHoLZhoYGBjHMPLAlzf6l7XSkq4aBgYGRkDqJYv5cX+EcgwMDIzBSCBZqpi05DAwMM5h9Ja6krIzX/aqLnlgYGCcwxiVjkFYrI4HquUxBgbG1ow/mK/6CHPF/U8AAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/javascript/">JavaScript</a><a href="/tags/python/">Python</a></div><div class="post-nav"><a class="pre" href="/blog/2016/06/30/python2-encoding/">Python2 中的编码问题</a><a class="next" href="/blog/2016/05/21/sicp-chapter5-summary/">SICP 第五章总结</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2016/05/28/scope-closure/';
    this.page.identifier = 'blog/2016/05/28/scope-closure/';
    this.page.title = '编程语言中的变量作用域与闭包';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">24</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/07/08/mark-sweep/">深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/06/15/garbage-collection-intro/">深入浅出垃圾回收（一）简介篇</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
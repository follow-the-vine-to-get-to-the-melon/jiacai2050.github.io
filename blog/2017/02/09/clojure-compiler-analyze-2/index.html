<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>Clojure 运行原理之字节码生成篇 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Clojure 运行原理之字节码生成篇</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Clojure 运行原理之字节码生成篇</h1><div class="post-meta">Feb 9, 2017<span> | </span><span class="category"><a href="/categories/langs/">编程语言</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2017/02/09/clojure-compiler-analyze-2/" href="/blog/2017/02/09/clojure-compiler-analyze-2/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类生成规则"><span class="toc-number">1.</span> <span class="toc-text">类生成规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态运行时"><span class="toc-number">2.</span> <span class="toc-text">动态运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOT-编译"><span class="toc-number">2.1.</span> <span class="toc-text">AOT 编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#core-init"><span class="toc-number">2.1.1.</span> <span class="toc-text">core__init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loading-5569-auto-36"><span class="toc-number">2.1.2.</span> <span class="toc-text">loading_5569_auto____36</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#core-main"><span class="toc-number">2.1.3.</span> <span class="toc-text">core$main</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DynamicClassLoader"><span class="toc-number">2.2.</span> <span class="toc-text">DynamicClassLoader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#慢启动"><span class="toc-number">3.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p><a href="/blog/2017/02/05/clojure-compiler-analyze/">上一篇文章</a>讲述了 Clojure 编译器工作的整体流程，主要涉及 LispReader 与 Compiler 这两个类，而且指出编译器并没有把 Clojure 转为相应的 Java 代码，而是直接使用 ASM 生成可运行在 JVM 中的 bytecode。本文将主要讨论 Clojure 编译成的 bytecode 如何实现动态运行时以及为什么 Clojure 程序启动慢，这会涉及到 JVM 的类加载机制。</p>
<h2 id="类生成规则"><a href="#类生成规则" class="headerlink" title="类生成规则"></a>类生成规则</h2><p>JVM 设计之初只是为 Java 语言考虑，所以最基本的概念是 class，除了八种基本类型，其他都是对象。Clojure 作为一本函数式编程语言，最基本的概念是函数，没有类的概念，那么 Clojure 代码生成以类为主的 bytecode 呢？</p>
<p>一种直观的想法是，每个命名空间（namespace）是一个类，命名空间里的函数相当于类的成员函数。但仔细想想会有如下问题：</p>
<ol>
<li>在 REPL 里面，可以动态添加、修改函数，如果一个命名空间相当于一个类，那么这个类会被反复加载</li>
<li>由于函数和字符串一样是一等成员，这意味这函数既可以作为参数、也可以作为返回值，如果函数作为类的方法，是无法实现的</li>
</ol>
<p>上述问题 2 就要求必须将函数编译成一个类。根据 <a href="https://clojure.org/reference/compilation" target="_blank" rel="noopener">Clojure 官方文档</a>，对应关系是这样的：</p>
<ul>
<li>函数生成一个类</li>
<li>每个文件（相当于一个命名空间）生成一个<code>&lt;filename&gt;__init</code> 的加载类</li>
<li><code>gen-class</code> 生成固定名字的类，方便与 Java 交互</li>
<li><code>defrecord</code>、<code>deftype</code>生成同名的类，<code>proxy</code>、<code>reify</code>生成匿名的类</li>
</ul>
<p>需要明确一点，只有在 AOT 编译时，Clojure 才会在本地生成 <code>.class</code> 文件，其他情况下生成的类均在内存中。</p>
<h2 id="动态运行时"><a href="#动态运行时" class="headerlink" title="动态运行时"></a>动态运行时</h2><p>明确了 Clojure 类生成规则后，下面介绍 Clojure 是如何实现动态运行时。这一问题将分为 AOT 编译与 DynamicClassLoader 类的实现两部分。</p>
<h3 id="AOT-编译"><a href="#AOT-编译" class="headerlink" title="AOT 编译"></a>AOT 编译</h3><p><img src="https://img.alicdn.com/imgextra/i3/581166664/TB26GwHd4xmpuFjSZFNXXXrRXXa_!!581166664.png" alt><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat src<span class="regexp">/how_clojure_work/</span>core.clj</span><br><span class="line"></span><br><span class="line">(ns how-clojure-work.core)</span><br><span class="line"></span><br><span class="line">(defn -main [&amp; _]</span><br><span class="line"> (<span class="keyword">println</span> <span class="string">"Hello, World!"</span>))</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>lein compile</code> 编译这个文件，会在<code>*compile-path*</code>指定的文件夹（一般是项目的<code>target</code>）下生成如下文件：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls target/classes/how_clojure_work/</span><br><span class="line"></span><br><span class="line">core$fn__38<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">core$loading__5569__auto____36<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">core$main<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">core__init<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>
<p><code>core$main.class</code>与<code>core__init.class</code>分别表示原文件的<code>main</code>函数与命名空间加载类，那么剩下两个类是从那里来的呢？</p>
<p>我们知道 Clojure 里面很多“函数”其实是用宏实现的，宏在编译时会进行展开，生成新代码，上面代码中的<code>ns</code>、<code>defn</code>都是宏，展开后（在 Cider + Emacs 开发环境下，<code>C-c  M-m</code>）可得<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">  (<span class="name"><span class="builtin-name">in-ns</span></span> 'how-clojure-work.core)</span><br><span class="line">  ((<span class="name">fn*</span></span><br><span class="line">     loading__5569__auto__</span><br><span class="line">     ([]</span><br><span class="line">       (<span class="name"><span class="builtin-name">.</span></span> clojure.lang.Var</span><br><span class="line">        (<span class="name">clojure.core/pushThreadBindings</span></span><br><span class="line">          &#123;clojure.lang.Compiler/LOADER</span><br><span class="line">           (<span class="name"><span class="builtin-name">.</span></span> (<span class="name"><span class="builtin-name">.</span></span> loading__5569__auto__ getClass) getClassLoader)&#125;))</span><br><span class="line">       (<span class="name"><span class="builtin-name">try</span></span></span><br><span class="line">         (<span class="name"><span class="builtin-name">refer</span></span> 'clojure.core)</span><br><span class="line">         (<span class="name">finally</span></span><br><span class="line">           (<span class="name"><span class="builtin-name">.</span></span> clojure.lang.Var (<span class="name">clojure.core/popThreadBindings</span>)))))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">.</span></span> 'how-clojure-work.core equals 'clojure.core)</span><br><span class="line">    <span class="literal">nil</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">      (<span class="name"><span class="builtin-name">.</span></span> clojure.lang.LockingTransaction</span><br><span class="line">       (<span class="name">clojure.core/runInTransaction</span></span><br><span class="line">         (<span class="name">fn*</span></span><br><span class="line">           ([]</span><br><span class="line">             (<span class="name"><span class="builtin-name">commute</span></span></span><br><span class="line">               (<span class="name"><span class="builtin-name">deref</span></span> #'clojure.core/*loaded-libs*)</span><br><span class="line">               conj</span><br><span class="line">               'how-clojure-work.core)))))</span><br><span class="line">      <span class="literal">nil</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> main (<span class="name">fn*</span> ([&amp; _] (<span class="name">println</span> <span class="string">"Hello, World!"</span>))))</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>ns</code>展开后的代码里面包含了两个匿名函数，对应本地上剩余的两个文件。下面依次分析这四个<code>class</code>文件</p>
<h4 id="core-init"><a href="#core-init" class="headerlink" title="core__init"></a>core__init</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ javap core__init<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">how_clojure_work</span>.<span class="title">core__init</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.Var const__0;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.AFn const__1;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.AFn const__2;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.Var const__3;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.AFn const__11;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">__init0</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Clojure 里面所有的函数都继承 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/IFn.java" target="_blank" rel="noopener">IFn 接口</a>，该接口有 20 个重载的 invoke 方法，之所以有这么多 invoke 方法，是因为 <a href="http://stackoverflow.com/a/2736636/2163429" target="_blank" rel="noopener">JVM 擅长根据参数数目进行方法调度（dispatch）</a>。<br><a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/AFn.java" target="_blank" rel="noopener">抽象类 AFn</a> 为 IFn 里的 20 个 invoke 方法提供了的默认实现（通过抛 throwArity 异常），这样其他函数就只需要继承 AFn 并重写相应 invoke 方法即可。</p>
</blockquote>
<p>可以看到，命名空间加载类里面有一些<code>Var</code>与<code>AFn</code>变量，可以认为一个<code>Var</code>对应一个<code>AFn</code>。使用 Intellj 或 <a href="http://jd.benow.ca/" target="_blank" rel="noopener">JD</a> 打开这个类文件，首先查看静态代码快。<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    __init0()<span class="comment">;</span></span><br><span class="line">    Compiler.pushNSandLoader(RT.classForName(<span class="string">"how_clojure_work.core__init"</span>).getClassLoader())<span class="comment">;</span></span><br><span class="line">    try &#123;</span><br><span class="line">        load()<span class="comment">;</span></span><br><span class="line">    &#125; catch (Throwable var1) &#123;</span><br><span class="line">        Var.popThreadBindings()<span class="comment">;</span></span><br><span class="line">        throw var1<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    Var.popThreadBindings()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面会先调用<code>__init0</code>：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> __init0() &#123;</span><br><span class="line">    const__0 = (Var)RT.<span class="keyword">var</span>(<span class="string">"clojure.core"</span>, <span class="string">"in-ns"</span>);</span><br><span class="line">    const__1 = (AFn)<span class="built_in">Symbol</span>.intern((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"how-clojure-work.core"</span>);</span><br><span class="line">    const__2 = (AFn)<span class="built_in">Symbol</span>.intern((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"clojure.core"</span>);</span><br><span class="line">    const__3 = (Var)RT.<span class="keyword">var</span>(<span class="string">"how-clojure-work.core"</span>, <span class="string">"main"</span>);</span><br><span class="line">    const__11 = (AFn)RT.map(<span class="keyword">new</span> <span class="built_in">Object</span>[] &#123;</span><br><span class="line">        RT.keyword((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"arglists"</span>), PersistentList.create(Arrays.asList(<span class="keyword">new</span> <span class="built_in">Object</span>[] &#123;</span><br><span class="line">            Tuple.create(<span class="built_in">Symbol</span>.intern((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"&amp;"</span>),</span><br><span class="line">            <span class="built_in">Symbol</span>.intern((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"_"</span>))</span><br><span class="line">        &#125;)),</span><br><span class="line">        RT.keyword((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"line"</span>), Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">        RT.keyword((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"column"</span>), Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">        RT.keyword((<span class="built_in">String</span>)<span class="keyword">null</span>, <span class="string">"file"</span>), <span class="string">"how_clojure_work/core.clj"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>RT</code> 是 Clojure runtime 的实现，在<code>__init0</code>里面会对命名空间里面出现的 var 进行赋值。</p>
<p>接下来是<code>pushNSandLoader</code>（内部用<code>pushThreadBindings</code>实现），它与后面的 <code>popThreadBindings</code> 形成一个 binding，功能等价下面的代码：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">binding</span> [clojure.core/*ns* <span class="literal">nil</span></span><br><span class="line">          clojure.core/*fn-loader* RT.classForName(<span class="string">"how_clojure_work.core__init"</span>).getClassLoader()</span><br><span class="line">          clojure.core/*read-eval <span class="literal">true</span>]</span><br><span class="line">  (<span class="name"><span class="builtin-name">load</span></span>))</span><br></pre></td></tr></table></figure></p>
<p>接着查看<code>load</code>的实现：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 in-ns，传入参数 how-clojure-work.core</span></span><br><span class="line">    ((IFn)const__0.getRawRoot()).invoke(const__1);</span><br><span class="line">    <span class="comment">// 执行 loading__5569__auto____36，功能等价于 (refer clojure.core)</span></span><br><span class="line">    ((IFn)(<span class="keyword">new</span> loading__5569__auto____36())).invoke();</span><br><span class="line">    Object var10002;</span><br><span class="line">    <span class="comment">// 如果当前的命名空间不是 clojure.core 那么会在一个 LockingTransaction 里执行 fn__38</span></span><br><span class="line">    <span class="comment">// 功能等价与(commute (deref #'clojure.core/*loaded-libs*) conj 'how-clojure-work.core)</span></span><br><span class="line">    <span class="keyword">if</span>(((Symbol)const__1).<span class="keyword">equals</span>(const__2)) &#123;</span><br><span class="line">        var10002 = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LockingTransaction.runInTransaction((Callable)(<span class="keyword">new</span> fn__38()));</span><br><span class="line">        var10002 = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Var var10003 = const__3;</span><br><span class="line">    <span class="comment">// 为 main 设置元信息，包括行号、列号等</span></span><br><span class="line">    const__3.setMeta((IPersistentMap)const__11);</span><br><span class="line">    var10003.bindRoot(<span class="keyword">new</span> main());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，命名空间加载类就分析完了。</p>
<h4 id="loading-5569-auto-36"><a href="#loading-5569-auto-36" class="headerlink" title="loading_5569_auto____36"></a>loading_5569_auto____36</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ javap core\$loading__5569__auto____36<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">Compiled</span> <span class="title">from</span> "<span class="title">core</span>.<span class="title">clj</span>"</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">class</span> <span class="title">how_clojure_work</span>.<span class="title">core$loading__5569__auto____36</span> <span class="keyword">extends</span> <span class="title">clojure</span>.<span class="title">lang</span>.<span class="title">AFunction</span> </span>&#123;</span><br><span class="line">  public static <span class="keyword">final</span> clojure.lang.<span class="type">Var</span> const__0;</span><br><span class="line">  public static <span class="keyword">final</span> clojure.lang.<span class="type">AFn</span> const__1;</span><br><span class="line">  public how_clojure_work.core$loading__5569__auto____36(); <span class="comment">// 构造函数</span></span><br><span class="line">  public java.lang.<span class="type">Object</span> invoke();</span><br><span class="line">  public static &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 <code>core__init</code> 类结构，包含一些 var 赋值与初始化函数，同时它还继承了<code>AFunction</code>，从名字就可以看出这是一个函数的实现。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是 var 赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Var const__0 = (Var)RT.var(<span class="string">"clojure.core"</span>, <span class="string">"refer"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AFn const__1 = (AFn)Symbol.intern((<span class="keyword">String</span>)<span class="keyword">null</span>, <span class="string">"clojure.core"</span>);</span><br><span class="line"><span class="comment">// invoke 是方法调用时的入口函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> invoke() &#123;</span><br><span class="line">    Var.pushThreadBindings((Associative)RT.mapUniqueKeys(<span class="keyword">new</span> <span class="keyword">Object</span>[]&#123;Compiler.LOADER, ((Class)<span class="keyword">this</span>.getClass()).getClassLoader()&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Object</span> var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var1 = ((IFn)const__0.getRawRoot()).invoke(const__1);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Var.popThreadBindings();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>invoke</code>方法等价于<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">binding</span> [<span class="name">Compiler.LOADER</span> (<span class="name">Class</span>)this.getClass()).getClassLoader()]</span><br><span class="line">  (<span class="name">refer</span> <span class="symbol">'clojure.core</span>))</span><br></pre></td></tr></table></figure></p>
<p><code>fn__38</code>与<code>loading__5569__auto____36</code> 类似， 这里不在赘述。</p>
<h4 id="core-main"><a href="#core-main" class="headerlink" title="core$main"></a>core$main</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ javap  core\$main.<span class="keyword">class</span></span><br><span class="line">Compiled <span class="keyword">from</span> <span class="string">"core.clj"</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> how_clojure_work.core$main <span class="keyword">extends</span> clojure.lang.RestFn &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> clojure.lang.Var const__0;</span><br><span class="line">  <span class="keyword">public</span> how_clojure_work.core$main();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> java.lang.Object invokeStatic(clojure.lang.ISeq);</span><br><span class="line">  <span class="keyword">public</span> java.lang.Object doInvoke(java.lang.Object);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> getRequiredArity();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>main</code>函数的参数数量是可变的，所以它继承了<code>RestFn</code>，除了 var 赋值外，重要的是以下两个函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Object <span class="title">invokeStatic</span><span class="params">(ISeq _)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// const__0 = (Var)RT.var("clojure.core", "println");</span></span><br><span class="line">    <span class="keyword">return</span> ((IFn)const__0.getRawRoot()).invoke(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">doInvoke</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">    ISeq var10000 = (ISeq)var1;</span><br><span class="line">    var1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">invokeStatic</span><span class="params">(var10000)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的分析，我们可以发现，每个函数在被调用时，会去调用<code>getRawRoot</code>函数得到该函数的实现，这种重定向是 Clojure 实现动态运行时非常重要一措施。这种重定向在开发时非常方便，可以用 <a href="https://github.com/clojure/tools.nrepl" target="_blank" rel="noopener">nrepl</a> 连接到正在运行的 Clojure 程序，动态修改程序的行为，无需重启。<br>但是在正式的生产环境，这种重定向对性能有影响，而且也没有重复定义函数的必要，所以可以在服务启动时指定<code>-Dclojure.compiler.direct-linking=true</code>来避免这类重定向，官方称为 <a href="https://clojure.org/reference/compilation#directlinking" target="_blank" rel="noopener">Direct linking</a>。可以在定义 var 时指定<code>^:redef</code>表示必须重定向。<code>^:dynamic</code>的 var 永远采用重定向的方式确定最终值。</p>
<p>需要注意的是，var 重定义对那些已经 direct linking 的代码是透明的。</p>
<h3 id="DynamicClassLoader"><a href="#DynamicClassLoader" class="headerlink" title="DynamicClassLoader"></a>DynamicClassLoader</h3><p>熟悉 JVM 类加载机制（不清楚的推荐我另一篇文章<a href="/blog/2014/07/12/order-of-initialization-in-java/">《JVM 的类初始化机制》</a>）的都会知道，</p>
<blockquote>
<p>一个类只会被一个 ClassLoader 加载一次。</p>
</blockquote>
<p>仅仅有上面介绍的重定向机制是无法实现动态运行时的，还需要一个灵活的 ClassLoader，可以在 REPL 做如下实验：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">user&gt;</span><span class="bash"> (defn foo [] 1)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">'user/foo</span></span></span><br><span class="line"><span class="meta">user&gt;</span><span class="bash"> (.. foo getClass getClassLoader)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">object[clojure.lang.DynamicClassLoader 0x72d256 <span class="string">"clojure.lang.DynamicClassLoader@72d256"</span>]</span></span><br><span class="line"><span class="meta">user&gt;</span><span class="bash"> (defn foo [] 1)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">'user/foo</span></span></span><br><span class="line"><span class="meta">user&gt;</span><span class="bash"> (.. foo getClass getClassLoader)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">object[clojure.lang.DynamicClassLoader 0x57e2068e <span class="string">"clojure.lang.DynamicClassLoader@57e2068e"</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，只要对一个函数进行了重定义，与之相关的 ClassLoader 随之也改变了。下面来看看 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/DynamicClassLoader.java#L72-L82" target="_blank" rel="noopener">DynamicClassLoader</a> 的核心实现：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放已经加载的类</span></span><br><span class="line"><span class="keyword">static</span> ConcurrentHashMap&lt;String, Reference&lt;<span class="keyword">Class</span>&gt;&gt;classCache =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, Reference&lt;<span class="keyword">Class</span>&gt; &gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// loadClass 会在一个类第一次主动使用时被 JVM 调用</span></span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">true<span class="keyword">Class</span> c = findLoadedClass(name);</span><br><span class="line">true<span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">truetruec = findInMemoryClass(name);</span><br><span class="line">truetrue<span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">truetruetruec = <span class="keyword">super</span>.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="keyword">if</span> (resolve)</span><br><span class="line">truetrueresolveClass(c);</span><br><span class="line">true<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户可以调用 defineClass 来动态生成类</span></span><br><span class="line"><span class="comment">// 每次调用时会先清空缓存里已加载的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span> defineClass(String name, <span class="keyword">byte</span>[] bytes, Object srcForm)&#123;</span><br><span class="line">trueUtil.clearCache(rq, classCache);</span><br><span class="line">true<span class="keyword">Class</span> c = defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    classCache.put(name, <span class="keyword">new</span> SoftReference(c,rq));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过搜索 Clojure 源码，只有在 <a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/RT.java#L2126" target="_blank" rel="noopener">RT.java 的 makeClassLoader 函数</a> 里面有<code>new DynamicClassLoader</code>语句，继续通过 Intellj 的 Find Usages 发现有如下三处调用<code>makeClassLoader</code>：<a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L7455" target="_blank" rel="noopener">Compiler/compile1</a>、<a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L6897" target="_blank" rel="noopener">Compiler/eval</a>、<a href="https://github.com/clojure/clojure/blob/clojure-1.8.0/src/jvm/clojure/lang/Compiler.java#L7352" target="_blank" rel="noopener">Compiler/load</a>。</p>
<p>正如<a href="/blog/2017/02/05/clojure-compiler-analyze/#Compiler-java">上一篇文章</a>的介绍，这三个方法正是 Compiler 的入口函数，这也就解释了上面 REPL 中的实验：</p>
<blockquote>
<p>每次重定义一个函数，都会生成一个新 DynamicClassLoader 实例去加载其实现。</p>
</blockquote>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>明白了 Clojure 是如何实现动态运行时，下面分析 Clojure 程序为什么启动慢。</p>
<p>首先需要明确一点，<a href="http://stackoverflow.com/questions/2163411/is-java-really-slow" target="_blank" rel="noopener">JVM 并不慢</a>，我们可以将之前的 Hello World 打成 uberjar，运行测试下时间。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;; (:gen-class) 指令能够生成与命名空间同名的类</span><br><span class="line">(ns how-clojure-work.core</span><br><span class="line">  (:gen-class))</span><br><span class="line"></span><br><span class="line">(defn -main [&amp; _]</span><br><span class="line">  (println <span class="string">"Hello, World!"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了能用 java -jar 方式运行，需要在 project.clj 中添加</span></span><br><span class="line"><span class="comment"># :main how-clojure-work.core</span></span><br><span class="line">$ lein uberjar</span><br><span class="line">$ time java -jar target/how-clojure-work-0.1.0-SNAPSHOT-standalone.jar</span><br><span class="line">Hello, World!</span><br><span class="line"></span><br><span class="line">real	0m0.900s</span><br><span class="line">user	0m1.422s</span><br><span class="line">sys	0m0.087s</span><br></pre></td></tr></table></figure></p>
<p>在启动时加入<code>-verbose:class</code> 参数，可以看到很多 clojure.core 开头的类<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[Loaded clojure.core$cond__GT__GT_ from <span class="string">file:</span><span class="regexp">/Users/</span>liujiacai<span class="regexp">/codes/</span>clojure<span class="regexp">/how-clojure-work/</span>target/how-clojure-work<span class="number">-0.1</span><span class="number">.0</span>-SNAPSHOT-standalone.jar]</span><br><span class="line">[Loaded clojure.core$as__GT_ from <span class="string">file:</span><span class="regexp">/Users/</span>liujiacai<span class="regexp">/codes/</span>clojure<span class="regexp">/how-clojure-work/</span>target/how-clojure-work<span class="number">-0.1</span><span class="number">.0</span>-SNAPSHOT-standalone.jar]</span><br><span class="line">[Loaded clojure.core$some__GT_ from <span class="string">file:</span><span class="regexp">/Users/</span>liujiacai<span class="regexp">/codes/</span>clojure<span class="regexp">/how-clojure-work/</span>target/how-clojure-work<span class="number">-0.1</span><span class="number">.0</span>-SNAPSHOT-standalone.jar]</span><br><span class="line">[Loaded clojure.core$some__GT__GT_ from <span class="string">file:</span><span class="regexp">/Users/</span>liujiacai<span class="regexp">/codes/</span>clojure<span class="regexp">/how-clojure-work/</span>target/how-clojure-work<span class="number">-0.1</span><span class="number">.0</span>-SNAPSHOT-standalone.jar]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>把生成的 uberjar 解压打开，可以发现 clojure.core 里面的函数都在，这些函数在程序启动时都会被加载。</p>
<center><br><img src="https://img.alicdn.com/imgextra/i2/581166664/TB2Hb_NdHXlpuFjSszfXXcSGXXa_!!581166664.png" alt="Clojure 版本 Hello World"><br></center>

<p>这就是 Clojure 启动慢的原因：加载大量用不到的类。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Clojure 作为一门 host 在 JVM 上的语言，其独特的实现方式让其拥动态的运行时的同时，方便与 Java 进行交互。当然，Clojure 还有很多可以提高的地方，比如上面的慢启动问题。另外，JVM 7 中增加了 <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html" target="_blank" rel="noopener">invokedynamic</a> 指令，可以让运行在 JVM 上的动态语言通过实现一个 CallSite （可以认为是函数调用）的 <code>MethodHandle</code> 函数来帮助编译器找到正确的实现，这无异会提升程序的执行速度。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.ndk.io/clojure-compilation2.html" target="_blank" rel="noopener">http://blog.ndk.io/clojure-compilation2.html</a></li>
<li><a href="http://stackoverflow.com/questions/7471316/how-does-clojure-class-reloading-work" target="_blank" rel="noopener">http://stackoverflow.com/questions/7471316/how-does-clojure-class-reloading-work</a></li>
<li><a href="http://blog.headius.com/2011/10/why-clojure-doesnt-need-invokedynamic.html" target="_blank" rel="noopener">http://blog.headius.com/2011/10/why-clojure-doesnt-need-invokedynamic.html</a></li>
<li><a href="http://www.deepbluelambda.org/programming/clojure/how-clojure-works-a-simple-namespace" target="_blank" rel="noopener">http://www.deepbluelambda.org/programming/clojure/how-clojure-works-a-simple-namespace</a></li>
<li><a href="https://8thlight.com/blog/aaron-lahey/2016/07/20/relationship-between-clojure-functions-symbols-vars-namespaces.html" target="_blank" rel="noopener">https://8thlight.com/blog/aaron-lahey/2016/07/20/relationship-between-clojure-functions-symbols-vars-namespaces.html</a></li>
<li><a href="http://blog.cognitect.com/blog/2016/9/15/works-on-my-machine-understanding-var-bindings-and-roots" target="_blank" rel="noopener">http://blog.cognitect.com/blog/2016/9/15/works-on-my-machine-understanding-var-bindings-and-roots</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2017/02/09/clojure-compiler-analyze-2/" data-id="ckhxlinwr003wszlj4bn6s8sf" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvElEQVR42u3aQQ7iMAwFUO5/aUaa1Uio8L/dwCxeV6iFNC9ItWvn8YiP59/j38+vx9XV1xHej/P626sRbjvw8PDwRlPPJ/2e8R7TTjRfxKuZ4OHh4Z3j5cGgDRVX001Gzr9zeR4PDw/vp7zN1U3gyUMLHh4e3v/Jy8sNs5AwW248PDy87/OSB/eslNCWcWdLfEOtBQ8PDy/mbSb6q8/H+3t4eHh4o676DQ/csgScpMvFbPHw8PAO8DbFhTaQ5G2t2eIWbwx4eHh4C15bIMjLB/stWcnIHxYXDw8P7wBv1vTaN/tnD/08mOHh4eGd4yW3uTflbcdP3gkuz+Dh4eEd4OU/22yuygsQeVIeRTk8PDy8A7x94aAlbZamLlXg4eHhHeDNSgNtgpun43nxIn8NwMPDwzvBayfRbghog0Rbga6r1Hh4eHgL3rmC7L1LUAeAdiA8PDy8m3hJytu2r2ZBaFYIxsPDwzvBywu1s7Q4mdamgBstEB4eHt6tvHbQfIqbjVPP+Pjw9+Dh4eEd4G1aWXmT7P35NoS06TUeHh7ead6siNCm4/em8tEbAx4eHt5hXpLyJlfzR3ybcBcj4OHh4d3Ky0sMswf3bItVnrJHGT0eHh7erbykkNpOJU/BZ6Xh5F54eHh4p3lt8ylfmrb8Ogtj0RsDHh4e3k28WSKbf39f6s2DzYdNV3h4eHhf4Z3bUtA2xtoggYeHh3eOlz+O282j0Xao0daE4dLg4eHh3cR7lsc+IZ610PKy74e4h4eHh7fm7VPeTQmj3WKVkIabD/Dw8PBK3iZR3rS1Wsaqv4eHh4d3gNfePt+AlZ/flHTry3h4eHhf4SVpcZs6b5DD1hceHh7eT3l5upz8dt8kW6XUeHh4eCUvL0bMirZJ2Jjd/cNy4OHh4R3gtQ2wfassScHzwPDYH3h4eHgp7w+UTA0BTKXkRwAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Clojure/">Clojure</a></div><div class="post-nav"><a class="pre" href="/blog/2017/03/05/method-vs-proc-in-ruby/">辨析 Ruby 中的 Method 与 Proc</a><a class="next" href="/blog/2017/02/05/clojure-compiler-analyze/">Clojure 运行原理之编译器剖析篇</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2017/02/09/clojure-compiler-analyze-2/';
    this.page.identifier = 'blog/2017/02/09/clojure-compiler-analyze-2/';
    this.page.title = 'Clojure 运行原理之字节码生成篇';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率工具/">效率工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">26</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/Emacs/" style="font-size: 15px;">Emacs</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/11/25/why-emacs/">Emacs 入门指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/08/08/go-meet-java/">实践总结：在 Java 中调用 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/14/go-struct-interface/">Go struct/interface 最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/02/review-2019/">2019 年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
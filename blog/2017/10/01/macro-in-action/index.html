<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>由浅入深学习 Lisp 宏之实战篇 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">由浅入深学习 Lisp 宏之实战篇</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">由浅入深学习 Lisp 宏之实战篇</h1><div class="post-meta">Oct 1, 2017<span> | </span><span class="category"><a href="/categories/langs/">编程语言</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2017/10/01/macro-in-action/" href="/blog/2017/10/01/macro-in-action/#disqus_thread"></a><div class="post-content"><p>本文是宏系列的第二篇文章，侧重于实战，对于新手建议先阅读宏系列的<a href="/blog/2017/08/31/master-macro-theory/">理论篇</a>，之后再来看本文。当然如果你有一定基础，也可以直接阅读本文。<br>其次，希望读者能把本文的 Clojure 代码手动敲到 REPL 里面去运行、调试，直到完全理解。</p>
<h2 id="Code-as-data"><a href="#Code-as-data" class="headerlink" title="Code as data"></a>Code as data</h2><p>在<a href="/blog/2017/08/31/master-macro-theory/">理论篇</a>中，介绍了宏（macro）的本质：<code>在编译时期运行的函数</code>。宏相对于普通函数，具有如下特点：</p>
<ol>
<li>宏的参数不会求值（eval），是 symbol 字面量</li>
<li>宏的返回值是 code（在运行期执行），不是一般的数据。</li>
</ol>
<p>这两条特性蕴含着一非常重要的思想： <a href="https://en.wikipedia.org/wiki/Homoiconicity" target="_blank" rel="noopener">code as data</a> ，也被称为同像性（homoiconicity，来自希腊语单词 homo，意为与符号含义表示相同）。同像性使得在 Lisp 中去操作语法树（AST）显得十分自然，而这在非 Lisp 语言只能由编译器（Compiler）去操作。这里举一典型的例子：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> when [test &amp; body]</span><br><span class="line">  (<span class="name"><span class="builtin-name">list</span></span> 'if test (<span class="name"><span class="builtin-name">cons</span></span> 'do body)))</span><br></pre></td></tr></table></figure>
<p><code>&#39;</code>代表 quote，作用是阻止后面的表达式求值，如果不使用<code>&#39;</code>的话，在进行<code>(list &#39;if test ...)</code>求值时会报错，因为对 special form 单独进行求值是非法的，这里需要的仅仅是 <code>if</code> 字面量，list 函数执行后的结果（是一个 list）作为 code 插入到调用 when 的地方去执行。</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">even?</span></span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">100</span>))</span><br><span class="line">  (<span class="name">println</span> <span class="string">"good luck!"</span>)</span><br><span class="line">  (<span class="name">println</span> <span class="string">"lisp rocks!"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; when 展开后的形式 </span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">even?</span></span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">100</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">do</span></span> (<span class="name">println</span> <span class="string">"good luck!"</span>) (<span class="name">println</span> <span class="string">"lisp rocks!"</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="syntax-quote-amp-unquote"><a href="#syntax-quote-amp-unquote" class="headerlink" title="syntax-quote &amp; unquote"></a>syntax-quote &amp; unquote</h3><p>对于一些简单的宏，可以采用像 when 那样的方式，使用 list 函数来形成要返回的 code，但对于复杂的宏，使用 list 函数来表示，会显得十分麻烦，看下 when-let 的实现：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> when-let [bindings &amp; body]</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [form (<span class="name">bindings</span> <span class="number">0</span>) tst (<span class="name">bindings</span> <span class="number">1</span>)]</span><br><span class="line">    `(<span class="name"><span class="builtin-name">let</span></span> [temp# ~tst]</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> temp#</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> [~form temp#]</span><br><span class="line">           ~@body)))))</span><br></pre></td></tr></table></figure>
<p>这里返回的 list 使用 <em>`</em>（backtick）进行了修饰，这称为 syntax-quote，它与 quote <code>&#39;</code> 类似，只不过在阻止表达式求值的同时，支持以下两个额外功能：</p>
<ol>
<li>表达式里的所有 symbol 会在当前 namespace 中进行 resolve，返回 fully-qualified symbol</li>
<li>允许通过 <code>~</code>(unquote) 或 <code>~@</code>(slicing-unquote) 阻止部分表达式的 quote，以达到对它们求值的效果</li>
</ol>
<p>可以通过下面一个例子来了解它们之间的区别：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [x '(<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">3</span>) y x]</span><br><span class="line">  (<span class="name">println</span> `y)</span><br><span class="line">  (<span class="name">println</span> ``y)</span><br><span class="line">  (<span class="name">println</span> ``~y)</span><br><span class="line">  (<span class="name">println</span> ``~~y)</span><br><span class="line">  (<span class="name">println</span> (<span class="name"><span class="builtin-name">eval</span></span> ``~~y))</span><br><span class="line">  (<span class="name">println</span> `[~@y]))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 依次输出</span></span><br><span class="line"></span><br><span class="line">user/y</span><br><span class="line">(<span class="name"><span class="builtin-name">quote</span></span> user/y)</span><br><span class="line">user/y</span><br><span class="line">(<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">[* <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>这里尤其要注意理解嵌套 syntax-quote 的情况，为了得到正确的值，需要 unquote 相应的次数（上例中的第四个println），这在 macro-writing macro 中十分有用，后面会介绍的。<br>最后需要注意一点，在整个 Clojure 程序生命周期中，<code>(syntax-)quote</code>, <code>(slicing-)unquote</code> 是 <a href="https://clojure.org/reference/reader" target="_blank" rel="noopener">Reader</a> 来解析的，详见 <a href="/blog/2017/02/05/clojure-compiler-analyze/#编译器工作流程">编译器工作流程</a>。可以通过<code>read-string</code>来验证：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user&gt; (read-string "`y")</span><br><span class="line">(<span class="name"><span class="builtin-name">quote</span></span> user/y)</span><br><span class="line">user&gt; (read-string "``y")</span><br><span class="line">(<span class="name">clojure.core/seq</span> (<span class="name">clojure.core/concat</span> (<span class="name">clojure.core/list</span> (<span class="name"><span class="builtin-name">quote</span></span> quote)) </span><br><span class="line">                                       (<span class="name">clojure.core/list</span> (<span class="name"><span class="builtin-name">quote</span></span> user/y))))</span><br><span class="line">user&gt; (read-string "``~y")</span><br><span class="line">(<span class="name"><span class="builtin-name">quote</span></span> user/y)</span><br><span class="line">user&gt; (read-string "``~~y")</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<h2 id="Macro-Rules-of-Thumb"><a href="#Macro-Rules-of-Thumb" class="headerlink" title="Macro Rules of Thumb"></a>Macro Rules of Thumb</h2><p>在正式实战前，这里摘抄 JoyOfClojure 一书中关于写宏的一般准则：</p>
<ol>
<li>如果函数能完成相应功能，不要写宏。在需要构造语法抽象（比如<code>when</code>）或新的binding 时再去用宏</li>
<li>写一个宏使用的 demo，并手动展开</li>
<li>使用<code>macroexpand</code>, <code>macroexpand-1</code> 与 <code>clojure.walk/macroexpand-all</code> 去验证宏是如何工作的</li>
<li>在 REPL 中测试</li>
<li>如果一个宏比较复杂，尽可能拆分成多个函数</li>
</ol>
<p>希望读者在写/读宏遇到困难时，思考是否对应了上述准则。</p>
<h2 id="In-Action"><a href="#In-Action" class="headerlink" title="In Action"></a>In Action</h2><p>前面介绍过，宏的一大应用场景是流程控制，比如上面介绍的 when、when-let，以及各种 do 的衍生品 dotimes、doseq，所以实战也从这里入手，构造一系列 do-primes，通过对它不断的完善修改，介绍写宏的技巧与注意事项。</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">do-primes</span> [n start end]</span><br><span class="line">  body)</span><br></pre></td></tr></table></figure>
<p>上面是 do-primes 的使用方式，它会遍历 <code>[start, end)</code> 范围内的素数，对于具体素数 n，执行 body 里面的内容。</p>
<h3 id="使用-gensym-保证宏-Hygiene"><a href="#使用-gensym-保证宏-Hygiene" class="headerlink" title="使用 gensym 保证宏 Hygiene"></a>使用 gensym 保证宏 Hygiene</h3><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> prime? [n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [guard (<span class="name"><span class="builtin-name">int</span></span> (<span class="name">Math/ceil</span> (<span class="name">Math/sqrt</span> n)))]</span><br><span class="line">    (<span class="name"><span class="builtin-name">loop</span></span> [i <span class="number">2</span>]</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">zero?</span></span> (<span class="name"><span class="builtin-name">mod</span></span> n i))</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> i guard)</span><br><span class="line">          <span class="literal">true</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">inc</span></span> i)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> next-prime [n]</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">prime?</span> n)</span><br><span class="line">    n</span><br><span class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name"><span class="builtin-name">inc</span></span> n))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes [[variable start end] &amp; body]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">loop</span></span> [~variable ~start]</span><br><span class="line">     (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~end)</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">         ~@body)</span><br><span class="line">       (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable))))))</span><br></pre></td></tr></table></figure>
<p>上面的实现比较直接，首先定义了两个辅助函数，然后通过返回由 loop 构成的 code 来达到遍历的效果。简单测试下：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">do-primes</span> [n <span class="number">2</span> <span class="number">13</span>]</span><br><span class="line">  (<span class="name">println</span> n))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">loop</span></span> [n <span class="number">2</span>]</span><br><span class="line">  (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n <span class="number">13</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">    (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 最终输出 3 5 7 11</span></span><br></pre></td></tr></table></figure>
<p>达到预期。但上述实现有些问题：end 在循环中进行比较时多次进行了求值，如果传入的 end 不是固定的数字，而是一个函数，而我们又无法确定这个函数有无副作用，这就可能产生问题。<br>也许你会说，这个解决也很简单，在进行 loop 之前，用一个 let 先把 end 的值先算出来就可以了。这个确实能解决多次执行的问题，但是又引入另一个隐患：<strong>end 先于 start 执行</strong>。这会不会产生不良后果，我们同样无法预知，我们能做到的就是<strong>尽量不用暴露宏的实现细节</strong>，具体表现就是<strong>保证宏参数的求值顺序</strong>。所以有了下面的修改：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2 [[variable start end] &amp; body]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [start# ~start</span><br><span class="line">         end# ~end]</span><br><span class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable start#]</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable end#)</span><br><span class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">           ~@body)</span><br><span class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">do-primes2</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name">println</span> n))</span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [start__17380__auto__ <span class="number">2</span> end__17381__auto__ (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n start__17380__auto__]</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n end__17381__auto__)</span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure>
<p>在 syntax-quote 里面，使用了 <code>name#</code> 的形式来定义 locals，这是 gensym 机制，用来生成全局唯一的 symbol，保证宏的“卫生”（<a href="http://clojure-doc.org/articles/language/macros.html#macro-hygiene-and-gensym" target="_blank" rel="noopener">hygiene</a>）。如果这里不使用 gensym，在 Common Lisp 里面可能会污染全局里面的同名变量，在 Clojure 里面，为了避免污染全局环境，name 部分会 resolve 成当前命名空间里面的变量，例如</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2-danger [[variable start end] &amp; body]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [inner-start ~start</span><br><span class="line">         inner-end ~end]</span><br><span class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable inner-start]</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable inner-end)</span><br><span class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">           ~@body)</span><br><span class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">do-primes2-danger</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">                        (<span class="name">println</span> n))</span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [user/inner-start <span class="number">2</span></span><br><span class="line">      user/inner-end (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n user/inner-start] </span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n user/inner-end) </span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) </span><br><span class="line">        (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure>
<p>通过宏展开的代码可以看到，这明显不是我们想要的，运行上述代码会直接报错<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException：Can'<span class="built_in">t</span> let qualified <span class="built_in">na</span><span class="symbol">me:</span> user/inner-start</span><br></pre></td></tr></table></figure></p>
<p>所以在定义内部 locals 时，一定要用 gensym 机制。如果能确保使用的名字不会造成污染，也可以使用 <code>~&#39;name</code> 的形式来避免 resolve 这一过程。<code>~&#39;name</code> 其实就是 <code>~(quote name)</code> 的简写，它在 syntax-quote 里面求值的结果就是 symbol 字面量 <code>name</code>：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes2-safe [[variable start end] &amp; body]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [~'inner-start ~start</span><br><span class="line">         ~'inner-end ~end]</span><br><span class="line">     (<span class="name"><span class="builtin-name">loop</span></span> [~variable ~'inner-start]</span><br><span class="line">       (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~'inner-end)</span><br><span class="line">         (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">           ~@body)</span><br><span class="line">         (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">do-primes2-safe</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">                 (<span class="name">println</span> n))</span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [inner-start <span class="number">2</span> inner-end (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n inner-start]</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n inner-end)</span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure>
<h3 id="Macro-writing-macro"><a href="#Macro-writing-macro" class="headerlink" title="Macro-writing macro"></a>Macro-writing macro</h3><p>通过上面的例子，我们知道，gensym 是一种非常实用的技巧，所以我们完全有可能再进行一次抽象，构造 only-once 宏，来保证传入的参数按照顺序只求值一次：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> only-once [names &amp; body]</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> [gensyms (<span class="name">repeatedly</span> (<span class="name"><span class="builtin-name">count</span></span> names) gensym)]</span><br><span class="line">    `(<span class="name"><span class="builtin-name">let</span></span> [~@(<span class="name">interleave</span> gensyms (<span class="name"><span class="builtin-name">repeat</span></span> '(<span class="name"><span class="builtin-name">gensym</span></span>)))]</span><br><span class="line">       `(<span class="name"><span class="builtin-name">let</span></span> [~~@(<span class="name"><span class="builtin-name">mapcat</span></span> #(<span class="name"><span class="builtin-name">list</span></span> %<span class="number">1</span> %<span class="number">2</span>) gensyms names)]</span><br><span class="line">          ~(<span class="name"><span class="builtin-name">let</span></span> [~@(<span class="name"><span class="builtin-name">mapcat</span></span> #(<span class="name"><span class="builtin-name">list</span></span> %<span class="number">1</span> %<span class="number">2</span>) names gensyms)]</span><br><span class="line">             ~@body)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> do-primes3 [[variable start end] &amp; body]</span><br><span class="line">  (<span class="name">only-once</span> [start end]</span><br><span class="line">             `(<span class="name"><span class="builtin-name">loop</span></span> [~variable ~start]</span><br><span class="line">                (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> ~variable ~end)</span><br><span class="line">                  (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> ~variable)</span><br><span class="line">                    ~@body)</span><br><span class="line">                  (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> ~variable)))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">do-primes3</span> [n <span class="number">2</span> (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name">println</span> n))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [G__18605 <span class="number">2</span> G__18606 (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n G__18605]</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n G__18606)</span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure>
<p>only-once 的核心思想是用 gensym 来替换掉传入的 symbol（即 names），为了达到这种效果，它首先定义出一组与参数数目相同的 gensyms（分别记为#s1 #s2），然后在第二层 let 为这些 gensyms 做 binding，value 也是用 gensym 生成的（分别记为#s3 #s4），这一层的 let 的返回值将内嵌到 do-primes3 内：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [#s1 #s3 #s2 #s4]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">let</span></span> [#s3 ~start #s3 ~end]</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> [start #s1 end #s2]</span><br><span class="line">      ~@body)))</span><br></pre></td></tr></table></figure>
<p>第三层 let 的结果作为 code 内嵌到调用 do-primes3 处，即最终的展开式：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> [#s3 <span class="number">2</span> #s4 (<span class="name"><span class="builtin-name">+</span></span> <span class="number">10</span> (<span class="name"><span class="builtin-name">rand-int</span></span> <span class="number">30</span>))]</span><br><span class="line">  (<span class="name"><span class="builtin-name">loop</span></span> [n #s3]</span><br><span class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n #s4)</span><br><span class="line">      (<span class="name"><span class="builtin-name">when</span></span> (<span class="name">prime?</span> n) (<span class="name">println</span> n))</span><br><span class="line">      (<span class="name"><span class="builtin-name">recur</span></span> (<span class="name">next-prime</span> (<span class="name"><span class="builtin-name">inc</span></span> n))))))</span><br></pre></td></tr></table></figure>
<p>根据上述分析过程，可以看到第四层嵌套的 let 先于第三层嵌套的 let 执行，第四层 let 做 binding 时，是把 #s1 对应的 #s3 赋值给 start，#s2 对应的 #s4 赋值给 end，这样就成功的实现了 symbol 的替换。</p>
<p>only-once 属于 macro-writing macro 的范畴，就是说它使用的对象本身还是个宏，所以有一定的难度，主要是分清不同表达式的求值环境，这一点对于理解这一类宏非常关键。不过这一类宏大家应该很少能见到，更多的时候是使用辅助函数来分解复杂宏。比如我们这里就使用了两个辅助函数 prime? next-prime 来简化宏的写法。下面一个例子会阐述这一点。</p>
<h3 id="使用辅助函数定义简化宏"><a href="#使用辅助函数定义简化宏" class="headerlink" title="使用辅助函数定义简化宏"></a>使用辅助函数定义简化宏</h3><p><code>def-watched</code> 可以定义一个受监控的 var，在 root binding 改变时打印前后的值</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> def-watched [name &amp; value]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">     (<span class="name"><span class="builtin-name">def</span></span> ~name ~@value)</span><br><span class="line">     (<span class="name"><span class="builtin-name">add-watch</span></span> (<span class="name"><span class="builtin-name">var</span></span> ~name)</span><br><span class="line">                <span class="symbol">:re-bind</span></span><br><span class="line">                (<span class="name"><span class="builtin-name">fn</span></span> [~'key ~'r old# new#]</span><br><span class="line">                  (<span class="name">println</span> '~name old# <span class="string">" -&gt; "</span> new#)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">def-watched</span> foo <span class="number">1</span>)                  </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> foo <span class="number">2</span>)</span><br><span class="line"><span class="comment">;; 这时打印 foo 1  -&gt;  2</span></span><br></pre></td></tr></table></figure>
<p>为了简化 def-watched，可能会想把里面的函数提取出来：</p>
<figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> gen-watch-fn [name]</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [k r o n]</span><br><span class="line">    (<span class="name">println</span> name <span class="string">":"</span> o <span class="string">" -&gt; "</span> n)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defmacro</span></span> def-watched2 [name &amp; value]</span><br><span class="line">  `(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">     (<span class="name"><span class="builtin-name">def</span></span> ~name ~@value)</span><br><span class="line">     (<span class="name"><span class="builtin-name">add-watch</span></span> (<span class="name"><span class="builtin-name">var</span></span> ~name)</span><br><span class="line">                <span class="symbol">:re-bind</span> (<span class="name">gen-watch-fn</span> '~name))))</span><br><span class="line"></span><br><span class="line">(<span class="name">def-watched2</span> bar <span class="number">1</span>)                  </span><br><span class="line"><span class="comment">;; 展开为</span></span><br><span class="line">(<span class="name"><span class="builtin-name">do</span></span> (<span class="name"><span class="builtin-name">def</span></span> bar <span class="number">1</span>) (<span class="name"><span class="builtin-name">add-watch</span></span> #'bar <span class="symbol">:re-bind</span> (<span class="name">gen-watch-fn</span> 'bar)))</span><br></pre></td></tr></table></figure>
<p>这时的效果和上面是一样的，请注意这里是把 gen-watch-fn 实现为了函数，如果用宏的话，会有什么效果呢？<br><figure class="highlight clj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 将 gen-watch-fn 改为 defmacro，其他均不变 </span></span><br><span class="line"><span class="comment">;; (def-watched2 bar 1) 展开后变成了</span></span><br><span class="line">(<span class="name"><span class="builtin-name">do</span></span></span><br><span class="line">  (<span class="name"><span class="builtin-name">def</span></span> bar <span class="number">1</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">add-watch</span></span></span><br><span class="line">    #'bar</span><br><span class="line">    <span class="symbol">:re-bind</span></span><br><span class="line">    #function[user/gen-watch-fn/fn--17288]))</span><br></pre></td></tr></table></figure></p>
<p>这直接会报 No matching ctor found for class #function[user/gen-watch-fn/fn–17288]，由于 gen-watch-fn 是宏，它返回的是 code，而不是一般的 data，这也就是问题发生的缘由。</p>
<p>回想本文一开始介绍的宏的两个特性：参数是否需要求值，返回值是 code 还是 data，这是决定是否用宏的关键。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文一开始就明确指出 Lisp 中 code as data 的特性，这一点表面看似比较好理解，但是放到具体环境中时，就十分容易搞错，所以还是要多写宏，实战岀真知。<br>实战部分介绍了一些注意事项以及管用技巧，引入了相比来说难以理解的 macro-writing marco，完全理解它有一定难度，但也不是无法入手，理清 quote unquote 的作用机制，并且在 REPL 中不断调试，肯定能有所收获。<br>虽说不推荐使用宏解决问题，但是在有些时候，一个简单的宏不仅仅能省掉好几十行代码，而且能使逻辑更清晰，这时候也就不要“吝啬”了。</p>
<p>最后，希望通过宏系列这两篇文章的介绍，大家能对宏有更深的理解。如果有问题，欢迎留言讨论！<br>Happy Lisp！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://8thlight.com/blog/colin-jones/2012/05/22/quoting-without-confusion.html" target="_blank" rel="noopener">Quoting Without Confusion</a></li>
<li><a href="https://clojure.org/reference/reader#syntax-quote" target="_blank" rel="noopener">https://clojure.org/reference/reader#syntax-quote</a></li>
<li><a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html" target="_blank" rel="noopener">http://www.gigamonkeys.com/book/macros-defining-your-own.html</a></li>
<li><a href="https://hubpages.com/technology/Clojure-macro-writing-macros" target="_blank" rel="noopener">https://hubpages.com/technology/Clojure-macro-writing-macros</a></li>
<li><a href="https://xivilization.net/~marek/blog/2013/09/17/clojure-and-hygienic-macros/" target="_blank" rel="noopener">https://xivilization.net/~marek/blog/2013/09/17/clojure-and-hygienic-macros/</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2017/10/01/macro-in-action/" data-id="ck5w7gy3t004pmalj9ysbehhi" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJUlEQVR42u3aQW7EIAwF0Ln/pdNtpemgbztTKfBYRW0GeFlY2Ob1isf1a7z//dPz+/vrOZNfjQYGBsZjGddyrJf8NEO+6fUMyd4wMDDOYXxaeP28nucuXrIWBgYGRrKJ/KiX/AoDAwNjzlgvnwTiJPXFwMDAqCax66nz8lwyvpiLY2BgPJCRV93///kr/Q0MDIxHMa7imPPyz1TYFQYGxtaM3lEvSUp774yOnhgYGAcw8vQ132LeTliX29YrYmBgnMDo5YnV0JmE7PkHxcDAOIGRtxvvej9vkeb/xcDA2IkxucjVWzJvQxaOlRgYGIcx8rR2clEsL8NFc2JgYGzN+EYCOQnW1U8TNQYwMDAezuhtel7WvzlaYmBgbM0oV+MG71fbkM16IQYGxnaMu8Loep58u82rFRgYGFszqs3I+QEuT1ObR0MMDIztGNWgmRfLem3L/ID4R7kNAwNjU8ZkumRzeTAdXbbAwMA4mNE7AvZam/kemmktBgbGwxlJeasaKHuXyQo3RD7dGcHAwDiGcdehsNoq6JXqMDAwzmTcFXCr7dJqOo2BgXEC4yqO6KvECeqkhRll2xgYGFswqmFuMvX8A0V3RjAwMDZl9C575cnnP0VFDAyMAxh51ptMnRTOJoEbAwMDo7fdvPQ2aUjcFnAxMDC2ZkwupPZaAlE5DwMD4wBGksQmV7uqW5+U4TAwMM5hTFLHvEiXB+hkrWZTEwMD43mMH1DHA/GBpQLqAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/Clojure/">Clojure</a></div><div class="post-nav"><a class="pre" href="/blog/2017/11/22/create-firefox-chrome-extensions-in-clojurescript/">使用 ClojureScript 开发浏览器插件的过程与收获</a><a class="next" href="/blog/2017/08/31/master-macro-theory/">由浅入深学习 Lisp 宏之理论篇</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2017/10/01/macro-in-action/';
    this.page.identifier = 'blog/2017/10/01/macro-in-action/';
    this.page.title = '由浅入深学习 Lisp 宏之实战篇';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">24</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/07/08/mark-sweep/">深入浅出垃圾回收（二）Mark-Sweep 详析及其优化</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/06/15/garbage-collection-intro/">深入浅出垃圾回收（一）简介篇</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
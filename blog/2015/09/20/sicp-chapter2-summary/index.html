<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>SICP 第二章总结 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SICP 第二章总结</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SICP 第二章总结</h1><div class="post-meta">Sep 20, 2015<span> | </span><span class="category"><a href="/categories/研习经典/">研习经典</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2015/09/20/sicp-chapter2-summary/" href="/blog/2015/09/20/sicp-chapter2-summary/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据抽象的意义"><span class="toc-number">1.</span> <span class="toc-text">数据抽象的意义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#过程抽象与数据抽象"><span class="toc-number">1.1.</span> <span class="toc-text">过程抽象与数据抽象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据抽象的语言支持"><span class="toc-number">2.</span> <span class="toc-text">数据抽象的语言支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#序对pair"><span class="toc-number">2.1.</span> <span class="toc-text">序对pair</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序对的操作"><span class="toc-number">2.2.</span> <span class="toc-text">序对的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据导向-vs-消息传递"><span class="toc-number">3.</span> <span class="toc-text">数据导向 vs. 消息传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-number">4.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#有理数运算"><span class="toc-number">4.1.</span> <span class="toc-text">有理数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Church数"><span class="toc-number">4.1.1.</span> <span class="toc-text">Church数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区间运算"><span class="toc-number">4.2.</span> <span class="toc-text">区间运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#八皇后问题"><span class="toc-number">4.3.</span> <span class="toc-text">八皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图形语言"><span class="toc-number">4.4.</span> <span class="toc-text">图形语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Huffman编码树🌲"><span class="toc-number">4.5.</span> <span class="toc-text">Huffman编码树🌲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复数的表示"><span class="toc-number">4.6.</span> <span class="toc-text">复数的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用型算术包的实现"><span class="toc-number">4.7.</span> <span class="toc-text">通用型算术包的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号代数——多项式算术"><span class="toc-number">4.8.</span> <span class="toc-text">符号代数——多项式算术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩充练习：有理函数"><span class="toc-number">4.9.</span> <span class="toc-text">扩充练习：有理函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>到今天为止终于把第二章看完了，相比于第一章，感觉难点少了些，这章主要是通过大量例子（主要有图形语言、区间运算、符号求导、集合的表示、通用型算术运算）来熟悉构造数据抽象的相关技能。下面来回顾总结一下第二章。</p>
<h2 id="数据抽象的意义"><a href="#数据抽象的意义" class="headerlink" title="数据抽象的意义"></a>数据抽象的意义</h2><p>在第一章中，只是进行了一些数值演算，这是比较简单的数据，并没有体现出数据抽象的意义，本章一开始就通过有理数的运算这个例子引出了数据抽象的意义。<br>数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序，使它们可以像操作数值等简单数据类型一样操作“抽象数据”。通过构造复合数据（与构造复合过程类似）可以达到下面的效果：</p>
<ol>
<li>降低程序间的耦合度</li>
<li>提高设计的模块性</li>
<li>增强语言表达能力，为处理计算问题提供更多手段和方法。</li>
</ol>
<p>第二章主要围绕下面两个部分展开：</p>
<ol>
<li>如何构造复合数据对象（通过数据组合）</li>
<li>如何处理复合数据对象</li>
</ol>
<p>其他一些细节点还包括：</p>
<ol>
<li>复合数据如何支持以“匹配和组合”方式工作的编程接口</li>
<li>通过定义数据抽象,进一步模糊“过程”和“数据”的差异</li>
<li>符号表达式的处理,这种表达式的基本部分是符号而不是数 通用型(泛型)操作,使同样操作可能用于不同的数据</li>
<li>数据制导（导向/驱动）的程序设计,方便新数据类的加入</li>
</ol>
<h3 id="过程抽象与数据抽象"><a href="#过程抽象与数据抽象" class="headerlink" title="过程抽象与数据抽象"></a>过程抽象与数据抽象</h3><p>一个过程描述了一类计算的模式,又可以作为元素用于实现其他(更复 杂的)过程。因此过程是一种抽象——过程抽象。过程抽象的优势在于：</p>
<ol>
<li>屏蔽计算的实现细节,可以用任何功能/使用形式合适的过程取代</li>
<li>规定了使用方式,使用方只依赖于抽象的使用方式约定</li>
</ol>
<p>数据抽象的情况类似。<br>一个数据抽象实现一类数据所需的所有功能,又像基本数据元素一样可以作为其他数据抽象的元素。主要优势：</p>
<ol>
<li>屏蔽一种复合数据的实现细节</li>
<li>提供一套抽象操作,使用组合数据的就像是使用基本数据</li>
<li>数据抽象的接口(界面)包括两类操作:构造函数和选择函数。构造函数基于一些参数构造这类数据,选择函数提取其内容</li>
</ol>
<p>后面将说明（在第三章😊）,如果需要支持基于状态的程序设计，那么就需要增加另外 一类变动操作（mutation，修改操作）。</p>
<h2 id="数据抽象的语言支持"><a href="#数据抽象的语言支持" class="headerlink" title="数据抽象的语言支持"></a>数据抽象的语言支持</h2><p>一般来说，实现数据抽象，编程语言需要提供下面三种机:</p>
<ol>
<li>粘合机制，支持把一组数据对象组合成一个整体（通过闭包实现）</li>
<li>操作定义机制，定义针对组合数据的操作（通过scheme内置的define实现）</li>
<li>抽象机制，屏蔽实现细节，使组合数据能像简单数据一样使用（通过数据导向的程序设计风格实现）</li>
</ol>
<p>处理复合数据的一个关键概念是<code>闭包</code>，这里的闭包概念来自<a href="https://en.wikipedia.org/wiki/Abstract_algebra" target="_blank" rel="noopener">抽象代数</a>，指的是</p>
<blockquote>
<p>通过数据对象组合起来得到的结果，还可以通过同样的操作再进行再次组合。</p>
</blockquote>
<p>这个概念和我们在JavaScript等现代编程语言中的概念（一种为表示带有自由变量的过程而用的实现技术）不一样，要注意区分。</p>
<h3 id="序对pair"><a href="#序对pair" class="headerlink" title="序对pair"></a>序对pair</h3><p>Scheme的基本复合结构称为“序对”，序对本身也是数据对象,可以用于构造更复杂的数据对象（也就是表，list）。例如<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">3</span> <span class="number">4</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> y (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">5</span> <span class="number">6</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> z (<span class="name"><span class="builtin-name">cons</span></span> x y))</span><br><span class="line"><span class="comment">; 注意理解序对pair 与表list 的区别</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> y (<span class="name"><span class="builtin-name">list</span></span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">cdr</span></span> x)  <span class="comment">; 2</span></span><br><span class="line">(<span class="name"><span class="builtin-name">cdr</span></span> y)  <span class="comment">; (2)</span></span><br></pre></td></tr></table></figure></p>
<p>常规过程性语言都没有内部的表数据类型，但是我们在算法与数据结构课上，一般都用C语言实现过各种表（单向双向链表，环形链表等）结构，C++的标准STL库的list，Java集合框架中的List。</p>
<p>表及其相关概念是从 Lisp 开始开发，现已经成为很多技术的基础：</p>
<ol>
<li>动态存储管理已经成为日常编程工作的基本支持</li>
<li>链表的定义和使用是常用技术（想想Java 中你用了多少次ArrayList吧）</li>
<li>有关表的使用和操作,以及各种操作的设计和实现,都可以从Lisp的表结构学习许多东西</li>
<li>基于map、reduce的hadoop</li>
<li>高阶表操作对分解程序复杂性很有意义</li>
</ol>
<h3 id="序对的操作"><a href="#序对的操作" class="headerlink" title="序对的操作"></a>序对的操作</h3><p>由于序对是构造复杂数据对象的基础，所有掌握序对的操作也就显得尤为重要，在学习这些操作时，我们可以感受到函数式编程的奇妙。<br>废话不多说，直接看代码<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/lib/list.scm" target="_blank" rel="noopener">list.scm</a>看代码吧。</p>
<h2 id="数据导向-vs-消息传递"><a href="#数据导向-vs-消息传递" class="headerlink" title="数据导向 vs. 消息传递"></a>数据导向 vs. 消息传递</h2><p>这两种方式是本章着重接受的两种数据抽象方式，分别对象函数式编程（数据导向）与面向对象编程（消息传递），具体辨析可参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.76.md" target="_blank" rel="noopener">习题2.76</a>。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>由于本章大部分内容都是用具体例子来讲解，下面我就再一一回顾遍。大部分内容都在我Github的读书笔记中，这里相当于个索引，具体例子可参考给出的相应链接😊。</p>
<h3 id="有理数运算"><a href="#有理数运算" class="headerlink" title="有理数运算"></a>有理数运算</h3><p>通过这里例子，引入数据抽象的意义。具体代码见<a href="https://github.com/jiacai2050/sicp/tree/master/exercises/02/lib/rational.scm" target="_blank" rel="noopener">rational.scm</a>。</p>
<p>介绍完这个例子后，书上提出了一个重要的问题，“什么是数据”，在有理数运算这个例子，中我们能看到的就是一个构造函数<code>make-rat</code>，两个选择函数<code>numer</code>与<code>demon</code>。首先我们要明确，并不是任意三个过程都能构成有理数的实现，需要满足<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">make-rat</span> (<span class="name">numer</span> x) (<span class="name">denom</span> x)) = x</span><br></pre></td></tr></table></figure></p>
<p>任意满足这一条件的三个函数，都能作为有理数表示的基础。<br>一般来说，一种数据对象的构造函数和选择函数都要满足一定条件。scheme中底层的数据结构序对也满足这一特点。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">car</span> (<span class="name">cons</span> a b)) = a</span><br><span class="line">(<span class="name">cdr</span> (<span class="name">cons</span> a b)) = b</span><br><span class="line">(<span class="name">cons</span> (<span class="name">car</span> x)(<span class="name">cdr</span> x)) = x  <span class="comment">;有前提,x 必须是序对</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Church数"><a href="#Church数" class="headerlink" title="Church数"></a>Church数</h4><p><a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.06.scm" target="_blank" rel="noopener">习题2.06</a>引出Church数，完全用过程实现整数算术系统，关于这一点，推荐大家看我之前写的<a href="/blog/2014/10/12/lambda-calculus-introduction/">编程语言的基石——Lambda calculus</a>，绝对能够颠覆你的思维。</p>
<h3 id="区间运算"><a href="#区间运算" class="headerlink" title="区间运算"></a>区间运算</h3><p>见相应的习题解答，推荐看<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.14_2.16.md" target="_blank" rel="noopener">习题2.14_2.16</a></p>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><center><br><img src="https://img.alicdn.com/imgextra/i3/581166664/TB23LNQfFXXXXckXXXXXXXXXXXX_!!581166664.png" alt="八皇后示意图"><br></center>

<p>经典的问题，参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.42_2.43.md" target="_blank" rel="noopener">习题2.42</a>。</p>
<h3 id="图形语言"><a href="#图形语言" class="headerlink" title="图形语言"></a>图形语言</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i3/581166664/TB2lhtEfFXXXXaRXpXXXXXXXXXX_!!581166664.png" alt="图形语言"><br></center><br>这个示例比较好玩，设计了一个图形语言，基本的元素painter用一过程表示，进一步模糊过程与数据的区别。参考相关习题，推荐<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.44_2.45.md" target="_blank" rel="noopener">2.44</a>、<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.49.md" target="_blank" rel="noopener">2.49</a>。<br>你可以看到，把painter用过程实现后，相关操作（flip-vert、besides等）变得何其简单。</p>
<h3 id="Huffman编码树🌲"><a href="#Huffman编码树🌲" class="headerlink" title="Huffman编码树🌲"></a>Huffman编码树🌲</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2Uy8RfFXXXXcEXXXXXXXXXXXX_!!581166664.png" alt="一个Huffman的例子"><br></center><br>又一经典算法，一定要看，推荐<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.69.scm" target="_blank" rel="noopener">练习2.69</a>，学习如果构造一个Huffman编码树。</p>
<h3 id="复数的表示"><a href="#复数的表示" class="headerlink" title="复数的表示"></a>复数的表示</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i2/581166664/TB213J7fFXXXXXOXXXXXXXXXXXX_!!581166664.png" alt="复数的表示"><br></center><br>这种主要是用直角坐标与极坐标两种形式表示复数，用带标志的数据，实现了数据导向的设计风格。</p>
<p>两种坐标的实现，参考代码<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/lib/generic_arithmetic.scm" target="_blank" rel="noopener">lib/generic_arithmetic.scm</a></p>
<h3 id="通用型算术包的实现"><a href="#通用型算术包的实现" class="headerlink" title="通用型算术包的实现"></a>通用型算术包的实现</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i4/581166664/TB2GYJSfFXXXXcFXXXXXXXXXXXX_!!581166664.png" alt="通用型算术包"><br></center><br>这一示例基本在前面有理数与复数的基础上，定义了统一的接口（add、sub等）来操作<code>scheme-number</code>、<code>rational</code>与<code>complex</code>三种类型的数据。</p>
<p>参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/lib/complex_number.scm" target="_blank" rel="noopener">lib/complex_number.scm</a></p>
<h3 id="符号代数——多项式算术"><a href="#符号代数——多项式算术" class="headerlink" title="符号代数——多项式算术"></a>符号代数——多项式算术</h3><p><center><br>    <img src="https://img.alicdn.com/imgextra/i3/581166664/TB2_HRVfFXXXXbzXXXXXXXXXXXX_!!581166664.png" alt="多边形的继承性（强制的难点）"><br></center><br>本章最后一个例子，难度比之前通用型算术包要大，因为不同类型的数据间操作需要“强制（coercion）”，而强制就需要一定的规则，实际编程中这种规则可能很复杂，所有这里需要注意的细节点比较多。</p>
<p>从“强制”引出的问题可以看出强类型语言的劣势，现在像python、javascript等弱类型的语言这么火，很大程序上就是由于弱类型语言的编译器把“强制”的工作给做了，程序员根本不用去关心。当然，如果所有“强制”工作都让编译器去做，也是不合适的，具体如何选择，就需要综合多种因素了。<br>我本身经验还不是很丰富，就不乱说了，如果你有这方面的亲身体会，可以留言，我会及时更新😊。</p>
<p>代码实现参考<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/lib/poly.scm" target="_blank" rel="noopener">lib/poly.scm</a>与<a href="https://github.com/jiacai2050/sicp/blob/master/exercises/02/2.92.md" target="_blank" rel="noopener">习题2.92</a>。</p>
<h3 id="扩充练习：有理函数"><a href="#扩充练习：有理函数" class="headerlink" title="扩充练习：有理函数"></a>扩充练习：有理函数</h3><p>经过前面多项式算术的习题，我基本已经败下阵来了，实在是吸收消化不了了，改日再战😂。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一次看第二章，陆陆续续用了2个月，基本上耗费平时下班＋周末双休的时间，收获还是挺大的。<br>不过由于本章习题量有些大，而且一开始像一些基础的过程<code>put</code>、<code>get</code>都没有，所以自己只是随便写写，没法运行，所以前面看的不好，这章习题之简的联系很紧密，前面没做好，后面只能呵呵了。</p>
<p>有一段时间让这些题弄的很烦，一点不想做，还好我这时候分散了下注意力，看了些其他的东西，像java集合框架的一些代码、the little schemer第九章的Y算子推导（虽然还没看懂），由于带着放松心情看的，遇到不懂的地方我就跳过去，没有深究，基本上达到了放松的目的。之后在网上把那些基础的过程都实现出来，再去做那些习题就顺多了。</p>
<p>这一章的内容，我之前多多少少了解过，所以大部分内容看起来还是比较顺畅的，就是习题多了点，由于当初给自己定的目标，所以还是慢慢的把所有习题（有理函数的除外）做了一遍。还是一点就是做后面的题时，忘了前面的知识点，需要平时没事多去翻翻，毕竟现在还达不到烂熟于心的地步。</p>
<p>下周一小组内再过一遍，向着第三章进军了。⛽️</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2015/09/20/sicp-chapter2-summary/" data-id="ckdkzhqnc002f6yljsinhjh38" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKklEQVR42u3aS27DMAwFwNz/0u66aK0+kkkBS+NVAf80DvBKiXq94uO6OX6evbt+/eS757z5wMDAeCzjWh75sO7Oru+tvvd2DBgYGAcwkiisBuUkdvOxYWBgYKyvWQdu9UNgYGBgvIuRTGKT51c/BAYGBkYymVw/KC8W14Xjx+fiGBgYD2TkUfj/f3+kv4GBgfEoxlU8qoE7D+toVBgYGFszJktp6wFVW5XVSS8GBsY5jGobMnlldaC9hbzb3wEDA2M7Rn5zvlWit5CXL7398X8DAwNjO0b15t7ZfANrHvTf3oWBgXEYY1K0VZua8xB/9TIbAwPjUYx8Upo3GifNyHmRioGBsTejN4GsFn+9s4XPhIGBsTWjt/Wh9wneFbsYGBgnMJLpazV8J1vB3jYXx8DA2IiRB19h00PxZc2tFb2ZMQYGxmMZebNw0p6sbhSrNiowMDBOY+QNgJzXC9NmnYuBgbERI9+SNbmmGr5JmYiBgXEOI4/ISeFYDevelRgYGCcwqlvE8jKuV0omE9dfAhcDA+MwRm9ZbR6seek5+ooYGBgPZPTajdU2ZLXoLIwWAwNjU8ZVPCYF36Q5+kfgYmBgbM2Yp3W1SZnDerGOgYGxKyMJ2WoLc/LlmoGLgYFxAKMafNXNXkkQ50gMDAyM/DX5vZMC8SOBi4GBcQCjukA2aQlEHwIDA+MARjKJrTYJJrzysh0GBsbWjOrUsbes34vmfIEPAwNjU8YXOiAi4FtpKu8AAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/sicp/">sicp</a></div><div class="post-nav"><a class="pre" href="/blog/2015/09/27/java-weakhashmap/">Java WeakHashMap 源码解析</a><a class="next" href="/blog/2015/09/12/java-linkedhashmap/">Java LinkedHashMap源码解析</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2015/09/20/sicp-chapter2-summary/';
    this.page.identifier = 'blog/2015/09/20/sicp-chapter2-summary/';
    this.page.title = 'SICP 第二章总结';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">26</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/08/08/go-meet-java/">在 Java 中调用 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/14/go-struct-interface/">Go struct/interface 最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/02/review-2019/">2019 年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
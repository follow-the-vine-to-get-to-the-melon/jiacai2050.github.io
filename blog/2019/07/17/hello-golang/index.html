<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>写给新手的 Go 开发指南 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">写给新手的 Go 开发指南</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">写给新手的 Go 开发指南</h1><div class="post-meta">Jul 17, 2019<span> | </span><span class="category"><a href="/categories/langs/">编程语言</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 13</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2019/07/17/hello-golang/" href="/blog/2019/07/17/hello-golang/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开发环境"><span class="toc-number">2.</span> <span class="toc-text">开发环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-interface"><span class="toc-number">3.1.</span> <span class="toc-text">struct/interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-slice"><span class="toc-number">3.2.</span> <span class="toc-text">map/slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chan-goroutine"><span class="toc-number">3.3.</span> <span class="toc-text">chan/goroutine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语言特性"><span class="toc-number">4.</span> <span class="toc-text">语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码风格"><span class="toc-number">4.1.</span> <span class="toc-text">代码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理"><span class="toc-number">4.2.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖管理"><span class="toc-number">4.3.</span> <span class="toc-text">依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC"><span class="toc-number">4.4.</span> <span class="toc-text">GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">6.</span> <span class="toc-text">扩展阅读</span></a></li></ol></div></div><div class="post-content"><p>转眼加入蚂蚁已经三个多月，这期间主要维护一 Go 写的服务器。虽然用的时间不算长，但还是积累了一些心得体会，这里总结归纳一下，供想尝试 Go 的同学参考。<br>本文会依次介绍 Go 的设计理念、开发环境、语言特性。本文在谈及语言特性的时也会讨论一些 Go 的不足之处，旨在给读者提供一个全面的视角。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一般来说，编程语言都会有一个 slogan 来表示它们的特点。比如提到 Clojure，一般会想到这么几个词汇：lisp on JVM、immutable、persistent；Java 的话我能想到的是企业级开发、中规中矩。对于 Go ，官网介绍到：</p>
<blockquote>
<p>Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</p>
</blockquote>
<p>提取几个关键词：open（开放）、simple（简洁）、reliable（可靠）、efficient（高效）。这也可以说是它的设计目标。除了上面这些口号外，初学者还需要知道 Go 是一门命令式的静态语言（是指在编译时检查变量类型是否匹配），与 Java 属于同一类别。</p>
<table>
<thead>
<tr>
<th></th>
<th>Imperative</th>
<th>Functional</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dynamic</td>
<td>Python/Ruby/Javascript</td>
<td>Lisp/Scheme/Clojure</td>
</tr>
<tr>
<td>Static</td>
<td>Java/C++/Rust/Go</td>
<td>OCaml/Scala/Haskell</td>
</tr>
</tbody>
</table>
<p>由于 <a href="https://play.golang.org/" target="_blank" rel="noopener">Hello World</a> 太简洁，不具备展示 Go 的特点，所以下面展示一段访问 httpbin，打印 response 的完整代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// http://httpbin.org/#/Anything/get_anything</span></span><br><span class="line">    r, err := http.Get(<span class="string">"http://httpbin.org/anything?hello=world"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"></span><br><span class="line">    bs, err := ioutil.ReadAll(r.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"body = %s\n"</span>, bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码片段包括了 Go 的主要组成：包的声明与引用、函数定义、错误处理、流程控制、<a href="https://tour.golang.org/flowcontrol/12" target="_blank" rel="noopener">defer</a>。</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>通过上面的代码片段，可以看出 Go 语言 simple（简洁）的特点，所以找一个最熟悉的文本编辑器，一般通过配置插件，都可以达到快速开发的目的。很久之前我就已经把所有文本编辑放到 Emacs 上，这里介绍下我的配置。</p>
<p>除了 <a href="https://github.com/dominikh/go-mode.el" target="_blank" rel="noopener">go-mode</a> 这个 major mode，为了配置像 源码跳转、API 自动补全、查看函数文档等现代 IDE 必备功能，需要安装以下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">go get -u github.com/rogpeppe/godef</span><br><span class="line">go get -u github.com/stamblerre/gocode <span class="comment"># for go-eldoc/company-go</span></span><br><span class="line">go get -u golang.org/x/tools/cmd/goimports</span><br><span class="line">go get -u github.com/kisielk/errcheck</span><br><span class="line">go get -u github.com/lukehoban/go-outline <span class="comment"># for go-imenu</span></span><br></pre></td></tr></table></figure></p>
<p>然后再按照 <a href="https://github.com/jiacai2050/dotfiles/blob/master/.emacs.d/customizations/setup-go.el" target="_blank" rel="noopener">setup-go.el</a> 里的配置，就拥有了一个功能完备的开发环境。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01TBr6Xm1z69vZesJfk_!!581166664.png" alt="Emacs Go 开发环境"></p>
<p>不像 Java 语言需要运行时，Go 支持直接将整个项目 build 成一个二进制文件，方便部署，而支持<a href="https://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5" target="_blank" rel="noopener">交叉编译</a>，不过在开发时，直接 <code>go run XXX.go</code> 更为便利，截止到 Go 1.12，还不支持 <a href="https://stackoverflow.com/questions/8513609/does-go-provide-repl" target="_blank" rel="noopener">REPL</a>，官方有提供在线版的 <a href="https://play.golang.org/" target="_blank" rel="noopener">Playground</a> 供分享、调试代码。</p>
<p>我个人的习惯是建一个 go-app 项目，每个要测试的逻辑放到一个 test 里面去，这样就可以使用 <code>go test -v -run XXX</code> 来运行。之所以不选用 <code>go run</code>，是因为一个目录下只允许有一个 main 的 package，多个 IDE 会提示错误。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>一般编程语言，<a href="https://go101.org/article/type-system-overview.html" target="_blank" rel="noopener">数据类型</a>分为基本的与复杂的两类。<br>基本的一般比较简单，表示一个值，Go 里面就有 string, bool, int8, int32(rune), int64, float32, float64, byte(uint8) 等基本类型<br>复杂类型一般表示多个值或具有某些高级用法，Go 里面有：</p>
<ul>
<li>pointer Go 里只支持取地址 <code>&amp;</code> 与间接访问 <code>*</code> 操作符，不支持对指针进行算术操作</li>
<li>struct 类似于 C 语言里面的 struct，Java 里面的对象</li>
<li>function 函数在 Go 里是一等成员</li>
<li>array 大小固定的数组</li>
<li>slice 动态的数组</li>
<li>map 哈希表</li>
<li>chan 用于在多个 goroutine 内通信</li>
<li>interface 类似于 Java 里面的接口，一组方法的封装</li>
</ul>
<p>下面将重点介绍 Go 里特有或用途最广的数据类型。</p>
<h3 id="struct-interface"><a href="#struct-interface" class="headerlink" title="struct/interface"></a>struct/interface</h3><p>Go 里面的 struct 类似于 Java 里面的 Object，但是并没有继承，仅仅是对数据的一层包装（抽象）。相对于其他复杂类型，struct 是<strong>值类型</strong>，也就是说作为函数参数或返回值时，会拷贝一份值。<br>一般来说，值类型分配在 stack 上，与之相对的引用类型，分配在 heap 上。<br>初学者一般会有这样的误区，认为传值比传引用要慢，实则不然，具体涉及到 Go <a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html" target="_blank" rel="noopener">如何管理内存</a>，这里暂不详述，感兴趣到可以阅读：</p>
<ul>
<li><a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65" target="_blank" rel="noopener">The Top 10 Most Common Mistakes I’ve Seen in Go Projects</a></li>
<li><a href="https://gist.github.com/teivah/a32a8e9039314a48f03538f3f9535537" target="_blank" rel="noopener">pointer_test.go</a> 这个测试在笔者机器上运行结果：<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkByPointer<span class="number">-8</span>    <span class="number">20000000</span>                <span class="number">86.7</span> ns/op</span><br><span class="line">BenchmarkByValue<span class="number">-8</span>      <span class="number">50000000</span>                <span class="number">31.9</span> ns/op</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所以一般情况下推荐直接使用值类型的 struct，如果需要改变状态，再考虑改为指针类型（&amp;struct）</p>
<p>如果说 struct 是对状态的封装，那么 interface 就是对行为的封装，相当于对外的契约（contract）。而且 Go 里面有这么一条<a href="https://www.reddit.com/r/golang/comments/cf1lda/having_trouble_understanding_how_to_properly_use/eu7r4f3" target="_blank" rel="noopener">最佳实践</a></p>
<blockquote>
<p>Accept interfaces, return concrete structs. （函数的参数尽量为 interface，返回值为 struct）</p>
</blockquote>
<p>这样的好处也很明显，作为类库的设计者，对其要求的参数尽量宽松，方便使用，返回具体值方便后续的操作处理。一个极端的情况，可以用 <code>interface{}</code> 表示任意类型的参数，因为这个接口里面没有任何行为，所以所有类型都是符合的。又由于 Go 里面不支持<a href="https://dev.to/deanveloper/go-2-draft-generics-3333" target="_blank" rel="noopener">范型</a>，所以<code>interface{}</code>是唯一的解决手段。</p>
<p>相比较 Java 这类面向对象的语言，接口需要显式（explicit）继承（使用 implements 关键字），而在 Go 里面是<a href="https://golang.org/doc/faq#implements_interface" target="_blank" rel="noopener">隐式的（implicit）</a>，新手往往需要一段时间来体会这一做法的巧妙，这里举一例子来说明：</p>
<p>Go 的 IO 操作涉及到两个基础类型：Writer/Reader ，其定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">        Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义类型如果实现了这两个方法，那么就实现了这两个接口，下面的 Example 就是这么一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Example <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Example)</span> <span class="title">Write</span><span class="params">(p <span class="keyword">byte</span>[])</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Example)</span> <span class="title">Read</span><span class="params">(p <span class="keyword">byte</span>[])</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于隐式继承过于灵活，在 Go 里面可能会看到<a href="https://stackoverflow.com/questions/17994519/golang-interface-compliance-compile-type-check" target="_blank" rel="noopener">如下代码</a>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ blob.Fetcher = (*CachingFetcher)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>这是通过将 nil 强转为 <code>*CachingFetcher</code>，然后在赋值时，指定 <code>blob.Fetcher</code> 类型，保证 <code>*CachingFetcher</code> 实现了 <code>blob.Fetcher</code> 接口。<br>作为接口的设计者，如果想实现者显式继承一个接口，可以在接口中<a href="https://golang.org/doc/faq#guarantee_satisfies_interface" target="_blank" rel="noopener">额外加一个方法</a>。比如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fooer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Foo()</span><br><span class="line">    ImplementsFooer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，实现者必须实现 <code>ImplementsFooer</code> 方法才能说是继承了 <code>Fooer</code> 接口。所以说隐式继承有利有弊，需要开发者自己去把握。</p>
<h3 id="map-slice"><a href="#map-slice" class="headerlink" title="map/slice"></a>map/slice</h3><p>Map/Slice 是 Go 里面最常用的两类数据结构，属于引用类型。在语言 runtime 层面实现，仅有的两个支持范型的结构。<br>Slice 是长度不固定的数组，类似于 Java 里面的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank" rel="noopener">List</a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 通过 make 进行初始化</span></span><br><span class="line"><span class="comment">// 如果提前知道 m 大小，建议通过 make 的第二个参数指定，避免后期的数据移动、复制</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">m[<span class="string">"zhangsan"</span>] = <span class="string">"teacher"</span></span><br><span class="line"><span class="comment">// 读取指定值，如不存在，返回其类型的默认值</span></span><br><span class="line">v := m[<span class="string">"zhangsan"</span>]</span><br><span class="line"><span class="comment">// 判断指定 key 知否在 map 内</span></span><br><span class="line">v, ok := m[<span class="string">"zhangsan"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 通过 make 进行初始化</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 增加元素</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 make 第二个参数指定大小</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line">    s[i] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以使用三个参数的 make 初始化 slice</span></span><br><span class="line"><span class="comment">// 第二个参数为初始化大小，第三个为最大容量</span></span><br><span class="line"><span class="comment">// 需要通过 append 增加元素</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span> ,<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="chan-goroutine"><a href="#chan-goroutine" class="headerlink" title="chan/goroutine"></a>chan/goroutine</h3><p>作为一门新语言，Goroutine 是 Go <a href="https://golang.org/doc/faq#csp" target="_blank" rel="noopener">借鉴 CSP 模型</a>提供的并发解决方案，相比传统 OS 级别的线程，它有以下<a href="https://stackoverflow.com/a/27794268/2163429" target="_blank" rel="noopener">特点</a>：</p>
<ol>
<li>轻量，完全在用户态调度（不涉及OS状态直接的转化）</li>
<li>资源占用少，启动快</li>
<li>目前，Goroutine 调度器不保证公平（fairness），抢占（pre-emption）也支持的非常有限，一个空的 <code>for{}</code> 可能会一直不被调度出去。</li>
</ol>
<p>一般可以使用 chan/select 来进行 Goroutine 之间的调度。chan 类似于 Java 里面的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html" target="_blank" rel="noopener">BlockingQueue</a>，且能保证 Goroutine-safe，也就是说多个 Goroutine 并发进行读写是安全的。</p>
<p>chan 里面的元素默认为1个，也可以在创建时指定缓冲区大小，读写支持堵塞、非堵塞两种模式，关闭一个 chan 后，再写数据时会 panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chan 与 slice/map 一样，使用 make 初始化</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// blocking read</span></span><br><span class="line">v := &lt;-ch</span><br><span class="line"><span class="comment">// nonblocking read, 需要注意 default 分支不能省略，否则会堵塞住</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v:=&lt;-ch:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// blocking write</span></span><br><span class="line">ch &lt;- v</span><br><span class="line"><span class="comment">// nonblocking write</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch&lt;-v:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chan 作为 Go 内一重要数据类型，看似简单，实则暗藏玄妙，用时需要多加留意，这里不再展开叙述，后面打算专门写一篇文章去介绍，感兴趣的可以阅读下面的文章：</p>
<ul>
<li><a href="https://dave.cheney.net/2013/04/30/curious-channels" target="_blank" rel="noopener">Curious Channels</a></li>
<li><a href="https://github.com/jiacai2050/prosumer" target="_blank" rel="noopener">Prosumer</a> 基于 buffered chan 实现的生产者消费者，核心点在于关闭 chan 只意味着生产者不能再发送数据，消费者无法获知 chan 是否已经关闭，需要用其他方式去通信。</li>
</ul>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>Go 相比 Java 来说，语言特性真的是少太多。推荐 <a href="https://learnxinyminutes.com/docs/go/" target="_blank" rel="noopener">Learn X in Y minutes</a> 这个网站，快速浏览一遍即可掌握 Go 的语法。Go 的简洁程度觉得和 JavaScript 差不多，但却是一门静态语言，具有强类型，这两点又让它区别于一般的脚本语言。</p>
<h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><p>Go 遵循约定大于配置（convention over configuratio）的设计理念，比如在构建一个项目时，直接 <code>go build</code> 一个命令就搞定了，不需要什么 Makefile、pom.xml 等配置文件。下面介绍几个常用的约定：</p>
<ul>
<li>一个包内函数、变量的可见性是通过首字母大小写确定的。大写表示可见。</li>
<li>一般 <code>{</code> 放在行末，否则 Go 编辑器会<a href="https://golang.org/doc/effective_go.html#semicolons" target="_blank" rel="noopener">自动插入一个逗号</a>，导致编译错误</li>
<li>一个文件夹内，只能定义一个包</li>
<li>变量、函数命名<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_identifier_length" target="_blank" rel="noopener">尽量简短</a>，标准库里面经常可以看到一个字母的变量</li>
</ul>
<p>由于以上种种约定，在看别人代码时很舒服，有种 Python 的感觉。另外建议在编辑器中配置 <a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a> 来自动化格式代码。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Go 内没有 try catch 机制，而且已经明确拒绝了这个 <a href="https://github.com/golang/go/issues/32437" target="_blank" rel="noopener">Proposal</a>，而是通过返回值的方式来处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> …, err  <span class="comment">// zero values for other results, if any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 的函数一般通过返回多值的方式来传递 error（且一般是第二个位置），实际项目中一般使用 <a href="https://github.com/pkg/errors" target="_blank" rel="noopener">pkg/errors</a> 去处理、包装 err。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>Go 的依赖管理，相比其他语言较弱。<br>在 Go 1.11 正式引入的 <a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">modules</a> 之前，项目必须放在 $GOPATH/src/xxx.com/username/project 内，这样 Go 才能去正确解析项目依赖，而且 Go 社区没有统一的包托管平台，不像 Java 中 maven 一样有中央仓库的概念，而是直接引用 Git 的库地址，所以在 Go 里，一般会使用 <code>github.com/username/package</code> 的方式来表示。<br><code>go get</code> 是下载依赖的命令，但一个个去 get 库不仅仅繁碎，而且无法固化依赖版本信息，所以 <a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a> 应运而生，添加新依赖后，直接运行 <code>dep ensure</code> 就可以全部下下来，而且会把当前依赖的 commit id 记录到 Gopkg.lock 里面，这就能解决版本不固定的问题。</p>
<p>但 modules 才是正路，且在 1.13 版本会默认开启，所以这里只介绍它的用法。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先导出环境变量</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="comment"># 在一个空文件夹执行 init，创建一个名为 hello 的项目</span></span><br><span class="line">go mod init hello</span><br><span class="line"><span class="comment"># 这时会在当前文件夹内创建 go.mod ，内容为</span></span><br><span class="line"></span><br><span class="line">module hello</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"><span class="comment"># 之后就可以编写 Go 文件，添加依赖后，执行 go run/test/build...</span></span><br><span class="line"><span class="comment"># 依赖会自动下载，并记录在 go.mod 内，版本信息记录在 go.sum</span></span><br></pre></td></tr></table></figure>
<p>更多用法可以参考官方示例，这里只是想说明 <a href="https://github.com/golang/tools" target="_blank" rel="noopener">go tools</a> 大部分已经支持，但是 <a href="https://github.com/golang/go/issues/26827" target="_blank" rel="noopener">godoc 还不支持</a>，更多可参考 <a href="https://github.com/golang/go/issues/24661" target="_blank" rel="noopener">#24661</a>。</p>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>Go 也是具有<a href="https://blog.golang.org/ismmkeynote" target="_blank" rel="noopener">垃圾回收</a>的语言，但相比于 JVM，Go GC 可能显得及其简单，从 Go 1.10 开始，Go GC 采用 Concurrent Mark &amp; Sweep (CMS) 算法，且不具有分代、compact 特性。读者如果对相关名词不熟悉，可以阅读：</p>
<ul>
<li><a href="https://engineering.linecorp.com/en/blog/go-gc/" target="_blank" rel="noopener">https://engineering.linecorp.com/en/blog/go-gc/</a></li>
</ul>
<p>而且 Go 里面调整 GC 的参数只有一个 <code>GOGC</code>，表示下面的比率</p>
<blockquote>
<p>新分配对象 / 上次 GC 后剩余对象</p>
</blockquote>
<p>默认 100，表示新分配对象达到上次 GC 后剩余对象的两倍时，进行 GC。</p>
<ul>
<li>调大 GOGC，可以减少 GC 的总体耗时</li>
<li>减小 GOGC，意味着用更多的 GC 来换取更少的内存使用</li>
</ul>
<p><code>GOGC=off</code> 可以关闭 GC，<a href="https://golang.org/pkg/runtime/debug/#SetGCPercent" target="_blank" rel="noopener">SetGCPercent</a> 可以动态修改这个比率。</p>
<p>在启动一个 Go 程序时，可以设置 <code>GODEBUG=gctrace=1</code> 来打印 GC 日志，日志具体含义可参考 <a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables" target="_blank" rel="noopener">pkg/runtime</a>，这里不再赘述。对调试感兴趣的可以阅读：</p>
<ul>
<li><a href="https://new.blog.cloudflare.com/go-dont-collect-my-garbage/" target="_blank" rel="noopener">https://new.blog.cloudflare.com/go-dont-collect-my-garbage/</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go 最初由 Google 在 2007 为解决软件复杂度、提升开发效率的一试验品，到如今不过十二年，但无疑已经<a href="https://hackernoon.com/major-programming-trends-to-prepare-for-in-2019-169987cc75f4" target="_blank" rel="noopener">家喻户晓</a>，成为<a href="https://thenewstack.io/go-the-programming-language-of-the-cloud/" target="_blank" rel="noopener">云时代的首选</a>。其面向接口的特有编程方式，也非常灵活，兼具动态语言的简洁与静态语言的高效，推荐大家尝试一下。Go Go Go!</p>
<p><img src="https://golang.org/lib/godoc/images/go-logo-blue.svg" alt="Go"></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://github.com/overnote/golang/blob/master/01-Go初识/03-包与依赖管理.md" target="_blank" rel="noopener">03-包与依赖管理.md</a></li>
<li><a href="http://dtrace.org/blogs/ahl/2016/08/02/i-love-go-i-hate-go/" target="_blank" rel="noopener">I Love Go; I Hate Go</a></li>
<li><a href="https://golang.org/ref/spec#Receive_operator" target="_blank" rel="noopener">The Go Programming Language Specification#Receive operator</a></li>
<li><a href="http://www.yinwang.org/blog-cn/2014/04/18/golang" target="_blank" rel="noopener">王垠：对 Go 语言的综合评价</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></li>
<li><a href="https://golang.org/doc/faq" target="_blank" rel="noopener">https://golang.org/doc/faq</a></li>
<li><a href="https://blog.golang.org/go15gc" target="_blank" rel="noopener">https://blog.golang.org/go15gc</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2019/07/17/hello-golang/" data-id="ckcro6imf005n25lj8p1d1v5i" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJ0lEQVR42u3aQW7DMAwF0dz/0u62QGFnyC+jkDhaBYkr+W1YUuTng9f1a/39nj///Az5q2jJkCFjW8b1uMgz5OC7Pe/25+8mQ4aMOYy7g++eeT74eWd+Fnk3GTJkyOh9rqaVMmTIkPG/AZd8Q36VIUOGDFLE5gVttUB9pRaXIUPGhoxVReYbn1/pb8iQIWMrxlVcJE1MmpRXa8mQIeNsBg9wJGnjl255O0GGDBnTGHz0Ic/H+GhFbxxNhgwZ5zH4tTs/LHmtZgtBhgwZRzPItRe/lCeBNSmAoxtBGTJkHMcgGWUecHmzE42AyJAhYwCDFKs8jPILsmoq+aUKlyFDxtGMZkLWovau9hb835AhQ8a2DF6yJglib7KrHFFlyJAxhpEcT8Bkf56qypAhYw4j3y4pbpsTIjJkyBjGKA83LNohKV/LqaEMGTI2ZJCSlY9frAqd/AJOhgwZExh8rCFJB6vjZTwllSFDxjRGcr1VvXTrNQAKzUsZMmQczeClZtJC4KcXgrIMGTIGMPI0jiSOSZMABVwZMmQczUiGt5JXrHZZm0WsDBkytmVcxfVcmlZHLqphGk20yZAh4zhGL8zxb3qhlqSDvWAtQ4aMfRl5kK2Wo7xRWgi4MmTIGMBYFfjyNgMvhmXIkCEjaVjytJIH4qZPhgwZgxm9kJoH2S/9DRkyZBzNIEUsuVDrFbF8pGPBdZsMGTI2ZPTyrqRJwGGrSl8ZMmRsy/gBgJL6CMVCxcwAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/Go/">Go</a></div><div class="post-nav"><a class="pre" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a><a class="next" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2019/07/17/hello-golang/';
    this.page.identifier = 'blog/2019/07/17/hello-golang/';
    this.page.title = '写给新手的 Go 开发指南';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">25</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/14/go-struct-interface/">Go struct/interface 最佳实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/02/review-2019/">2019 年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
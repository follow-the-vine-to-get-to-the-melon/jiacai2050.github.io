<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>写给新手的 Go 开发指南 - Keep Coding</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="刘家财" /><meta name="description" content="转眼加入蚂蚁已经三个多月，这期间主要维护一 Go 写的服务器。虽然用的时间不算长，但还是积累了一些心得体会，这里总结归纳一下，供想尝试 Go 的同学参考" /><meta name="keywords" content="lisp, clojure, emacs, database, life" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="https://liujiacai.net/blog/2019/07/17/hello-golang/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="写给新手的 Go 开发指南" />
<meta property="og:description" content="转眼加入蚂蚁已经三个多月，这期间主要维护一 Go 写的服务器。虽然用的时间不算长，但还是积累了一些心得体会，这里总结归纳一下，供想尝试 Go 的同学参考" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liujiacai.net/blog/2019/07/17/hello-golang/" />
<meta property="article:published_time" content="2019-07-17T21:52:33+00:00" />
<meta property="article:modified_time" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="name" content="写给新手的 Go 开发指南">
<meta itemprop="description" content="转眼加入蚂蚁已经三个多月，这期间主要维护一 Go 写的服务器。虽然用的时间不算长，但还是积累了一些心得体会，这里总结归纳一下，供想尝试 Go 的同学参考">
<meta itemprop="datePublished" content="2019-07-17T21:52:33+00:00" />
<meta itemprop="dateModified" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="wordCount" content="4266">



<meta itemprop="keywords" content="Go," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="写给新手的 Go 开发指南"/>
<meta name="twitter:description" content="转眼加入蚂蚁已经三个多月，这期间主要维护一 Go 写的服务器。虽然用的时间不算长，但还是积累了一些心得体会，这里总结归纳一下，供想尝试 Go 的同学参考"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Keep Coding</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/podcast/">
        <li class="mobile-menu-item">Podcast</li>
      </a><a href="/blogrolls/">
        <li class="mobile-menu-item">友链</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Keep Coding</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/podcast/">Podcast</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/blogrolls/">友链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">写给新手的 Go 开发指南</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-07-17 </span>
        <div class="post-category">
            <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"> 编程语言 </a>
            </div>
          <span class="more-meta"> 约 4266 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#开发环境">开发环境</a></li>
        <li><a href="#数据类型">数据类型</a>
          <ul>
            <li><a href="#structinterface">struct/interface</a></li>
            <li><a href="#mapslice">map/slice</a></li>
            <li><a href="#changoroutine">chan/goroutine</a></li>
          </ul>
        </li>
        <li><a href="#语言特性">语言特性</a>
          <ul>
            <li><a href="#代码风格">代码风格</a></li>
            <li><a href="#错误处理">错误处理</a></li>
            <li><a href="#依赖管理">依赖管理</a></li>
            <li><a href="#gc">GC</a></li>
          </ul>
        </li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#扩展阅读">扩展阅读</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>转眼加入蚂蚁已经三个多月，这期间主要维护一 Go 写的服务器。虽然用的时间不算长，但还是积累了一些心得体会，这里总结归纳一下，供想尝试 Go 的同学参考。
本文会依次介绍 Go 的设计理念、开发环境、语言特性。本文在谈及语言特性的时也会讨论一些 Go 的不足之处，旨在给读者提供一个全面的视角。</p>
<h2 id="简介">简介</h2>
<p>一般来说，编程语言都会有一个 slogan 来表示它们的特点。比如提到 Clojure，一般会想到这么几个词汇：lisp on JVM、immutable、persistent；Java 的话我能想到的是企业级开发、中规中矩。对于 Go ，官网介绍到：</p>
<blockquote>
<p>Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.</p>
</blockquote>
<p>提取几个关键词：open（开放）、simple（简洁）、reliable（可靠）、efficient（高效）。这也可以说是它的设计目标。除了上面这些口号外，初学者还需要知道 Go 是一门命令式的静态语言（是指在编译时检查变量类型是否匹配），与 Java 属于同一类别。</p>
<table>
<thead>
<tr>
<th></th>
<th>Imperative</th>
<th>Functional</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dynamic</td>
<td>Python/Ruby/Javascript</td>
<td>Lisp/Scheme/Clojure</td>
</tr>
<tr>
<td>Static</td>
<td>Java/C++/Rust/Go</td>
<td>OCaml/Scala/Haskell</td>
</tr>
</tbody>
</table>
<p>由于 <a href="https://play.golang.org/">Hello World</a> 太简洁，不具备展示 Go 的特点，所以下面展示一段访问 httpbin，打印 response 的完整代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;io/ioutil&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// http://httpbin.org/#/Anything/get_anything
</span><span class="c1"></span>    <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;http://httpbin.org/anything?hello=world&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">bs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;body = %s\n&#34;</span><span class="p">,</span> <span class="nx">bs</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>上面的代码片段包括了 Go 的主要组成：包的声明与引用、函数定义、错误处理、流程控制、<a href="https://tour.golang.org/flowcontrol/12">defer</a>。</p>
<h2 id="开发环境">开发环境</h2>
<p>通过上面的代码片段，可以看出 Go 语言 simple（简洁）的特点，所以找一个最熟悉的文本编辑器，一般通过配置插件，都可以达到快速开发的目的。很久之前我就已经把所有文本编辑放到 Emacs 上，这里介绍下我的配置。</p>
<p>除了 <a href="https://github.com/dominikh/go-mode.el">go-mode</a> 这个 major mode，为了配置像 源码跳转、API 自动补全、查看函数文档等现代 IDE 必备功能，需要安装以下命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">
go get -u github.com/rogpeppe/godef
go get -u github.com/stamblerre/gocode <span class="c1"># for go-eldoc/company-go</span>
go get -u golang.org/x/tools/cmd/goimports
go get -u github.com/kisielk/errcheck
go get -u github.com/lukehoban/go-outline <span class="c1"># for go-imenu</span>
</code></pre></td></tr></table>
</div>
</div><p>然后再按照 <a href="https://github.com/jiacai2050/dotfiles/blob/master/.emacs.d/customizations/setup-go.el">setup-go.el</a> 里的配置，就拥有了一个功能完备的开发环境。</p>
<p>
  <figure>
    <img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01TBr6Xm1z69vZesJfk_!!581166664.png" alt="Emacs Go 开发环境">
    <figcaption><center>Emacs Go 开发环境</center></figcaption>
  </figure>

</p>
<p>不像 Java 语言需要运行时，Go 支持直接将整个项目 build 成一个二进制文件，方便部署，而支持<a href="https://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5">交叉编译</a>，不过在开发时，直接 <code>go run XXX.go</code> 更为便利，截止到 Go 1.12，还不支持 <a href="https://stackoverflow.com/questions/8513609/does-go-provide-repl">REPL</a>，官方有提供在线版的 <a href="https://play.golang.org/">Playground</a> 供分享、调试代码。</p>
<p>我个人的习惯是建一个 go-app 项目，每个要测试的逻辑放到一个 test 里面去，这样就可以使用 <code>go test -v -run XXX</code> 来运行。之所以不选用 <code>go run</code>，是因为一个目录下只允许有一个 main 的 package，多个 IDE 会提示错误。</p>
<h2 id="数据类型">数据类型</h2>
<p>一般编程语言，<a href="https://go101.org/article/type-system-overview.html">数据类型</a>分为基本的与复杂的两类。
基本的一般比较简单，表示一个值，Go 里面就有 string, bool, int8, int32(rune), int64, float32, float64, byte(uint8) 等基本类型
复杂类型一般表示多个值或具有某些高级用法，Go 里面有：</p>
<ul>
<li>pointer Go 里只支持取地址 <code>&amp;</code> 与间接访问 <code>*</code> 操作符，不支持对指针进行算术操作</li>
<li>struct 类似于 C 语言里面的 struct，Java 里面的对象</li>
<li>function 函数在 Go 里是一等成员</li>
<li>array 大小固定的数组</li>
<li>slice 动态的数组</li>
<li>map 哈希表</li>
<li>chan 用于在多个 goroutine 内通信</li>
<li>interface 类似于 Java 里面的接口，一组方法的封装</li>
</ul>
<p>下面将重点介绍 Go 里特有或用途最广的数据类型。</p>
<h3 id="structinterface">struct/interface</h3>
<p>Go 里面的 struct 类似于 Java 里面的 Object，但是并没有继承，仅仅是对数据的一层包装（抽象）。相对于其他复杂类型，struct 是<strong>值类型</strong>，也就是说作为函数参数或返回值时，会拷贝一份值。
一般来说，值类型分配在 stack 上，与之相对的引用类型，分配在 heap 上。
初学者一般会有这样的误区，认为传值比传引用要慢，实则不然，具体涉及到 Go <a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">如何管理内存</a>，这里暂不详述，感兴趣到可以阅读：</p>
<ul>
<li><a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65">The Top 10 Most Common Mistakes I’ve Seen in Go Projects</a></li>
<li><a href="https://gist.github.com/teivah/a32a8e9039314a48f03538f3f9535537">pointer_test.go</a> 这个测试在笔者机器上运行结果：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">BenchmarkByPointer-8    20000000                86.7 ns/op
BenchmarkByValue-8      50000000                31.9 ns/op
</code></pre></td></tr></table>
</div>
</div><p>所以一般情况下推荐直接使用值类型的 struct，如果需要改变状态，再考虑改为指针类型（&amp;struct）</p>
<p>如果说 struct 是对状态的封装，那么 interface 就是对行为的封装，相当于对外的契约（contract）。而且 Go 里面有这么一条<a href="https://www.reddit.com/r/golang/comments/cf1lda/having_trouble_understanding_how_to_properly_use/eu7r4f3">最佳实践</a></p>
<blockquote>
<p>Accept interfaces, return concrete structs. （函数的参数尽量为 interface，返回值为 struct）</p>
</blockquote>
<p>这样的好处也很明显，作为类库的设计者，对其要求的参数尽量宽松，方便使用，返回具体值方便后续的操作处理。一个极端的情况，可以用 <code>interface{}</code> 表示任意类型的参数，因为这个接口里面没有任何行为，所以所有类型都是符合的。又由于 Go 里面不支持<a href="https://dev.to/deanveloper/go-2-draft-generics-3333">范型</a>，所以<code>interface{}</code>是唯一的解决手段。</p>
<p>相比较 Java 这类面向对象的语言，接口需要显式（explicit）继承（使用 implements 关键字），而在 Go 里面是<a href="https://golang.org/doc/faq#implements_interface">隐式的（implicit）</a>，新手往往需要一段时间来体会这一做法的巧妙，这里举一例子来说明：</p>
<p>Go 的 IO 操作涉及到两个基础类型：Writer/Reader ，其定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
        <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
        <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>自定义类型如果实现了这两个方法，那么就实现了这两个接口，下面的 Example 就是这么一个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Example</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Example</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="kt">byte</span><span class="p">[])</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Example</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="kt">byte</span><span class="p">[])</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由于隐式继承过于灵活，在 Go 里面可能会看到<a href="https://stackoverflow.com/questions/17994519/golang-interface-compliance-compile-type-check">如下代码</a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">_</span> <span class="nx">blob</span><span class="p">.</span><span class="nx">Fetcher</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">CachingFetcher</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这是通过将 nil 强转为 <code>*CachingFetcher</code>，然后在赋值时，指定 <code>blob.Fetcher</code> 类型，保证 <code>*CachingFetcher</code> 实现了 <code>blob.Fetcher</code> 接口。
作为接口的设计者，如果想实现者显式继承一个接口，可以在接口中<a href="https://golang.org/doc/faq#guarantee_satisfies_interface">额外加一个方法</a>。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Fooer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Foo</span><span class="p">()</span>
    <span class="nf">ImplementsFooer</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，实现者必须实现 <code>ImplementsFooer</code> 方法才能说是继承了 <code>Fooer</code> 接口。所以说隐式继承有利有弊，需要开发者自己去把握。</p>
<h3 id="mapslice">map/slice</h3>
<p>Map/Slice 是 Go 里面最常用的两类数据结构，属于引用类型。在语言 runtime 层面实现，仅有的两个支持范型的结构。
Slice 是长度不固定的数组，类似于 Java 里面的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// map 通过 make 进行初始化
</span><span class="c1">// 如果提前知道 m 大小，建议通过 make 的第二个参数指定，避免后期的数据移动、复制
</span><span class="c1"></span><span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1">// 赋值
</span><span class="c1"></span><span class="nx">m</span><span class="p">[</span><span class="s">&#34;zhangsan&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;teacher&#34;</span>
<span class="c1">// 读取指定值，如不存在，返回其类型的默认值
</span><span class="c1"></span><span class="nx">v</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="s">&#34;zhangsan&#34;</span><span class="p">]</span>
<span class="c1">// 判断指定 key 知否在 map 内
</span><span class="c1"></span><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="s">&#34;zhangsan&#34;</span><span class="p">]</span>

<span class="c1">// slice 通过 make 进行初始化
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>
<span class="c1">// 增加元素
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">// 也可以通过 make 第二个参数指定大小
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
<span class="p">}</span>
<span class="c1">// 也可以使用三个参数的 make 初始化 slice
</span><span class="c1">// 第二个参数为初始化大小，第三个为最大容量
</span><span class="c1">// 需要通过 append 增加元素
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="changoroutine">chan/goroutine</h3>
<p>作为一门新语言，Goroutine 是 Go <a href="https://golang.org/doc/faq#csp">借鉴 CSP 模型</a>提供的并发解决方案，相比传统 OS 级别的线程，它有以下<a href="https://stackoverflow.com/a/27794268/2163429">特点</a>：</p>
<ol>
<li>轻量，完全在用户态调度（不涉及OS状态直接的转化）</li>
<li>资源占用少，启动快</li>
<li>目前，Goroutine 调度器不保证公平（fairness），抢占（pre-emption）也支持的非常有限，一个空的 <code>for{}</code> 可能会一直不被调度出去。</li>
</ol>
<p>一般可以使用 chan/select 来进行 Goroutine 之间的调度。chan 类似于 Java 里面的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue</a>，且能保证 Goroutine-safe，也就是说多个 Goroutine 并发进行读写是安全的。</p>
<p>chan 里面的元素默认为1个，也可以在创建时指定缓冲区大小，读写支持堵塞、非堵塞两种模式，关闭一个 chan 后，再写数据时会 panic。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// chan 与 slice/map 一样，使用 make 初始化
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">// blocking read
</span><span class="c1"></span><span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
<span class="c1">// nonblocking read, 需要注意 default 分支不能省略，否则会堵塞住
</span><span class="c1"></span><span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">v</span><span class="o">:=&lt;-</span><span class="nx">ch</span><span class="p">:</span>
    <span class="k">default</span><span class="p">:</span>
<span class="p">}</span> 

<span class="c1">// blocking write
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">v</span>
<span class="c1">// nonblocking write
</span><span class="c1"></span><span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">ch</span><span class="o">&lt;-</span><span class="nx">v</span><span class="p">:</span>
    <span class="k">default</span><span class="p">:</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>chan 作为 Go 内一重要数据类型，看似简单，实则暗藏玄妙，用时需要多加留意，这里不再展开叙述，后面打算专门写一篇文章去介绍，感兴趣的可以阅读下面的文章：</p>
<ul>
<li><a href="https://dave.cheney.net/2013/04/30/curious-channels">Curious Channels</a></li>
<li><a href="https://github.com/jiacai2050/prosumer">Prosumer</a> 基于 buffered chan 实现的生产者消费者，核心点在于关闭 chan 只意味着生产者不能再发送数据，消费者无法获知 chan 是否已经关闭，需要用其他方式去通信。</li>
</ul>
<h2 id="语言特性">语言特性</h2>
<p>Go 相比 Java 来说，语言特性真的是少太多。推荐 <a href="https://learnxinyminutes.com/docs/go/">Learn X in Y minutes</a> 这个网站，快速浏览一遍即可掌握 Go 的语法。Go 的简洁程度觉得和 JavaScript 差不多，但却是一门静态语言，具有强类型，这两点又让它区别于一般的脚本语言。</p>
<h3 id="代码风格">代码风格</h3>
<p>Go 遵循约定大于配置（convention over configuratio）的设计理念，比如在构建一个项目时，直接 <code>go build</code> 一个命令就搞定了，不需要什么 Makefile、pom.xml 等配置文件。下面介绍几个常用的约定：</p>
<ul>
<li>一个包内函数、变量的可见性是通过首字母大小写确定的。大写表示可见。</li>
<li>一般 <code>{</code> 放在行末，否则 Go 编辑器会<a href="https://golang.org/doc/effective_go.html#semicolons">自动插入一个逗号</a>，导致编译错误</li>
<li>一个文件夹内，只能定义一个包</li>
<li>变量、函数命名<a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_identifier_length">尽量简短</a>，标准库里面经常可以看到一个字母的变量</li>
</ul>
<p>由于以上种种约定，在看别人代码时很舒服，有种 Python 的感觉。另外建议在编辑器中配置 <a href="https://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a> 来自动化格式代码。</p>
<h3 id="错误处理">错误处理</h3>
<p>Go 内没有 try catch 机制，而且已经明确拒绝了这个 <a href="https://github.com/golang/go/issues/32437">Proposal</a>，而是通过返回值的方式来处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="err">…</span><span class="p">,</span> <span class="nx">err</span>  <span class="c1">// zero values for other results, if any
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Go 的函数一般通过返回多值的方式来传递 error（且一般是第二个位置），实际项目中一般使用 <a href="https://github.com/pkg/errors">pkg/errors</a> 去处理、包装 err。</p>
<h3 id="依赖管理">依赖管理</h3>
<p>Go 的依赖管理，相比其他语言较弱。
在 Go 1.11 正式引入的 <a href="https://blog.golang.org/using-go-modules">modules</a> 之前，项目必须放在 $GOPATH/src/xxx.com/username/project 内，这样 Go 才能去正确解析项目依赖，而且 Go 社区没有统一的包托管平台，不像 Java 中 maven 一样有中央仓库的概念，而是直接引用 Git 的库地址，所以在 Go 里，一般会使用 <code>github.com/username/package</code> 的方式来表示。
<code>go get</code> 是下载依赖的命令，但一个个去 get 库不仅仅繁碎，而且无法固化依赖版本信息，所以 <a href="https://github.com/golang/dep">dep</a> 应运而生，添加新依赖后，直接运行 <code>dep ensure</code> 就可以全部下下来，而且会把当前依赖的 commit id 记录到 Gopkg.lock 里面，这就能解决版本不固定的问题。</p>
<p>但 modules 才是正路，且在 1.13 版本会默认开启，所以这里只介绍它的用法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 首先导出环境变量</span>
<span class="nb">export</span> <span class="nv">GO111MODULE</span><span class="o">=</span>on
<span class="c1"># 在一个空文件夹执行 init，创建一个名为 hello 的项目</span>
go mod init hello
<span class="c1"># 这时会在当前文件夹内创建 go.mod ，内容为</span>

module hello

go 1.12
<span class="c1"># 之后就可以编写 Go 文件，添加依赖后，执行 go run/test/build...</span>
<span class="c1"># 依赖会自动下载，并记录在 go.mod 内，版本信息记录在 go.sum</span>
</code></pre></td></tr></table>
</div>
</div><p>更多用法可以参考官方示例，这里只是想说明 <a href="https://github.com/golang/tools">go tools</a> 大部分已经支持，但是 <a href="https://github.com/golang/go/issues/26827">godoc 还不支持</a>，更多可参考 <a href="https://github.com/golang/go/issues/24661">#24661</a>。</p>
<h3 id="gc">GC</h3>
<p>Go 也是具有<a href="https://blog.golang.org/ismmkeynote">垃圾回收</a>的语言，但相比于 JVM，Go GC 可能显得及其简单，从 Go 1.10 开始，Go GC 采用 Concurrent Mark &amp; Sweep (CMS) 算法，且不具有分代、compact 特性。读者如果对相关名词不熟悉，可以阅读：</p>
<ul>
<li><a href="https://engineering.linecorp.com/en/blog/go-gc/">https://engineering.linecorp.com/en/blog/go-gc/</a></li>
</ul>
<p>而且 Go 里面调整 GC 的参数只有一个 <code>GOGC</code>，表示下面的比率</p>
<blockquote>
<p>新分配对象 / 上次 GC 后剩余对象</p>
</blockquote>
<p>默认 100，表示新分配对象达到上次 GC 后剩余对象的两倍时，进行 GC。</p>
<ul>
<li>调大 GOGC，可以减少 GC 的总体耗时</li>
<li>减小 GOGC，意味着用更多的 GC 来换取更少的内存使用</li>
</ul>
<p><code>GOGC=off</code> 可以关闭 GC，<a href="https://golang.org/pkg/runtime/debug/#SetGCPercent">SetGCPercent</a> 可以动态修改这个比率。</p>
<p>在启动一个 Go 程序时，可以设置 <code>GODEBUG=gctrace=1</code> 来打印 GC 日志，日志具体含义可参考 <a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables">pkg/runtime</a>，这里不再赘述。对调试感兴趣的可以阅读：</p>
<ul>
<li><a href="https://new.blog.cloudflare.com/go-dont-collect-my-garbage/">https://new.blog.cloudflare.com/go-dont-collect-my-garbage/</a></li>
</ul>
<h2 id="总结">总结</h2>
<p>Go 最初由 Google 在 2007 为解决软件复杂度、提升开发效率的一试验品，到如今不过十二年，但无疑已经<a href="https://hackernoon.com/major-programming-trends-to-prepare-for-in-2019-169987cc75f4">家喻户晓</a>，成为<a href="https://thenewstack.io/go-the-programming-language-of-the-cloud/">云时代的首选</a>。其面向接口的特有编程方式，也非常灵活，兼具动态语言的简洁与静态语言的高效，推荐大家尝试一下。Go Go Go!</p>
<p>
  <figure>
    <img src="https://golang.org/lib/godoc/images/go-logo-blue.svg" alt="Go">
    <figcaption><center>Go</center></figcaption>
  </figure>

</p>
<h2 id="扩展阅读">扩展阅读</h2>
<ul>
<li><a href="https://github.com/overnote/golang/blob/master/01-Go%E5%88%9D%E8%AF%86/03-%E5%8C%85%E4%B8%8E%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.md">03-包与依赖管理.md</a></li>
<li><a href="http://dtrace.org/blogs/ahl/2016/08/02/i-love-go-i-hate-go/">I Love Go; I Hate Go</a></li>
<li><a href="https://golang.org/ref/spec#Receive_operator">The Go Programming Language Specification#Receive operator</a></li>
<li><a href="http://www.yinwang.org/blog-cn/2014/04/18/golang">王垠：对 Go 语言的综合评价</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">https://github.com/golang/go/wiki/CodeReviewComments</a></li>
<li><a href="https://golang.org/doc/faq">https://golang.org/doc/faq</a></li>
<li><a href="https://blog.golang.org/go15gc">https://blog.golang.org/go15gc</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">刘家财</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-12-04
        <a href="https://github.com/jiacai2050/jiacai2050.github.io/commit/8f8c30acc9eabc6498854bdbb13df6a4b744f17d" title="fix bad categories">(8f8c30a)</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">Go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/blog/2019/10/24/go-modules/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">何处安放我们的 Go 代码</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/blog/2019/04/21/experience-in-clojure/">
            <span class="next-text nav-default">Clojure 开发经验总结</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'jiacai2050';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jiacai2050&#43;blog@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/2163429/jiacai-liu" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.twitter.com/liujiacai" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/jiacai2050" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/liujiacai" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/jiacai2050" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/liujiacai/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://liujiacai.net/atom.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2014 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>刘家财</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-50745138-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>

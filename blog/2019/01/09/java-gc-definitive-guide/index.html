<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Do have faith in what you are doing."><title>Java 垃圾回收权威指北 | Keep Coding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50745138-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '3ffc15f400ce3f8b1db5afc4f29b6ce9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java 垃圾回收权威指北</h1><a id="logo" href="/.">Keep Coding</a><p class="description">Stay hungry, Stay foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blogrolls/"><i class="fa fa-group"> 友情链接</i></a><a href="/podcast/"><i class="fa fa-podcast"> Podcast</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java 垃圾回收权威指北</h1><div class="post-meta">Jan 9, 2019<span> | </span><span class="category"><a href="/categories/aha-computer/">理解计算机</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 6.1k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 26</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="blog/2019/01/09/java-gc-definitive-guide/" href="/blog/2019/01/09/java-gc-definitive-guide/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#预备知识"><span class="toc-number">1.</span> <span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#术语"><span class="toc-number">1.1.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-版本"><span class="toc-number">1.2.</span> <span class="toc-text">JDK 版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打印-GC-信息"><span class="toc-number">1.3.</span> <span class="toc-text">打印 GC 信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-中支持的-GC"><span class="toc-number">2.</span> <span class="toc-text">JDK 中支持的 GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心流程指北"><span class="toc-number">3.</span> <span class="toc-text">核心流程指北</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ParallelGC"><span class="toc-number">3.1.</span> <span class="toc-text">ParallelGC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ergonomics"><span class="toc-number">3.1.1.</span> <span class="toc-text">Ergonomics</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用场景"><span class="toc-number">3.1.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS"><span class="toc-number">3.2.</span> <span class="toc-text">CMS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Concurrent-mode-failure"><span class="toc-number">3.2.1.</span> <span class="toc-text">Concurrent mode failure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存碎片"><span class="toc-number">3.2.2.</span> <span class="toc-text">内存碎片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Abortable-Preclean"><span class="toc-number">3.2.3.</span> <span class="toc-text">Abortable Preclean</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调优"><span class="toc-number">4.</span> <span class="toc-text">调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实战"><span class="toc-number">4.1.</span> <span class="toc-text">实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">4.2.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">6.</span> <span class="toc-text">扩展阅读</span></a></li></ol></div></div><div class="post-content"><p>毫无疑问，GC（垃圾回收） 已经是现代编程语言标配，为了研究这个方向之前曾经写过四篇<a href="/blog/2018/06/15/garbage-collection-intro/">《深入浅出垃圾回收》</a>博文来介绍其理论，之后也看了不少网络上关于 JDK GC 原理、优化的文章，质量参差不齐，其中理解有误的文字以讹传讹，遍布各地，更是把初学者弄的晕头转向。<br>不仅仅是个人开发者的文章，一些<a href="https://engineering.linkedin.com/garbage-collection/garbage-collection-optimization-high-throughput-and-low-latency-java-applications" target="_blank" rel="noopener">大厂的官博</a>也有错误。<br>本文在实验+阅读 openjdk 源码的基础上，整理出一份相对来说比较靠谱的资料，供大家参考。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>为方便理解 GC 算法时，需要先介绍一些常见的名词</p>
<ul>
<li>mutator，应用程序的线程</li>
<li>collector，用于进行垃圾回收的线程</li>
<li>concurrent（并发），指 collector 与 mutator 可以并发执行</li>
<li>parallel（并行），指 collector 是多线程的，可以利用多核 CPU 工作</li>
<li>young/old(也称Tenured) 代，根据大多数对象“朝生夕死”的特点，现代 GC 都是分代</li>
</ul>
<p>一个 gc 算法可以同时具有 concurrent/parallel 的特性，或者只具有一个。</p>
<h3 id="JDK-版本"><a href="#JDK-版本" class="headerlink" title="JDK 版本"></a>JDK 版本</h3><ul>
<li>HotSpot 1.8.0_172</li>
<li><a href="https://openjdk.java.net/projects/jdk8u/" target="_blank" rel="noopener">openjdk8u</a>（changeset: 2298:1c0d5a15ab4c）</li>
</ul>
<p>为了方便查看当前版本 JVM 支持的选项，建议配置下面这个 alias</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> jflags=<span class="string">'java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version'</span></span><br></pre></td></tr></table></figure>
<p>然后就可以用 <code>jflags | grep XXX</code> 的方式来定位选项与其默认值了。</p>
<h3 id="打印-GC-信息"><a href="#打印-GC-信息" class="headerlink" title="打印 GC 信息"></a>打印 GC 信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-Xloggc:/data/logs/gc-%t.log</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCCause</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:NumberOfGCLogFiles=10</span><br><span class="line">-XX:GCLogFileSize=50M</span><br><span class="line">-XX:+PrintPromotionFailure</span><br></pre></td></tr></table></figure>
<h2 id="JDK-中支持的-GC"><a href="#JDK-中支持的-GC" class="headerlink" title="JDK 中支持的 GC"></a>JDK 中支持的 GC</h2><p>Java 8 中默认集成了哪些 GC 实现呢？ jflags 可以告诉我们</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jflags |  grep <span class="string">"Use.*GC"</span></span><br><span class="line">     bool UseAdaptiveGCBoundary                     = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizeDecayMajorGCCost           = <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     bool UseAdaptiveSizePolicyWithSystemGC         = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseAutoGCSelectPolicy                     = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseConcMarkSweepGC                        = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseDynamicNumberOfGCThreads               = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseG1GC                                   = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseGCLogFileRotation                      = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseGCOverheadLimit                        = <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     bool UseGCTaskAffinity                         = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseMaximumCompactionOnSystemGC            = <span class="literal">true</span>                                &#123;product&#125;</span><br><span class="line">     bool UseParNewGC                               = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseParallelGC                             = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseParallelOldGC                          = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">     bool UseSerialGC                               = <span class="literal">false</span>                               &#123;product&#125;</span><br><span class="line">java version <span class="string">"1.8.0_172"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_172-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.172-b11, mixed mode)</span><br></pre></td></tr></table></figure>
<p>肉眼筛选下，就知道有如下几个相关配置：</p>
<ul>
<li>UseSerialGC</li>
<li>UseParNewGC，</li>
<li>UseParallelGC</li>
<li>UseParallelOldGC</li>
<li>UseConcMarkSweepGC</li>
<li>UseG1GC</li>
</ul>
<p>每个配置项都会对应两个 collector ，表示对 young/old 的不同收集方式。而且由于 JVM 不断的演化，不同 collector 的组合方式其实很复杂。而且在 Java 7u4 后，UseParallelGC 与 UseParallelOldGC 其实是等价的，openjdk 中有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/runtime/arguments.cpp#set_gc_specific_flags</span></span><br><span class="line"><span class="comment">// Set per-collector flags</span></span><br><span class="line"><span class="keyword">if</span> (UseParallelGC || UseParallelOldGC) &#123;</span><br><span class="line">  set_parallel_gc_flags();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (UseConcMarkSweepGC) &#123; <span class="comment">// Should be done before ParNew check below</span></span><br><span class="line">  set_cms_and_parnew_gc_flags();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (UseParNewGC) &#123;  <span class="comment">// Skipped if CMS is set above</span></span><br><span class="line">  set_parnew_gc_flags();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (UseG1GC) &#123;</span><br><span class="line">  set_g1_gc_flags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用<a href="https://stackoverflow.com/a/19837515/2163429" target="_blank" rel="noopener">下面的代码</a>测试使用不同配置时，young/old 代默认所使用的 collector：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gc;</span><br><span class="line"><span class="comment">// 省略 import 语句</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhichGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;GarbageCollectorMXBean&gt; gcMxBeans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line">            <span class="keyword">for</span> (GarbageCollectorMXBean gcMxBean : gcMxBeans) &#123;</span><br><span class="line">                System.out.println(gcMxBean.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exp) &#123;</span><br><span class="line">            System.err.println(exp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ java gc.WhichGC  <span class="comment"># 两个输出分别表示 young/old 代的 collector</span></span><br><span class="line">PS Scavenge</span><br><span class="line">PS MarkSweep</span><br><span class="line"></span><br><span class="line">$ java -XX:+UseSerialGC gc.WhichGC</span><br><span class="line">Copy</span><br><span class="line">MarkSweepCompact</span><br><span class="line"></span><br><span class="line">$ java -XX:+UseParNewGC gc.WhichGC <span class="comment"># 注意提示</span></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed <span class="keyword">in</span> a future release</span><br><span class="line">ParNew</span><br><span class="line">MarkSweepCompact</span><br><span class="line"></span><br><span class="line">$ java -XX:+UseParallelGC gc.WhichGC</span><br><span class="line">PS Scavenge</span><br><span class="line">PS MarkSweep <span class="comment"># 虽然名为 MarkSweep，但其实现是 mark-sweep-compact</span></span><br><span class="line"></span><br><span class="line">$ java -XX:+UseParallelOldGC gc.WhichGC <span class="comment"># 与上面输出一致，不加 flag 时这样同样的输出</span></span><br><span class="line">PS Scavenge</span><br><span class="line">PS MarkSweep</span><br><span class="line"></span><br><span class="line">$ java -XX:+UseConcMarkSweepGC gc.WhichGC <span class="comment"># ParNew 中 Par 表示 parallel，表明采用并行方式收集 young 代</span></span><br><span class="line">ParNew</span><br><span class="line">ConcurrentMarkSweep  <span class="comment"># 注意这里没有 compact 过程，也就是说 CMS 的 old 可能会产生碎片</span></span><br><span class="line"></span><br><span class="line">$ java -XX:+UseG1GC gc.WhichGC</span><br><span class="line">G1 Young Generation</span><br><span class="line">G1 Old Generation</span><br></pre></td></tr></table></figure>
<p>PS 开头的系列 collector 是 Java5u6 开始引入的。按照 <a href="https://hllvm-group.iteye.com/group/topic/27629" target="_blank" rel="noopener">R 大的说法</a>，这之前的 collector 都是在一个框架内开发的，所以 young/old 代的 collector 可以任意搭配，但 PS 系列与后来的 G1 不是在这个框架内的，所以只能单独使用。</p>
<p>使用 UseSerialGC 时 young 代的 collector 是 Copy，这是单线程的，PS Scavenge 与 ParNew 分别对其并行化，至于这两个并行 young 代 collector 的区别呢？这里再引用 <a href="https://hllvm-group.iteye.com/group/topic/37095#post-242695" target="_blank" rel="noopener">R 大的回复</a>：</p>
<ol>
<li>PS以前是广度优先顺序来遍历对象图的，JDK6的时候改为默认用深度优先顺序遍历，并留有一个UseDepthFirstScavengeOrder参数来选择是用深度还是广度优先。在JDK6u18之后这个参数被去掉，PS变为只用深度优先遍历。ParNew则是一直都只用广度优先顺序来遍历 </li>
<li>PS完整实现了adaptive size policy，而ParNew及“分代式GC框架”内的其它GC都没有实现完（倒不是不能实现，就是麻烦+没人力资源去做）。所以千万千万别在用ParNew+CMS的组合下用UseAdaptiveSizePolicy，请只在使用UseParallelGC或UseParallelOldGC的时候用它。 </li>
<li>由于在“分代式GC框架”内，ParNew可以跟CMS搭配使用，而ParallelScavenge不能。当时ParNew GC被从Exact VM移植到HotSpot VM的最大原因就是为了跟CMS搭配使用。 </li>
<li>在PS成为主要的throughput GC之后，它还实现了针对NUMA的优化；而ParNew一直没有得到NUMA优化的实现。 </li>
</ol>
<p>如果你对上面所说的 mark/sweep/compact 这些名词不了解，建议参考下面这篇文章：</p>
<ul>
<li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations" target="_blank" rel="noopener">https://plumbr.io/handbook/garbage-collection-algorithms-implementations</a></li>
</ul>
<p>其实原理很简单，和我们整理抽屉差不多，找出没用的垃圾，丢出去，然后把剩下的堆一边去。但是别忘了</p>
<blockquote>
<p>The evil always comes from details!</p>
</blockquote>
<p>怎么定义「没用」？丢垃圾时还允不允许同时向抽屉里放新东西？如果允许放，怎么区别出来，以防止被误丢？抽屉小时，一个人整理还算快，如果抽屉很大，多个人怎么协作？</p>
<h2 id="核心流程指北"><a href="#核心流程指北" class="headerlink" title="核心流程指北"></a>核心流程指北</h2><h3 id="ParallelGC"><a href="#ParallelGC" class="headerlink" title="ParallelGC"></a>ParallelGC</h3><p>SerialGC 采用的收集方式十分简单，没有并行、并发，一般用在资源有限的设备中。由于其简单，对其也没什么好说的，毕竟也没怎么用过 :-)<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html" target="_blank" rel="noopener">ParallelGC</a> 相比之下，使用多线程来回收，这就有些意思了，比如</p>
<ul>
<li>多个GC线程如何实现同步，需要注意一点，ParallelGC 运行时会 STW，因此不存在与 mutator 同步问题</li>
<li>回收时，并行度如何选择（也就是 GC 对应用本身的 overhead）</li>
</ul>
<p>凭借仅有的 cpp 知识，大略扫一下 <code>parNewGeneration.cpp</code> 这个文件，大概是这样实现多个 GC 线程同步的：</p>
<blockquote>
<p>每个 GC 线程对应一个 queue（叫 ObjToScanQueue），然后还支持不同 GC 线程间 steal，保证充分利用 cpu</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParNewGeneration 构造方法</span></span><br><span class="line"><span class="keyword">for</span> (uint i1 = <span class="number">0</span>; i1 &lt; ParallelGCThreads; i1++) &#123;</span><br><span class="line">  ObjToScanQueue *q = <span class="keyword">new</span> ObjToScanQueue();</span><br><span class="line">  guarantee(q != <span class="literal">NULL</span>, <span class="string">"work_queue Allocation failure."</span>);</span><br><span class="line">  _task_queues-&gt;register_queue(i1, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do_void 方法</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// We have no local work, attempt to steal from other threads.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// attempt to steal work from promoted.</span></span><br><span class="line">  <span class="keyword">if</span> (task_queues()-&gt;steal(par_scan_state()-&gt;thread_num(),</span><br><span class="line">                           par_scan_state()-&gt;hash_seed(),</span><br><span class="line">                           obj_to_scan)) &#123;</span><br><span class="line">    <span class="keyword">bool</span> res = work_q-&gt;push(obj_to_scan);</span><br><span class="line">    assert(res, <span class="string">"Empty queue should have room for a push."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   if successful, goto Start.</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try global overflow list.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (par_gen()-&gt;take_from_overflow_list(par_scan_state())) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面还是重点说一下我们开发者能控制的选项，</p>
<ul>
<li><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code> 应用停顿（STW）的的最大时间</li>
<li><code>-XX:GCTimeRatio=&lt;N&gt;</code>  GC 时间占整个应用的占比，默认 99。需要注意的是，它是这么用的 <code>1/(1+N)</code>，即默认 GC 占应用时间 1%。这么说来这个选项的意思貌似正好反了！<br>其实不仅仅是这个，类似的还有 <code>NewRatio</code> <code>SurvivorRatio</code>，喜欢八卦的可以看看<a href="http://yoroto.io/wo-ke-neng-zai-pao-yi-ge-jia-gc/" target="_blank" rel="noopener">《我可能在跑一个假GC》</a></li>
</ul>
<p>当然，上面两个指标是软限制，GC 会采用后面提到的自适应策略（Ergonomics）来调整 young/old 代大小来满足。</p>
<h4 id="Ergonomics"><a href="#Ergonomics" class="headerlink" title="Ergonomics"></a>Ergonomics</h4><p>每次 gc 后，会记录一些统计信息，比如 pause time，然后根据这些信息来决定</p>
<ol>
<li>目标是否满足</li>
<li>是否需要调整代大小</li>
</ol>
<p>可以通过 <code>-XX:AdaptiveSizePolicyOutputInterval=N</code> 来打印出每次的调整，N 表示每隔 N 次 GC 打印。<br>默认情况下，一个代增长或缩小是按照固定百分比，这样有助于达到指定大小。默认增加以 20% 的速率，缩小以 5%。也可以自己设定<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:YoungGenerationSizeIncrement=&lt;Y&gt;</span><br><span class="line">-XX:TenuredGenerationSizeIncrement=&lt;T&gt;</span><br><span class="line">-XX:AdaptiveSizeDecrementScaleFactor=&lt;D&gt;</span><br><span class="line"><span class="comment"># 如果增长的增量是 X，那么减少的减量则为 X/D</span></span><br></pre></td></tr></table></figure></p>
<p>当然，一般情况下是不需要自己设置这三个值的，除非你有明确理由。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>ParallelGC 另一个名字就表明了它的用途：吞吐量 collector。主要用在对延迟要求低，更看重吞吐量的应用上。<br>我们公司的数据导入导出、跑报表的定时任务，用的就是这个 GC。（能提供数据导入导出的都是良心公司呀！）<br>一般利用自适应策略就能满足需求。线上的日志大概这样子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">2018-12-27T22:14:19.006+0800: 5433.841: [GC (Allocation Failure) [PSYoungGen: 606785K-&gt;3041K(656896K)] 746943K-&gt;143356K(2055168K), 0.0157837 secs] [Times: user=0.03 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.02         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:21:36.581+0800: 5871.417: [GC (Allocation Failure) [PSYoungGen: 615905K-&gt;3089K(654848K)] 756220K-&gt;143504K(2053120K), 0.0157796 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:28:51.669+0800: 6306.505: [GC (Allocation Failure) [PSYoungGen: 615953K-&gt;3089K(660992K)] 756368K-&gt;143664K(2059264K), 0.0178418 secs] [Times: user=0.03 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:36:17.738+0800: 6752.573: [GC (Allocation Failure) [PSYoungGen: 624145K-&gt;2896K(658944K)] 764720K-&gt;143576K(2057216K), 0.0144179 secs] [Times: user=0.02 sys=0.01, real=0.01 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:43:40.208+0800: 7195.043: [GC (Allocation Failure) [PSYoungGen: 623952K-&gt;2976K(665088K)] 764632K-&gt;143720K(2063360K), 0.0135656 secs] [Times: user=0.03 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:48:59.110+0800: 7513.945: [GC (Allocation Failure) [PSYoungGen: 632224K-&gt;5393K(663040K)] 772968K-&gt;146241K(2061312K), 0.0230613 secs] [Times: user=0.05 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br><span class="line">2018-12-27T22:54:05.871+0800: 7820.706: [GC (Allocation Failure) [PSYoungGen: 634641K-&gt;4785K(669696K)] 775489K-&gt;147601K(2067968K), 0.0173448 secs] [Times: user=0.04 sys=0.01, real=0.02 secs]</span><br><span class="line">    UseAdaptiveSizePolicy actions to meet  *** reduced footprint ***</span><br><span class="line">                       GC overhead (%)</span><br><span class="line">    Young generation:        0.01         (attempted to shrink)</span><br><span class="line">    Tenured generation:      0.00         (attempted to shrink)</span><br><span class="line">    Tenuring threshold:    (attempted to decrease to balance GC costs) = 1</span><br></pre></td></tr></table></figure>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS 相比于 ParallelGC，支持并发式的回收，虽然个别环节还是需要 STW，但相比之前已经小了很多；另一点不同是 old 代在 sweep 后，没有 compact 过程，而是通过 freelist 来将空闲地址串起来。CMS 具体流程还是参考下面的文章：</p>
<ul>
<li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep" target="_blank" rel="noopener">https://plumbr.io/handbook/garbage-collection-algorithms-implementations/concurrent-mark-and-sweep</a></li>
</ul>
<p>上述文章会针对 gc 日志里面的每行含义做解释，务必弄清楚每一个数字含义，这是今后调试优化的基础。网站找了个<a href="http://fengfu.io/2016/06/21/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8CMS%E4%B9%8B%E5%90%84%E9%98%B6%E6%AE%B5%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">比较详细的图</a>供大家参考：</p>
<p><img src="https://img.alicdn.com/imgextra/i4/581166664/O1CN01eiAx891z69sKEdsdy_!!581166664.jpg" alt="CMS 工作流程示意图"></p>
<p>之前在有赞的同事阿杜写过一篇<a href="https://www.jianshu.com/p/78017c8b8e0f" target="_blank" rel="noopener">《不可错过的CMS学习笔记》</a> 推荐大家看看，主要是文章的思路比较欣赏，带着问题去探索。这里重申下 CMS 的特点：</p>
<ul>
<li>CMS 作用于 old 区，与 mutator 并发执行（因为是多线程的，所以也是并行的）；默认与 young 代 ParNew 算法一起工作</li>
</ul>
<p>下面重点介绍以下三点：</p>
<ul>
<li>误传最广的 CMF</li>
<li>影响最为严重的内存碎片问题</li>
<li>最被忽视的 Abortable Preclean</li>
</ul>
<h4 id="Concurrent-mode-failure"><a href="#Concurrent-mode-failure" class="headerlink" title="Concurrent mode failure"></a>Concurrent mode failure</h4><p>在每次 young gc 开始前，collector 都需要确保 old 代有足够的空间来容纳新晋级的对象（通过之前GC的统计估计），如果判断不足，或者当前判断足够，但是真正晋级对象时空间不够了（即发生 Promotion failure），那么就会发生 Concurrent mode failure（后面简写 CMF），CMF 发生时，不一定会进行 Full GC，而是这样的：</p>
<blockquote>
<p>如果这时 CMS 会正在运行，则会被中断，然后根据 UseCMSCompactAtFullCollection、CMSFullGCsBeforeCompaction 和当前收集状态去决定后面的行为</p>
</blockquote>
<p>有两种选择：</p>
<ol>
<li>使用跟Serial Old GC一样的LISP2算法的mark-compact来做 Full GC，或</li>
<li>用CMS自己的mark-sweep来做不并发的（串行的）old generation GC （这种串行的模式在 openjdk 中称为 foreground collector，与此对应，并发模型的 CMS 称为 background collector）</li>
</ol>
<p>UseCMSCompactAtFullCollection默认为true，CMSFullGCsBeforeCompaction默认是0，这样的组合保证CMS默认不使用foreground collector，而是用Serial Old GC的方式来进行 Full GC，而且在 JDK9 中，彻底去掉了这两个参数以及 foreground GC 模式，具体见：<a href="https://bugs.openjdk.java.net/browse/JDK-8010202" target="_blank" rel="noopener">JDK-8010202: Remove CMS foreground collection</a>，所以这两个参数就不需要再去用了。</p>
<p>这里还需要注意，上述两个备选策略的异同，它们所采用的算法与作用范围均不同：</p>
<ol>
<li>Serial Old GC的算法是mark-compact（也可以叫做mark-sweep-compact，但要注意它不是“mark-sweep”）。具体算法名是LISP2。它收集的范围是整个GC堆，包括Java heap的young generation和old generation，以及non-Java heap的permanent generation。因而其名 Full GC</li>
<li>CMS的foreground collector的算法就是普通的mark-sweep。它收集的范围只是CMS的old generation，而不包括其它generation。因而它在HotSpot VM里不叫做Full GC</li>
</ol>
<p>这里大家可能会有疑问，既然能够用多线程方式去进行 Full GC（比如 ParallelGC），那么 CMS 在降级时却采用了 Serial 的方式呢？从 <a href="https://bugs.openjdk.java.net/browse/JDK-8130200" target="_blank" rel="noopener">JDK-8130200</a> 里可以略知端倪，大概是这样的：</p>
<blockquote>
<p>Google 的开发人员实现了多线程版本的 Full GC，然后在 2015 年给 openjdk 提了个 PR，但是这个 PR 一直没人理，根据<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-dev/2015-June/thread.html#13649" target="_blank" rel="noopener">邮件列表</a>来看，主要是 CMS 没有 leader maintainer 了，其他 maintainer 又怕这个改动太大，带来今后巨大的维护成本，就一直没合这个 PR，再后来 G1 出来了，这个 PR 就更不受人待见了</p>
</blockquote>
<p>解决 CMF 的方式，一般是尽早执行 CMS，可以通过下面两个参数设置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingOccupancyFraction=60</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br></pre></td></tr></table></figure>
<p>上述两个参数缺一不可，第一个表示 old 区占用量超过 60% 时开始执行 CMS，第二个参数禁用掉 JVM 的自适应策略，如果不设置这个 JVM 可能会忽略第一个参数。</p>
<p>此外，除了 CMF 能触发 Full GC 外，<code>System.gc()</code> 的方式也能触发，不过 CMS 有个选项，可以将这个单线程的 Full GC 转化为 CMS 并发收集过程，一般建议打开：<code>-XX:+ExplicitGCInvokesConcurrent</code>。</p>
<p>上述关于 CMF 解释主要参考</p>
<ul>
<li><a href="https://hllvm-group.iteye.com/group/topic/42365" target="_blank" rel="noopener">R 大的这个帖子</a></li>
<li><a href="http://blog.ragozin.info/2011/10/java-cg-hotspots-cms-and-heap.html" target="_blank" rel="noopener">http://blog.ragozin.info/2011/10/java-cg-hotspots-cms-and-heap.html</a></li>
<li>自己的消化吸收，如果有误肯定是我的（请留言指出），与 <a href="https://www.zhihu.com/question/48973999" target="_blank" rel="noopener">R 大</a>无关</li>
</ul>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>Promotion failure 一般是由于 heap 内存碎片过多导致检测空间足够，但是真正晋级时却没有足够连续的空间，监控 old 代碎片可以用下面的选项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintPromotionFailure</span><br><span class="line">-XX:PrintFLSStatistics=1</span><br></pre></td></tr></table></figure>
<p>这时的 gc 日志大致是这样的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">592.079: [ParNew (0: promotion failure size = 2698)  (promotion failed): 135865K-&gt;134943K(138240K), 0.1433555 secs]</span><br><span class="line">Statistics <span class="keyword">for</span> BinaryTreeDictionary:</span><br><span class="line">------------------------------------</span><br><span class="line">Total Free Space: 40115394</span><br><span class="line">Max   Chunk Size: 38808526</span><br><span class="line">Number of Blocks: 1360</span><br><span class="line">Av.  Block  Size: 29496</span><br><span class="line">Tree      Height: 22</span><br></pre></td></tr></table></figure>
<p>重点是 Max Chunk Size 这个参数，如果这个值一直在减少，那么说明碎片问题再加剧。解决碎片问题可以按照下面步骤：</p>
<ol>
<li>尽可能提供较大的 old 空间，但是最好不要超过 32G，<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html#compressed_oops" target="_blank" rel="noopener">超过了就没法用压缩指针了</a>。</li>
<li>尽早执行 CMS，即修改  initiating occupancy 参数</li>
<li>减少 PLAB，我具体还没试过，可参考 <a href="http://blog.ragozin.info/2011/11/java-gc-hotspots-cms-promotion-buffers.html" target="_blank" rel="noopener">Java GC, HotSpot’s CMS promotion buffers
</a> 这篇文章</li>
<li>应用尽量不要去分配巨型对象</li>
</ol>
<h4 id="Abortable-Preclean"><a href="#Abortable-Preclean" class="headerlink" title="Abortable Preclean"></a>Abortable Preclean</h4><p><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01iVE4uz1z69sCiXptB_!!581166664.png" alt="ParallelGC vs CMS 工作流程"><br>根据上图重新回顾下 CMS 工作流程。Openjdk 内部通过 <code>_collectorState</code> 这个变量实现不同状态的转变（采用状态机设计模式），在 <code>collect_in_background</code> 方法内有个大 switch 进行转化，对应的 case 顺序即为状态机转化顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrentMarkSweepGeneration.cpp#collect_in_background</span></span><br><span class="line"><span class="keyword">while</span> (_collectorState != Idling) &#123;</span><br><span class="line">   ....</span><br><span class="line">  <span class="keyword">switch</span> (_collectorState) &#123;</span><br><span class="line">    <span class="keyword">case</span> InitialMarking:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">ReleaseForegroundGC <span class="title">x</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        stats().record_cms_begin();</span><br><span class="line">        <span class="function">VM_CMS_Initial_Mark <span class="title">initial_mark_op</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        VMThread::execute(&amp;initial_mark_op);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The collector state may be any legal state at this point</span></span><br><span class="line">      <span class="comment">// since the background collector may have yielded to the</span></span><br><span class="line">      <span class="comment">// foreground collector.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Marking:</span><br><span class="line">      <span class="comment">// initial marking in checkpointRootsInitialWork has been completed</span></span><br><span class="line">      <span class="keyword">if</span> (markFromRoots(<span class="literal">true</span>)) &#123; <span class="comment">// we were successful</span></span><br><span class="line">        assert(_collectorState == Precleaning, <span class="string">"Collector state should "</span></span><br><span class="line">          <span class="string">"have changed"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(_foregroundGCIsActive, <span class="string">"Internal state inconsistency"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Precleaning:</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_precleaning_begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// marking from roots in markFromRoots has been completed</span></span><br><span class="line">      preclean();</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_precleaning_end();</span><br><span class="line">      &#125;</span><br><span class="line">      assert(_collectorState == AbortablePreclean ||</span><br><span class="line">             _collectorState == FinalMarking,</span><br><span class="line">             <span class="string">"Collector state should have changed"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AbortablePreclean:</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">      size_policy()-&gt;concurrent_phases_resume();</span><br><span class="line">      &#125;</span><br><span class="line">      abortable_preclean();</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_precleaning_end();</span><br><span class="line">      &#125;</span><br><span class="line">      assert(_collectorState == FinalMarking, <span class="string">"Collector state should "</span></span><br><span class="line">        <span class="string">"have changed"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FinalMarking:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">ReleaseForegroundGC <span class="title">x</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">VM_CMS_Final_Remark <span class="title">final_remark_op</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        VMThread::execute(&amp;final_remark_op);</span><br><span class="line">      &#125;</span><br><span class="line">      assert(_foregroundGCShouldWait, <span class="string">"block post-condition"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Sweeping:</span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_sweeping_begin();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// final marking in checkpointRootsFinal has been completed</span></span><br><span class="line">      sweep(<span class="literal">true</span>);</span><br><span class="line">      assert(_collectorState == Resizing, <span class="string">"Collector state change "</span></span><br><span class="line">        <span class="string">"to Resizing must be done under the free_list_lock"</span>);</span><br><span class="line">      _full_gcs_since_conc_gc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Stop the timers for adaptive size policy for the concurrent phases</span></span><br><span class="line">      <span class="keyword">if</span> (UseAdaptiveSizePolicy) &#123;</span><br><span class="line">        size_policy()-&gt;concurrent_sweeping_end();</span><br><span class="line">        size_policy()-&gt;concurrent_phases_end(gch-&gt;gc_cause(),</span><br><span class="line">                                           gch-&gt;prev_gen(_cmsGen)-&gt;capacity(),</span><br><span class="line">                                           _cmsGen-&gt;<span class="built_in">free</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Resizing: &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Resetting:</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Idling:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      ShouldNotReachHere();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到里面有 Precleaning 与 AbortablePreclean 两个状态，他们底层都是调用 <code>preclean_work</code> 进行具体工作，区别只是 </p>
<ul>
<li>precleaning 阶段只执行一次，而 AbortablePreclean 是个迭代执行的过程，直到某个条件不成立。先看看 AbortablePreclean 阶段受哪些条件限制，再来介绍 preclean_work 里面做的具体事情。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrentMarkSweepGeneration.cpp#abortable_preclean()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (get_eden_used() &gt; CMSScheduleRemarkEdenSizeThreshold) &#123;</span><br><span class="line">  <span class="keyword">size_t</span> loops = <span class="number">0</span>, workdone = <span class="number">0</span>, cumworkdone = <span class="number">0</span>, waited = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!(should_abort_preclean() ||</span><br><span class="line">           ConcurrentMarkSweepThread::should_terminate())) &#123;</span><br><span class="line">    workdone = preclean_work(CMSPrecleanRefLists2, CMSPrecleanSurvivors2);</span><br><span class="line">    cumworkdone += workdone;</span><br><span class="line">    loops++;</span><br><span class="line">    <span class="comment">// Voluntarily terminate abortable preclean phase if we have</span></span><br><span class="line">    <span class="comment">// been at it for too long.</span></span><br><span class="line">    <span class="keyword">if</span> ((CMSMaxAbortablePrecleanLoops != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        loops &gt;= CMSMaxAbortablePrecleanLoops) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PrintGCDetails) &#123;</span><br><span class="line">        gclog_or_tty-&gt;print(<span class="string">" CMS: abort preclean due to loops "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pa.wallclock_millis() &gt; CMSMaxAbortablePrecleanTime) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PrintGCDetails) &#123;</span><br><span class="line">        gclog_or_tty-&gt;print(<span class="string">" CMS: abort preclean due to time "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we are doing little work each iteration, we should</span></span><br><span class="line">    <span class="comment">// take a short break.</span></span><br><span class="line">    <span class="keyword">if</span> (workdone &lt; CMSAbortablePrecleanMinWorkPerIteration) &#123;</span><br><span class="line">      <span class="comment">// Sleep for some time, waiting for work to accumulate</span></span><br><span class="line">      stopTimer();</span><br><span class="line">      cmsThread()-&gt;wait_on_cms_lock(CMSAbortablePrecleanWaitMillis);</span><br><span class="line">      startTimer();</span><br><span class="line">      waited++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (PrintCMSStatistics &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    gclog_or_tty-&gt;print(<span class="string">" [%d iterations, %d waits, %d cards)] "</span>,</span><br><span class="line">                        loops, waited, cumworkdone);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件包括下面几个：</p>
<ol>
<li>首先要 eden 大于 CMSScheduleRemarkEdenSizeThreshold（默认 2M）时才继续</li>
<li>下面的 while 里面条件主要是为了与 foregroundGC 做同步用的，这里可以先忽略</li>
<li>while 后面的第一个 if 表示这个阶段执行的次数小于 CMSMaxAbortablePrecleanLoops 时才继续，由于这个值默认为 0，所以默认不会进入这个分支</li>
<li>紧接着的那个 if 表示这个阶段的运行时间不能大于 CMSMaxAbortablePrecleanTime，默认是 5s</li>
</ol>
<p>好了，上面就是 abortable preclean 迭代执行的条件，任意一个不满足即会转到下一个状态。<br>下面介绍 <code>preclean_work</code> 里做的事情，主要包含两个：</p>
<ol>
<li>根据 card marking 状态，重新 mark 在 concurrent mark 阶段，mutator 又有访问的对象<br><img src="https://img.alicdn.com/imgextra/i1/581166664/O1CN012DBLER1z69sHf5zR6_!!581166664.png" alt="preclean 执行前 card mark 以及对象 live mark 状态"><br><img src="https://img.alicdn.com/imgextra/i3/581166664/O1CN01Rdi6pg1z69sIciHq8_!!581166664.png" alt="preclean 执行后 card mark 以及对象 live mark 状态"></li>
<li>对 eden 进行抽样（sample），把 eden 划分成大小相近的 chunk ，且每个 chunk 的起始地址都是对象的起始地址。</li>
</ol>
<p>把 eden 划分成不同 chunk 主要是为了方便后面的 remark 阶段并发执行。试想一下，如果 remark 阶段以多线程的方式重新 mark 被 mutator 访问的对象，势必要将 eden 划分为不同区域，然后不同区域由不同的线程去 mark，这里的区域就是 chunk。这个抽样过程主要是保证不同 chunk 大小一致，这样不同线程的工作量就均匀了。根据<a href="http://hiroshiyamauchi.blogspot.com/2013/08/parallel-initial-mark-and-more-parallel.html" target="_blank" rel="noopener">这个功能作者测试</a>，这个抽样使得 remark 阶段的 STW 由 500ms 减到 100ms</p>
<p>不过这个抽样阶段，也可能发生在 ParNew 过程中，是由 CMSEdenChunksRecordAlways 这个选项控制的，而且默认是 true，表示 preclean 阶段不对 eden 进行抽样，而是在 ParNew 运行时抽样，相关代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrentMarkSweepGeneration.cpp </span></span><br><span class="line"><span class="comment">// preclean_work 会调用 sample_eden，但是这里的 !CMSEdenChunksRecordAlways 默认为 false</span></span><br><span class="line"><span class="comment">// 所以这里不会进行抽样</span></span><br><span class="line"><span class="keyword">void</span> CMSCollector::sample_eden() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_eden_chunk_array != <span class="literal">NULL</span> &amp;&amp; !CMSEdenChunksRecordAlways) &#123;</span><br><span class="line">    ...... <span class="keyword">do</span> sample</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defNewGeneration.cpp#allocate() </span></span><br><span class="line">  HeapWord* result = eden()-&gt;par_allocate(word_size);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (CMSEdenChunksRecordAlways &amp;&amp; _next_gen != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里会调用 concurrentMarkSweepGeneration 里的 sample_eden_chunk</span></span><br><span class="line">      _next_gen-&gt;sample_eden_chunk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// concurrentMarkSweepGeneration.cpp </span></span><br><span class="line"><span class="keyword">void</span> CMSCollector::sample_eden_chunk() &#123;</span><br><span class="line">  <span class="comment">// 默认会在这里进行抽样</span></span><br><span class="line">  <span class="keyword">if</span> (CMSEdenChunksRecordAlways &amp;&amp; _eden_chunk_array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ..... <span class="keyword">do</span> sample</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>说到优化，让很多人望而却步，一方便有人不断在说“不要过早优化”，另一方面在真正有问题时，不知道如何入手。这里介绍我自己的一些经验供大家参考。</p>
<p>既然提到 GC 优化，首先要明确衡量 GC 的几个指标，LinkedIn 在这方面值得借鉴，在 <a href="https://engineering.linkedin.com/26/tuning-java-garbage-collection-web-services" target="_blank" rel="noopener">Tuning Java Garbage Collection for Web Services
</a> 提出了从 gc 日志中可以获知的 5 个指标：</p>
<ol>
<li>Allocation Rate: the size of the young generation divided by the time between young generation collections</li>
<li>Promotion Rate: the change in usage of the old gen over time (excluding collections)</li>
<li>Survivor Death Ratio: when looking at a log, the size of survivors in age N divided by the size of survivors in age N-1 in the previous collection</li>
<li>Old Gen collection times: the total time between a CMS-initial-mark and the next CMS-concurrent-reset. You’ll want both your ‘normal’ and the maximum observed</li>
<li>Young Gen collection times: both normal and maximum. These are just the “total collection time” entries in the logs Old Gen Buffer: <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the promotion rate*the maximum Old Gen collection time*(1 + a little bit)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>直接从纯文本的 gc 日志中得出这 5 项指标比较困难，还好有个比较好用的开源工具 <a href="https://github.com/dmart28/gcplot" target="_blank" rel="noopener">gcplot</a>，借助 docker，一行命令即可启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 gcplot/gcplot</span><br></pre></td></tr></table></figure>
<p>如果发现 gcplot 里面的指标不符合你的预期，那就可以根据所使用 GC 算法的特点进行优化了。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>利用 gcplot，我对公司内部 API 服务（使用 CMS）进行了一次优化，效果较为明显：</p>
<p>优化前的配置：Xmx/Xms 均为 4G，CMSInitiatingOccupancyFraction=60，下面是使用 gcplot 得到的一些数据</p>
<table>
<thead>
<tr>
<th>Percentiles</th>
<th>STW Pause (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>50%</td>
<td>22.203</td>
</tr>
<tr>
<td>90%</td>
<td>32.872</td>
</tr>
<tr>
<td>95%</td>
<td>40.255</td>
</tr>
<tr>
<td>99%</td>
<td>76.724</td>
</tr>
<tr>
<td>99.9%</td>
<td>317.584</td>
</tr>
</tbody>
</table>
<ul>
<li>STW Pause per Minute: 3.396 secs</li>
<li>STW Events per Minute: 133</li>
</ul>
<table>
<thead>
<tr>
<th>Promoted Total</th>
<th>17.313 GB</th>
</tr>
</thead>
<tbody>
<tr>
<td>Promotion Rate (MB/Sec)</td>
<td>5.99</td>
</tr>
<tr>
<td>Allocated Total</td>
<td>5.053 TB</td>
</tr>
<tr>
<td>Allocation Rate (MB/Sec)</td>
<td>1273.73</td>
</tr>
</tbody>
</table>
<p>优化后的配置：Xmx/Xms 均为 4G, NewRatio 为 1， CMSInitiatingOccupancyFraction=80。<br>这么修改主要是增加 young 区空间，因为对于 Web 服务来说，除了一些 cache 外，没什么常驻内存的对象；通过把 OccupancyFraction 调大，延迟 CMS 发生频率，还是基于前面的推论，大多数对象不会晋级到 old 代，所以发生碎片的概率也不会怎么大。下面是优化后的相关参数，也证明了上面的猜想</p>
<table>
<thead>
<tr>
<th>percentiles</th>
<th>STW pause(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>50%</td>
<td>19.75</td>
</tr>
<tr>
<td>90%</td>
<td>30.334</td>
</tr>
<tr>
<td>95%</td>
<td>35.441</td>
</tr>
</tbody>
</table>
<p> 99%         | 53.5          |<br>| 99.9%       | 120.008       |</p>
<ul>
<li>STW Pause per Minute: 826.607 ms</li>
<li>STW Events per Minute: 38</li>
</ul>
<table>
<thead>
<tr>
<th>Promoted Total</th>
<th>6.182 GB</th>
</tr>
</thead>
<tbody>
<tr>
<td>Promotion Rate (MB/Sec)</td>
<td>0.29</td>
</tr>
<tr>
<td>Allocated Total</td>
<td>28.254 TB</td>
</tr>
<tr>
<td>Allocation Rate (MB/Sec)</td>
<td>1121.29</td>
</tr>
</tbody>
</table>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>虽然本文一开始指出 LinkedIn 文章中存在理解误差，但是那篇文章的思路还是值得解决，下面再次给出链接</p>
<ul>
<li><a href="https://engineering.linkedin.com/garbage-collection/garbage-collection-optimization-high-throughput-and-low-latency-java-applications" target="_blank" rel="noopener">https://engineering.linkedin.com/garbage-collection/garbage-collection-optimization-high-throughput-and-low-latency-java-applications</a></li>
<li>段子手王四哥对上面文章的指正：<a href="http://yoroto.io/nan-dao-ta-men-shuo-de-du-shi-zhen-de/" target="_blank" rel="noopener">难道他们说的都是真的？</a></li>
<li>江南白衣的 <a href="http://calvin1978.blogcn.com/articles/jvmoption-7.html" target="_blank" rel="noopener">关键业务系统的JVM参数推荐</a>，说到这里就不得不提 <a href="https://github.com/vipshop/vjtools/" target="_blank" rel="noopener">vjtools</a> 了，我目前主要用了 vjtop。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面基本把 ParallelGC 与 CMS 核心点过了一遍，然后顺带介绍了下优化，主要还是熟悉 GC 日志中的每个指标含义，理解透后再去决定是否需要优化。关于 G1 本文没有过多介绍，主要是用的确实不多，后面会尝试把服务升级到 G1 后再来写写它。</p>
<p>本文一开始就说网络上关于 GC 的误解很多，本文可能也是这样的，虽然我已经尽可能保证“正确”，但还是需要大家带着辩证的眼光来看。元芳,你怎么看？</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All" target="_blank" rel="noopener">https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html</a></li>
<li><a href="https://blogs.oracle.com/jonthecollector/did-you-know" target="_blank" rel="noopener">https://blogs.oracle.com/jonthecollector/did-you-know</a></li>
<li><a href="https://dzone.com/articles/how-tame-java-gc-pauses" target="_blank" rel="noopener">https://dzone.com/articles/how-tame-java-gc-pauses</a></li>
<li><a href="https://mechanical-sympathy.blogspot.com/2013/07/java-garbage-collection-distilled.html" target="_blank" rel="noopener">https://mechanical-sympathy.blogspot.com/2013/07/java-garbage-collection-distilled.html</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://liujiacai.net/blog/2019/01/09/java-gc-definitive-guide/" data-id="ck7sg887w005ggkljpz2dm57c" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJElEQVR42u3aW27CMBAFUPa/abqAlnLvOCDFPv6qaBPnBGnqeTwe8Xr+WvnnyT3zq5YWBgbGbRnPf1e+5avt879JXtNLKgYGxgGMfPsk4Ca/bfd688wYGBgYQRCc4TEwMDA+HXDXU9NXYRoDAwNjlsSuhNFkry/l4hgYGDdk5FX37//8kf4GBgbGrRjPciVHwFljYOmpMDAwtmbMbp2noMnDrVMxMDD2ZuRp58rYRHvPpFT3x/eAgYGxNSNvK7Zlr5WxjPx5MDAw9ma0xbWk3N8muvm1USMTAwNjU8YFeXAZsvOhjeToiYGBcQIjL9BfdWRsg/vFDU4MDIwbMmbHtU9clYf7N0dDDAyMTRltczEfrcjLZG07AQMD4zRGUXC/tEi3MrRRvD8MDIyNGLMQnKS1bZuz6GNgYGAcwJglonlpLCGttxkwMDD2ZuSHtjZxnTUM8h0xMDBOYLRHsTaYrrQBipIcBgbG1ox22KJNX9tMM79nkdZiYGBswVhvMeZpapvoFs0DDAyMYxiz7dvC2UrwjQIuBgbG1oy2VXlVSW420oGBgXEC41muq46JbeMz+h4wMDA2ZczmrGbtgdngxXBmBAMDYztGsk0ykNGmu22b8827x8DAOIDRjmclsLzDmP8HiHJxDAyM4xltwpk0NdtAjIGBgTEr/c/KarMg+zKJxcDA2JrRJqJJia1NcWf3xMDAOIGxEvLaT/LgmwRZDAyMAxg/WAeTYTbZsuUAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/java/">Java</a><a href="/tags/gc/">GC</a></div><div class="post-nav"><a class="pre" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a><a class="next" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://liujiacai.net/blog/2019/01/09/java-gc-definitive-guide/';
    this.page.identifier = 'blog/2019/01/09/java-gc-definitive-guide/';
    this.page.title = 'Java 垃圾回收权威指北';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jiacai2050.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jiacai2050.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jiacai2050.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://liujiacai.net"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reproduce/">他山之石</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">大数据</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/search-engine/">搜索引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">热爱生活</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/aha-computer/">理解计算机</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/研习经典/">研习经典</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/langs/">编程语言</a><span class="category-list-count">25</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/GEB/" style="font-size: 15px;">GEB</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/mooc/" style="font-size: 15px;">mooc</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/algorithm/" style="font-size: 15px;">算法</a> <a href="/tags/mozilla/" style="font-size: 15px;">mozilla</a> <a href="/tags/lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/lisp/" style="font-size: 15px;">Lisp</a> <a href="/tags/best-practice/" style="font-size: 15px;">最佳实践</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/sicp/" style="font-size: 15px;">sicp</a> <a href="/tags/scheme/" style="font-size: 15px;">Scheme</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/python/" style="font-size: 15px;">Python</a> <a href="/tags/ruby/" style="font-size: 15px;">Ruby</a> <a href="/tags/Clojure/" style="font-size: 15px;">Clojure</a> <a href="/tags/ideas/" style="font-size: 15px;">ideas</a> <a href="/tags/gc/" style="font-size: 15px;">GC</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2020/03/14/go-struct-interface/">Go struct/interface 实践分享</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2020/02/02/review-2019/">2019 年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/10/24/go-modules/">何处安放我们的 Go 代码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/07/17/hello-golang/">写给新手的 Go 开发指南</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/04/21/experience-in-clojure/">Clojure 开发经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/01/09/java-gc-definitive-guide/">Java 垃圾回收权威指北</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/12/29/how-java-synchronizer-work/">Java 线程同步原理探析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/11/10/damn-single-socket/">形单影只的 Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jiacai2050.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Keep Coding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
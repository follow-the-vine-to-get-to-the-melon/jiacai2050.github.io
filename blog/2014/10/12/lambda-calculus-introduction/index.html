<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>编程语言的基石——Lambda calculus - Keep Coding</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="刘家财" /><meta name="description" content="Lambda calculus我们一般称为λ演算，最早是由邱奇（Alonzo Church，图灵的博导）在20世纪30年代引入，当时的背景是解决函数可计算" /><meta name="keywords" content="lisp, clojure, emacs, database, life" />






<meta name="generator" content="Hugo 0.79.0 with theme even" />


<link rel="canonical" href="https://liujiacai.net/blog/2014/10/12/lambda-calculus-introduction/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="编程语言的基石——Lambda calculus" />
<meta property="og:description" content="Lambda calculus我们一般称为λ演算，最早是由邱奇（Alonzo Church，图灵的博导）在20世纪30年代引入，当时的背景是解决函数可计算" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://liujiacai.net/blog/2014/10/12/lambda-calculus-introduction/" />
<meta property="article:published_time" content="2014-10-12T10:16:42+08:00" />
<meta property="article:modified_time" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="name" content="编程语言的基石——Lambda calculus">
<meta itemprop="description" content="Lambda calculus我们一般称为λ演算，最早是由邱奇（Alonzo Church，图灵的博导）在20世纪30年代引入，当时的背景是解决函数可计算">
<meta itemprop="datePublished" content="2014-10-12T10:16:42+08:00" />
<meta itemprop="dateModified" content="2020-12-04T22:35:59+08:00" />
<meta itemprop="wordCount" content="4598">



<meta itemprop="keywords" content="Lambda,Lisp," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="编程语言的基石——Lambda calculus"/>
<meta name="twitter:description" content="Lambda calculus我们一般称为λ演算，最早是由邱奇（Alonzo Church，图灵的博导）在20世纪30年代引入，当时的背景是解决函数可计算"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Keep Coding</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/podcast/">
        <li class="mobile-menu-item">Podcast</li>
      </a><a href="/blogrolls/">
        <li class="mobile-menu-item">友链</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Keep Coding</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/podcast/">Podcast</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/blogrolls/">友链</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">编程语言的基石——Lambda calculus</h1>

      <div class="post-meta">
        <span class="post-time"> 2014-10-12 </span>
        <div class="post-category">
            <a href="/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 理解计算机 </a>
            </div>
          <span class="more-meta"> 约 4598 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#λ演算的语法与求值">λ演算的语法与求值</a>
          <ul>
            <li><a href="#语法syntax">语法(syntax)</a></li>
            <li><a href="#求值evaluation">求值(evaluation)</a></li>
          </ul>
        </li>
        <li><a href="#λ演算与编程语言的关系">λ演算与编程语言的关系</a>
          <ul>
            <li><a href="#编码boolean">编码Boolean</a></li>
            <li><a href="#编码pair">编码pair</a></li>
            <li><a href="#编码number">编码number</a></li>
          </ul>
        </li>
        <li><a href="#λ-演算与图灵机">λ-演算与图灵机</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Lambda calculus我们一般称为<a href="http://en.wikipedia.org/wiki/Lambda_calculus">λ演算</a>，最早是由<a href="http://en.wikipedia.org/wiki/Alonzo_Church">邱奇（Alonzo Church，图灵的博导）</a>在20世纪30年代引入，当时的背景是解决<a href="http://en.wikipedia.org/wiki/Computable_function">函数可计算的本质</a>性问题，初期λ演算成功的解决了在可计算理论中的<a href="http://en.wikipedia.org/wiki/Entscheidungsproblem">判定性问题</a>，后来根据<a href="http://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church–Turing thesis</a>，证明了λ演算与图灵机是等价的。</p>
<p>好了，经过上边简单的介绍，大家应该对λ演算有了初步印象。下面我将重点介绍λ演算的具体内容，并且阐述λ演算是如何奠基了我们现在常用的编程语言（如：Java、python、Lisp等）。</p>
<h2 id="λ演算的语法与求值">λ演算的语法与求值</h2>
<h3 id="语法syntax">语法(syntax)</h3>
<p>因为λ演算研究的是函数的本质性问题，所以形式极其简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    E = x           variables
      | λx. E       function creation(abstraction)
      | E1 E2       function application           
</code></pre></td></tr></table>
</div>
</div><p>上面的E称为λ-表达式(expressions)或λ-terms，它的值有三种形式：</p>
<ol>
<li>变量(variables)。</li>
<li>函数声明或抽象(function creation/abstraction)。需要注意是的，函数中<strong>有且仅有</strong>一个参数。在λx. E中，x是参数，E是函数体</li>
<li>函数应用(function application)。也就是我们理解的函数调用，但官方术语就叫函数应用，本文后面也会采用“应用”的叫法。</li>
</ol>
<h4 id="λ表达式例子">λ表达式例子</h4>
<p>上面就是λ演算的语法了，很是简单吧。下面看几个例子：</p>
<ol>
<li>恒等函数
<code>λx.x</code></li>
<li>一个返回恒等函数的函数
<code>λy. (λx.x)</code>
可以看到，这里的y参数直接被忽略了</li>
</ol>
<p>在使用λ演算时，有一些惯例需要说一下：</p>
<ol>
<li>函数声明时，函数体尽可能的向右扩展。什么意思呢，举个例子大家就明白了</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">λx.x λy.x y z 应该理解为 λ x. (x (λy. ((x y) z)))
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>函数应用时，遵循左结合。在举个例子：
x y z 应该解释为 (x y) z</li>
</ol>
<h4 id="currying带有多个参数的函数">Currying带有多个参数的函数</h4>
<p>从上面我们知道，λ演算中函数只有一个参数，那两个参数的函数的是不是就没法表示了呢，那λ演算的功能也太弱了吧，这就是λ的神奇之处，函数在本质上只需要一个参数即可。如果想要声明多个参数的函数，通过currying技术即可。下面来说说currying。
<code>λx y. (+ x y)----&gt;λx. (λ y. + x y)</code>
上面这个转化就叫currying，它展示了，我们如何实现加法（这里假设+这个符号已经具有相加的功能，后面我们会讲到如何用λ表达式来实现这个+的功能）。
其实就是我们现在意义上的闭包——你调用一个函数，这个函数返回另一个函数，返回的函数中存储保留了调用函数的变量。currying是闭包的鼻祖。
如果用Python来表示就是这样的东西：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">def add(x):
    return lambda y: x+y

add(4)(3) //return 7   
</code></pre></td></tr></table>
</div>
</div><p>如果用函数式语言clojure来表示就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">(defn add [x]
  (fn [y] (+ x y)))

((add 4) 3) ;return 7
</code></pre></td></tr></table>
</div>
</div><h3 id="求值evaluation">求值(evaluation)</h3>
<p>在λ演算中，有两条求值规则：</p>
<ol>
<li>Alpha equivalence( or conversion )</li>
<li>Beta reduction</li>
</ol>
<h4 id="alpha-equivalence">Alpha equivalence</h4>
<p>这个比较简单也好理解，就是说λx.x与λy.y是等价的，并不因为换了变量名而改变函数的意义。
简单并不说这个规则不重要，在一些变量覆盖的场合很重要，如下这个例子：
<code>λx. x (λx. x)</code>如果你这么写的话，第二个函数定义中的x与第一个函数定义中的x重复了，也就是在第二个函数里把第一个的x给覆盖了。
如果改为<code>λx. x (λy. y)</code>就不会有歧义了。</p>
<h4 id="beta-reduction">Beta reduction</h4>
<p>这个规则是λ演算中函数应用的重点了。一句话来解释就是，把参数应用到函数体中。举一个例子：
有这么一个函数应用<code>(λx.x)(λy.y)</code>，在这里把<code>(λy.y)</code>带入前面函数的x中，就能得到最终的结果<code>(λy.y)</code>，这里传入一个函数，然后又返回一个函数，这就是最终的结果。</p>
<h4 id="求值顺序">求值顺序</h4>
<p>考虑下面这个函数应用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    (λ y. (λ x. x) y) E
</code></pre></td></tr></table>
</div>
</div><p>有两种计算方法，如下图
<img src="http://img04.taobaocdn.com/imgextra/i4/581166664/TB2fQf6aFXXXXa2XXXXXXXXXXXX_!!581166664.png" alt=" evaluation-order"/>
可以先计算内层的函数调用再计算外层的函数调用，反之也可。
根据<a href="http://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem">Church–Rosser定理</a>，这两种方法是等价的，最终会得到相等的结果，如上图最后都得到了E。
但如果我们要自己实现一种语言，就有可能必选二选其一，于是有了下面两种方式：</p>
<ol>
<li>Call by Value(Eager Evaluation及早求值)
也就是上图中的inner，这种方式在函数应用前，就计算函数参数的值。如：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    (λy. (λx. x) y) ((λu. u) (λv. v)) ---&gt;
    (λy. (λx. x) y) (λv. v)  ---&gt;
    (λx. x) (λv. v)  ---&gt;
    λv. v
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>Call by Name (Lazy Evaluation惰性求值)
也就是上图中的outer，这种方式在函数应用前，不计算函数参数的值，直到需要时才求值。如：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    (λy. (λx. x) y) ((λu. u) (λv. v)) ---&gt;
    (λx. x) ((λu. u) (λv. v)) ---&gt;
    (λu. u) (λv. v) ---&gt;
    λv. v
</code></pre></td></tr></table>
</div>
</div><p>值得一提的是，Call by Name这种方式在我们目前的语言中，只有函数式语言支持。</p>
<h2 id="λ演算与编程语言的关系">λ演算与编程语言的关系</h2>
<p>在λ演算中只有函数（变量依附于函数而有意义），如果要用纯λ演算来实现一门编程语言的话，我们还需要一些数据类型，比如boolean、number、list等，那怎么办呢？
λ的强大又再一次展现出来，所有的数据类型都能用函数模拟出来，秘诀就是
<code>不要去关心数据的值是什么，重点是我们能对这个值做什么操作</code>，然后我们用合法的λ表达式把这些操作表示出来即可。</p>
<p>听上去很些云里雾里，但看了我下面的讲解以后，你会发现，编程语言原来还可以这么玩，希望我能把这部分讲清楚些，个人感觉这些东西太funny了 :-)</p>
<p>好了，我们先从最简单——boolean的开始。</p>
<h3 id="编码boolean">编码Boolean</h3>
<p>Ask：我们能对boolean值做什么？
Answer：我们能够进行条件判断，二选其一。</p>
<p>好，知道了能对boolean的操作，下面就用λ表达式来定义它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    true = λx. λy. x
    false = λx. λy. y
    if E1 then E2 else E3 = E1 E2 E3
</code></pre></td></tr></table>
</div>
</div><p>来简单解释一下，boolean就是这么一个函数，它有两个参数（通过currying实现），返回其中一个。下面看个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    if true then u else v 可以写成   
    (λx. λy. x) u v ---&gt; (λy. u) v ---&gt; u
</code></pre></td></tr></table>
</div>
</div><p>哈哈，很神奇吧，更精彩的还在后头呢，继续</p>
<h3 id="编码pair">编码pair</h3>
<p>这里简单解释下pair，其实就是序列对，如(1 2)、(hello world)，这些就是pair，只有两个元素，但不要小看了pair，我们用的list就是通过pair连接起来形成的。</p>
<p>Ask：我们能对pair做什么？
Answer：我们能够选择pair中的任意一个元素</p>
<p>好，知道了能对pair的操作，下面就用λ表达式来定义它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    mkpair x y = λb. (b x y)
    fst p      = p true
    snd p      = p false
</code></pre></td></tr></table>
</div>
</div><p>这里用到了true与false的编码。解释一下：
pair就是这么一个函数，参数是一个boolean值，根据这个参数确定返回值。还是看例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    fst (mkpair x y)---&gt;(mkpair x y) true---&gt;true x y---&gt;x   
</code></pre></td></tr></table>
</div>
</div><p>这样我们就能取到pair的第一个元素了。很好玩吧，下面的更有趣，继续</p>
<h3 id="编码number">编码number</h3>
<p>这里讲的number是指的自然数。</p>
<p>Ask：我们能对number做什么？
Answer：我们能够依次遍历这些数字</p>
<p>好，知道了能对number的操作，下面就用λ表达式来定义它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    0 = λf. λs. s
    1 = λf. λs. f s
    2 = λf. λs. f (f s)
    ......
</code></pre></td></tr></table>
</div>
</div><p>解释一下，利用currying，我们知道上面的定义其实相当于一个具有两个参数的函数：一个函数f，另一个是起始值s，然后不断应用f实现遍历数字的操作。先不要管为什么这么定义，看了下面我们如何定义加法乘法的例子你应该就会豁然开朗了：
首先我们需要定义一个后继函数(The successor function)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    succ n = λf. λs. f (n f s)
</code></pre></td></tr></table>
</div>
</div><p>然后，就可以定义加法与乘法了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    add n1 n2 = n1 succ n2
    mult n1 n2 = n1 (add n2) 0
</code></pre></td></tr></table>
</div>
</div><p>只看定义要想弄懂应该还是有些困难，下面看个具体的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">add 0 = (λn1. λn2. n1 succ n2) 0  // 这里直接根据上面 add 定义进行展开
 
-------将 0 带入 n1，可得--------&gt;
λn2. 0 succ n2 = λn2. (λf. λs. s) succ n2 
 
-------将 succ 带入 f，n2 带入 s，可得--&gt;
λn2. n2 = λx. x
</code></pre></td></tr></table>
</div>
</div><p>我第一次看这个例子有个疑问，add不是两个参数吗，你怎么就加一个0呢？其实还是currying没理解好，两个参数的函数内部不也是用一个参数的函数来表示的嘛，如果只传递一个参数，那么我们就知道还会返回一个函数，本例中就是<code>λx. x</code>，这是恒等函数，也就是说加 0 ,相当于什么也没加，还是本身。</p>
<p>哈哈，看来也不过如此嘛，如果你能看到这里，说明你已经对lambda掌握的差不多了。下面再来看个“难点”的例子——<code>1+1</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    add 1 1 ---&gt;
    1 succ 1 ---&gt;
    succ 1 ---&gt;
    λf. λs. f (f s) ---&gt; 2
</code></pre></td></tr></table>
</div>
</div><p>最后一个例子，<code>2*2</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    mult 2 2 ---&gt;
    2 (add 2) 0 ---&gt;
    (add 2) ((add 2) 0) ---&gt;
    2 succ (add 2 0) ---&gt;
    2 succ (2 succ 0) ---&gt;
    succ (succ (succ (succ 0))) ---&gt;
    succ (succ (succ (λf. λs. f (0 f s)))) ---&gt;
    succ (succ (succ (λf. λs. f s))) ---&gt;
    succ (succ (λg. λy. g ((λf. λs. f s) g y)))
    succ (succ (λg. λy. g (g y))) ---&gt;......---&gt; λg. λy. g (g (g (g y))) = 4
</code></pre></td></tr></table>
</div>
</div><p>不要一看到这么多步骤就吓跑了，原则很简单，就是不断进行函数应用，需要注意的就是这里的2、0不再是单纯的数字了，它是从具有两个参数的函数，如果你应用时只传入一个参数，说明它还会返回一个函数。</p>
<p>不管怎样，如果你已经看到了这里，我希望你能把上面这个乘法的例子看懂，就是不断进行函数应用而已，没什么东西，我觉得难点在于思维的转化，因为以前都很理所当然认为2×2=4了，而不知道这么简单的计算后面的本质性东西，通过这个例子，希望大家能明确一点：<code>值是什么不重要，重要的是我们能对这个值进行的操作</code>。</p>
<p>最后再来一个收尾菜：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    如果想要判断一个数字是否为0，可以这么定义                
    iszero n = n (λb. false) true        
</code></pre></td></tr></table>
</div>
</div><h2 id="λ-演算与图灵机">λ-演算与图灵机</h2>
<p>本文一开始就说明了，λ-演算与图灵机是等价，这里简单说下我对图灵机的理解：</p>
<blockquote>
<p>在一个不限时间、不限资源的前提下，图灵机通过前进、后退、跳转、输出1或0这四个简单的命令，在一条无限长的纸带上执行事先编好的程序。</p>
</blockquote>
<p>根据目前的证明，图灵机是宇宙间最强大的机器（理想中的），我们现有的计算机都没有超过图灵机。</p>
<p>如果说一个语言是图灵完备的，就是说，世界上任何可计算性问题，它都能解决。</p>
<p>我们现有的命令式语言，如C、Java等就是以图灵机为基础的。如果说这些语言图灵完备，需要具有以下两个特征：</p>
<ol>
<li>有if、goto语句（或while、for之类的循环语句）</li>
<li>能够进行赋值操作（也就是改变内存状态）</li>
</ol>
<p>与图灵机对应，λ-演算的直接影响是函数式编程语言，如lisp、Haskell等，如果说这些函数式语言图灵完备，需要有以下两个特征：</p>
<ol>
<li>能够进行函数抽象（也就是函数定义）</li>
<li>能够进行函数应用（也就是函数调用）</li>
</ol>
<p>鉴别一个语言是不是函数式的标准是：这个语言能否在运行时创建函数，如果能，就是函数式语言。</p>
<h2 id="总结">总结</h2>
<p>通过上面长篇大论（希望你能抽时间看完），我们用一些无意义符号表达了我们已经熟知的一些概念，这就是λ演算的精髓之处，通过一套形式化的规则来描述这些东西，要知道，这里面的很多东西我们现如今想当然的接受了，但如何让笨重的计算机来理解这个世界呢，这就需要这些形式化的规则来指导了。</p>
<p>我这里介绍的lambda calculus并不完全，只是其中的一部分，像<a href="http://en.wikipedia.org/wiki/Lambda_calculus#Recursion_and_fixed_points">递归</a>这个重要的东西就没说，大家凭借兴趣再自己去看吧，我觉得我这篇文章就是个砖头，希望能引出大家的宝玉就好。</p>
<p>我们现在的编程语言趋向于多范式化，像python、ruby的兴起就说明了这点。
因为纯函数式语言不能改变变量状态，这个恐怕在很多场合不适用吧。
纯OO也不好，因为我们大多数程序员，都是用OO的语言来写过程式的程序，看看大家有多Helper类，Util类就明白了。</p>
<p>有了对 lambda 的认识后，就可以尝试下一个主题了——Y 算子，下面给出我觉得讲解的最好的一篇文章：</p>
<ul>
<li><a href="http://shellfly.org/blog/2015/01/07/yi-the-y-combinator-slight-return/">(译) The Y combinator (Slight Return)</a></li>
</ul>
<p>最后，推荐王垠的一篇文章，以飨读者：</p>
<ul>
<li><a href="http://geek.csdn.net/news/detail/3603">面向对象编程和函数式编程的问题出在哪里？</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">刘家财</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-12-04
        <a href="https://github.com/jiacai2050/jiacai2050.github.io/commit/8f8c30acc9eabc6498854bdbb13df6a4b744f17d" title="fix bad categories">(8f8c30a)</a>
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/lambda/">Lambda</a>
          <a href="/tags/lisp/">Lisp</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/blog/2014/11/08/secret-of-firefox-prefs/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">让firefox与chrome一样快</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/blog/2014/09/14/mozilla-history/">
            <span class="next-text nav-default">Mozilla 前世今生</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'jiacai2050';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jiacai2050&#43;blog@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/2163429/jiacai-liu" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://www.twitter.com/liujiacai" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/jiacai2050" class="iconfont icon-github" title="github"></a>
      <a href="http://weibo.com/liujiacai" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/jiacai2050" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://www.douban.com/people/liujiacai/" class="iconfont icon-douban" title="douban"></a>
  <a href="https://liujiacai.net/atom.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2014 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>刘家财</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-50745138-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?3ffc15f400ce3f8b1db5afc4f29b6ce9";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>
